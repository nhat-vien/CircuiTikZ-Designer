// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      if (res === false) {
        return {};
      }
      // Synthesize a module to follow re-exports.
      if (Array.isArray(res)) {
        var m = {__esModule: true};
        res.forEach(function (v) {
          var key = v[0];
          var id = v[1];
          var exp = v[2] || v[0];
          var x = newRequire(id);
          if (key === '*') {
            Object.keys(x).forEach(function (key) {
              if (
                key === 'default' ||
                key === '__esModule' ||
                Object.prototype.hasOwnProperty.call(m, key)
              ) {
                return;
              }

              Object.defineProperty(m, key, {
                enumerable: true,
                get: function () {
                  return x[key];
                },
              });
            });
          } else if (exp === '*') {
            Object.defineProperty(m, key, {
              enumerable: true,
              value: x,
            });
          } else {
            Object.defineProperty(m, key, {
              enumerable: true,
              get: function () {
                if (exp === 'default') {
                  return x.__esModule ? x.default : x;
                }
                return x[exp];
              },
            });
          }
        });
        return m;
      }
      return newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"i6nKT":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "f8fb2b3f6c4b1899";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"g3CsF":[function(require,module,exports,__globalThis) {
/**
 * The main source file. Does only include {@link MainController}, which does the actual work.
 */ var _internal = require("./internal");
// @ts-ignore
window.mainController = (0, _internal.MainController).instance;

},{"./internal":"f6vBb"}],"f6vBb":[function(require,module,exports,__globalThis) {
// controllers
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mainController = require("./controllers/mainController");
parcelHelpers.exportAll(_mainController, exports);
var _canvasController = require("./controllers/canvasController");
parcelHelpers.exportAll(_canvasController, exports);
var _eraseController = require("./controllers/eraseController");
parcelHelpers.exportAll(_eraseController, exports);
var _exportController = require("./controllers/exportController");
parcelHelpers.exportAll(_exportController, exports);
var _saveController = require("./controllers/saveController");
parcelHelpers.exportAll(_saveController, exports);
var _selectionController = require("./controllers/selectionController");
parcelHelpers.exportAll(_selectionController, exports);
var _undoController = require("./controllers/undoController");
parcelHelpers.exportAll(_undoController, exports);
var _copyController = require("./controllers/copyController");
parcelHelpers.exportAll(_copyController, exports);
var _propertiesController = require("./controllers/propertiesController");
parcelHelpers.exportAll(_propertiesController, exports);
// properties
var _editableProperty = require("./properties/editableProperty");
parcelHelpers.exportAll(_editableProperty, exports);
var _booleanProperty = require("./properties/booleanProperty");
parcelHelpers.exportAll(_booleanProperty, exports);
var _choiceProperty = require("./properties/choiceProperty");
parcelHelpers.exportAll(_choiceProperty, exports);
var _textProperty = require("./properties/textProperty");
parcelHelpers.exportAll(_textProperty, exports);
var _textAreaProperty = require("./properties/textAreaProperty");
parcelHelpers.exportAll(_textAreaProperty, exports);
var _infoProperty = require("./properties/infoProperty");
parcelHelpers.exportAll(_infoProperty, exports);
var _buttonGridProperty = require("./properties/buttonGridProperty");
parcelHelpers.exportAll(_buttonGridProperty, exports);
var _mathjaxProperty = require("./properties/mathjaxProperty");
parcelHelpers.exportAll(_mathjaxProperty, exports);
var _sliderProperty = require("./properties/sliderProperty");
parcelHelpers.exportAll(_sliderProperty, exports);
var _sectionHeaderProperty = require("./properties/sectionHeaderProperty");
parcelHelpers.exportAll(_sectionHeaderProperty, exports);
var _colorProperty = require("./properties/colorProperty");
parcelHelpers.exportAll(_colorProperty, exports);
var _radioButtonProperty = require("./properties/radioButtonProperty");
parcelHelpers.exportAll(_radioButtonProperty, exports);
//mixins
var _fillable = require("./mixins/fillable");
parcelHelpers.exportAll(_fillable, exports);
var _strokable = require("./mixins/strokable");
parcelHelpers.exportAll(_strokable, exports);
var _nameable = require("./mixins/nameable");
parcelHelpers.exportAll(_nameable, exports);
var _labelable = require("./mixins/labelable");
parcelHelpers.exportAll(_labelable, exports);
var _voltageable = require("./mixins/voltageable");
parcelHelpers.exportAll(_voltageable, exports);
var _currentable = require("./mixins/currentable");
parcelHelpers.exportAll(_currentable, exports);
// components
var _circuitComponent = require("./components/circuitComponent");
parcelHelpers.exportAll(_circuitComponent, exports);
var _pathComponent = require("./components/pathComponent");
parcelHelpers.exportAll(_pathComponent, exports);
var _nodeComponent = require("./components/nodeComponent");
parcelHelpers.exportAll(_nodeComponent, exports);
var _componentPlacer = require("./components/componentPlacer");
parcelHelpers.exportAll(_componentPlacer, exports);
var _componentSymbol = require("./components/componentSymbol");
parcelHelpers.exportAll(_componentSymbol, exports);
var _nodeSymbolComponent = require("./components/nodeSymbolComponent");
parcelHelpers.exportAll(_nodeSymbolComponent, exports);
var _pathSymbolComponent = require("./components/pathSymbolComponent");
parcelHelpers.exportAll(_pathSymbolComponent, exports);
var _wireComponent = require("./components/wireComponent");
parcelHelpers.exportAll(_wireComponent, exports);
var _shapeComponent = require("./components/shapeComponent");
parcelHelpers.exportAll(_shapeComponent, exports);
var _rectangleComponent = require("./components/rectangleComponent");
parcelHelpers.exportAll(_rectangleComponent, exports);
var _ellipseComponent = require("./components/ellipseComponent");
parcelHelpers.exportAll(_ellipseComponent, exports);
var _polygonComponent = require("./components/polygonComponent");
parcelHelpers.exportAll(_polygonComponent, exports);
var _groupComponent = require("./components/groupComponent");
parcelHelpers.exportAll(_groupComponent, exports);
// snapDrag
var _dragHandlers = require("./snapDrag/dragHandlers");
parcelHelpers.exportAll(_dragHandlers, exports);
var _snapController = require("./snapDrag/snapController");
parcelHelpers.exportAll(_snapController, exports);
var _snapCursor = require("./snapDrag/snapCursor");
parcelHelpers.exportAll(_snapCursor, exports);
var _snapPoint = require("./snapDrag/snapPoint");
parcelHelpers.exportAll(_snapPoint, exports);
// other
var _textHelper = require("./utils/textHelper");
parcelHelpers.exportAll(_textHelper, exports);
var _utils = require("./utils/utils");
parcelHelpers.exportAll(_utils, exports);
var _tikzBuilder = require("./utils/tikzBuilder");
parcelHelpers.exportAll(_tikzBuilder, exports);

},{"./controllers/mainController":"NWFmJ","./controllers/canvasController":"3nlqp","./controllers/eraseController":"bYHDp","./controllers/exportController":"5kipo","./controllers/saveController":"i9Wnp","./controllers/selectionController":"eSfs2","./controllers/undoController":"az8F5","./controllers/copyController":"jV7zX","./controllers/propertiesController":"6pbkP","./properties/editableProperty":"hk88F","./properties/booleanProperty":"gAKSE","./properties/choiceProperty":"eDwSi","./properties/textProperty":"bp8yV","./properties/textAreaProperty":"9NuDL","./properties/infoProperty":"9lB9j","./properties/buttonGridProperty":"113v3","./properties/mathjaxProperty":"53K7Y","./properties/sliderProperty":"kPoUl","./properties/sectionHeaderProperty":"fBkJN","./properties/colorProperty":"72Y1w","./properties/radioButtonProperty":"1aiK6","./mixins/fillable":"b9ZYS","./mixins/strokable":"6kSOz","./mixins/nameable":"cC9nW","./mixins/labelable":"aw6et","./mixins/voltageable":"lvPBm","./mixins/currentable":"dLPaW","./components/circuitComponent":"1yrgf","./components/pathComponent":"6xV6c","./components/nodeComponent":"lAjjL","./components/componentPlacer":"4Xjna","./components/componentSymbol":"eN8C9","./components/nodeSymbolComponent":"d2BGD","./components/pathSymbolComponent":"eLq3m","./components/wireComponent":"65cLX","./components/shapeComponent":"jLqoY","./components/rectangleComponent":"2wU8d","./components/ellipseComponent":"i8ejU","./components/polygonComponent":"I5TWf","./components/groupComponent":"3qwR8","./snapDrag/dragHandlers":"8WwEC","./snapDrag/snapController":"fGtGO","./snapDrag/snapCursor":"d5mkJ","./snapDrag/snapPoint":"4M1ai","./utils/textHelper":"2ip9f","./utils/utils":"ibn1F","./utils/tikzBuilder":"k3mu1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"NWFmJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Modes", ()=>Modes);
// TODO Test
// TODO redo comments
parcelHelpers.export(exports, "MainController", ()=>MainController);
var _svgJs = require("@svgdotjs/svg.js");
var _bootstrap = require("bootstrap");
var _impSVGNumber = require("../utils/impSVGNumber");
var _domWatcher = require("../utils/domWatcher");
var _hotkeysJs = require("hotkeys-js");
var _hotkeysJsDefault = parcelHelpers.interopDefault(_hotkeysJs);
var _packageJson = require("../../../package.json");
var _internal = require("../internal");
var Modes;
(function(Modes) {
    Modes[Modes["DRAG_PAN"] = 0] = "DRAG_PAN";
    Modes[Modes["COMPONENT"] = 1] = "COMPONENT";
    Modes[Modes["ERASE"] = 2] = "ERASE";
})(Modes || (Modes = {}));
class MainController {
    static _instance;
    static get instance() {
        if (!MainController._instance) MainController._instance = new MainController();
        return MainController._instance;
    }
    // controllers
    canvasController;
    symbolsSVG;
    symbols;
    darkMode = true;
    darkModeLast = true;
    currentTheme = "dark";
    tabID = -1;
    mode = Modes.DRAG_PAN;
    modeSwitchButtons = {
        modeDragPan: null,
        modeDrawLine: null,
        modeEraser: null
    };
    initPromise;
    isInitDone = false;
    circuitComponents = [];
    // instances: ComponentInstance[] = [];
    // lines: Line[] = [];
    static appVersion = "0.0.0";
    isMac = false;
    selectionController;
    broadcastChannel;
    designName;
    db;
    /**
     * Init the app.
     */ constructor(){
        MainController._instance = this;
        this.isMac = window.navigator.userAgent.toUpperCase().indexOf("MAC") >= 0;
        this.broadcastChannel = new BroadcastChannel("circuitikz-designer");
        // dark mode init
        const htmlElement = document.documentElement;
        const switchElement = document.getElementById("darkModeSwitch");
        const defaultTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        this.currentTheme = localStorage.getItem("circuitikz-designer-theme") || defaultTheme;
        htmlElement.setAttribute("data-bs-theme", this.currentTheme);
        this.darkModeLast = false;
        this.darkMode = this.currentTheme === "dark";
        switchElement.checked = this.darkMode;
        let mathJaxPromise = this.loadMathJax();
        let canvasPromise = this.initCanvas();
        let symbolsDBPromise = this.initSymbolDB();
        let fontPromise = Promise.all([
            document.fonts.load("1em Computer Modern Serif"),
            (0, _internal.loadTextConverter)()
        ]);
        MainController.appVersion = (0, _packageJson.version);
        document.addEventListener("DOMContentLoaded", ()=>{
            for (const element of document.getElementsByClassName("version"))element.textContent = "v" + (0, _packageJson.version);
        });
        const fileExportName = document.getElementById("exportModalFileBasename");
        this.designName = new (0, _internal.TextProperty)("Design Name", "");
        this.designName.addChangeListener(()=>{
            document.title = this.designName.value + (this.designName.value ? " - " : "") + "CircuiTikZ Designer";
            fileExportName.placeholder = MainController.instance.designName.value.replace(/[^a-z0-9]/gi, "_") || "Circuit";
            let tabsObjectStore = MainController.instance.db.transaction("tabs", "readwrite").objectStore("tabs");
            tabsObjectStore.get(this.tabID).onsuccess = function(event) {
                const data = event.target.result;
                data.designName = MainController.instance.designName.value;
                tabsObjectStore.put(data);
                MainController.instance.sendBroadcastMessage("update");
            };
        });
        this.initModeButtons();
        this.updateTooltips();
        // init exporting
        (0, _internal.ExportController).instance;
        const exportCircuiTikZButton = document.getElementById("exportCircuiTikZButton");
        exportCircuiTikZButton.addEventListener("click", (0, _internal.ExportController).instance.exportCircuiTikZ.bind((0, _internal.ExportController).instance), {
            passive: true
        });
        const exportSVGButton = document.getElementById("exportSVGButton");
        exportSVGButton.addEventListener("click", (0, _internal.ExportController).instance.exportSVG.bind((0, _internal.ExportController).instance), {
            passive: true
        });
        const exportImageButton = document.getElementById("exportImageButton");
        exportImageButton.addEventListener("click", (0, _internal.ExportController).instance.exportImage.bind((0, _internal.ExportController).instance), {
            passive: true
        });
        // init save and load
        (0, _internal.SaveController).instance;
        const saveButton = document.getElementById("saveButton");
        saveButton.addEventListener("click", (0, _internal.SaveController).instance.save.bind((0, _internal.SaveController).instance), {
            passive: true
        });
        const loadButton = document.getElementById("loadButton");
        loadButton.addEventListener("click", (0, _internal.SaveController).instance.load.bind((0, _internal.SaveController).instance), {
            passive: true
        });
        canvasPromise.then(()=>{
            (0, _internal.EraseController).instance;
            (0, _internal.SelectionController).instance;
            (0, _internal.PropertyController).instance;
            (0, _internal.ComponentPlacer).instance;
        });
        this.initPromise = Promise.all([
            canvasPromise,
            symbolsDBPromise,
            mathJaxPromise,
            fontPromise
        ]).then(()=>{
            document.getElementById("loadingSpinner")?.classList.add("d-none");
            this.initAddComponentOffcanvas();
            this.initShortcuts();
            // Prevent "normal" browser menu
            document.getElementById("canvas").addEventListener("contextmenu", (evt)=>evt.preventDefault(), {
                passive: false
            });
            this.addSaveStateManagement();
            // prepare symbolDB for colorTheme
            for (const g of this.symbolsSVG.defs().node.querySelectorAll("symbol>g"))this.preprocessSymbolColors(g);
            const htmlElement = document.documentElement;
            const switchElement = document.getElementById("darkModeSwitch");
            switchElement.addEventListener("change", function() {
                if (MainController.instance.darkMode = switchElement.checked) {
                    htmlElement.setAttribute("data-bs-theme", "dark");
                    localStorage.setItem("circuitikz-designer-theme", "dark");
                } else {
                    htmlElement.setAttribute("data-bs-theme", "light");
                    localStorage.setItem("circuitikz-designer-theme", "light");
                }
                MainController.instance.updateTheme();
            });
            MainController.instance.updateTheme();
            (0, _internal.PropertyController).instance.update();
            this.isInitDone = true;
        });
    }
    allTooltips = [];
    updateTooltips() {
        var isMobile = window.matchMedia("only screen and (max-width: 760px)").matches;
        //enable tooltips globally
        const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"],[data-bs-toggle-second="tooltip"]');
        for (const tooltip of this.allTooltips)tooltip.dispose();
        if (isMobile) this.allTooltips = [
            ...tooltipTriggerList
        ].map((tooltipTriggerEl)=>new (0, _bootstrap.Tooltip)(tooltipTriggerEl, {
                fallbackPlacements: [],
                trigger: "manual"
            }));
        else this.allTooltips = [
            ...tooltipTriggerList
        ].map((tooltipTriggerEl)=>new (0, _bootstrap.Tooltip)(tooltipTriggerEl, {
                fallbackPlacements: [],
                delay: {
                    show: 1000,
                    hide: 0
                }
            }));
    }
    async loadMathJax() {
        var promise = new Promise((resolve)=>{
            if (!("MathJax" in window)) window.MathJax = {
                tex: {
                    inlineMath: {
                        "[+]": [
                            [
                                "$",
                                "$"
                            ]
                        ]
                    }
                }
            };
            var script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js";
            document.head.appendChild(script);
            script.addEventListener("load", function() {
                resolve("");
            }, false);
        });
        return promise;
    }
    /**
     * handle tabs and save state management
     */ addSaveStateManagement() {
        // remove old localStorage data
        localStorage.removeItem("currentProgress");
        localStorage.removeItem("circuit2tikz-designer-grid");
        localStorage.removeItem("circuitikz-designer-grid");
        localStorage.removeItem("circuitikz-designer-saveState");
        sessionStorage.removeItem("circuitikz-designer-tabID");
        const defaultSettings = {};
        const IDBrequest = indexedDB.open("circuitikz-designer-db", 1);
        IDBrequest.onerror = function(event) {
            console.error("IndexedDB error");
            console.error(event);
        };
        IDBrequest.onupgradeneeded = function(event) {
            MainController.instance.db = event.target.result;
            if (!MainController.instance.db.objectStoreNames.contains("tabs")) {
                const objectStore = MainController.instance.db.createObjectStore("tabs", {
                    keyPath: "id"
                });
                objectStore.createIndex("open", "open", {
                    unique: false
                });
            }
        };
        IDBrequest.onsuccess = function(event) {
            MainController.instance.db = event.target.result;
            window.addEventListener("visibilitychange", (ev)=>{
                if (document.visibilityState == "hidden") MainController.instance.saveCurrentState(false);
            });
            window.addEventListener("beforeunload", (ev)=>{
                MainController.instance.saveCurrentState();
            });
            let tabsObjectStore = MainController.instance.db.transaction("tabs", "readwrite").objectStore("tabs");
            // the URL of the current page
            var url = new URL(window.location.href);
            // check if a tabID is requested in the URL, otherwise use the first closed tab
            var requestedID = parseInt(url.searchParams.get("tabID"));
            tabsObjectStore.getAll().onsuccess = function(event) {
                let allTabs = event.target.result;
                if (Number.isNaN(requestedID)) {
                    // no tabID is requested in the URL, so we need to find the first closed tab
                    requestedID = allTabs.findIndex((tab)=>tab.open == "false");
                    if (requestedID < 0) {
                        // no closed tab found, use the next available ID
                        requestedID = 0;
                        while(allTabs.find((tab)=>tab.id == requestedID))requestedID++;
                    }
                }
                let requestedTab = allTabs.find((tab)=>tab.id == requestedID);
                if (requestedTab) {
                    // if the requested tab is closed, open it
                    requestedTab.open = "true";
                    MainController.instance.tabID = requestedTab.id;
                    MainController.instance.designName.updateValue(requestedTab.designName ?? "", true, true);
                    (0, _internal.CanvasController).instance.setSettings(requestedTab.settings);
                    (0, _internal.SaveController).instance.loadFromJSON(requestedTab.data);
                    tabsObjectStore.put(requestedTab).onsuccess = (event)=>{
                        MainController.instance.sendBroadcastMessage("update");
                    };
                } else {
                    // requested tab not found, so we create a new one
                    const newEntry = {
                        id: requestedID,
                        open: "true",
                        data: (0, _internal.emtpySaveState),
                        settings: defaultSettings
                    };
                    MainController.instance.tabID = requestedID;
                    tabsObjectStore.add(newEntry).onsuccess = (event)=>{
                        // as soon as the tab is created and saved in the db, we can notify the other tabs
                        MainController.instance.sendBroadcastMessage("update");
                    };
                }
            };
        };
        //settings modal
        const settingsModalEl = document.getElementById("settingsModal");
        const settingsTableBody = document.getElementById("settingsTableBody");
        settingsModalEl.addEventListener("show.bs.modal", (event)=>{
            this.saveCurrentState(false);
            let tabsObjectStoreRead = MainController.instance.db.transaction("tabs").objectStore("tabs");
            tabsObjectStoreRead.getAll().onsuccess = function(event) {
                settingsTableBody.innerHTML = "";
                const currentData = event.target.result;
                let totalSize = 0;
                for(let i = 0; i < currentData.length; i++){
                    const tabData = currentData[i];
                    let row = settingsTableBody.appendChild(document.createElement("tr"));
                    row.classList.add("text-end");
                    let cell1 = row.appendChild(document.createElement("td"));
                    cell1.innerText = tabData.designName || "" + i;
                    let cell2 = row.appendChild(document.createElement("td"));
                    cell2.innerText = countComponents(tabData.data.components) + "";
                    let cell3 = row.appendChild(document.createElement("td"));
                    let size = (0, _internal.memorySizeOf)(tabData.data);
                    totalSize += size;
                    cell3.innerText = sizeString(size);
                    let cell4 = row.appendChild(document.createElement("td"));
                    if (tabData.open == "false") {
                        let openButton = cell4.appendChild(document.createElement("button"));
                        openButton.classList.add("btn", "btn-primary", "me-2");
                        openButton.innerText = "Open";
                        openButton.addEventListener("click", ()=>{
                            // set the data in the object store to open
                            let allOpen = true;
                            for(let index = 0; index < tabData.id; index++){
                                // current data will not be stale since the tab management gets updated immediately when something changes
                                let current = currentData.find((tab)=>tab.id == index);
                                if (current) allOpen = allOpen && current.open == "true";
                                else allOpen = false;
                            }
                            if (allOpen) // if possible, don't use the tabID parameter
                            window.open(".", "_blank");
                            else window.open(".?tabID=" + tabData.id, "_blank");
                        });
                        let deleteButton = cell4.appendChild(document.createElement("button"));
                        deleteButton.classList.add("btn", "btn-danger", "material-symbols-outlined");
                        deleteButton.innerText = "delete";
                        deleteButton.addEventListener("click", ()=>{
                            let tabsObjectStore = MainController.instance.db.transaction("tabs", "readwrite").objectStore("tabs");
                            tabsObjectStore.delete(tabData.id).onsuccess = function() {
                                settingsModalEl.dispatchEvent(new Event("show.bs.modal"));
                                MainController.instance.sendBroadcastMessage("update");
                            };
                        });
                    } else if (tabData.id == MainController.instance.tabID) {
                        let infoButton = cell4.appendChild(document.createElement("button"));
                        infoButton.classList.add("btn");
                        infoButton.innerText = "This tab";
                        infoButton.disabled = true;
                        let _ = [
                            cell1,
                            cell2,
                            cell3,
                            cell4
                        ].forEach((cell)=>{
                            cell.classList.add("bg-primary");
                        });
                    } else {
                        let closeButton = cell4.appendChild(document.createElement("button"));
                        closeButton.classList.add("btn", "btn-primary");
                        closeButton.innerText = "Highlight tab";
                        closeButton.addEventListener("click", ()=>{
                            // send a message to the broadcast channel to show the tab
                            MainController.instance.sendBroadcastMessage("show", tabData.id);
                        });
                    }
                }
                let row = settingsTableBody.appendChild(document.createElement("tr"));
                let cell1 = row.appendChild(document.createElement("td"));
                cell1.colSpan = 4;
                cell1.classList.add("text-center");
                let newTabButton = cell1.appendChild(document.createElement("button"));
                newTabButton.classList.add("btn", "btn-primary");
                newTabButton.innerText = "New tab";
                newTabButton.addEventListener("click", ()=>{
                    // set the data in the object store to open
                    let requestedID = 0;
                    let allOpen = true;
                    while(true){
                        // continue until no tab is found
                        let tab = currentData.find((tab)=>tab.id == requestedID);
                        if (tab) {
                            requestedID++;
                            allOpen = allOpen && tab.open == "true";
                        } else break;
                    }
                    if (allOpen) // if possible, don't use the tabID parameter
                    window.open(".", "_blank");
                    else window.open(".?tabID=" + requestedID, "_blank");
                });
                document.getElementById("storageUsed").innerHTML = sizeString(totalSize);
            };
        });
        document.getElementById("probeRefresh").addEventListener("click", ()=>{
            // set all open states in indexedDB to false, then send a probe message to all tabs
            let tabsObjectStore = MainController.instance.db.transaction("tabs", "readwrite").objectStore("tabs");
            tabsObjectStore.getAll().onsuccess = function(event) {
                let allTabs = event.target.result;
                let requests = [];
                for (const tab of allTabs){
                    if (tab.id == MainController.instance.tabID) continue;
                    if (tab.open == "true") {
                        tab.open = "false";
                        if (tab.data.components.length > 0) requests.push(tabsObjectStore.put(tab));
                        else // if no data is present, delete the entry (keeps the db clean)
                        requests.push(tabsObjectStore.delete(tab.id));
                    }
                }
                Promise.all(requests.map((r)=>new Promise((res, rej)=>{
                        r.onsuccess = ()=>res(true);
                        r.onerror = ()=>rej();
                    }))).then(()=>{
                    // after all tabs are closed, send a probe message to all tabs
                    // this will cause all open tabs to set their state to open=true again
                    MainController.instance.sendBroadcastMessage("probe");
                });
            };
        });
        const favicon = document.getElementById("favicon");
        const faviconLink = favicon.href;
        const faviconAlternate = document.getElementById("faviconAlternate");
        const alternateLink = faviconAlternate.href;
        faviconAlternate.href = " ";
        faviconAlternate.disabled = true;
        this.broadcastChannel.onmessage = (event)=>{
            const msg = event.data;
            if (msg.type == "show") {
                const tabID = parseInt(msg.payload); // get the tabID
                if (tabID == MainController.instance.tabID) {
                    const oldTitle = document.title;
                    let darkMode = true;
                    const switchFavicon = ()=>{
                        if (darkMode) {
                            favicon.href = alternateLink;
                            document.title = "Click here!";
                        } else {
                            favicon.href = faviconLink;
                            document.title = oldTitle;
                        }
                        darkMode = !darkMode;
                    };
                    const interval = setInterval(switchFavicon, 1100);
                    switchFavicon();
                    // Stop flashing if tab becomes visible
                    document.addEventListener("visibilitychange", ()=>{
                        if (!document.hidden) {
                            clearInterval(interval);
                            darkMode = false;
                            switchFavicon();
                        }
                    });
                }
            } else if (msg.type == "update") {
                if (settingsModalEl.classList.contains("show")) settingsModalEl.dispatchEvent(new Event("show.bs.modal"));
            } else if (msg.type == "clipboard") (0, _internal.CopyPaste).setClipboard(msg.payload);
            else if (msg.type == "probe") // also respond with the orginal sender as the payload
            this.sendBroadcastMessage("probe-response", msg.from);
            else if (msg.type == "probe-response") {
                if (msg.payload != this.tabID) // only handle response if the orignal probe message came from this tab
                return;
                // set the indexedDB entry with tabID msg.tabID to open=true
                let tabsObjectStore = MainController.instance.db.transaction("tabs", "readwrite").objectStore("tabs");
                tabsObjectStore.get(msg.from).onsuccess = function(event) {
                    const data = event.target.result;
                    if (data) {
                        data.open = "true";
                        tabsObjectStore.put(data).onsuccess = function() {
                            MainController.instance.sendBroadcastMessage("update");
                        };
                    }
                };
            }
            return false;
        };
        function sizeString(size) {
            if (size < 1024) return size + " B";
            else if (size < 1048576) return (size / 1024).toFixed(2) + " KB";
            else if (size < 1073741824) return (size / 1048576).toFixed(2) + " MB";
            else return (size / 1073741824).toFixed(2) + " GB";
        }
        function countComponents(data) {
            let count = 0;
            for (const component of data){
                if (component.type == "group") count += countComponents(component.components);
                count++;
            }
            return count;
        }
    }
    sendBroadcastMessage(type, payload) {
        const broadcastMessage = {
            type: type,
            from: this.tabID
        };
        if (payload != undefined) broadcastMessage.payload = payload;
        this.broadcastChannel.postMessage(broadcastMessage);
    }
    saveCurrentState(closeTab = true) {
        (0, _internal.Undo).addState();
        let tabsObjectStore = MainController.instance.db.transaction("tabs", "readwrite").objectStore("tabs");
        tabsObjectStore.get(this.tabID).onsuccess = function(event) {
            const data = event.target.result;
            if (closeTab) data.open = "false";
            data.data.components = (0, _internal.Undo).getCurrentState();
            data.data.version = (0, _internal.currentSaveVersion);
            if (data.data.components.length > 0) {
                data.settings.gridVisible = (0, _internal.CanvasController).instance.gridVisible;
                data.settings.majorGridSizecm = (0, _internal.CanvasController).instance.majorGridSizecm;
                data.settings.majorGridSubdivisions = (0, _internal.CanvasController).instance.majorGridSubdivisions;
                data.settings.viewBox = (0, _internal.CanvasController).instance.canvas.viewbox();
                data.settings.viewZoom = (0, _internal.CanvasController).instance.currentZoom;
                data.designName = MainController.instance.designName.value || undefined;
                tabsObjectStore.put(data).onsuccess = function() {
                    MainController.instance.sendBroadcastMessage("update");
                };
            } else if (closeTab) // if no data is present, delete the entry (keeps the db clean)
            tabsObjectStore.delete(MainController.instance.tabID).onsuccess = function() {
                MainController.instance.sendBroadcastMessage("update");
            };
        };
    }
    /**
     * initialises keyboard shortcuts
     */ initShortcuts() {
        // stop reload behaviour
        (0, _hotkeysJsDefault.default)("ctrl+r,command+r", ()=>false);
        // rotate selection
        (0, _hotkeysJsDefault.default)("ctrl+r,command+r", ()=>{
            if (this.mode == Modes.COMPONENT) (0, _internal.ComponentPlacer).instance.placeRotate(-90);
            else if ((0, _internal.SelectionController).instance.hasSelection()) {
                (0, _internal.SelectionController).instance.rotateSelection(-90);
                (0, _internal.Undo).addState();
            }
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+shift+r,command+shift+r", ()=>{
            if (this.mode == Modes.COMPONENT) (0, _internal.ComponentPlacer).instance.placeRotate(90);
            else if ((0, _internal.SelectionController).instance.hasSelection()) {
                (0, _internal.SelectionController).instance.rotateSelection(90);
                (0, _internal.Undo).addState();
            }
            return false;
        });
        //flip selection
        (0, _hotkeysJsDefault.default)("shift+x", ()=>{
            if (this.mode == Modes.COMPONENT) (0, _internal.ComponentPlacer).instance.placeFlip(true);
            else if ((0, _internal.SelectionController).instance.hasSelection()) {
                (0, _internal.SelectionController).instance.flipSelection(true);
                (0, _internal.Undo).addState();
            }
            return false;
        });
        (0, _hotkeysJsDefault.default)("shift+y", ()=>{
            if (this.mode == Modes.COMPONENT) (0, _internal.ComponentPlacer).instance.placeFlip(false);
            else if ((0, _internal.SelectionController).instance.hasSelection()) {
                (0, _internal.SelectionController).instance.flipSelection(false);
                (0, _internal.Undo).addState();
            }
            return false;
        });
        // select everything
        (0, _hotkeysJsDefault.default)("ctrl+a,command+a", ()=>{
            (0, _internal.SelectionController).instance.selectAll();
            return false;
        });
        //undo/redo
        (0, _hotkeysJsDefault.default)("ctrl+z,command+z", ()=>{
            (0, _internal.Undo).undo();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+y,command+y", ()=>{
            (0, _internal.Undo).redo();
            return false;
        });
        document.getElementById("undoButton").addEventListener("click", ()=>(0, _internal.Undo).undo());
        document.getElementById("redoButton").addEventListener("click", ()=>(0, _internal.Undo).redo());
        //copy/paste
        (0, _hotkeysJsDefault.default)("ctrl+c,command+c", ()=>{
            (0, _internal.CopyPaste).copy();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+v,command+v", ()=>{
            (0, _internal.CopyPaste).paste();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+x,command+x", ()=>{
            (0, _internal.CopyPaste).cut();
            return false;
        });
        //save/load
        (0, _hotkeysJsDefault.default)("ctrl+s,command+s", ()=>{
            (0, _internal.SaveController).instance.save();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+o,command+o", ()=>{
            (0, _internal.SaveController).instance.load();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+e,command+e", ()=>{
            (0, _internal.ExportController).instance.exportCircuiTikZ();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+shift+e,command+shift+e", ()=>{
            (0, _internal.ExportController).instance.exportSVG();
            return false;
        });
        (0, _hotkeysJsDefault.default)("ctrl+shift+i,command+shift+i", ()=>{
            (0, _internal.ExportController).instance.exportImage();
            return false;
        });
        // mode change
        (0, _hotkeysJsDefault.default)("q", ()=>{
            document.getElementById("addComponentButton").dispatchEvent(new MouseEvent("click"));
            return false;
        });
        (0, _hotkeysJsDefault.default)("esc", ()=>{
            this.switchMode(Modes.DRAG_PAN);
            return false;
        });
        (0, _hotkeysJsDefault.default)("w", ()=>{
            this.switchMode(Modes.DRAG_PAN);
            (0, _internal.ComponentPlacer).instance.placeComponent(new (0, _internal.WireComponent)());
            return false;
        });
        (0, _hotkeysJsDefault.default)("del, backspace", ()=>{
            if (!(0, _internal.SelectionController).instance.hasSelection()) this.switchMode(Modes.ERASE);
            else {
                (0, _internal.SelectionController).instance.removeSelection();
                (0, _internal.Undo).addState();
            }
            return false;
        });
        (0, _hotkeysJsDefault.default)("t", ()=>{
            this.switchMode(Modes.DRAG_PAN);
            (0, _internal.ComponentPlacer).instance.placeComponent(new (0, _internal.RectangleComponent)(true));
            return false;
        });
        // handle shortcuts for adding components
        // shortcutDict maps the Shortcut key to the title attribute of the html element where the callback can be found
        var shortcutDict = [
            {
                shortcut: "g",
                component: "Ground"
            },
            {
                shortcut: "alt+g,option+g",
                component: "Ground (tailless)"
            },
            {
                shortcut: "r",
                component: "Resistor (american)"
            },
            {
                shortcut: "c",
                component: "Capacitor"
            },
            {
                shortcut: "alt+c,option+c",
                component: "Curved (polarized) capacitor"
            },
            {
                shortcut: "l",
                component: "Inductor (cute)"
            },
            {
                shortcut: "alt+l,option+l",
                component: "Inductor (american)"
            },
            {
                shortcut: "d",
                component: "Empty diode"
            },
            {
                shortcut: "b",
                component: "NPN"
            },
            {
                shortcut: "alt+b,option+b",
                component: "PNP"
            },
            {
                shortcut: "n",
                component: "NMOS"
            },
            {
                shortcut: "alt+n,option+n",
                component: "PMOS"
            },
            {
                shortcut: "x",
                component: "Plain style crossing node"
            },
            {
                shortcut: "alt+x,option+x",
                component: "Jumper-style crossing node"
            },
            {
                shortcut: ".",
                component: "Connected terminal"
            },
            {
                shortcut: "alt+.,option+.",
                component: "Unconnected terminal"
            }
        ];
        // when a valid shortcut button is pressed, simulate a click on the corresponding button for the component
        for (const { shortcut, component } of shortcutDict)(0, _hotkeysJsDefault.default)(shortcut, ()=>{
            this.switchMode(Modes.DRAG_PAN); //switch to standard mode to avoid weird states
            var componentButton = document.querySelector('[title="' + component + '"]');
            var clickEvent = new MouseEvent("mouseup", {
                view: window,
                bubbles: true,
                cancelable: true
            });
            componentButton?.dispatchEvent(clickEvent);
        });
    }
    /**
     * Init the canvas controller
     */ async initCanvas() {
        let canvasElement = await (0, _domWatcher.waitForElementLoaded)("canvas");
        if (canvasElement) this.canvasController = new (0, _internal.CanvasController)(new _svgJs.Svg(canvasElement));
    }
    /**
     * Fetch & parse the symbol(s) svg.
     */ async initSymbolDB() {
        // Fetch symbol DB
        const symbolDBlink = await (0, _domWatcher.waitForElementLoaded)("symbolDBlink");
        const response = await fetch(symbolDBlink.href, {
            method: "GET",
            // must match symbolDBlink cors options in order to actually use the preloaded file
            mode: "cors",
            credentials: "same-origin"
        });
        const textContent = await response.text();
        // Parse & add to DOM
        const symbolsDocument = new DOMParser().parseFromString(textContent, "image/svg+xml");
        const symbolsSVGSVGElement = document.adoptNode(symbolsDocument.firstElementChild);
        symbolsSVGSVGElement.style.display = "none";
        symbolsSVGSVGElement.setAttribute("id", "symbolDB");
        document.body.appendChild(symbolsSVGSVGElement);
        // Extract symbols
        this.symbolsSVG = new _svgJs.Svg(symbolsSVGSVGElement);
        const componentsMetadata = Array.from(this.symbolsSVG.node.getElementsByTagName("component"));
        this.symbols = componentsMetadata.flatMap((componentMetadata)=>{
            return new (0, _internal.ComponentSymbol)(componentMetadata);
        });
    }
    /**
     * Init the mode change buttons.
     */ initModeButtons() {
        this.modeSwitchButtons.modeDragPan = document.getElementById("modeDragPan");
        this.modeSwitchButtons.modeDrawLine = document.getElementById("modeDrawLine");
        this.modeSwitchButtons.modeEraser = document.getElementById("modeEraser");
        this.modeSwitchButtons.modeDragPan.addEventListener("click", ()=>this.switchMode(Modes.DRAG_PAN), {
            passive: false
        });
        this.modeSwitchButtons.modeDrawLine.addEventListener("click", ()=>{
            this.switchMode(Modes.DRAG_PAN);
            this.modeSwitchButtons.modeDrawLine.classList.add("selected");
            (0, _internal.ComponentPlacer).instance.placeComponent(new (0, _internal.WireComponent)());
        }, {
            passive: false
        });
        this.modeSwitchButtons.modeEraser.addEventListener("click", ()=>this.switchMode(Modes.ERASE), {
            passive: false
        });
    }
    addShapeComponentsToOffcanvas(leftOffcanvasAccordion, leftOffcanvasOC) {
        // Add shapes accordion area
        let groupName = "Basic";
        const collapseGroupID = "collapseGroup-" + groupName.replace(/[^\d\w\-\_]+/gi, "-");
        const accordionGroup = leftOffcanvasAccordion.appendChild(document.createElement("div"));
        accordionGroup.classList.add("accordion-item");
        const accordionItemHeader = accordionGroup.appendChild(document.createElement("h2"));
        accordionItemHeader.classList.add("accordion-header");
        const accordionItemButton = accordionItemHeader.appendChild(document.createElement("button"));
        accordionItemButton.classList.add("accordion-button");
        accordionItemButton.innerText = groupName;
        accordionItemButton.setAttribute("aria-controls", collapseGroupID);
        accordionItemButton.setAttribute("aria-expanded", "true");
        accordionItemButton.setAttribute("data-bs-target", "#" + collapseGroupID);
        accordionItemButton.setAttribute("data-bs-toggle", "collapse");
        accordionItemButton.type = "button";
        const accordionItemCollapse = accordionGroup.appendChild(document.createElement("div"));
        accordionItemCollapse.classList.add("accordion-collapse", "collapse", "show");
        accordionItemCollapse.id = collapseGroupID;
        accordionItemCollapse.setAttribute("data-bs-parent", "#leftOffcanvasAccordion");
        const accordionItemBody = accordionItemCollapse.appendChild(document.createElement("div"));
        accordionItemBody.classList.add("accordion-body", "iconLibAccordionBody");
        //Add Text
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "text node");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Text";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.DRAG_PAN);
                let newComponent = new (0, _internal.RectangleComponent)(true);
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(-1, -14, 30, 15);
            svgIcon.text((add)=>{
                add.tspan("Text").fill({
                    color: (0, _internal.defaultStroke)
                });
            });
        }
        //Add rectangle
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "rect rectangle node");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Rectangle/Text";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.DRAG_PAN);
                let newComponent = new (0, _internal.RectangleComponent)(false);
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(0, 0, 17, 12);
            svgIcon.rect(15, 10).move(1, 1).fill("none").stroke({
                color: (0, _internal.defaultStroke),
                width: 1
            });
        }
        //Add Ellipse
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "ellipse circle node");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Ellipse";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.COMPONENT);
                if ((0, _internal.ComponentPlacer).instance.component) (0, _internal.ComponentPlacer).instance.placeCancel();
                let newComponent = new (0, _internal.EllipseComponent)();
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(0, 0, 17, 12);
            svgIcon.ellipse(15, 10).move(1, 1).fill("none").stroke({
                color: (0, _internal.defaultStroke),
                width: 1
            });
        }
        //Add Polygon
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "polygon path");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Polygon";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.COMPONENT);
                if ((0, _internal.ComponentPlacer).instance.component) (0, _internal.ComponentPlacer).instance.placeCancel();
                let newComponent = new (0, _internal.PolygonComponent)();
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(0, 0, 17, 12);
            svgIcon.polygon([
                [
                    1,
                    1
                ],
                [
                    16,
                    1
                ],
                [
                    15,
                    11
                ],
                [
                    11,
                    9
                ],
                [
                    5,
                    11
                ]
            ]).fill("none").stroke({
                color: (0, _internal.defaultStroke),
                width: 1
            });
        }
        //Add straight line
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "straight line path");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Straight line";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.DRAG_PAN);
                let newComponent = new (0, _internal.WireComponent)(true);
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(0, 0, 17, 12);
            svgIcon.line(2, 10, 15, 2).stroke({
                color: (0, _internal.defaultStroke),
                width: 1,
                opacity: 1
            });
        }
        //Add straight arrow
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "straight arrow path");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Straight arrow";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.DRAG_PAN);
                let newComponent = new (0, _internal.WireComponent)(true, true);
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(-1, -1, 12, 6);
            svgIcon.polygon([
                [
                    6,
                    0
                ],
                [
                    10,
                    2
                ],
                [
                    6,
                    4
                ],
                [
                    6,
                    2.2
                ],
                [
                    0,
                    2.2
                ],
                [
                    0,
                    1.8
                ],
                [
                    6,
                    1.8
                ]
            ]).rotate(-30, 5, 2).fill({
                color: (0, _internal.defaultStroke)
            });
        }
        //Add arrow
        {
            const addButton = accordionItemBody.appendChild(document.createElement("div"));
            addButton.classList.add("libComponent");
            addButton.setAttribute("searchData", "arrow path");
            addButton.ariaRoleDescription = "button";
            addButton.title = "Arrow";
            const listener = (ev)=>{
                ev.preventDefault();
                this.switchMode(Modes.DRAG_PAN);
                let newComponent = new (0, _internal.WireComponent)(false, true);
                (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                leftOffcanvasOC.hide();
            };
            addButton.addEventListener("mouseup", listener);
            addButton.addEventListener("touchstart", listener, {
                passive: false
            });
            let svgIcon = _svgJs.SVG().addTo(addButton);
            svgIcon.viewbox(-1, -2, 12, 8);
            svgIcon.polyline([
                [
                    0,
                    5
                ],
                [
                    5,
                    5
                ],
                [
                    5,
                    0
                ],
                [
                    9.1,
                    0
                ]
            ]).stroke({
                color: (0, _internal.defaultStroke),
                width: 0.5
            }).fill("none");
            svgIcon.polygon([
                [
                    9,
                    -1
                ],
                [
                    10.5,
                    0
                ],
                [
                    9,
                    1
                ]
            ]).fill({
                color: (0, _internal.defaultStroke)
            });
        }
    }
    /**
     * Init the left add offcanvas.
     */ async initAddComponentOffcanvas() {
        const leftOffcanvas = document.getElementById("leftOffcanvas");
        const leftOffcanvasOC = new (0, _bootstrap.Offcanvas)(leftOffcanvas);
        document.getElementById("componentFilterInput").addEventListener("input", this.filterComponents);
        document.getElementById("filterRegexButton").addEventListener("click", this.filterComponents);
        const addComponentButton = document.getElementById("addComponentButton");
        addComponentButton.addEventListener("click", ((ev)=>{
            this.switchMode(Modes.DRAG_PAN);
            leftOffcanvasOC.toggle();
            if (leftOffcanvas.classList.contains("showing") && ev.pointerType !== "touch") {
                let searchBar = document.getElementById("componentFilterInput");
                const refocus = ()=>{
                    searchBar.focus();
                    leftOffcanvas.removeEventListener("shown.bs.offcanvas", refocus);
                };
                refocus();
                leftOffcanvas.addEventListener("shown.bs.offcanvas", refocus);
            }
        }).bind(this), {
            passive: true
        });
        const leftOffcanvasAccordion = document.getElementById("leftOffcanvasAccordion");
        const groupedSymbols = this.symbols.reduce((groupedSymbols, symbol)=>{
            const key = symbol.groupName || "Unsorted components";
            let group = groupedSymbols.get(key);
            if (group) group.push(symbol);
            else groupedSymbols.set(key, [
                symbol
            ]);
            return groupedSymbols;
        }, new Map());
        this.addShapeComponentsToOffcanvas(leftOffcanvasAccordion, leftOffcanvasOC);
        for (const [groupName, symbols] of groupedSymbols.entries()){
            const collapseGroupID = "collapseGroup-" + groupName.replace(/[^\d\w\-\_]+/gi, "-");
            const accordionGroup = leftOffcanvasAccordion.appendChild(document.createElement("div"));
            accordionGroup.classList.add("accordion-item");
            const accordionItemHeader = accordionGroup.appendChild(document.createElement("h2"));
            accordionItemHeader.classList.add("accordion-header");
            const accordionItemButton = accordionItemHeader.appendChild(document.createElement("button"));
            accordionItemButton.classList.add("accordion-button", "collapsed");
            accordionItemButton.innerText = groupName;
            accordionItemButton.setAttribute("aria-controls", collapseGroupID);
            accordionItemButton.setAttribute("aria-expanded", "false");
            accordionItemButton.setAttribute("data-bs-target", "#" + collapseGroupID);
            accordionItemButton.setAttribute("data-bs-toggle", "collapse");
            accordionItemButton.type = "button";
            const accordionItemCollapse = accordionGroup.appendChild(document.createElement("div"));
            accordionItemCollapse.classList.add("accordion-collapse", "collapse");
            accordionItemCollapse.id = collapseGroupID;
            accordionItemCollapse.setAttribute("data-bs-parent", "#leftOffcanvasAccordion");
            const accordionItemBody = accordionItemCollapse.appendChild(document.createElement("div"));
            accordionItemBody.classList.add("accordion-body", "iconLibAccordionBody");
            for (const symbol of symbols){
                const addButton = accordionItemBody.appendChild(document.createElement("div"));
                addButton.classList.add("libComponent");
                addButton.setAttribute("searchData", [
                    symbol.tikzName,
                    symbol.isNodeSymbol ? "node" : "path"
                ].concat(symbol.possibleOptions.map((option)=>option.displayName ?? option.name).concat(symbol.possibleEnumOptions.flatMap((enumOption)=>enumOption.options.map((option)=>option.displayName ?? option.name)))).join(" "));
                addButton.ariaRoleDescription = "button";
                addButton.title = symbol.displayName || symbol.tikzName;
                const listener = (ev)=>{
                    ev.preventDefault();
                    this.switchMode(Modes.COMPONENT);
                    if ((0, _internal.ComponentPlacer).instance.component) (0, _internal.ComponentPlacer).instance.placeCancel();
                    let newComponent;
                    if (symbol.isNodeSymbol) newComponent = new (0, _internal.NodeSymbolComponent)(symbol);
                    else newComponent = new (0, _internal.PathSymbolComponent)(symbol);
                    (0, _internal.ComponentPlacer).instance.placeComponent(newComponent);
                    leftOffcanvasOC.hide();
                };
                addButton.addEventListener("mouseup", listener);
                addButton.addEventListener("touchstart", listener, {
                    passive: false
                });
                let svgIcon = _svgJs.SVG().addTo(addButton);
                let viewBox = new _svgJs.Box(symbol._mapping.values().toArray()[0].viewBox);
                //oversize viewbox due to stroke widths
                viewBox.width += symbol.maxStroke;
                viewBox.height += symbol.maxStroke;
                viewBox.x -= symbol.maxStroke / 2;
                viewBox.y -= symbol.maxStroke / 2;
                // svg icon should have new size
                svgIcon.viewbox(viewBox).width(viewBox.width).height(viewBox.height);
                let use = svgIcon.use(symbol.symbolElement.id());
                use.width(symbol.viewBox.width).height(symbol.viewBox.height); // use should have original size values
                use.stroke((0, _internal.defaultStroke)).fill((0, _internal.defaultFill)).node.style.color = (0, _internal.defaultStroke);
            }
        }
    }
    /**
     * filter the components in the left OffCanvas to only show what matches the search string (in a new accordeon item)
     */ filterComponents(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        const element = document.getElementById("componentFilterInput");
        const feedbacktext = document.getElementById("invalid-feedback-text");
        const filterWithRegex = document.getElementById("filterRegexButton").classList.contains("active");
        let text = element.value;
        let regex = null;
        if (filterWithRegex) {
            regex = new RegExp(text, "i");
            element.classList.remove("is-invalid");
            feedbacktext.classList.add("d-none");
        } else try {
            regex = new RegExp(".*" + text.split("").join(".*") + ".*", "i");
            element.classList.remove("is-invalid");
            feedbacktext.classList.add("d-none");
        } catch (e) {
            text = "";
            regex = new RegExp(text, "i");
            element.classList.add("is-invalid");
            feedbacktext.classList.remove("d-none");
        }
        const accordion = document.getElementById("leftOffcanvasAccordion");
        const accordionItems = accordion.getElementsByClassName("accordion-item");
        Array.prototype.forEach.call(accordionItems, (accordionItem, index)=>{
            const libComponents = accordionItem.getElementsByClassName("libComponent");
            let showCount = 0;
            Array.prototype.forEach.call(libComponents, (libComponent)=>{
                if (text) {
                    if (!(regex.test(libComponent.title) || regex.test(libComponent.getAttribute("searchData")))) {
                        libComponent.classList.add("d-none");
                        return;
                    }
                }
                libComponent.classList.remove("d-none");
                showCount++;
            });
            if (showCount === 0) accordionItem.classList.add("d-none");
            else accordionItem.classList.remove("d-none");
            if (text) {
                accordionItem.children[0]?.children[0]?.classList.remove("collapsed");
                accordionItem.children[1]?.classList.add("show");
            } else {
                accordionItem.children[0]?.children[0]?.classList.add("collapsed");
                accordionItem.children[1]?.classList.remove("show");
            }
            if (index === 0) {
                accordionItem.children[0]?.children[0]?.classList.remove("collapsed");
                accordionItem.children[1]?.classList.add("show");
            }
        });
    }
    /**
     * Switches the mode. This deactivates the old controller and activates the new one.
     */ switchMode(newMode) {
        if (newMode == this.mode) return;
        let oldMode = this.mode;
        this.mode = newMode;
        switch(oldMode){
            case Modes.DRAG_PAN:
                this.modeSwitchButtons.modeDragPan.classList.remove("selected");
                (0, _internal.CanvasController).instance.deactivatePanning();
                (0, _internal.SelectionController).instance.deactivateSelection();
                break;
            case Modes.ERASE:
                this.modeSwitchButtons.modeEraser.classList.remove("selected");
                (0, _internal.EraseController).instance.deactivate();
                break;
            case Modes.COMPONENT:
                this.modeSwitchButtons.modeDragPan.classList.remove("selected");
                this.modeSwitchButtons.modeDrawLine.classList.remove("selected");
                (0, _internal.ComponentPlacer).instance.placeCancel();
                (0, _internal.CanvasController).instance.deactivatePanning();
                break;
            default:
                break;
        }
        switch(newMode){
            case Modes.DRAG_PAN:
                this.modeSwitchButtons.modeDragPan.classList.add("selected");
                (0, _internal.CanvasController).instance.activatePanning();
                (0, _internal.SelectionController).instance.activateSelection();
                break;
            case Modes.ERASE:
                this.modeSwitchButtons.modeEraser.classList.add("selected");
                (0, _internal.EraseController).instance.activate();
                break;
            case Modes.COMPONENT:
                this.modeSwitchButtons.modeDragPan.classList.add("selected");
                (0, _internal.CanvasController).instance.activatePanning();
                break;
            default:
                break;
        }
    }
    updateTheme() {
        if (this.darkModeLast == this.darkMode) return;
        for (const instance of this.circuitComponents)instance.updateTheme();
        this.darkModeLast = this.darkMode;
    }
    /**
     * add missing fill attributes to all symbol db entries where fill is undefined --> needs explicit setting, otherwise the color theme change does strange things.
     * called once on initialization
     * @param {Element} node
     */ preprocessSymbolColors(node) {
        let elementsWithFill = node.querySelectorAll("[fill]");
        let elementsWithStroke = node.querySelectorAll("[stroke]");
        //this group
        let currentFill = node.getAttribute("fill");
        if (currentFill == "#fff") node.setAttribute("fill", "currentFill");
        let currentStroke = node.getAttribute("stroke");
        if (currentStroke == "#000") node.setAttribute("stroke", "currentStroke");
        for (const element of elementsWithFill){
            let currentFill = element.getAttribute("fill");
            if (currentFill == "#fff") element.setAttribute("fill", "currentFill");
        }
        for (const element of elementsWithStroke){
            let currentStroke = element.getAttribute("stroke");
            if (currentStroke == "#000") element.setAttribute("stroke", "currentStroke");
        }
        this.addFill(node);
    }
    addFill(node) {
        let hasFill = node.getAttribute("fill") !== null;
        if (hasFill) return;
        for (const element of node.children){
            if (element.nodeName === "g") this.addFill(element);
            else if (!element.getAttribute("fill")) element.setAttribute("fill", "currentColor");
        }
    }
    /**
     * Adds a new instance to {@link circuitComponents} and adds its snapping points.
     */ addComponent(circuitComponent) {
        this.circuitComponents.push(circuitComponent);
    }
    /**
     * Removes an instance from {@link instances} and also removes its snapping points.
     */ removeComponent(circuitComponent) {
        const idx = this.circuitComponents.indexOf(circuitComponent);
        if (idx > -1) {
            this.circuitComponents.splice(idx, 1);
            circuitComponent.remove();
        }
    }
}

},{"@svgdotjs/svg.js":"fFByv","bootstrap":"hjCRY","../utils/impSVGNumber":"iUHL8","../utils/domWatcher":"2YEDM","hotkeys-js":"7tDMU","../../../package.json":"c3hj5","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fFByv":[function(require,module,exports,__globalThis) {
/*!
* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.
* @version 3.2.4
* https://svgjs.dev/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Thu Jun 27 2024 12:00:16 GMT+0200 (Central European Summer Time)
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "A", ()=>A);
parcelHelpers.export(exports, "Animator", ()=>Animator);
parcelHelpers.export(exports, "Array", ()=>SVGArray);
parcelHelpers.export(exports, "Box", ()=>Box);
parcelHelpers.export(exports, "Circle", ()=>Circle);
parcelHelpers.export(exports, "ClipPath", ()=>ClipPath);
parcelHelpers.export(exports, "Color", ()=>Color);
parcelHelpers.export(exports, "Container", ()=>Container);
parcelHelpers.export(exports, "Controller", ()=>Controller);
parcelHelpers.export(exports, "Defs", ()=>Defs);
parcelHelpers.export(exports, "Dom", ()=>Dom);
parcelHelpers.export(exports, "Ease", ()=>Ease);
parcelHelpers.export(exports, "Element", ()=>Element);
parcelHelpers.export(exports, "Ellipse", ()=>Ellipse);
parcelHelpers.export(exports, "EventTarget", ()=>EventTarget);
parcelHelpers.export(exports, "ForeignObject", ()=>ForeignObject);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "G", ()=>G);
parcelHelpers.export(exports, "Gradient", ()=>Gradient);
parcelHelpers.export(exports, "Image", ()=>Image);
parcelHelpers.export(exports, "Line", ()=>Line);
parcelHelpers.export(exports, "List", ()=>List);
parcelHelpers.export(exports, "Marker", ()=>Marker);
parcelHelpers.export(exports, "Mask", ()=>Mask);
parcelHelpers.export(exports, "Matrix", ()=>Matrix);
parcelHelpers.export(exports, "Morphable", ()=>Morphable);
parcelHelpers.export(exports, "NonMorphable", ()=>NonMorphable);
parcelHelpers.export(exports, "Number", ()=>SVGNumber);
parcelHelpers.export(exports, "ObjectBag", ()=>ObjectBag);
parcelHelpers.export(exports, "PID", ()=>PID);
parcelHelpers.export(exports, "Path", ()=>Path);
parcelHelpers.export(exports, "PathArray", ()=>PathArray);
parcelHelpers.export(exports, "Pattern", ()=>Pattern);
parcelHelpers.export(exports, "Point", ()=>Point);
parcelHelpers.export(exports, "PointArray", ()=>PointArray);
parcelHelpers.export(exports, "Polygon", ()=>Polygon);
parcelHelpers.export(exports, "Polyline", ()=>Polyline);
parcelHelpers.export(exports, "Queue", ()=>Queue);
parcelHelpers.export(exports, "Rect", ()=>Rect);
parcelHelpers.export(exports, "Runner", ()=>Runner);
parcelHelpers.export(exports, "SVG", ()=>SVG);
parcelHelpers.export(exports, "Shape", ()=>Shape);
parcelHelpers.export(exports, "Spring", ()=>Spring);
parcelHelpers.export(exports, "Stop", ()=>Stop);
parcelHelpers.export(exports, "Style", ()=>Style);
parcelHelpers.export(exports, "Svg", ()=>Svg);
parcelHelpers.export(exports, "Symbol", ()=>Symbol);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "TextPath", ()=>TextPath);
parcelHelpers.export(exports, "Timeline", ()=>Timeline);
parcelHelpers.export(exports, "TransformBag", ()=>TransformBag);
parcelHelpers.export(exports, "Tspan", ()=>Tspan);
parcelHelpers.export(exports, "Use", ()=>Use);
parcelHelpers.export(exports, "adopt", ()=>adopt);
parcelHelpers.export(exports, "assignNewId", ()=>assignNewId);
parcelHelpers.export(exports, "clearEvents", ()=>clearEvents);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "defaults", ()=>defaults);
parcelHelpers.export(exports, "dispatch", ()=>dispatch);
parcelHelpers.export(exports, "easing", ()=>easing);
parcelHelpers.export(exports, "eid", ()=>eid);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "find", ()=>baseFind);
parcelHelpers.export(exports, "getClass", ()=>getClass);
parcelHelpers.export(exports, "getEventTarget", ()=>getEventTarget);
parcelHelpers.export(exports, "getEvents", ()=>getEvents);
parcelHelpers.export(exports, "getWindow", ()=>getWindow);
parcelHelpers.export(exports, "makeInstance", ()=>makeInstance);
parcelHelpers.export(exports, "makeMorphable", ()=>makeMorphable);
parcelHelpers.export(exports, "mockAdopt", ()=>mockAdopt);
parcelHelpers.export(exports, "namespaces", ()=>namespaces);
parcelHelpers.export(exports, "nodeOrNew", ()=>nodeOrNew);
parcelHelpers.export(exports, "off", ()=>off);
parcelHelpers.export(exports, "on", ()=>on);
parcelHelpers.export(exports, "parser", ()=>parser);
parcelHelpers.export(exports, "regex", ()=>regex);
parcelHelpers.export(exports, "register", ()=>register);
parcelHelpers.export(exports, "registerMorphableType", ()=>registerMorphableType);
parcelHelpers.export(exports, "registerWindow", ()=>registerWindow);
parcelHelpers.export(exports, "restoreWindow", ()=>restoreWindow);
parcelHelpers.export(exports, "root", ()=>root);
parcelHelpers.export(exports, "saveWindow", ()=>saveWindow);
parcelHelpers.export(exports, "utils", ()=>utils);
parcelHelpers.export(exports, "windowEvents", ()=>windowEvents);
parcelHelpers.export(exports, "withWindow", ()=>withWindow);
parcelHelpers.export(exports, "wrapWithAttrCheck", ()=>wrapWithAttrCheck);
const methods$1 = {};
const names = [];
function registerMethods(name, m) {
    if (Array.isArray(name)) {
        for (const _name of name)registerMethods(_name, m);
        return;
    }
    if (typeof name === 'object') {
        for(const _name in name)registerMethods(_name, name[_name]);
        return;
    }
    addMethodNames(Object.getOwnPropertyNames(m));
    methods$1[name] = Object.assign(methods$1[name] || {}, m);
}
function getMethodsFor(name) {
    return methods$1[name] || {};
}
function getMethodNames() {
    return [
        ...new Set(names)
    ];
}
function addMethodNames(_names) {
    names.push(..._names);
}
// Map function
function map(array, block) {
    let i;
    const il = array.length;
    const result = [];
    for(i = 0; i < il; i++)result.push(block(array[i]));
    return result;
}
// Filter function
function filter(array, block) {
    let i;
    const il = array.length;
    const result = [];
    for(i = 0; i < il; i++)if (block(array[i])) result.push(array[i]);
    return result;
}
// Degrees to radians
function radians(d) {
    return d % 360 * Math.PI / 180;
}
// Radians to degrees
function degrees(r) {
    return r * 180 / Math.PI % 360;
}
// Convert camel cased string to dash separated
function unCamelCase(s) {
    return s.replace(/([A-Z])/g, function(m, g) {
        return '-' + g.toLowerCase();
    });
}
// Capitalize first letter of a string
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
// Calculate proportional width and height values when necessary
function proportionalSize(element, width, height, box) {
    if (width == null || height == null) {
        box = box || element.bbox();
        if (width == null) width = box.width / box.height * height;
        else if (height == null) height = box.height / box.width * width;
    }
    return {
        width: width,
        height: height
    };
}
/**
 * This function adds support for string origins.
 * It searches for an origin in o.origin o.ox and o.originX.
 * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50
 **/ function getOrigin(o, element) {
    const origin = o.origin;
    // First check if origin is in ox or originX
    let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';
    let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center';
    // Then check if origin was used and overwrite in that case
    if (origin != null) [ox, oy] = Array.isArray(origin) ? origin : typeof origin === 'object' ? [
        origin.x,
        origin.y
    ] : [
        origin,
        origin
    ];
    // Make sure to only call bbox when actually needed
    const condX = typeof ox === 'string';
    const condY = typeof oy === 'string';
    if (condX || condY) {
        const { height, width, x, y } = element.bbox();
        // And only overwrite if string was passed for this specific axis
        if (condX) ox = ox.includes('left') ? x : ox.includes('right') ? x + width : x + width / 2;
        if (condY) oy = oy.includes('top') ? y : oy.includes('bottom') ? y + height : y + height / 2;
    }
    // Return the origin as it is if it wasn't a string
    return [
        ox,
        oy
    ];
}
const descriptiveElements = new Set([
    'desc',
    'metadata',
    'title'
]);
const isDescriptive = (element)=>descriptiveElements.has(element.nodeName);
const writeDataToDom = (element, data, defaults = {})=>{
    const cloned = {
        ...data
    };
    for(const key in cloned)if (cloned[key].valueOf() === defaults[key]) delete cloned[key];
    if (Object.keys(cloned).length) element.node.setAttribute('data-svgjs', JSON.stringify(cloned)); // see #428
    else {
        element.node.removeAttribute('data-svgjs');
        element.node.removeAttribute('svgjs:data');
    }
};
var utils = {
    __proto__: null,
    capitalize: capitalize,
    degrees: degrees,
    filter: filter,
    getOrigin: getOrigin,
    isDescriptive: isDescriptive,
    map: map,
    proportionalSize: proportionalSize,
    radians: radians,
    unCamelCase: unCamelCase,
    writeDataToDom: writeDataToDom
};
// Default namespaces
const svg = 'http://www.w3.org/2000/svg';
const html = 'http://www.w3.org/1999/xhtml';
const xmlns = 'http://www.w3.org/2000/xmlns/';
const xlink = 'http://www.w3.org/1999/xlink';
var namespaces = {
    __proto__: null,
    html: html,
    svg: svg,
    xlink: xlink,
    xmlns: xmlns
};
const globals = {
    window: typeof window === 'undefined' ? null : window,
    document: typeof document === 'undefined' ? null : document
};
function registerWindow(win = null, doc = null) {
    globals.window = win;
    globals.document = doc;
}
const save = {};
function saveWindow() {
    save.window = globals.window;
    save.document = globals.document;
}
function restoreWindow() {
    globals.window = save.window;
    globals.document = save.document;
}
function withWindow(win, fn) {
    saveWindow();
    registerWindow(win, win.document);
    fn(win, win.document);
    restoreWindow();
}
function getWindow() {
    return globals.window;
}
class Base {
}
const elements = {};
const root = '___SYMBOL___ROOT___';
// Method for element creation
function create(name, ns = svg) {
    // create element
    return globals.document.createElementNS(ns, name);
}
function makeInstance(element, isHTML = false) {
    if (element instanceof Base) return element;
    if (typeof element === 'object') return adopter(element);
    if (element == null) return new elements[root]();
    if (typeof element === 'string' && element.charAt(0) !== '<') return adopter(globals.document.querySelector(element));
    // Make sure, that HTML elements are created with the correct namespace
    const wrapper = isHTML ? globals.document.createElement('div') : create('svg');
    wrapper.innerHTML = element;
    // We can use firstChild here because we know,
    // that the first char is < and thus an element
    element = adopter(wrapper.firstChild);
    // make sure, that element doesn't have its wrapper attached
    wrapper.removeChild(wrapper.firstChild);
    return element;
}
function nodeOrNew(name, node) {
    return node && (node instanceof globals.window.Node || node.ownerDocument && node instanceof node.ownerDocument.defaultView.Node) ? node : create(name);
}
// Adopt existing svg elements
function adopt(node) {
    // check for presence of node
    if (!node) return null;
    // make sure a node isn't already adopted
    if (node.instance instanceof Base) return node.instance;
    if (node.nodeName === '#document-fragment') return new elements.Fragment(node);
    // initialize variables
    let className = capitalize(node.nodeName || 'Dom');
    // Make sure that gradients are adopted correctly
    if (className === 'LinearGradient' || className === 'RadialGradient') className = 'Gradient';
    else if (!elements[className]) className = 'Dom';
    return new elements[className](node);
}
let adopter = adopt;
function mockAdopt(mock = adopt) {
    adopter = mock;
}
function register(element, name = element.name, asRoot = false) {
    elements[name] = element;
    if (asRoot) elements[root] = element;
    addMethodNames(Object.getOwnPropertyNames(element.prototype));
    return element;
}
function getClass(name) {
    return elements[name];
}
// Element id sequence
let did = 1000;
// Get next named element id
function eid(name) {
    return 'Svgjs' + capitalize(name) + did++;
}
// Deep new id assignment
function assignNewId(node) {
    // do the same for SVG child nodes as well
    for(let i = node.children.length - 1; i >= 0; i--)assignNewId(node.children[i]);
    if (node.id) {
        node.id = eid(node.nodeName);
        return node;
    }
    return node;
}
// Method for extending objects
function extend(modules, methods) {
    let key, i;
    modules = Array.isArray(modules) ? modules : [
        modules
    ];
    for(i = modules.length - 1; i >= 0; i--)for(key in methods)modules[i].prototype[key] = methods[key];
}
function wrapWithAttrCheck(fn) {
    return function(...args) {
        const o = args[args.length - 1];
        if (o && o.constructor === Object && !(o instanceof Array)) return fn.apply(this, args.slice(0, -1)).attr(o);
        else return fn.apply(this, args);
    };
}
// Get all siblings, including myself
function siblings() {
    return this.parent().children();
}
// Get the current position siblings
function position() {
    return this.parent().index(this);
}
// Get the next element (will return null if there is none)
function next() {
    return this.siblings()[this.position() + 1];
}
// Get the next element (will return null if there is none)
function prev() {
    return this.siblings()[this.position() - 1];
}
// Send given element one step forward
function forward() {
    const i = this.position();
    const p = this.parent();
    // move node one step forward
    p.add(this.remove(), i + 1);
    return this;
}
// Send given element one step backward
function backward() {
    const i = this.position();
    const p = this.parent();
    p.add(this.remove(), i ? i - 1 : 0);
    return this;
}
// Send given element all the way to the front
function front() {
    const p = this.parent();
    // Move node forward
    p.add(this.remove());
    return this;
}
// Send given element all the way to the back
function back() {
    const p = this.parent();
    // Move node back
    p.add(this.remove(), 0);
    return this;
}
// Inserts a given element before the targeted element
function before(element) {
    element = makeInstance(element);
    element.remove();
    const i = this.position();
    this.parent().add(element, i);
    return this;
}
// Inserts a given element after the targeted element
function after(element) {
    element = makeInstance(element);
    element.remove();
    const i = this.position();
    this.parent().add(element, i + 1);
    return this;
}
function insertBefore(element) {
    element = makeInstance(element);
    element.before(this);
    return this;
}
function insertAfter(element) {
    element = makeInstance(element);
    element.after(this);
    return this;
}
registerMethods('Dom', {
    siblings,
    position,
    next,
    prev,
    forward,
    backward,
    front,
    back,
    before,
    after,
    insertBefore,
    insertAfter
});
// Parse unit value
const numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;
// Parse hex value
const hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
// Parse rgb value
const rgb = /rgb\((\d+),(\d+),(\d+)\)/;
// Parse reference id
const reference = /(#[a-z_][a-z0-9\-_]*)/i;
// splits a transformation chain
const transforms = /\)\s*,?\s*/;
// Whitespace
const whitespace = /\s/g;
// Test hex value
const isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;
// Test rgb value
const isRgb = /^rgb\(/;
// Test for blank string
const isBlank = /^(\s+)?$/;
// Test for numeric string
const isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
// Test for image url
const isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;
// split at whitespace and comma
const delimiter = /[\s,]+/;
// Test for path letter
const isPathLetter = /[MLHVCSQTAZ]/i;
var regex = {
    __proto__: null,
    delimiter: delimiter,
    hex: hex,
    isBlank: isBlank,
    isHex: isHex,
    isImage: isImage,
    isNumber: isNumber,
    isPathLetter: isPathLetter,
    isRgb: isRgb,
    numberAndUnit: numberAndUnit,
    reference: reference,
    rgb: rgb,
    transforms: transforms,
    whitespace: whitespace
};
// Return array of classes on the node
function classes() {
    const attr = this.attr('class');
    return attr == null ? [] : attr.trim().split(delimiter);
}
// Return true if class exists on the node, false otherwise
function hasClass(name) {
    return this.classes().indexOf(name) !== -1;
}
// Add class to the node
function addClass(name) {
    if (!this.hasClass(name)) {
        const array = this.classes();
        array.push(name);
        this.attr('class', array.join(' '));
    }
    return this;
}
// Remove class from the node
function removeClass(name) {
    if (this.hasClass(name)) this.attr('class', this.classes().filter(function(c) {
        return c !== name;
    }).join(' '));
    return this;
}
// Toggle the presence of a class on the node
function toggleClass(name) {
    return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
}
registerMethods('Dom', {
    classes,
    hasClass,
    addClass,
    removeClass,
    toggleClass
});
// Dynamic style generator
function css(style, val) {
    const ret = {};
    if (arguments.length === 0) {
        // get full style as object
        this.node.style.cssText.split(/\s*;\s*/).filter(function(el) {
            return !!el.length;
        }).forEach(function(el) {
            const t = el.split(/\s*:\s*/);
            ret[t[0]] = t[1];
        });
        return ret;
    }
    if (arguments.length < 2) {
        // get style properties as array
        if (Array.isArray(style)) {
            for (const name of style){
                const cased = name;
                ret[name] = this.node.style.getPropertyValue(cased);
            }
            return ret;
        }
        // get style for property
        if (typeof style === 'string') return this.node.style.getPropertyValue(style);
        // set styles in object
        if (typeof style === 'object') for(const name in style)// set empty string if null/undefined/'' was given
        this.node.style.setProperty(name, style[name] == null || isBlank.test(style[name]) ? '' : style[name]);
    }
    // set style for property
    if (arguments.length === 2) this.node.style.setProperty(style, val == null || isBlank.test(val) ? '' : val);
    return this;
}
// Show element
function show() {
    return this.css('display', '');
}
// Hide element
function hide() {
    return this.css('display', 'none');
}
// Is element visible?
function visible() {
    return this.css('display') !== 'none';
}
registerMethods('Dom', {
    css,
    show,
    hide,
    visible
});
// Store data values on svg nodes
function data(a, v, r) {
    if (a == null) // get an object of attributes
    return this.data(map(filter(this.node.attributes, (el)=>el.nodeName.indexOf('data-') === 0), (el)=>el.nodeName.slice(5)));
    else if (a instanceof Array) {
        const data = {};
        for (const key of a)data[key] = this.data(key);
        return data;
    } else if (typeof a === 'object') for(v in a)this.data(v, a[v]);
    else if (arguments.length < 2) try {
        return JSON.parse(this.attr('data-' + a));
    } catch (e) {
        return this.attr('data-' + a);
    }
    else this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
    return this;
}
registerMethods('Dom', {
    data
});
// Remember arbitrary data
function remember(k, v) {
    // remember every item in an object individually
    if (typeof arguments[0] === 'object') for(const key in k)this.remember(key, k[key]);
    else if (arguments.length === 1) // retrieve memory
    return this.memory()[k];
    else // store memory
    this.memory()[k] = v;
    return this;
}
// Erase a given memory
function forget() {
    if (arguments.length === 0) this._memory = {};
    else for(let i = arguments.length - 1; i >= 0; i--)delete this.memory()[arguments[i]];
    return this;
}
// This triggers creation of a new hidden class which is not performant
// However, this function is not rarely used so it will not happen frequently
// Return local memory object
function memory() {
    return this._memory = this._memory || {};
}
registerMethods('Dom', {
    remember,
    forget,
    memory
});
function sixDigitHex(hex) {
    return hex.length === 4 ? [
        '#',
        hex.substring(1, 2),
        hex.substring(1, 2),
        hex.substring(2, 3),
        hex.substring(2, 3),
        hex.substring(3, 4),
        hex.substring(3, 4)
    ].join('') : hex;
}
function componentHex(component) {
    const integer = Math.round(component);
    const bounded = Math.max(0, Math.min(255, integer));
    const hex = bounded.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
}
function is(object, space) {
    for(let i = space.length; i--;){
        if (object[space[i]] == null) return false;
    }
    return true;
}
function getParameters(a, b) {
    const params = is(a, 'rgb') ? {
        _a: a.r,
        _b: a.g,
        _c: a.b,
        _d: 0,
        space: 'rgb'
    } : is(a, 'xyz') ? {
        _a: a.x,
        _b: a.y,
        _c: a.z,
        _d: 0,
        space: 'xyz'
    } : is(a, 'hsl') ? {
        _a: a.h,
        _b: a.s,
        _c: a.l,
        _d: 0,
        space: 'hsl'
    } : is(a, 'lab') ? {
        _a: a.l,
        _b: a.a,
        _c: a.b,
        _d: 0,
        space: 'lab'
    } : is(a, 'lch') ? {
        _a: a.l,
        _b: a.c,
        _c: a.h,
        _d: 0,
        space: 'lch'
    } : is(a, 'cmyk') ? {
        _a: a.c,
        _b: a.m,
        _c: a.y,
        _d: a.k,
        space: 'cmyk'
    } : {
        _a: 0,
        _b: 0,
        _c: 0,
        space: 'rgb'
    };
    params.space = b || params.space;
    return params;
}
function cieSpace(space) {
    if (space === 'lab' || space === 'xyz' || space === 'lch') return true;
    else return false;
}
function hueToRgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
}
class Color {
    constructor(...inputs){
        this.init(...inputs);
    }
    // Test if given value is a color
    static isColor(color) {
        return color && (color instanceof Color || this.isRgb(color) || this.test(color));
    }
    // Test if given value is an rgb object
    static isRgb(color) {
        return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
    }
    /*
  Generating random colors
  */ static random(mode = 'vibrant', t) {
        // Get the math modules
        const { random, round, sin, PI: pi } = Math;
        // Run the correct generator
        if (mode === 'vibrant') {
            const l = 24 * random() + 57;
            const c = 38 * random() + 45;
            const h = 360 * random();
            const color = new Color(l, c, h, 'lch');
            return color;
        } else if (mode === 'sine') {
            t = t == null ? random() : t;
            const r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
            const g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
            const b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);
            const color = new Color(r, g, b);
            return color;
        } else if (mode === 'pastel') {
            const l = 8 * random() + 86;
            const c = 17 * random() + 9;
            const h = 360 * random();
            const color = new Color(l, c, h, 'lch');
            return color;
        } else if (mode === 'dark') {
            const l = 10 + 10 * random();
            const c = 50 * random() + 86;
            const h = 360 * random();
            const color = new Color(l, c, h, 'lch');
            return color;
        } else if (mode === 'rgb') {
            const r = 255 * random();
            const g = 255 * random();
            const b = 255 * random();
            const color = new Color(r, g, b);
            return color;
        } else if (mode === 'lab') {
            const l = 100 * random();
            const a = 256 * random() - 128;
            const b = 256 * random() - 128;
            const color = new Color(l, a, b, 'lab');
            return color;
        } else if (mode === 'grey') {
            const grey = 255 * random();
            const color = new Color(grey, grey, grey);
            return color;
        } else throw new Error('Unsupported random color mode');
    }
    // Test if given value is a color string
    static test(color) {
        return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));
    }
    cmyk() {
        // Get the rgb values for the current color
        const { _a, _b, _c } = this.rgb();
        const [r, g, b] = [
            _a,
            _b,
            _c
        ].map((v)=>v / 255);
        // Get the cmyk values in an unbounded format
        const k = Math.min(1 - r, 1 - g, 1 - b);
        if (k === 1) // Catch the black case
        return new Color(0, 0, 0, 1, 'cmyk');
        const c = (1 - r - k) / (1 - k);
        const m = (1 - g - k) / (1 - k);
        const y = (1 - b - k) / (1 - k);
        // Construct the new color
        const color = new Color(c, m, y, k, 'cmyk');
        return color;
    }
    hsl() {
        // Get the rgb values
        const { _a, _b, _c } = this.rgb();
        const [r, g, b] = [
            _a,
            _b,
            _c
        ].map((v)=>v / 255);
        // Find the maximum and minimum values to get the lightness
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        // If the r, g, v values are identical then we are grey
        const isGrey = max === min;
        // Calculate the hue and saturation
        const delta = max - min;
        const s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
        const h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0;
        // Construct and return the new color
        const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
        return color;
    }
    init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {
        // This catches the case when a falsy value is passed like ''
        a = !a ? 0 : a;
        // Reset all values in case the init function is rerun with new color space
        if (this.space) for(const component in this.space)delete this[this.space[component]];
        if (typeof a === 'number') {
            // Allow for the case that we don't need d...
            space = typeof d === 'string' ? d : space;
            d = typeof d === 'string' ? 0 : d;
            // Assign the values straight to the color
            Object.assign(this, {
                _a: a,
                _b: b,
                _c: c,
                _d: d,
                space
            });
        // If the user gave us an array, make the color from it
        } else if (a instanceof Array) {
            this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
            Object.assign(this, {
                _a: a[0],
                _b: a[1],
                _c: a[2],
                _d: a[3] || 0
            });
        } else if (a instanceof Object) {
            // Set the object up and assign its values directly
            const values = getParameters(a, b);
            Object.assign(this, values);
        } else if (typeof a === 'string') {
            if (isRgb.test(a)) {
                const noWhitespace = a.replace(whitespace, '');
                const [_a, _b, _c] = rgb.exec(noWhitespace).slice(1, 4).map((v)=>parseInt(v));
                Object.assign(this, {
                    _a,
                    _b,
                    _c,
                    _d: 0,
                    space: 'rgb'
                });
            } else if (isHex.test(a)) {
                const hexParse = (v)=>parseInt(v, 16);
                const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse);
                Object.assign(this, {
                    _a,
                    _b,
                    _c,
                    _d: 0,
                    space: 'rgb'
                });
            } else throw Error("Unsupported string format, can't construct Color");
        }
        // Now add the components as a convenience
        const { _a, _b, _c, _d } = this;
        const components = this.space === 'rgb' ? {
            r: _a,
            g: _b,
            b: _c
        } : this.space === 'xyz' ? {
            x: _a,
            y: _b,
            z: _c
        } : this.space === 'hsl' ? {
            h: _a,
            s: _b,
            l: _c
        } : this.space === 'lab' ? {
            l: _a,
            a: _b,
            b: _c
        } : this.space === 'lch' ? {
            l: _a,
            c: _b,
            h: _c
        } : this.space === 'cmyk' ? {
            c: _a,
            m: _b,
            y: _c,
            k: _d
        } : {};
        Object.assign(this, components);
    }
    lab() {
        // Get the xyz color
        const { x, y, z } = this.xyz();
        // Get the lab components
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        // Construct and return a new color
        const color = new Color(l, a, b, 'lab');
        return color;
    }
    lch() {
        // Get the lab color directly
        const { l, a, b } = this.lab();
        // Get the chromaticity and the hue using polar coordinates
        const c = Math.sqrt(a ** 2 + b ** 2);
        let h = 180 * Math.atan2(b, a) / Math.PI;
        if (h < 0) {
            h *= -1;
            h = 360 - h;
        }
        // Make a new color and return it
        const color = new Color(l, c, h, 'lch');
        return color;
    }
    /*
  Conversion Methods
  */ rgb() {
        if (this.space === 'rgb') return this;
        else if (cieSpace(this.space)) {
            // Convert to the xyz color space
            let { x, y, z } = this;
            if (this.space === 'lab' || this.space === 'lch') {
                // Get the values in the lab space
                let { l, a, b } = this;
                if (this.space === 'lch') {
                    const { c, h } = this;
                    const dToR = Math.PI / 180;
                    a = c * Math.cos(dToR * h);
                    b = c * Math.sin(dToR * h);
                }
                // Undo the nonlinear function
                const yL = (l + 16) / 116;
                const xL = a / 500 + yL;
                const zL = yL - b / 200;
                // Get the xyz values
                const ct = 16 / 116;
                const mx = 0.008856;
                const nm = 7.787;
                x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);
                y = 1.0 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);
                z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);
            }
            // Convert xyz to unbounded rgb values
            const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
            const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
            const bU = x * 0.0557 + y * -0.204 + z * 1.057;
            // Convert the values to true rgb values
            const pow = Math.pow;
            const bd = 0.0031308;
            const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
            const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
            const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;
            // Make and return the color
            const color = new Color(255 * r, 255 * g, 255 * b);
            return color;
        } else if (this.space === 'hsl') {
            // https://bgrins.github.io/TinyColor/docs/tinycolor.html
            // Get the current hsl values
            let { h, s, l } = this;
            h /= 360;
            s /= 100;
            l /= 100;
            // If we are grey, then just make the color directly
            if (s === 0) {
                l *= 255;
                const color = new Color(l, l, l);
                return color;
            }
            // TODO I have no idea what this does :D If you figure it out, tell me!
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            // Get the rgb values
            const r = 255 * hueToRgb(p, q, h + 1 / 3);
            const g = 255 * hueToRgb(p, q, h);
            const b = 255 * hueToRgb(p, q, h - 1 / 3);
            // Make a new color
            const color = new Color(r, g, b);
            return color;
        } else if (this.space === 'cmyk') {
            // https://gist.github.com/felipesabino/5066336
            // Get the normalised cmyk values
            const { c, m, y, k } = this;
            // Get the rgb values
            const r = 255 * (1 - Math.min(1, c * (1 - k) + k));
            const g = 255 * (1 - Math.min(1, m * (1 - k) + k));
            const b = 255 * (1 - Math.min(1, y * (1 - k) + k));
            // Form the color and return it
            const color = new Color(r, g, b);
            return color;
        } else return this;
    }
    toArray() {
        const { _a, _b, _c, _d, space } = this;
        return [
            _a,
            _b,
            _c,
            _d,
            space
        ];
    }
    toHex() {
        const [r, g, b] = this._clamped().map(componentHex);
        return `#${r}${g}${b}`;
    }
    toRgb() {
        const [rV, gV, bV] = this._clamped();
        const string = `rgb(${rV},${gV},${bV})`;
        return string;
    }
    toString() {
        return this.toHex();
    }
    xyz() {
        // Normalise the red, green and blue values
        const { _a: r255, _b: g255, _c: b255 } = this.rgb();
        const [r, g, b] = [
            r255,
            g255,
            b255
        ].map((v)=>v / 255);
        // Convert to the lab rgb space
        const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        // Convert to the xyz color space without bounding the values
        const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
        const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0;
        const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;
        // Get the proper xyz values by applying the bounding
        const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
        const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
        const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;
        // Make and return the color
        const color = new Color(x, y, z, 'xyz');
        return color;
    }
    /*
  Input and Output methods
  */ _clamped() {
        const { _a, _b, _c } = this.rgb();
        const { max, min, round } = Math;
        const format = (v)=>max(0, min(round(v), 255));
        return [
            _a,
            _b,
            _c
        ].map(format);
    }
}
class Point {
    // Initialize
    constructor(...args){
        this.init(...args);
    }
    // Clone point
    clone() {
        return new Point(this);
    }
    init(x, y) {
        const base = {
            x: 0,
            y: 0
        };
        // ensure source as object
        const source = Array.isArray(x) ? {
            x: x[0],
            y: x[1]
        } : typeof x === 'object' ? {
            x: x.x,
            y: x.y
        } : {
            x: x,
            y: y
        };
        // merge source
        this.x = source.x == null ? base.x : source.x;
        this.y = source.y == null ? base.y : source.y;
        return this;
    }
    toArray() {
        return [
            this.x,
            this.y
        ];
    }
    transform(m) {
        return this.clone().transformO(m);
    }
    // Transform point with matrix
    transformO(m) {
        if (!Matrix.isMatrixLike(m)) m = new Matrix(m);
        const { x, y } = this;
        // Perform the matrix multiplication
        this.x = m.a * x + m.c * y + m.e;
        this.y = m.b * x + m.d * y + m.f;
        return this;
    }
}
function point(x, y) {
    return new Point(x, y).transformO(this.screenCTM().inverseO());
}
function closeEnough(a, b, threshold) {
    return Math.abs(b - a) < 1e-6;
}
class Matrix {
    constructor(...args){
        this.init(...args);
    }
    static formatTransforms(o) {
        // Get all of the parameters required to form the matrix
        const flipBoth = o.flip === 'both' || o.flip === true;
        const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
        const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
        const skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;
        const skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;
        const scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;
        const scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;
        const shear = o.shear || 0;
        const theta = o.rotate || o.theta || 0;
        const origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
        const ox = origin.x;
        const oy = origin.y;
        // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN
        const position = new Point(o.position || o.px || o.positionX || NaN, o.py || o.positionY || NaN);
        const px = position.x;
        const py = position.y;
        const translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);
        const tx = translate.x;
        const ty = translate.y;
        const relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
        const rx = relative.x;
        const ry = relative.y;
        // Populate all of the values
        return {
            scaleX,
            scaleY,
            skewX,
            skewY,
            shear,
            theta,
            rx,
            ry,
            tx,
            ty,
            ox,
            oy,
            px,
            py
        };
    }
    static fromArray(a) {
        return {
            a: a[0],
            b: a[1],
            c: a[2],
            d: a[3],
            e: a[4],
            f: a[5]
        };
    }
    static isMatrixLike(o) {
        return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;
    }
    // left matrix, right matrix, target matrix which is overwritten
    static matrixMultiply(l, r, o) {
        // Work out the product directly
        const a = l.a * r.a + l.c * r.b;
        const b = l.b * r.a + l.d * r.b;
        const c = l.a * r.c + l.c * r.d;
        const d = l.b * r.c + l.d * r.d;
        const e = l.e + l.a * r.e + l.c * r.f;
        const f = l.f + l.b * r.e + l.d * r.f;
        // make sure to use local variables because l/r and o could be the same
        o.a = a;
        o.b = b;
        o.c = c;
        o.d = d;
        o.e = e;
        o.f = f;
        return o;
    }
    around(cx, cy, matrix) {
        return this.clone().aroundO(cx, cy, matrix);
    }
    // Transform around a center point
    aroundO(cx, cy, matrix) {
        const dx = cx || 0;
        const dy = cy || 0;
        return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);
    }
    // Clones this matrix
    clone() {
        return new Matrix(this);
    }
    // Decomposes this matrix into its affine parameters
    decompose(cx = 0, cy = 0) {
        // Get the parameters from the matrix
        const a = this.a;
        const b = this.b;
        const c = this.c;
        const d = this.d;
        const e = this.e;
        const f = this.f;
        // Figure out if the winding direction is clockwise or counterclockwise
        const determinant = a * d - b * c;
        const ccw = determinant > 0 ? 1 : -1;
        // Since we only shear in x, we can use the x basis to get the x scale
        // and the rotation of the resulting matrix
        const sx = ccw * Math.sqrt(a * a + b * b);
        const thetaRad = Math.atan2(ccw * b, ccw * a);
        const theta = 180 / Math.PI * thetaRad;
        const ct = Math.cos(thetaRad);
        const st = Math.sin(thetaRad);
        // We can then solve the y basis vector simultaneously to get the other
        // two affine parameters directly from these parameters
        const lam = (a * c + b * d) / determinant;
        const sy = c * sx / (lam * a - b) || d * sx / (lam * b + a);
        // Use the translations
        const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
        const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy);
        // Construct the decomposition and return it
        return {
            // Return the affine parameters
            scaleX: sx,
            scaleY: sy,
            shear: lam,
            rotate: theta,
            translateX: tx,
            translateY: ty,
            originX: cx,
            originY: cy,
            // Return the matrix parameters
            a: this.a,
            b: this.b,
            c: this.c,
            d: this.d,
            e: this.e,
            f: this.f
        };
    }
    // Check if two matrices are equal
    equals(other) {
        if (other === this) return true;
        const comp = new Matrix(other);
        return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
    }
    // Flip matrix on x or y, at a given offset
    flip(axis, around) {
        return this.clone().flipO(axis, around);
    }
    flipO(axis, around) {
        return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point
    }
    // Initialize
    init(source) {
        const base = Matrix.fromArray([
            1,
            0,
            0,
            1,
            0,
            0
        ]);
        // ensure source as object
        source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : typeof source === 'object' && Matrix.isMatrixLike(source) ? source : typeof source === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base;
        // Merge the source matrix with the base matrix
        this.a = source.a != null ? source.a : base.a;
        this.b = source.b != null ? source.b : base.b;
        this.c = source.c != null ? source.c : base.c;
        this.d = source.d != null ? source.d : base.d;
        this.e = source.e != null ? source.e : base.e;
        this.f = source.f != null ? source.f : base.f;
        return this;
    }
    inverse() {
        return this.clone().inverseO();
    }
    // Inverses matrix
    inverseO() {
        // Get the current parameters out of the matrix
        const a = this.a;
        const b = this.b;
        const c = this.c;
        const d = this.d;
        const e = this.e;
        const f = this.f;
        // Invert the 2x2 matrix in the top left
        const det = a * d - b * c;
        if (!det) throw new Error('Cannot invert ' + this);
        // Calculate the top 2x2 matrix
        const na = d / det;
        const nb = -b / det;
        const nc = -c / det;
        const nd = a / det;
        // Apply the inverted matrix to the top right
        const ne = -(na * e + nc * f);
        const nf = -(nb * e + nd * f);
        // Construct the inverted matrix
        this.a = na;
        this.b = nb;
        this.c = nc;
        this.d = nd;
        this.e = ne;
        this.f = nf;
        return this;
    }
    lmultiply(matrix) {
        return this.clone().lmultiplyO(matrix);
    }
    lmultiplyO(matrix) {
        const r = this;
        const l = matrix instanceof Matrix ? matrix : new Matrix(matrix);
        return Matrix.matrixMultiply(l, r, this);
    }
    // Left multiplies by the given matrix
    multiply(matrix) {
        return this.clone().multiplyO(matrix);
    }
    multiplyO(matrix) {
        // Get the matrices
        const l = this;
        const r = matrix instanceof Matrix ? matrix : new Matrix(matrix);
        return Matrix.matrixMultiply(l, r, this);
    }
    // Rotate matrix
    rotate(r, cx, cy) {
        return this.clone().rotateO(r, cx, cy);
    }
    rotateO(r, cx = 0, cy = 0) {
        // Convert degrees to radians
        r = radians(r);
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        const { a, b, c, d, e, f } = this;
        this.a = a * cos - b * sin;
        this.b = b * cos + a * sin;
        this.c = c * cos - d * sin;
        this.d = d * cos + c * sin;
        this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
        this.f = f * cos + e * sin - cx * sin - cy * cos + cy;
        return this;
    }
    // Scale matrix
    scale() {
        return this.clone().scaleO(...arguments);
    }
    scaleO(x, y = x, cx = 0, cy = 0) {
        // Support uniform scaling
        if (arguments.length === 3) {
            cy = cx;
            cx = y;
            y = x;
        }
        const { a, b, c, d, e, f } = this;
        this.a = a * x;
        this.b = b * y;
        this.c = c * x;
        this.d = d * y;
        this.e = e * x - cx * x + cx;
        this.f = f * y - cy * y + cy;
        return this;
    }
    // Shear matrix
    shear(a, cx, cy) {
        return this.clone().shearO(a, cx, cy);
    }
    // eslint-disable-next-line no-unused-vars
    shearO(lx, cx = 0, cy = 0) {
        const { a, b, c, d, e, f } = this;
        this.a = a + b * lx;
        this.c = c + d * lx;
        this.e = e + f * lx - cy * lx;
        return this;
    }
    // Skew Matrix
    skew() {
        return this.clone().skewO(...arguments);
    }
    skewO(x, y = x, cx = 0, cy = 0) {
        // support uniformal skew
        if (arguments.length === 3) {
            cy = cx;
            cx = y;
            y = x;
        }
        // Convert degrees to radians
        x = radians(x);
        y = radians(y);
        const lx = Math.tan(x);
        const ly = Math.tan(y);
        const { a, b, c, d, e, f } = this;
        this.a = a + b * lx;
        this.b = b + a * ly;
        this.c = c + d * lx;
        this.d = d + c * ly;
        this.e = e + f * lx - cy * lx;
        this.f = f + e * ly - cx * ly;
        return this;
    }
    // SkewX
    skewX(x, cx, cy) {
        return this.skew(x, 0, cx, cy);
    }
    // SkewY
    skewY(y, cx, cy) {
        return this.skew(0, y, cx, cy);
    }
    toArray() {
        return [
            this.a,
            this.b,
            this.c,
            this.d,
            this.e,
            this.f
        ];
    }
    // Convert matrix to string
    toString() {
        return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';
    }
    // Transform a matrix into another matrix by manipulating the space
    transform(o) {
        // Check if o is a matrix and then left multiply it directly
        if (Matrix.isMatrixLike(o)) {
            const matrix = new Matrix(o);
            return matrix.multiplyO(this);
        }
        // Get the proposed transformations and the current transformations
        const t = Matrix.formatTransforms(o);
        const current = this;
        const { x: ox, y: oy } = new Point(t.ox, t.oy).transform(current);
        // Construct the resulting matrix
        const transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy);
        // If we want the origin at a particular place, we force it there
        if (isFinite(t.px) || isFinite(t.py)) {
            const origin = new Point(ox, oy).transform(transformer);
            // TODO: Replace t.px with isFinite(t.px)
            // Doesn't work because t.px is also 0 if it wasn't passed
            const dx = isFinite(t.px) ? t.px - origin.x : 0;
            const dy = isFinite(t.py) ? t.py - origin.y : 0;
            transformer.translateO(dx, dy);
        }
        // Translate now after positioning
        transformer.translateO(t.tx, t.ty);
        return transformer;
    }
    // Translate matrix
    translate(x, y) {
        return this.clone().translateO(x, y);
    }
    translateO(x, y) {
        this.e += x || 0;
        this.f += y || 0;
        return this;
    }
    valueOf() {
        return {
            a: this.a,
            b: this.b,
            c: this.c,
            d: this.d,
            e: this.e,
            f: this.f
        };
    }
}
function ctm() {
    return new Matrix(this.node.getCTM());
}
function screenCTM() {
    try {
        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
       This is needed because FF does not return the transformation matrix
       for the inner coordinate system when getScreenCTM() is called on nested svgs.
       However all other Browsers do that */ if (typeof this.isRoot === 'function' && !this.isRoot()) {
            const rect = this.rect(1, 1);
            const m = rect.node.getScreenCTM();
            rect.remove();
            return new Matrix(m);
        }
        return new Matrix(this.node.getScreenCTM());
    } catch (e) {
        console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`);
        return new Matrix();
    }
}
register(Matrix, 'Matrix');
function parser() {
    // Reuse cached element if possible
    if (!parser.nodes) {
        const svg = makeInstance().size(2, 0);
        svg.node.style.cssText = [
            'opacity: 0',
            'position: absolute',
            'left: -100%',
            'top: -100%',
            'overflow: hidden'
        ].join(';');
        svg.attr('focusable', 'false');
        svg.attr('aria-hidden', 'true');
        const path = svg.path().node;
        parser.nodes = {
            svg,
            path
        };
    }
    if (!parser.nodes.svg.node.parentNode) {
        const b = globals.document.body || globals.document.documentElement;
        parser.nodes.svg.addTo(b);
    }
    return parser.nodes;
}
function isNulledBox(box) {
    return !box.width && !box.height && !box.x && !box.y;
}
function domContains(node) {
    return node === globals.document || (globals.document.documentElement.contains || function(node) {
        // This is IE - it does not support contains() for top-level SVGs
        while(node.parentNode)node = node.parentNode;
        return node === globals.document;
    }).call(globals.document.documentElement, node);
}
class Box {
    constructor(...args){
        this.init(...args);
    }
    addOffset() {
        // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
        this.x += globals.window.pageXOffset;
        this.y += globals.window.pageYOffset;
        return new Box(this);
    }
    init(source) {
        const base = [
            0,
            0,
            0,
            0
        ];
        source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === 'object' ? [
            source.left != null ? source.left : source.x,
            source.top != null ? source.top : source.y,
            source.width,
            source.height
        ] : arguments.length === 4 ? [].slice.call(arguments) : base;
        this.x = source[0] || 0;
        this.y = source[1] || 0;
        this.width = this.w = source[2] || 0;
        this.height = this.h = source[3] || 0;
        // Add more bounding box properties
        this.x2 = this.x + this.w;
        this.y2 = this.y + this.h;
        this.cx = this.x + this.w / 2;
        this.cy = this.y + this.h / 2;
        return this;
    }
    isNulled() {
        return isNulledBox(this);
    }
    // Merge rect box with another, return a new instance
    merge(box) {
        const x = Math.min(this.x, box.x);
        const y = Math.min(this.y, box.y);
        const width = Math.max(this.x + this.width, box.x + box.width) - x;
        const height = Math.max(this.y + this.height, box.y + box.height) - y;
        return new Box(x, y, width, height);
    }
    toArray() {
        return [
            this.x,
            this.y,
            this.width,
            this.height
        ];
    }
    toString() {
        return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
    }
    transform(m) {
        if (!(m instanceof Matrix)) m = new Matrix(m);
        let xMin = Infinity;
        let xMax = -Infinity;
        let yMin = Infinity;
        let yMax = -Infinity;
        const pts = [
            new Point(this.x, this.y),
            new Point(this.x2, this.y),
            new Point(this.x, this.y2),
            new Point(this.x2, this.y2)
        ];
        pts.forEach(function(p) {
            p = p.transform(m);
            xMin = Math.min(xMin, p.x);
            xMax = Math.max(xMax, p.x);
            yMin = Math.min(yMin, p.y);
            yMax = Math.max(yMax, p.y);
        });
        return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
    }
}
function getBox(el, getBBoxFn, retry) {
    let box;
    try {
        // Try to get the box with the provided function
        box = getBBoxFn(el.node);
        // If the box is worthless and not even in the dom, retry
        // by throwing an error here...
        if (isNulledBox(box) && !domContains(el.node)) throw new Error('Element not in the dom');
    } catch (e) {
        // ... and calling the retry handler here
        box = retry(el);
    }
    return box;
}
function bbox() {
    // Function to get bbox is getBBox()
    const getBBox = (node)=>node.getBBox();
    // Take all measures so that a stupid browser renders the element
    // so we can get the bbox from it when we try again
    const retry = (el)=>{
        try {
            const clone = el.clone().addTo(parser().svg).show();
            const box = clone.node.getBBox();
            clone.remove();
            return box;
        } catch (e) {
            // We give up...
            throw new Error(`Getting bbox of element "${el.node.nodeName}" is not possible: ${e.toString()}`);
        }
    };
    const box = getBox(this, getBBox, retry);
    const bbox = new Box(box);
    return bbox;
}
function rbox(el) {
    const getRBox = (node)=>node.getBoundingClientRect();
    const retry = (el)=>{
        // There is no point in trying tricks here because if we insert the element into the dom ourselves
        // it obviously will be at the wrong position
        throw new Error(`Getting rbox of element "${el.node.nodeName}" is not possible`);
    };
    const box = getBox(this, getRBox, retry);
    const rbox = new Box(box);
    // If an element was passed, we want the bbox in the coordinate system of that element
    if (el) return rbox.transform(el.screenCTM().inverseO());
    // Else we want it in absolute screen coordinates
    // Therefore we need to add the scrollOffset
    return rbox.addOffset();
}
// Checks whether the given point is inside the bounding box
function inside(x, y) {
    const box = this.bbox();
    return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
}
registerMethods({
    viewbox: {
        viewbox (x, y, width, height) {
            // act as getter
            if (x == null) return new Box(this.attr('viewBox'));
            // act as setter
            return this.attr('viewBox', new Box(x, y, width, height));
        },
        zoom (level, point) {
            // Its best to rely on the attributes here and here is why:
            // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)
            // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely
            //                        that means, their clientRect is always as big as the content.
            //                        Furthermore this size is incorrect if the element is further transformed by its parents
            // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!
            // getBBox: returns the bounding box of its content - that doesn't help!
            let { width, height } = this.attr([
                'width',
                'height'
            ]);
            // Width and height is a string when a number with a unit is present which we can't use
            // So we try clientXYZ
            if (!width && !height || typeof width === 'string' || typeof height === 'string') {
                width = this.node.clientWidth;
                height = this.node.clientHeight;
            }
            // Giving up...
            if (!width || !height) throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element');
            const v = this.viewbox();
            const zoomX = width / v.width;
            const zoomY = height / v.height;
            const zoom = Math.min(zoomX, zoomY);
            if (level == null) return zoom;
            let zoomAmount = zoom / level;
            // Set the zoomAmount to the highest value which is safe to process and recover from
            // The * 100 is a bit of wiggle room for the matrix transformation
            if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;
            point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);
            const box = new Box(v).transform(new Matrix({
                scale: zoomAmount,
                origin: point
            }));
            return this.viewbox(box);
        }
    }
});
register(Box, 'Box');
// import { subClassArray } from './ArrayPolyfill.js'
class List extends Array {
    constructor(arr = [], ...args){
        super(arr, ...args);
        if (typeof arr === 'number') return this;
        this.length = 0;
        this.push(...arr);
    }
}
extend([
    List
], {
    each (fnOrMethodName, ...args) {
        if (typeof fnOrMethodName === 'function') return this.map((el, i, arr)=>{
            return fnOrMethodName.call(el, el, i, arr);
        });
        else return this.map((el)=>{
            return el[fnOrMethodName](...args);
        });
    },
    toArray () {
        return Array.prototype.concat.apply([], this);
    }
});
const reserved = [
    'toArray',
    'constructor',
    'each'
];
List.extend = function(methods) {
    methods = methods.reduce((obj, name)=>{
        // Don't overwrite own methods
        if (reserved.includes(name)) return obj;
        // Don't add private methods
        if (name[0] === '_') return obj;
        // Allow access to original Array methods through a prefix
        if (name in Array.prototype) obj['$' + name] = Array.prototype[name];
        // Relay every call to each()
        obj[name] = function(...attrs) {
            return this.each(name, ...attrs);
        };
        return obj;
    }, {});
    extend([
        List
    ], methods);
};
function baseFind(query, parent) {
    return new List(map((parent || globals.document).querySelectorAll(query), function(node) {
        return adopt(node);
    }));
}
// Scoped find method
function find(query) {
    return baseFind(query, this.node);
}
function findOne(query) {
    return adopt(this.node.querySelector(query));
}
let listenerId = 0;
const windowEvents = {};
function getEvents(instance) {
    let n = instance.getEventHolder();
    // We dont want to save events in global space
    if (n === globals.window) n = windowEvents;
    if (!n.events) n.events = {};
    return n.events;
}
function getEventTarget(instance) {
    return instance.getEventTarget();
}
function clearEvents(instance) {
    let n = instance.getEventHolder();
    if (n === globals.window) n = windowEvents;
    if (n.events) n.events = {};
}
// Add event binder in the SVG namespace
function on(node, events, listener, binding, options) {
    const l = listener.bind(binding || node);
    const instance = makeInstance(node);
    const bag = getEvents(instance);
    const n = getEventTarget(instance);
    // events can be an array of events or a string of events
    events = Array.isArray(events) ? events : events.split(delimiter);
    // add id to listener
    if (!listener._svgjsListenerId) listener._svgjsListenerId = ++listenerId;
    events.forEach(function(event) {
        const ev = event.split('.')[0];
        const ns = event.split('.')[1] || '*';
        // ensure valid object
        bag[ev] = bag[ev] || {};
        bag[ev][ns] = bag[ev][ns] || {};
        // reference listener
        bag[ev][ns][listener._svgjsListenerId] = l;
        // add listener
        n.addEventListener(ev, l, options || false);
    });
}
// Add event unbinder in the SVG namespace
function off(node, events, listener, options) {
    const instance = makeInstance(node);
    const bag = getEvents(instance);
    const n = getEventTarget(instance);
    // listener can be a function or a number
    if (typeof listener === 'function') {
        listener = listener._svgjsListenerId;
        if (!listener) return;
    }
    // events can be an array of events or a string or undefined
    events = Array.isArray(events) ? events : (events || '').split(delimiter);
    events.forEach(function(event) {
        const ev = event && event.split('.')[0];
        const ns = event && event.split('.')[1];
        let namespace, l;
        if (listener) // remove listener reference
        {
            if (bag[ev] && bag[ev][ns || '*']) {
                // removeListener
                n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);
                delete bag[ev][ns || '*'][listener];
            }
        } else if (ev && ns) // remove all listeners for a namespaced event
        {
            if (bag[ev] && bag[ev][ns]) {
                for(l in bag[ev][ns])off(n, [
                    ev,
                    ns
                ].join('.'), l);
                delete bag[ev][ns];
            }
        } else if (ns) // remove all listeners for a specific namespace
        for(event in bag){
            for(namespace in bag[event])if (ns === namespace) off(n, [
                event,
                ns
            ].join('.'));
        }
        else if (ev) // remove all listeners for the event
        {
            if (bag[ev]) {
                for(namespace in bag[ev])off(n, [
                    ev,
                    namespace
                ].join('.'));
                delete bag[ev];
            }
        } else {
            // remove all listeners on a given node
            for(event in bag)off(n, event);
            clearEvents(instance);
        }
    });
}
function dispatch(node, event, data, options) {
    const n = getEventTarget(node);
    // Dispatch event
    if (event instanceof globals.window.Event) n.dispatchEvent(event);
    else {
        event = new globals.window.CustomEvent(event, {
            detail: data,
            cancelable: true,
            ...options
        });
        n.dispatchEvent(event);
    }
    return event;
}
class EventTarget extends Base {
    addEventListener() {}
    dispatch(event, data, options) {
        return dispatch(this, event, data, options);
    }
    dispatchEvent(event) {
        const bag = this.getEventHolder().events;
        if (!bag) return true;
        const events = bag[event.type];
        for(const i in events)for(const j in events[i])events[i][j](event);
        return !event.defaultPrevented;
    }
    // Fire given event
    fire(event, data, options) {
        this.dispatch(event, data, options);
        return this;
    }
    getEventHolder() {
        return this;
    }
    getEventTarget() {
        return this;
    }
    // Unbind event from listener
    off(event, listener, options) {
        off(this, event, listener, options);
        return this;
    }
    // Bind given event to listener
    on(event, listener, binding, options) {
        on(this, event, listener, binding, options);
        return this;
    }
    removeEventListener() {}
}
register(EventTarget, 'EventTarget');
function noop() {}
// Default animation values
const timeline = {
    duration: 400,
    ease: '>',
    delay: 0
};
// Default attribute values
const attrs = {
    // fill and stroke
    'fill-opacity': 1,
    'stroke-opacity': 1,
    'stroke-width': 0,
    'stroke-linejoin': 'miter',
    'stroke-linecap': 'butt',
    fill: '#000000',
    stroke: '#000000',
    opacity: 1,
    // position
    x: 0,
    y: 0,
    cx: 0,
    cy: 0,
    // size
    width: 0,
    height: 0,
    // radius
    r: 0,
    rx: 0,
    ry: 0,
    // gradient
    offset: 0,
    'stop-opacity': 1,
    'stop-color': '#000000',
    // text
    'text-anchor': 'start'
};
var defaults = {
    __proto__: null,
    attrs: attrs,
    noop: noop,
    timeline: timeline
};
class SVGArray extends Array {
    constructor(...args){
        super(...args);
        this.init(...args);
    }
    clone() {
        return new this.constructor(this);
    }
    init(arr) {
        // This catches the case, that native map tries to create an array with new Array(1)
        if (typeof arr === 'number') return this;
        this.length = 0;
        this.push(...this.parse(arr));
        return this;
    }
    // Parse whitespace separated string
    parse(array = []) {
        // If already is an array, no need to parse it
        if (array instanceof Array) return array;
        return array.trim().split(delimiter).map(parseFloat);
    }
    toArray() {
        return Array.prototype.concat.apply([], this);
    }
    toSet() {
        return new Set(this);
    }
    toString() {
        return this.join(' ');
    }
    // Flattens the array if needed
    valueOf() {
        const ret = [];
        ret.push(...this);
        return ret;
    }
}
// Module for unit conversions
class SVGNumber {
    // Initialize
    constructor(...args){
        this.init(...args);
    }
    convert(unit) {
        return new SVGNumber(this.value, unit);
    }
    // Divide number
    divide(number) {
        number = new SVGNumber(number);
        return new SVGNumber(this / number, this.unit || number.unit);
    }
    init(value, unit) {
        unit = Array.isArray(value) ? value[1] : unit;
        value = Array.isArray(value) ? value[0] : value;
        // initialize defaults
        this.value = 0;
        this.unit = unit || '';
        // parse value
        if (typeof value === 'number') // ensure a valid numeric value
        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -340000000000000000000000000000000000000 : 340000000000000000000000000000000000000 : value;
        else if (typeof value === 'string') {
            unit = value.match(numberAndUnit);
            if (unit) {
                // make value numeric
                this.value = parseFloat(unit[1]);
                // normalize
                if (unit[5] === '%') this.value /= 100;
                else if (unit[5] === 's') this.value *= 1000;
                // store unit
                this.unit = unit[5];
            }
        } else if (value instanceof SVGNumber) {
            this.value = value.valueOf();
            this.unit = value.unit;
        }
        return this;
    }
    // Subtract number
    minus(number) {
        number = new SVGNumber(number);
        return new SVGNumber(this - number, this.unit || number.unit);
    }
    // Add number
    plus(number) {
        number = new SVGNumber(number);
        return new SVGNumber(this + number, this.unit || number.unit);
    }
    // Multiply number
    times(number) {
        number = new SVGNumber(number);
        return new SVGNumber(this * number, this.unit || number.unit);
    }
    toArray() {
        return [
            this.value,
            this.unit
        ];
    }
    toJSON() {
        return this.toString();
    }
    toString() {
        return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;
    }
    valueOf() {
        return this.value;
    }
}
const colorAttributes = new Set([
    'fill',
    'stroke',
    'color',
    'bgcolor',
    'stop-color',
    'flood-color',
    'lighting-color'
]);
const hooks = [];
function registerAttrHook(fn) {
    hooks.push(fn);
}
// Set svg element attribute
function attr(attr, val, ns) {
    // act as full getter
    if (attr == null) {
        // get an object of attributes
        attr = {};
        val = this.node.attributes;
        for (const node of val)attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;
        return attr;
    } else if (attr instanceof Array) // loop through array and get all values
    return attr.reduce((last, curr)=>{
        last[curr] = this.attr(curr);
        return last;
    }, {});
    else if (typeof attr === 'object' && attr.constructor === Object) // apply every attribute individually if an object is passed
    for(val in attr)this.attr(val, attr[val]);
    else if (val === null) // remove value
    this.node.removeAttribute(attr);
    else if (val == null) {
        // act as a getter if the first and only argument is not an object
        val = this.node.getAttribute(attr);
        return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;
    } else {
        // Loop through hooks and execute them to convert value
        val = hooks.reduce((_val, hook)=>{
            return hook(attr, _val, this);
        }, val);
        // ensure correct numeric values (also accepts NaN and Infinity)
        if (typeof val === 'number') val = new SVGNumber(val);
        else if (colorAttributes.has(attr) && Color.isColor(val)) // ensure full hex color
        val = new Color(val);
        else if (val.constructor === Array) // Check for plain arrays and parse array values
        val = new SVGArray(val);
        // if the passed attribute is leading...
        if (attr === 'leading') // ... call the leading method instead
        {
            if (this.leading) this.leading(val);
        } else // set given attribute on node
        typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());
        // rebuild if required
        if (this.rebuild && (attr === 'font-size' || attr === 'x')) this.rebuild();
    }
    return this;
}
class Dom extends EventTarget {
    constructor(node, attrs){
        super();
        this.node = node;
        this.type = node.nodeName;
        if (attrs && node !== attrs) this.attr(attrs);
    }
    // Add given element at a position
    add(element, i) {
        element = makeInstance(element);
        // If non-root svg nodes are added we have to remove their namespaces
        if (element.removeNamespace && this.node instanceof globals.window.SVGElement) element.removeNamespace();
        if (i == null) this.node.appendChild(element.node);
        else if (element.node !== this.node.childNodes[i]) this.node.insertBefore(element.node, this.node.childNodes[i]);
        return this;
    }
    // Add element to given container and return self
    addTo(parent, i) {
        return makeInstance(parent).put(this, i);
    }
    // Returns all child elements
    children() {
        return new List(map(this.node.children, function(node) {
            return adopt(node);
        }));
    }
    // Remove all elements in this container
    clear() {
        // remove children
        while(this.node.hasChildNodes())this.node.removeChild(this.node.lastChild);
        return this;
    }
    // Clone element
    clone(deep = true, assignNewIds = true) {
        // write dom data to the dom so the clone can pickup the data
        this.writeDataToDom();
        // clone element
        let nodeClone = this.node.cloneNode(deep);
        if (assignNewIds) // assign new id
        nodeClone = assignNewId(nodeClone);
        return new this.constructor(nodeClone);
    }
    // Iterates over all children and invokes a given block
    each(block, deep) {
        const children = this.children();
        let i, il;
        for(i = 0, il = children.length; i < il; i++){
            block.apply(children[i], [
                i,
                children
            ]);
            if (deep) children[i].each(block, deep);
        }
        return this;
    }
    element(nodeName, attrs) {
        return this.put(new Dom(create(nodeName), attrs));
    }
    // Get first child
    first() {
        return adopt(this.node.firstChild);
    }
    // Get a element at the given index
    get(i) {
        return adopt(this.node.childNodes[i]);
    }
    getEventHolder() {
        return this.node;
    }
    getEventTarget() {
        return this.node;
    }
    // Checks if the given element is a child
    has(element) {
        return this.index(element) >= 0;
    }
    html(htmlOrFn, outerHTML) {
        return this.xml(htmlOrFn, outerHTML, html);
    }
    // Get / set id
    id(id) {
        // generate new id if no id set
        if (typeof id === 'undefined' && !this.node.id) this.node.id = eid(this.type);
        // don't set directly with this.node.id to make `null` work correctly
        return this.attr('id', id);
    }
    // Gets index of given element
    index(element) {
        return [].slice.call(this.node.childNodes).indexOf(element.node);
    }
    // Get the last child
    last() {
        return adopt(this.node.lastChild);
    }
    // matches the element vs a css selector
    matches(selector) {
        const el = this.node;
        const matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;
        return matcher && matcher.call(el, selector);
    }
    // Returns the parent element instance
    parent(type) {
        let parent = this;
        // check for parent
        if (!parent.node.parentNode) return null;
        // get parent element
        parent = adopt(parent.node.parentNode);
        if (!type) return parent;
        // loop through ancestors if type is given
        do {
            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
        }while (parent = adopt(parent.node.parentNode));
        return parent;
    }
    // Basically does the same as `add()` but returns the added element instead
    put(element, i) {
        element = makeInstance(element);
        this.add(element, i);
        return element;
    }
    // Add element to given container and return container
    putIn(parent, i) {
        return makeInstance(parent).add(this, i);
    }
    // Remove element
    remove() {
        if (this.parent()) this.parent().removeElement(this);
        return this;
    }
    // Remove a given child
    removeElement(element) {
        this.node.removeChild(element.node);
        return this;
    }
    // Replace this with element
    replace(element) {
        element = makeInstance(element);
        if (this.node.parentNode) this.node.parentNode.replaceChild(element.node, this.node);
        return element;
    }
    round(precision = 2, map = null) {
        const factor = 10 ** precision;
        const attrs = this.attr(map);
        for(const i in attrs)if (typeof attrs[i] === 'number') attrs[i] = Math.round(attrs[i] * factor) / factor;
        this.attr(attrs);
        return this;
    }
    // Import / Export raw svg
    svg(svgOrFn, outerSVG) {
        return this.xml(svgOrFn, outerSVG, svg);
    }
    // Return id on string conversion
    toString() {
        return this.id();
    }
    words(text) {
        // This is faster than removing all children and adding a new one
        this.node.textContent = text;
        return this;
    }
    wrap(node) {
        const parent = this.parent();
        if (!parent) return this.addTo(node);
        const position = parent.index(this);
        return parent.put(node, position).put(this);
    }
    // write svgjs data to the dom
    writeDataToDom() {
        // dump variables recursively
        this.each(function() {
            this.writeDataToDom();
        });
        return this;
    }
    // Import / Export raw svg
    xml(xmlOrFn, outerXML, ns) {
        if (typeof xmlOrFn === 'boolean') {
            ns = outerXML;
            outerXML = xmlOrFn;
            xmlOrFn = null;
        }
        // act as getter if no svg string is given
        if (xmlOrFn == null || typeof xmlOrFn === 'function') {
            // The default for exports is, that the outerNode is included
            outerXML = outerXML == null ? true : outerXML;
            // write svgjs data to the dom
            this.writeDataToDom();
            let current = this;
            // An export modifier was passed
            if (xmlOrFn != null) {
                current = adopt(current.node.cloneNode(true));
                // If the user wants outerHTML we need to process this node, too
                if (outerXML) {
                    const result = xmlOrFn(current);
                    current = result || current;
                    // The user does not want this node? Well, then he gets nothing
                    if (result === false) return '';
                }
                // Deep loop through all children and apply modifier
                current.each(function() {
                    const result = xmlOrFn(this);
                    const _this = result || this;
                    // If modifier returns false, discard node
                    if (result === false) this.remove();
                    else if (result && this !== _this) this.replace(_this);
                }, true);
            }
            // Return outer or inner content
            return outerXML ? current.node.outerHTML : current.node.innerHTML;
        }
        // Act as setter if we got a string
        // The default for import is, that the current node is not replaced
        outerXML = outerXML == null ? false : outerXML;
        // Create temporary holder
        const well = create('wrapper', ns);
        const fragment = globals.document.createDocumentFragment();
        // Dump raw svg
        well.innerHTML = xmlOrFn;
        // Transplant nodes into the fragment
        for(let len = well.children.length; len--;)fragment.appendChild(well.firstElementChild);
        const parent = this.parent();
        // Add the whole fragment at once
        return outerXML ? this.replace(fragment) && parent : this.add(fragment);
    }
}
extend(Dom, {
    attr,
    find,
    findOne
});
register(Dom, 'Dom');
class Element extends Dom {
    constructor(node, attrs){
        super(node, attrs);
        // initialize data object
        this.dom = {};
        // create circular reference
        this.node.instance = this;
        if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
        this.setData(JSON.parse(node.getAttribute('data-svgjs')) ?? JSON.parse(node.getAttribute('svgjs:data')) ?? {});
    }
    // Move element by its center
    center(x, y) {
        return this.cx(x).cy(y);
    }
    // Move by center over x-axis
    cx(x) {
        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
    }
    // Move by center over y-axis
    cy(y) {
        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
    }
    // Get defs
    defs() {
        const root = this.root();
        return root && root.defs();
    }
    // Relative move over x and y axes
    dmove(x, y) {
        return this.dx(x).dy(y);
    }
    // Relative move over x axis
    dx(x = 0) {
        return this.x(new SVGNumber(x).plus(this.x()));
    }
    // Relative move over y axis
    dy(y = 0) {
        return this.y(new SVGNumber(y).plus(this.y()));
    }
    getEventHolder() {
        return this;
    }
    // Set height of element
    height(height) {
        return this.attr('height', height);
    }
    // Move element to given x and y values
    move(x, y) {
        return this.x(x).y(y);
    }
    // return array of all ancestors of given type up to the root svg
    parents(until = this.root()) {
        const isSelector = typeof until === 'string';
        if (!isSelector) until = makeInstance(until);
        const parents = new List();
        let parent = this;
        while((parent = parent.parent()) && parent.node !== globals.document && parent.nodeName !== '#document-fragment'){
            parents.push(parent);
            if (!isSelector && parent.node === until.node) break;
            if (isSelector && parent.matches(until)) break;
            if (parent.node === this.root().node) // We worked our way to the root and didn't match `until`
            return null;
        }
        return parents;
    }
    // Get referenced element form attribute value
    reference(attr) {
        attr = this.attr(attr);
        if (!attr) return null;
        const m = (attr + '').match(reference);
        return m ? makeInstance(m[1]) : null;
    }
    // Get parent document
    root() {
        const p = this.parent(getClass(root));
        return p && p.root();
    }
    // set given data to the elements data property
    setData(o) {
        this.dom = o;
        return this;
    }
    // Set element size to given width and height
    size(width, height) {
        const p = proportionalSize(this, width, height);
        return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));
    }
    // Set width of element
    width(width) {
        return this.attr('width', width);
    }
    // write svgjs data to the dom
    writeDataToDom() {
        writeDataToDom(this, this.dom);
        return super.writeDataToDom();
    }
    // Move over x-axis
    x(x) {
        return this.attr('x', x);
    }
    // Move over y-axis
    y(y) {
        return this.attr('y', y);
    }
}
extend(Element, {
    bbox,
    rbox,
    inside,
    point,
    ctm,
    screenCTM
});
register(Element, 'Element');
// Define list of available attributes for stroke and fill
const sugar = {
    stroke: [
        'color',
        'width',
        'opacity',
        'linecap',
        'linejoin',
        'miterlimit',
        'dasharray',
        'dashoffset'
    ],
    fill: [
        'color',
        'opacity',
        'rule'
    ],
    prefix: function(t, a) {
        return a === 'color' ? t : t + '-' + a;
    }
};
[
    'fill',
    'stroke'
].forEach(function(m) {
    const extension = {};
    let i;
    extension[m] = function(o) {
        if (typeof o === 'undefined') return this.attr(m);
        if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) this.attr(m, o);
        else {
            // set all attributes from sugar.fill and sugar.stroke list
            for(i = sugar[m].length - 1; i >= 0; i--)if (o[sugar[m][i]] != null) this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
        return this;
    };
    registerMethods([
        'Element',
        'Runner'
    ], extension);
});
registerMethods([
    'Element',
    'Runner'
], {
    // Let the user set the matrix directly
    matrix: function(mat, b, c, d, e, f) {
        // Act as a getter
        if (mat == null) return new Matrix(this);
        // Act as a setter, the user can pass a matrix or a set of numbers
        return this.attr('transform', new Matrix(mat, b, c, d, e, f));
    },
    // Map rotation to transform
    rotate: function(angle, cx, cy) {
        return this.transform({
            rotate: angle,
            ox: cx,
            oy: cy
        }, true);
    },
    // Map skew to transform
    skew: function(x, y, cx, cy) {
        return arguments.length === 1 || arguments.length === 3 ? this.transform({
            skew: x,
            ox: y,
            oy: cx
        }, true) : this.transform({
            skew: [
                x,
                y
            ],
            ox: cx,
            oy: cy
        }, true);
    },
    shear: function(lam, cx, cy) {
        return this.transform({
            shear: lam,
            ox: cx,
            oy: cy
        }, true);
    },
    // Map scale to transform
    scale: function(x, y, cx, cy) {
        return arguments.length === 1 || arguments.length === 3 ? this.transform({
            scale: x,
            ox: y,
            oy: cx
        }, true) : this.transform({
            scale: [
                x,
                y
            ],
            ox: cx,
            oy: cy
        }, true);
    },
    // Map translate to transform
    translate: function(x, y) {
        return this.transform({
            translate: [
                x,
                y
            ]
        }, true);
    },
    // Map relative translations to transform
    relative: function(x, y) {
        return this.transform({
            relative: [
                x,
                y
            ]
        }, true);
    },
    // Map flip to transform
    flip: function(direction = 'both', origin = 'center') {
        if ('xybothtrue'.indexOf(direction) === -1) {
            origin = direction;
            direction = 'both';
        }
        return this.transform({
            flip: direction,
            origin: origin
        }, true);
    },
    // Opacity
    opacity: function(value) {
        return this.attr('opacity', value);
    }
});
registerMethods('radius', {
    // Add x and y radius
    radius: function(x, y = x) {
        const type = (this._element || this).type;
        return type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y);
    }
});
registerMethods('Path', {
    // Get path length
    length: function() {
        return this.node.getTotalLength();
    },
    // Get point at length
    pointAt: function(length) {
        return new Point(this.node.getPointAtLength(length));
    }
});
registerMethods([
    'Element',
    'Runner'
], {
    // Set font
    font: function(a, v) {
        if (typeof a === 'object') {
            for(v in a)this.font(v, a[v]);
            return this;
        }
        return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
    }
});
// Add events to elements
const methods = [
    'click',
    'dblclick',
    'mousedown',
    'mouseup',
    'mouseover',
    'mouseout',
    'mousemove',
    'mouseenter',
    'mouseleave',
    'touchstart',
    'touchmove',
    'touchleave',
    'touchend',
    'touchcancel',
    'contextmenu',
    'wheel',
    'pointerdown',
    'pointermove',
    'pointerup',
    'pointerleave',
    'pointercancel'
].reduce(function(last, event) {
    // add event to Element
    const fn = function(f) {
        if (f === null) this.off(event);
        else this.on(event, f);
        return this;
    };
    last[event] = fn;
    return last;
}, {});
registerMethods('Element', methods);
// Reset all transformations
function untransform() {
    return this.attr('transform', null);
}
// merge the whole transformation chain into one matrix and returns it
function matrixify() {
    const matrix = (this.attr('transform') || '').split(transforms).slice(0, -1).map(function(str) {
        // generate key => value pairs
        const kv = str.trim().split('(');
        return [
            kv[0],
            kv[1].split(delimiter).map(function(str) {
                return parseFloat(str);
            })
        ];
    }).reverse()// merge every transformation into one matrix
    .reduce(function(matrix, transform) {
        if (transform[0] === 'matrix') return matrix.lmultiply(Matrix.fromArray(transform[1]));
        return matrix[transform[0]].apply(matrix, transform[1]);
    }, new Matrix());
    return matrix;
}
// add an element to another parent without changing the visual representation on the screen
function toParent(parent, i) {
    if (this === parent) return this;
    if (isDescriptive(this.node)) return this.addTo(parent, i);
    const ctm = this.screenCTM();
    const pCtm = parent.screenCTM().inverse();
    this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));
    return this;
}
// same as above with parent equals root-svg
function toRoot(i) {
    return this.toParent(this.root(), i);
}
// Add transformations
function transform(o, relative) {
    // Act as a getter if no object was passed
    if (o == null || typeof o === 'string') {
        const decomposed = new Matrix(this).decompose();
        return o == null ? decomposed : decomposed[o];
    }
    if (!Matrix.isMatrixLike(o)) // Set the origin according to the defined transform
    o = {
        ...o,
        origin: getOrigin(o, this)
    };
    // The user can pass a boolean, an Element or an Matrix or nothing
    const cleanRelative = relative === true ? this : relative || false;
    const result = new Matrix(cleanRelative).transform(o);
    return this.attr('transform', result);
}
registerMethods('Element', {
    untransform,
    matrixify,
    toParent,
    toRoot,
    transform
});
class Container extends Element {
    flatten() {
        this.each(function() {
            if (this instanceof Container) return this.flatten().ungroup();
        });
        return this;
    }
    ungroup(parent = this.parent(), index = parent.index(this)) {
        // when parent != this, we want append all elements to the end
        index = index === -1 ? parent.children().length : index;
        this.each(function(i, children) {
            // reverse each
            return children[children.length - i - 1].toParent(parent, index);
        });
        return this.remove();
    }
}
register(Container, 'Container');
class Defs extends Container {
    constructor(node, attrs = node){
        super(nodeOrNew('defs', node), attrs);
    }
    flatten() {
        return this;
    }
    ungroup() {
        return this;
    }
}
register(Defs, 'Defs');
class Shape extends Element {
}
register(Shape, 'Shape');
// Radius x value
function rx(rx) {
    return this.attr('rx', rx);
}
// Radius y value
function ry(ry) {
    return this.attr('ry', ry);
}
// Move over x-axis
function x$3(x) {
    return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());
}
// Move over y-axis
function y$3(y) {
    return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());
}
// Move by center over x-axis
function cx$1(x) {
    return this.attr('cx', x);
}
// Move by center over y-axis
function cy$1(y) {
    return this.attr('cy', y);
}
// Set width of element
function width$2(width) {
    return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));
}
// Set height of element
function height$2(height) {
    return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));
}
var circled = {
    __proto__: null,
    cx: cx$1,
    cy: cy$1,
    height: height$2,
    rx: rx,
    ry: ry,
    width: width$2,
    x: x$3,
    y: y$3
};
class Ellipse extends Shape {
    constructor(node, attrs = node){
        super(nodeOrNew('ellipse', node), attrs);
    }
    size(width, height) {
        const p = proportionalSize(this, width, height);
        return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));
    }
}
extend(Ellipse, circled);
registerMethods('Container', {
    // Create an ellipse
    ellipse: wrapWithAttrCheck(function(width = 0, height = width) {
        return this.put(new Ellipse()).size(width, height).move(0, 0);
    })
});
register(Ellipse, 'Ellipse');
class Fragment extends Dom {
    constructor(node = globals.document.createDocumentFragment()){
        super(node);
    }
    // Import / Export raw xml
    xml(xmlOrFn, outerXML, ns) {
        if (typeof xmlOrFn === 'boolean') {
            ns = outerXML;
            outerXML = xmlOrFn;
            xmlOrFn = null;
        }
        // because this is a fragment we have to put all elements into a wrapper first
        // before we can get the innerXML from it
        if (xmlOrFn == null || typeof xmlOrFn === 'function') {
            const wrapper = new Dom(create('wrapper', ns));
            wrapper.add(this.node.cloneNode(true));
            return wrapper.xml(false, ns);
        }
        // Act as setter if we got a string
        return super.xml(xmlOrFn, false, ns);
    }
}
register(Fragment, 'Fragment');
function from(x, y) {
    return (this._element || this).type === 'radialGradient' ? this.attr({
        fx: new SVGNumber(x),
        fy: new SVGNumber(y)
    }) : this.attr({
        x1: new SVGNumber(x),
        y1: new SVGNumber(y)
    });
}
function to(x, y) {
    return (this._element || this).type === 'radialGradient' ? this.attr({
        cx: new SVGNumber(x),
        cy: new SVGNumber(y)
    }) : this.attr({
        x2: new SVGNumber(x),
        y2: new SVGNumber(y)
    });
}
var gradiented = {
    __proto__: null,
    from: from,
    to: to
};
class Gradient extends Container {
    constructor(type, attrs){
        super(nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs);
    }
    // custom attr to handle transform
    attr(a, b, c) {
        if (a === 'transform') a = 'gradientTransform';
        return super.attr(a, b, c);
    }
    bbox() {
        return new Box();
    }
    targets() {
        return baseFind('svg [fill*=' + this.id() + ']');
    }
    // Alias string conversion to fill
    toString() {
        return this.url();
    }
    // Update gradient
    update(block) {
        // remove all stops
        this.clear();
        // invoke passed block
        if (typeof block === 'function') block.call(this, this);
        return this;
    }
    // Return the fill id
    url() {
        return 'url(#' + this.id() + ')';
    }
}
extend(Gradient, gradiented);
registerMethods({
    Container: {
        // Create gradient element in defs
        gradient (...args) {
            return this.defs().gradient(...args);
        }
    },
    // define gradient
    Defs: {
        gradient: wrapWithAttrCheck(function(type, block) {
            return this.put(new Gradient(type)).update(block);
        })
    }
});
register(Gradient, 'Gradient');
class Pattern extends Container {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('pattern', node), attrs);
    }
    // custom attr to handle transform
    attr(a, b, c) {
        if (a === 'transform') a = 'patternTransform';
        return super.attr(a, b, c);
    }
    bbox() {
        return new Box();
    }
    targets() {
        return baseFind('svg [fill*=' + this.id() + ']');
    }
    // Alias string conversion to fill
    toString() {
        return this.url();
    }
    // Update pattern by rebuilding
    update(block) {
        // remove content
        this.clear();
        // invoke passed block
        if (typeof block === 'function') block.call(this, this);
        return this;
    }
    // Return the fill id
    url() {
        return 'url(#' + this.id() + ')';
    }
}
registerMethods({
    Container: {
        // Create pattern element in defs
        pattern (...args) {
            return this.defs().pattern(...args);
        }
    },
    Defs: {
        pattern: wrapWithAttrCheck(function(width, height, block) {
            return this.put(new Pattern()).update(block).attr({
                x: 0,
                y: 0,
                width: width,
                height: height,
                patternUnits: 'userSpaceOnUse'
            });
        })
    }
});
register(Pattern, 'Pattern');
class Image extends Shape {
    constructor(node, attrs = node){
        super(nodeOrNew('image', node), attrs);
    }
    // (re)load image
    load(url, callback) {
        if (!url) return this;
        const img = new globals.window.Image();
        on(img, 'load', function(e) {
            const p = this.parent(Pattern);
            // ensure image size
            if (this.width() === 0 && this.height() === 0) this.size(img.width, img.height);
            if (p instanceof Pattern) // ensure pattern size if not set
            {
                if (p.width() === 0 && p.height() === 0) p.size(this.width(), this.height());
            }
            if (typeof callback === 'function') callback.call(this, e);
        }, this);
        on(img, 'load error', function() {
            // dont forget to unbind memory leaking events
            off(img);
        });
        return this.attr('href', img.src = url, xlink);
    }
}
registerAttrHook(function(attr, val, _this) {
    // convert image fill and stroke to patterns
    if (attr === 'fill' || attr === 'stroke') {
        if (isImage.test(val)) val = _this.root().defs().image(val);
    }
    if (val instanceof Image) val = _this.root().defs().pattern(0, 0, (pattern)=>{
        pattern.add(val);
    });
    return val;
});
registerMethods({
    Container: {
        // create image element, load image and set its size
        image: wrapWithAttrCheck(function(source, callback) {
            return this.put(new Image()).size(0, 0).load(source, callback);
        })
    }
});
register(Image, 'Image');
class PointArray extends SVGArray {
    // Get bounding box of points
    bbox() {
        let maxX = -Infinity;
        let maxY = -Infinity;
        let minX = Infinity;
        let minY = Infinity;
        this.forEach(function(el) {
            maxX = Math.max(el[0], maxX);
            maxY = Math.max(el[1], maxY);
            minX = Math.min(el[0], minX);
            minY = Math.min(el[1], minY);
        });
        return new Box(minX, minY, maxX - minX, maxY - minY);
    }
    // Move point string
    move(x, y) {
        const box = this.bbox();
        // get relative offset
        x -= box.x;
        y -= box.y;
        // move every point
        if (!isNaN(x) && !isNaN(y)) for(let i = this.length - 1; i >= 0; i--)this[i] = [
            this[i][0] + x,
            this[i][1] + y
        ];
        return this;
    }
    // Parse point string and flat array
    parse(array = [
        0,
        0
    ]) {
        const points = [];
        // if it is an array, we flatten it and therefore clone it to 1 depths
        if (array instanceof Array) array = Array.prototype.concat.apply([], array);
        else // Else, it is considered as a string
        // parse points
        array = array.trim().split(delimiter).map(parseFloat);
        // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
        // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
        if (array.length % 2 !== 0) array.pop();
        // wrap points in two-tuples
        for(let i = 0, len = array.length; i < len; i = i + 2)points.push([
            array[i],
            array[i + 1]
        ]);
        return points;
    }
    // Resize poly string
    size(width, height) {
        let i;
        const box = this.bbox();
        // recalculate position of all points according to new size
        for(i = this.length - 1; i >= 0; i--){
            if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;
            if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
        }
        return this;
    }
    // Convert array to line object
    toLine() {
        return {
            x1: this[0][0],
            y1: this[0][1],
            x2: this[1][0],
            y2: this[1][1]
        };
    }
    // Convert array to string
    toString() {
        const array = [];
        // convert to a poly point string
        for(let i = 0, il = this.length; i < il; i++)array.push(this[i].join(','));
        return array.join(' ');
    }
    transform(m) {
        return this.clone().transformO(m);
    }
    // transform points with matrix (similar to Point.transform)
    transformO(m) {
        if (!Matrix.isMatrixLike(m)) m = new Matrix(m);
        for(let i = this.length; i--;){
            // Perform the matrix multiplication
            const [x, y] = this[i];
            this[i][0] = m.a * x + m.c * y + m.e;
            this[i][1] = m.b * x + m.d * y + m.f;
        }
        return this;
    }
}
const MorphArray = PointArray;
// Move by left top corner over x-axis
function x$2(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y);
}
// Move by left top corner over y-axis
function y$2(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y);
}
// Set width of element
function width$1(width) {
    const b = this.bbox();
    return width == null ? b.width : this.size(width, b.height);
}
// Set height of element
function height$1(height) {
    const b = this.bbox();
    return height == null ? b.height : this.size(b.width, height);
}
var pointed = {
    __proto__: null,
    MorphArray: MorphArray,
    height: height$1,
    width: width$1,
    x: x$2,
    y: y$2
};
class Line extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('line', node), attrs);
    }
    // Get array
    array() {
        return new PointArray([
            [
                this.attr('x1'),
                this.attr('y1')
            ],
            [
                this.attr('x2'),
                this.attr('y2')
            ]
        ]);
    }
    // Move by left top corner
    move(x, y) {
        return this.attr(this.array().move(x, y).toLine());
    }
    // Overwrite native plot() method
    plot(x1, y1, x2, y2) {
        if (x1 == null) return this.array();
        else if (typeof y1 !== 'undefined') x1 = {
            x1,
            y1,
            x2,
            y2
        };
        else x1 = new PointArray(x1).toLine();
        return this.attr(x1);
    }
    // Set element size to given width and height
    size(width, height) {
        const p = proportionalSize(this, width, height);
        return this.attr(this.array().size(p.width, p.height).toLine());
    }
}
extend(Line, pointed);
registerMethods({
    Container: {
        // Create a line element
        line: wrapWithAttrCheck(function(...args) {
            // make sure plot is called as a setter
            // x1 is not necessarily a number, it can also be an array, a string and a PointArray
            return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [
                0,
                0,
                0,
                0
            ]);
        })
    }
});
register(Line, 'Line');
class Marker extends Container {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('marker', node), attrs);
    }
    // Set height of element
    height(height) {
        return this.attr('markerHeight', height);
    }
    orient(orient) {
        return this.attr('orient', orient);
    }
    // Set marker refX and refY
    ref(x, y) {
        return this.attr('refX', x).attr('refY', y);
    }
    // Return the fill id
    toString() {
        return 'url(#' + this.id() + ')';
    }
    // Update marker
    update(block) {
        // remove all content
        this.clear();
        // invoke passed block
        if (typeof block === 'function') block.call(this, this);
        return this;
    }
    // Set width of element
    width(width) {
        return this.attr('markerWidth', width);
    }
}
registerMethods({
    Container: {
        marker (...args) {
            // Create marker element in defs
            return this.defs().marker(...args);
        }
    },
    Defs: {
        // Create marker
        marker: wrapWithAttrCheck(function(width, height, block) {
            // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
            return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
        })
    },
    marker: {
        // Create and attach markers
        marker (marker, width, height, block) {
            let attr = [
                'marker'
            ];
            // Build attribute name
            if (marker !== 'all') attr.push(marker);
            attr = attr.join('-');
            // Set marker attribute
            marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);
            return this.attr(attr, marker);
        }
    }
});
register(Marker, 'Marker');
/***
Base Class
==========
The base stepper class that will be
***/ function makeSetterGetter(k, f) {
    return function(v) {
        if (v == null) return this[k];
        this[k] = v;
        if (f) f.call(this);
        return this;
    };
}
const easing = {
    '-': function(pos) {
        return pos;
    },
    '<>': function(pos) {
        return -Math.cos(pos * Math.PI) / 2 + 0.5;
    },
    '>': function(pos) {
        return Math.sin(pos * Math.PI / 2);
    },
    '<': function(pos) {
        return -Math.cos(pos * Math.PI / 2) + 1;
    },
    bezier: function(x1, y1, x2, y2) {
        // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
        return function(t) {
            if (t < 0) {
                if (x1 > 0) return y1 / x1 * t;
                else if (x2 > 0) return y2 / x2 * t;
                else return 0;
            } else if (t > 1) {
                if (x2 < 1) return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);
                else if (x1 < 1) return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);
                else return 1;
            } else return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3;
        };
    },
    // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
    steps: function(steps, stepPosition = 'end') {
        // deal with "jump-" prefix
        stepPosition = stepPosition.split('-').reverse()[0];
        let jumps = steps;
        if (stepPosition === 'none') --jumps;
        else if (stepPosition === 'both') ++jumps;
        // The beforeFlag is essentially useless
        return (t, beforeFlag = false)=>{
            // Step is called currentStep in referenced url
            let step = Math.floor(t * steps);
            const jumping = t * step % 1 === 0;
            if (stepPosition === 'start' || stepPosition === 'both') ++step;
            if (beforeFlag && jumping) --step;
            if (t >= 0 && step < 0) step = 0;
            if (t <= 1 && step > jumps) step = jumps;
            return step / jumps;
        };
    }
};
class Stepper {
    done() {
        return false;
    }
}
/***
Easing Functions
================
***/ class Ease extends Stepper {
    constructor(fn = timeline.ease){
        super();
        this.ease = easing[fn] || fn;
    }
    step(from, to, pos) {
        if (typeof from !== 'number') return pos < 1 ? from : to;
        return from + (to - from) * this.ease(pos);
    }
}
/***
Controller Types
================
***/ class Controller extends Stepper {
    constructor(fn){
        super();
        this.stepper = fn;
    }
    done(c) {
        return c.done;
    }
    step(current, target, dt, c) {
        return this.stepper(current, target, dt, c);
    }
}
function recalculate() {
    // Apply the default parameters
    const duration = (this._duration || 500) / 1000;
    const overshoot = this._overshoot || 0;
    // Calculate the PID natural response
    const eps = 1e-10;
    const pi = Math.PI;
    const os = Math.log(overshoot / 100 + eps);
    const zeta = -os / Math.sqrt(pi * pi + os * os);
    const wn = 3.9 / (zeta * duration);
    // Calculate the Spring values
    this.d = 2 * zeta * wn;
    this.k = wn * wn;
}
class Spring extends Controller {
    constructor(duration = 500, overshoot = 0){
        super();
        this.duration(duration).overshoot(overshoot);
    }
    step(current, target, dt, c) {
        if (typeof current === 'string') return current;
        c.done = dt === Infinity;
        if (dt === Infinity) return target;
        if (dt === 0) return current;
        if (dt > 100) dt = 16;
        dt /= 1000;
        // Get the previous velocity
        const velocity = c.velocity || 0;
        // Apply the control to get the new position and store it
        const acceleration = -this.d * velocity - this.k * (current - target);
        const newPosition = current + velocity * dt + acceleration * dt * dt / 2;
        // Store the velocity
        c.velocity = velocity + acceleration * dt;
        // Figure out if we have converged, and if so, pass the value
        c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
        return c.done ? target : newPosition;
    }
}
extend(Spring, {
    duration: makeSetterGetter('_duration', recalculate),
    overshoot: makeSetterGetter('_overshoot', recalculate)
});
class PID extends Controller {
    constructor(p = 0.1, i = 0.01, d = 0, windup = 1000){
        super();
        this.p(p).i(i).d(d).windup(windup);
    }
    step(current, target, dt, c) {
        if (typeof current === 'string') return current;
        c.done = dt === Infinity;
        if (dt === Infinity) return target;
        if (dt === 0) return current;
        const p = target - current;
        let i = (c.integral || 0) + p * dt;
        const d = (p - (c.error || 0)) / dt;
        const windup = this._windup;
        // antiwindup
        if (windup !== false) i = Math.max(-windup, Math.min(i, windup));
        c.error = p;
        c.integral = i;
        c.done = Math.abs(p) < 0.001;
        return c.done ? target : current + (this.P * p + this.I * i + this.D * d);
    }
}
extend(PID, {
    windup: makeSetterGetter('_windup'),
    p: makeSetterGetter('P'),
    i: makeSetterGetter('I'),
    d: makeSetterGetter('D')
});
const segmentParameters = {
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7,
    Z: 0
};
const pathHandlers = {
    M: function(c, p, p0) {
        p.x = p0.x = c[0];
        p.y = p0.y = c[1];
        return [
            'M',
            p.x,
            p.y
        ];
    },
    L: function(c, p) {
        p.x = c[0];
        p.y = c[1];
        return [
            'L',
            c[0],
            c[1]
        ];
    },
    H: function(c, p) {
        p.x = c[0];
        return [
            'H',
            c[0]
        ];
    },
    V: function(c, p) {
        p.y = c[0];
        return [
            'V',
            c[0]
        ];
    },
    C: function(c, p) {
        p.x = c[4];
        p.y = c[5];
        return [
            'C',
            c[0],
            c[1],
            c[2],
            c[3],
            c[4],
            c[5]
        ];
    },
    S: function(c, p) {
        p.x = c[2];
        p.y = c[3];
        return [
            'S',
            c[0],
            c[1],
            c[2],
            c[3]
        ];
    },
    Q: function(c, p) {
        p.x = c[2];
        p.y = c[3];
        return [
            'Q',
            c[0],
            c[1],
            c[2],
            c[3]
        ];
    },
    T: function(c, p) {
        p.x = c[0];
        p.y = c[1];
        return [
            'T',
            c[0],
            c[1]
        ];
    },
    Z: function(c, p, p0) {
        p.x = p0.x;
        p.y = p0.y;
        return [
            'Z'
        ];
    },
    A: function(c, p) {
        p.x = c[5];
        p.y = c[6];
        return [
            'A',
            c[0],
            c[1],
            c[2],
            c[3],
            c[4],
            c[5],
            c[6]
        ];
    }
};
const mlhvqtcsaz = 'mlhvqtcsaz'.split('');
for(let i = 0, il = mlhvqtcsaz.length; i < il; ++i)pathHandlers[mlhvqtcsaz[i]] = function(i) {
    return function(c, p, p0) {
        if (i === 'H') c[0] = c[0] + p.x;
        else if (i === 'V') c[0] = c[0] + p.y;
        else if (i === 'A') {
            c[5] = c[5] + p.x;
            c[6] = c[6] + p.y;
        } else for(let j = 0, jl = c.length; j < jl; ++j)c[j] = c[j] + (j % 2 ? p.y : p.x);
        return pathHandlers[i](c, p, p0);
    };
}(mlhvqtcsaz[i].toUpperCase());
function makeAbsolut(parser) {
    const command = parser.segment[0];
    return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0);
}
function segmentComplete(parser) {
    return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()];
}
function startNewSegment(parser, token) {
    parser.inNumber && finalizeNumber(parser, false);
    const pathLetter = isPathLetter.test(token);
    if (pathLetter) parser.segment = [
        token
    ];
    else {
        const lastCommand = parser.lastCommand;
        const small = lastCommand.toLowerCase();
        const isSmall = lastCommand === small;
        parser.segment = [
            small === 'm' ? isSmall ? 'l' : 'L' : lastCommand
        ];
    }
    parser.inSegment = true;
    parser.lastCommand = parser.segment[0];
    return pathLetter;
}
function finalizeNumber(parser, inNumber) {
    if (!parser.inNumber) throw new Error('Parser Error');
    parser.number && parser.segment.push(parseFloat(parser.number));
    parser.inNumber = inNumber;
    parser.number = '';
    parser.pointSeen = false;
    parser.hasExponent = false;
    if (segmentComplete(parser)) finalizeSegment(parser);
}
function finalizeSegment(parser) {
    parser.inSegment = false;
    if (parser.absolute) parser.segment = makeAbsolut(parser);
    parser.segments.push(parser.segment);
}
function isArcFlag(parser) {
    if (!parser.segment.length) return false;
    const isArc = parser.segment[0].toUpperCase() === 'A';
    const length = parser.segment.length;
    return isArc && (length === 4 || length === 5);
}
function isExponential(parser) {
    return parser.lastToken.toUpperCase() === 'E';
}
const pathDelimiters = new Set([
    ' ',
    ',',
    '\t',
    '\n',
    '\r',
    '\f'
]);
function pathParser(d, toAbsolute = true) {
    let index = 0;
    let token = '';
    const parser = {
        segment: [],
        inNumber: false,
        number: '',
        lastToken: '',
        inSegment: false,
        segments: [],
        pointSeen: false,
        hasExponent: false,
        absolute: toAbsolute,
        p0: new Point(),
        p: new Point()
    };
    while(parser.lastToken = token, token = d.charAt(index++)){
        if (!parser.inSegment) {
            if (startNewSegment(parser, token)) continue;
        }
        if (token === '.') {
            if (parser.pointSeen || parser.hasExponent) {
                finalizeNumber(parser, false);
                --index;
                continue;
            }
            parser.inNumber = true;
            parser.pointSeen = true;
            parser.number += token;
            continue;
        }
        if (!isNaN(parseInt(token))) {
            if (parser.number === '0' || isArcFlag(parser)) {
                parser.inNumber = true;
                parser.number = token;
                finalizeNumber(parser, true);
                continue;
            }
            parser.inNumber = true;
            parser.number += token;
            continue;
        }
        if (pathDelimiters.has(token)) {
            if (parser.inNumber) finalizeNumber(parser, false);
            continue;
        }
        if (token === '-' || token === '+') {
            if (parser.inNumber && !isExponential(parser)) {
                finalizeNumber(parser, false);
                --index;
                continue;
            }
            parser.number += token;
            parser.inNumber = true;
            continue;
        }
        if (token.toUpperCase() === 'E') {
            parser.number += token;
            parser.hasExponent = true;
            continue;
        }
        if (isPathLetter.test(token)) {
            if (parser.inNumber) finalizeNumber(parser, false);
            else if (!segmentComplete(parser)) throw new Error('parser Error');
            else finalizeSegment(parser);
            --index;
        }
    }
    if (parser.inNumber) finalizeNumber(parser, false);
    if (parser.inSegment && segmentComplete(parser)) finalizeSegment(parser);
    return parser.segments;
}
function arrayToString(a) {
    let s = '';
    for(let i = 0, il = a.length; i < il; i++){
        s += a[i][0];
        if (a[i][1] != null) {
            s += a[i][1];
            if (a[i][2] != null) {
                s += ' ';
                s += a[i][2];
                if (a[i][3] != null) {
                    s += ' ';
                    s += a[i][3];
                    s += ' ';
                    s += a[i][4];
                    if (a[i][5] != null) {
                        s += ' ';
                        s += a[i][5];
                        s += ' ';
                        s += a[i][6];
                        if (a[i][7] != null) {
                            s += ' ';
                            s += a[i][7];
                        }
                    }
                }
            }
        }
    }
    return s + ' ';
}
class PathArray extends SVGArray {
    // Get bounding box of path
    bbox() {
        parser().path.setAttribute('d', this.toString());
        return new Box(parser.nodes.path.getBBox());
    }
    // Move path string
    move(x, y) {
        // get bounding box of current situation
        const box = this.bbox();
        // get relative offset
        x -= box.x;
        y -= box.y;
        if (!isNaN(x) && !isNaN(y)) // move every point
        for(let l, i = this.length - 1; i >= 0; i--){
            l = this[i][0];
            if (l === 'M' || l === 'L' || l === 'T') {
                this[i][1] += x;
                this[i][2] += y;
            } else if (l === 'H') this[i][1] += x;
            else if (l === 'V') this[i][1] += y;
            else if (l === 'C' || l === 'S' || l === 'Q') {
                this[i][1] += x;
                this[i][2] += y;
                this[i][3] += x;
                this[i][4] += y;
                if (l === 'C') {
                    this[i][5] += x;
                    this[i][6] += y;
                }
            } else if (l === 'A') {
                this[i][6] += x;
                this[i][7] += y;
            }
        }
        return this;
    }
    // Absolutize and parse path to array
    parse(d = 'M0 0') {
        if (Array.isArray(d)) d = Array.prototype.concat.apply([], d).toString();
        return pathParser(d);
    }
    // Resize path string
    size(width, height) {
        // get bounding box of current situation
        const box = this.bbox();
        let i, l;
        // If the box width or height is 0 then we ignore
        // transformations on the respective axis
        box.width = box.width === 0 ? 1 : box.width;
        box.height = box.height === 0 ? 1 : box.height;
        // recalculate position of all points according to new size
        for(i = this.length - 1; i >= 0; i--){
            l = this[i][0];
            if (l === 'M' || l === 'L' || l === 'T') {
                this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
                this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
            } else if (l === 'H') this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
            else if (l === 'V') this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
            else if (l === 'C' || l === 'S' || l === 'Q') {
                this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
                this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
                this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;
                this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;
                if (l === 'C') {
                    this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;
                    this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;
                }
            } else if (l === 'A') {
                // resize radii
                this[i][1] = this[i][1] * width / box.width;
                this[i][2] = this[i][2] * height / box.height;
                // move position values
                this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;
                this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;
            }
        }
        return this;
    }
    // Convert array to string
    toString() {
        return arrayToString(this);
    }
}
const getClassForType = (value)=>{
    const type = typeof value;
    if (type === 'number') return SVGNumber;
    else if (type === 'string') {
        if (Color.isColor(value)) return Color;
        else if (delimiter.test(value)) return isPathLetter.test(value) ? PathArray : SVGArray;
        else if (numberAndUnit.test(value)) return SVGNumber;
        else return NonMorphable;
    } else if (morphableTypes.indexOf(value.constructor) > -1) return value.constructor;
    else if (Array.isArray(value)) return SVGArray;
    else if (type === 'object') return ObjectBag;
    else return NonMorphable;
};
class Morphable {
    constructor(stepper){
        this._stepper = stepper || new Ease('-');
        this._from = null;
        this._to = null;
        this._type = null;
        this._context = null;
        this._morphObj = null;
    }
    at(pos) {
        return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);
    }
    done() {
        const complete = this._context.map(this._stepper.done).reduce(function(last, curr) {
            return last && curr;
        }, true);
        return complete;
    }
    from(val) {
        if (val == null) return this._from;
        this._from = this._set(val);
        return this;
    }
    stepper(stepper) {
        if (stepper == null) return this._stepper;
        this._stepper = stepper;
        return this;
    }
    to(val) {
        if (val == null) return this._to;
        this._to = this._set(val);
        return this;
    }
    type(type) {
        // getter
        if (type == null) return this._type;
        // setter
        this._type = type;
        return this;
    }
    _set(value) {
        if (!this._type) this.type(getClassForType(value));
        let result = new this._type(value);
        if (this._type === Color) result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
        if (this._type === ObjectBag) result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;
        result = result.toConsumable();
        this._morphObj = this._morphObj || new this._type();
        this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function(o) {
            o.done = true;
            return o;
        });
        return result;
    }
}
class NonMorphable {
    constructor(...args){
        this.init(...args);
    }
    init(val) {
        val = Array.isArray(val) ? val[0] : val;
        this.value = val;
        return this;
    }
    toArray() {
        return [
            this.value
        ];
    }
    valueOf() {
        return this.value;
    }
}
class TransformBag {
    constructor(...args){
        this.init(...args);
    }
    init(obj) {
        if (Array.isArray(obj)) obj = {
            scaleX: obj[0],
            scaleY: obj[1],
            shear: obj[2],
            rotate: obj[3],
            translateX: obj[4],
            translateY: obj[5],
            originX: obj[6],
            originY: obj[7]
        };
        Object.assign(this, TransformBag.defaults, obj);
        return this;
    }
    toArray() {
        const v = this;
        return [
            v.scaleX,
            v.scaleY,
            v.shear,
            v.rotate,
            v.translateX,
            v.translateY,
            v.originX,
            v.originY
        ];
    }
}
TransformBag.defaults = {
    scaleX: 1,
    scaleY: 1,
    shear: 0,
    rotate: 0,
    translateX: 0,
    translateY: 0,
    originX: 0,
    originY: 0
};
const sortByKey = (a, b)=>{
    return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;
};
class ObjectBag {
    constructor(...args){
        this.init(...args);
    }
    align(other) {
        const values = this.values;
        for(let i = 0, il = values.length; i < il; ++i){
            // If the type is the same we only need to check if the color is in the correct format
            if (values[i + 1] === other[i + 1]) {
                if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {
                    const space = other[i + 7];
                    const color = new Color(this.values.splice(i + 3, 5))[space]().toArray();
                    this.values.splice(i + 3, 0, ...color);
                }
                i += values[i + 2] + 2;
                continue;
            }
            if (!other[i + 1]) return this;
            // The types differ, so we overwrite the new type with the old one
            // And initialize it with the types default (e.g. black for color or 0 for number)
            const defaultObject = new other[i + 1]().toArray();
            // Than we fix the values array
            const toDelete = values[i + 2] + 3;
            values.splice(i, toDelete, other[i], other[i + 1], other[i + 2], ...defaultObject);
            i += values[i + 2] + 2;
        }
        return this;
    }
    init(objOrArr) {
        this.values = [];
        if (Array.isArray(objOrArr)) {
            this.values = objOrArr.slice();
            return;
        }
        objOrArr = objOrArr || {};
        const entries = [];
        for(const i in objOrArr){
            const Type = getClassForType(objOrArr[i]);
            const val = new Type(objOrArr[i]).toArray();
            entries.push([
                i,
                Type,
                val.length,
                ...val
            ]);
        }
        entries.sort(sortByKey);
        this.values = entries.reduce((last, curr)=>last.concat(curr), []);
        return this;
    }
    toArray() {
        return this.values;
    }
    valueOf() {
        const obj = {};
        const arr = this.values;
        // for (var i = 0, len = arr.length; i < len; i += 2) {
        while(arr.length){
            const key = arr.shift();
            const Type = arr.shift();
            const num = arr.shift();
            const values = arr.splice(0, num);
            obj[key] = new Type(values); // .valueOf()
        }
        return obj;
    }
}
const morphableTypes = [
    NonMorphable,
    TransformBag,
    ObjectBag
];
function registerMorphableType(type = []) {
    morphableTypes.push(...[].concat(type));
}
function makeMorphable() {
    extend(morphableTypes, {
        to (val) {
            return new Morphable().type(this.constructor).from(this.toArray()) // this.valueOf())
            .to(val);
        },
        fromArray (arr) {
            this.init(arr);
            return this;
        },
        toConsumable () {
            return this.toArray();
        },
        morph (from, to, pos, stepper, context) {
            const mapper = function(i, index) {
                return stepper.step(i, to[index], pos, context[index], context);
            };
            return this.fromArray(from.map(mapper));
        }
    });
}
class Path extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('path', node), attrs);
    }
    // Get array
    array() {
        return this._array || (this._array = new PathArray(this.attr('d')));
    }
    // Clear array cache
    clear() {
        delete this._array;
        return this;
    }
    // Set height of element
    height(height) {
        return height == null ? this.bbox().height : this.size(this.bbox().width, height);
    }
    // Move by left top corner
    move(x, y) {
        return this.attr('d', this.array().move(x, y));
    }
    // Plot new path
    plot(d) {
        return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));
    }
    // Set element size to given width and height
    size(width, height) {
        const p = proportionalSize(this, width, height);
        return this.attr('d', this.array().size(p.width, p.height));
    }
    // Set width of element
    width(width) {
        return width == null ? this.bbox().width : this.size(width, this.bbox().height);
    }
    // Move by left top corner over x-axis
    x(x) {
        return x == null ? this.bbox().x : this.move(x, this.bbox().y);
    }
    // Move by left top corner over y-axis
    y(y) {
        return y == null ? this.bbox().y : this.move(this.bbox().x, y);
    }
}
// Define morphable array
Path.prototype.MorphArray = PathArray;
// Add parent method
registerMethods({
    Container: {
        // Create a wrapped path element
        path: wrapWithAttrCheck(function(d) {
            // make sure plot is called as a setter
            return this.put(new Path()).plot(d || new PathArray());
        })
    }
});
register(Path, 'Path');
// Get array
function array() {
    return this._array || (this._array = new PointArray(this.attr('points')));
}
// Clear array cache
function clear() {
    delete this._array;
    return this;
}
// Move by left top corner
function move$2(x, y) {
    return this.attr('points', this.array().move(x, y));
}
// Plot new path
function plot(p) {
    return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));
}
// Set element size to given width and height
function size$1(width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr('points', this.array().size(p.width, p.height));
}
var poly = {
    __proto__: null,
    array: array,
    clear: clear,
    move: move$2,
    plot: plot,
    size: size$1
};
class Polygon extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('polygon', node), attrs);
    }
}
registerMethods({
    Container: {
        // Create a wrapped polygon element
        polygon: wrapWithAttrCheck(function(p) {
            // make sure plot is called as a setter
            return this.put(new Polygon()).plot(p || new PointArray());
        })
    }
});
extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, 'Polygon');
class Polyline extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('polyline', node), attrs);
    }
}
registerMethods({
    Container: {
        // Create a wrapped polygon element
        polyline: wrapWithAttrCheck(function(p) {
            // make sure plot is called as a setter
            return this.put(new Polyline()).plot(p || new PointArray());
        })
    }
});
extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, 'Polyline');
class Rect extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('rect', node), attrs);
    }
}
extend(Rect, {
    rx,
    ry
});
registerMethods({
    Container: {
        // Create a rect element
        rect: wrapWithAttrCheck(function(width, height) {
            return this.put(new Rect()).size(width, height);
        })
    }
});
register(Rect, 'Rect');
class Queue {
    constructor(){
        this._first = null;
        this._last = null;
    }
    // Shows us the first item in the list
    first() {
        return this._first && this._first.value;
    }
    // Shows us the last item in the list
    last() {
        return this._last && this._last.value;
    }
    push(value) {
        // An item stores an id and the provided value
        const item = typeof value.next !== 'undefined' ? value : {
            value: value,
            next: null,
            prev: null
        };
        // Deal with the queue being empty or populated
        if (this._last) {
            item.prev = this._last;
            this._last.next = item;
            this._last = item;
        } else {
            this._last = item;
            this._first = item;
        }
        // Return the current item
        return item;
    }
    // Removes the item that was returned from the push
    remove(item) {
        // Relink the previous item
        if (item.prev) item.prev.next = item.next;
        if (item.next) item.next.prev = item.prev;
        if (item === this._last) this._last = item.prev;
        if (item === this._first) this._first = item.next;
        // Invalidate item
        item.prev = null;
        item.next = null;
    }
    shift() {
        // Check if we have a value
        const remove = this._first;
        if (!remove) return null;
        // If we do, remove it and relink things
        this._first = remove.next;
        if (this._first) this._first.prev = null;
        this._last = this._first ? this._last : null;
        return remove.value;
    }
}
const Animator = {
    nextDraw: null,
    frames: new Queue(),
    timeouts: new Queue(),
    immediates: new Queue(),
    timer: ()=>globals.window.performance || globals.window.Date,
    transforms: [],
    frame (fn) {
        // Store the node
        const node = Animator.frames.push({
            run: fn
        });
        // Request an animation frame if we don't have one
        if (Animator.nextDraw === null) Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
        // Return the node so we can remove it easily
        return node;
    },
    timeout (fn, delay) {
        delay = delay || 0;
        // Work out when the event should fire
        const time = Animator.timer().now() + delay;
        // Add the timeout to the end of the queue
        const node = Animator.timeouts.push({
            run: fn,
            time: time
        });
        // Request another animation frame if we need one
        if (Animator.nextDraw === null) Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
        return node;
    },
    immediate (fn) {
        // Add the immediate fn to the end of the queue
        const node = Animator.immediates.push(fn);
        // Request another animation frame if we need one
        if (Animator.nextDraw === null) Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
        return node;
    },
    cancelFrame (node) {
        node != null && Animator.frames.remove(node);
    },
    clearTimeout (node) {
        node != null && Animator.timeouts.remove(node);
    },
    cancelImmediate (node) {
        node != null && Animator.immediates.remove(node);
    },
    _draw (now) {
        // Run all the timeouts we can run, if they are not ready yet, add them
        // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
        let nextTimeout = null;
        const lastTimeout = Animator.timeouts.last();
        while(nextTimeout = Animator.timeouts.shift()){
            // Run the timeout if its time, or push it to the end
            if (now >= nextTimeout.time) nextTimeout.run();
            else Animator.timeouts.push(nextTimeout);
            // If we hit the last item, we should stop shifting out more items
            if (nextTimeout === lastTimeout) break;
        }
        // Run all of the animation frames
        let nextFrame = null;
        const lastFrame = Animator.frames.last();
        while(nextFrame !== lastFrame && (nextFrame = Animator.frames.shift()))nextFrame.run(now);
        let nextImmediate = null;
        while(nextImmediate = Animator.immediates.shift())nextImmediate();
        // If we have remaining timeouts or frames, draw until we don't anymore
        Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
    }
};
const makeSchedule = function(runnerInfo) {
    const start = runnerInfo.start;
    const duration = runnerInfo.runner.duration();
    const end = start + duration;
    return {
        start: start,
        duration: duration,
        end: end,
        runner: runnerInfo.runner
    };
};
const defaultSource = function() {
    const w = globals.window;
    return (w.performance || w.Date).now();
};
class Timeline extends EventTarget {
    // Construct a new timeline on the given element
    constructor(timeSource = defaultSource){
        super();
        this._timeSource = timeSource;
        // terminate resets all variables to their initial state
        this.terminate();
    }
    active() {
        return !!this._nextFrame;
    }
    finish() {
        // Go to end and pause
        this.time(this.getEndTimeOfTimeline() + 1);
        return this.pause();
    }
    // Calculates the end of the timeline
    getEndTime() {
        const lastRunnerInfo = this.getLastRunnerInfo();
        const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
        const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
        return lastStartTime + lastDuration;
    }
    getEndTimeOfTimeline() {
        const endTimes = this._runners.map((i)=>i.start + i.runner.duration());
        return Math.max(0, ...endTimes);
    }
    getLastRunnerInfo() {
        return this.getRunnerInfoById(this._lastRunnerId);
    }
    getRunnerInfoById(id) {
        return this._runners[this._runnerIds.indexOf(id)] || null;
    }
    pause() {
        this._paused = true;
        return this._continue();
    }
    persist(dtOrForever) {
        if (dtOrForever == null) return this._persist;
        this._persist = dtOrForever;
        return this;
    }
    play() {
        // Now make sure we are not paused and continue the animation
        this._paused = false;
        return this.updateTime()._continue();
    }
    reverse(yes) {
        const currentSpeed = this.speed();
        if (yes == null) return this.speed(-currentSpeed);
        const positive = Math.abs(currentSpeed);
        return this.speed(yes ? -positive : positive);
    }
    // schedules a runner on the timeline
    schedule(runner, delay, when) {
        if (runner == null) return this._runners.map(makeSchedule);
        // The start time for the next animation can either be given explicitly,
        // derived from the current timeline time or it can be relative to the
        // last start time to chain animations directly
        let absoluteStartTime = 0;
        const endTime = this.getEndTime();
        delay = delay || 0;
        // Work out when to start the animation
        if (when == null || when === 'last' || when === 'after') // Take the last time and increment
        absoluteStartTime = endTime;
        else if (when === 'absolute' || when === 'start') {
            absoluteStartTime = delay;
            delay = 0;
        } else if (when === 'now') absoluteStartTime = this._time;
        else if (when === 'relative') {
            const runnerInfo = this.getRunnerInfoById(runner.id);
            if (runnerInfo) {
                absoluteStartTime = runnerInfo.start + delay;
                delay = 0;
            }
        } else if (when === 'with-last') {
            const lastRunnerInfo = this.getLastRunnerInfo();
            const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
            absoluteStartTime = lastStartTime;
        } else throw new Error('Invalid value for the "when" parameter');
        // Manage runner
        runner.unschedule();
        runner.timeline(this);
        const persist = runner.persist();
        const runnerInfo = {
            persist: persist === null ? this._persist : persist,
            start: absoluteStartTime + delay,
            runner
        };
        this._lastRunnerId = runner.id;
        this._runners.push(runnerInfo);
        this._runners.sort((a, b)=>a.start - b.start);
        this._runnerIds = this._runners.map((info)=>info.runner.id);
        this.updateTime()._continue();
        return this;
    }
    seek(dt) {
        return this.time(this._time + dt);
    }
    source(fn) {
        if (fn == null) return this._timeSource;
        this._timeSource = fn;
        return this;
    }
    speed(speed) {
        if (speed == null) return this._speed;
        this._speed = speed;
        return this;
    }
    stop() {
        // Go to start and pause
        this.time(0);
        return this.pause();
    }
    time(time) {
        if (time == null) return this._time;
        this._time = time;
        return this._continue(true);
    }
    // Remove the runner from this timeline
    unschedule(runner) {
        const index = this._runnerIds.indexOf(runner.id);
        if (index < 0) return this;
        this._runners.splice(index, 1);
        this._runnerIds.splice(index, 1);
        runner.timeline(null);
        return this;
    }
    // Makes sure, that after pausing the time doesn't jump
    updateTime() {
        if (!this.active()) this._lastSourceTime = this._timeSource();
        return this;
    }
    // Checks if we are running and continues the animation
    _continue(immediateStep = false) {
        Animator.cancelFrame(this._nextFrame);
        this._nextFrame = null;
        if (immediateStep) return this._stepImmediate();
        if (this._paused) return this;
        this._nextFrame = Animator.frame(this._step);
        return this;
    }
    _stepFn(immediateStep = false) {
        // Get the time delta from the last time and update the time
        const time = this._timeSource();
        let dtSource = time - this._lastSourceTime;
        if (immediateStep) dtSource = 0;
        const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
        this._lastSourceTime = time;
        // Only update the time if we use the timeSource.
        // Otherwise use the current time
        if (!immediateStep) {
            // Update the time
            this._time += dtTime;
            this._time = this._time < 0 ? 0 : this._time;
        }
        this._lastStepTime = this._time;
        this.fire('time', this._time);
        // This is for the case that the timeline was seeked so that the time
        // is now before the startTime of the runner. That is why we need to set
        // the runner to position 0
        // FIXME:
        // However, resetting in insertion order leads to bugs. Considering the case,
        // where 2 runners change the same attribute but in different times,
        // resetting both of them will lead to the case where the later defined
        // runner always wins the reset even if the other runner started earlier
        // and therefore should win the attribute battle
        // this can be solved by resetting them backwards
        for(let k = this._runners.length; k--;){
            // Get and run the current runner and ignore it if its inactive
            const runnerInfo = this._runners[k];
            const runner = runnerInfo.runner;
            // Make sure that we give the actual difference
            // between runner start time and now
            const dtToStart = this._time - runnerInfo.start;
            // Dont run runner if not started yet
            // and try to reset it
            if (dtToStart <= 0) runner.reset();
        }
        // Run all of the runners directly
        let runnersLeft = false;
        for(let i = 0, len = this._runners.length; i < len; i++){
            // Get and run the current runner and ignore it if its inactive
            const runnerInfo = this._runners[i];
            const runner = runnerInfo.runner;
            let dt = dtTime;
            // Make sure that we give the actual difference
            // between runner start time and now
            const dtToStart = this._time - runnerInfo.start;
            // Dont run runner if not started yet
            if (dtToStart <= 0) {
                runnersLeft = true;
                continue;
            } else if (dtToStart < dt) // Adjust dt to make sure that animation is on point
            dt = dtToStart;
            if (!runner.active()) continue;
            // If this runner is still going, signal that we need another animation
            // frame, otherwise, remove the completed runner
            const finished = runner.step(dt).done;
            if (!finished) runnersLeft = true;
            else if (runnerInfo.persist !== true) {
                // runner is finished. And runner might get removed
                const endTime = runner.duration() - runner.time() + this._time;
                if (endTime + runnerInfo.persist < this._time) {
                    // Delete runner and correct index
                    runner.unschedule();
                    --i;
                    --len;
                }
            }
        }
        // Basically: we continue when there are runners right from us in time
        // when -->, and when runners are left from us when <--
        if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) this._continue();
        else {
            this.pause();
            this.fire('finished');
        }
        return this;
    }
    terminate() {
        // cleanup memory
        // Store the timing variables
        this._startTime = 0;
        this._speed = 1.0;
        // Determines how long a runner is hold in memory. Can be a dt or true/false
        this._persist = 0;
        // Keep track of the running animations and their starting parameters
        this._nextFrame = null;
        this._paused = true;
        this._runners = [];
        this._runnerIds = [];
        this._lastRunnerId = -1;
        this._time = 0;
        this._lastSourceTime = 0;
        this._lastStepTime = 0;
        // Make sure that step is always called in class context
        this._step = this._stepFn.bind(this, false);
        this._stepImmediate = this._stepFn.bind(this, true);
    }
}
registerMethods({
    Element: {
        timeline: function(timeline) {
            if (timeline == null) {
                this._timeline = this._timeline || new Timeline();
                return this._timeline;
            } else {
                this._timeline = timeline;
                return this;
            }
        }
    }
});
class Runner extends EventTarget {
    constructor(options){
        super();
        // Store a unique id on the runner, so that we can identify it later
        this.id = Runner.id++;
        // Ensure a default value
        options = options == null ? timeline.duration : options;
        // Ensure that we get a controller
        options = typeof options === 'function' ? new Controller(options) : options;
        // Declare all of the variables
        this._element = null;
        this._timeline = null;
        this.done = false;
        this._queue = [];
        // Work out the stepper and the duration
        this._duration = typeof options === 'number' && options;
        this._isDeclarative = options instanceof Controller;
        this._stepper = this._isDeclarative ? options : new Ease();
        // We copy the current values from the timeline because they can change
        this._history = {};
        // Store the state of the runner
        this.enabled = true;
        this._time = 0;
        this._lastTime = 0;
        // At creation, the runner is in reset state
        this._reseted = true;
        // Save transforms applied to this runner
        this.transforms = new Matrix();
        this.transformId = 1;
        // Looping variables
        this._haveReversed = false;
        this._reverse = false;
        this._loopsDone = 0;
        this._swing = false;
        this._wait = 0;
        this._times = 1;
        this._frameId = null;
        // Stores how long a runner is stored after being done
        this._persist = this._isDeclarative ? true : null;
    }
    static sanitise(duration, delay, when) {
        // Initialise the default parameters
        let times = 1;
        let swing = false;
        let wait = 0;
        duration = duration ?? timeline.duration;
        delay = delay ?? timeline.delay;
        when = when || 'last';
        // If we have an object, unpack the values
        if (typeof duration === 'object' && !(duration instanceof Stepper)) {
            delay = duration.delay ?? delay;
            when = duration.when ?? when;
            swing = duration.swing || swing;
            times = duration.times ?? times;
            wait = duration.wait ?? wait;
            duration = duration.duration ?? timeline.duration;
        }
        return {
            duration: duration,
            delay: delay,
            swing: swing,
            times: times,
            wait: wait,
            when: when
        };
    }
    active(enabled) {
        if (enabled == null) return this.enabled;
        this.enabled = enabled;
        return this;
    }
    /*
  Private Methods
  ===============
  Methods that shouldn't be used externally
  */ addTransform(transform) {
        this.transforms.lmultiplyO(transform);
        return this;
    }
    after(fn) {
        return this.on('finished', fn);
    }
    animate(duration, delay, when) {
        const o = Runner.sanitise(duration, delay, when);
        const runner = new Runner(o.duration);
        if (this._timeline) runner.timeline(this._timeline);
        if (this._element) runner.element(this._element);
        return runner.loop(o).schedule(o.delay, o.when);
    }
    clearTransform() {
        this.transforms = new Matrix();
        return this;
    }
    // TODO: Keep track of all transformations so that deletion is faster
    clearTransformsFromQueue() {
        if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) this._queue = this._queue.filter((item)=>{
            return !item.isTransform;
        });
    }
    delay(delay) {
        return this.animate(0, delay);
    }
    duration() {
        return this._times * (this._wait + this._duration) - this._wait;
    }
    during(fn) {
        return this.queue(null, fn);
    }
    ease(fn) {
        this._stepper = new Ease(fn);
        return this;
    }
    /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */ element(element) {
        if (element == null) return this._element;
        this._element = element;
        element._prepareRunner();
        return this;
    }
    finish() {
        return this.step(Infinity);
    }
    loop(times, swing, wait) {
        // Deal with the user passing in an object
        if (typeof times === 'object') {
            swing = times.swing;
            wait = times.wait;
            times = times.times;
        }
        // Sanitise the values and store them
        this._times = times || Infinity;
        this._swing = swing || false;
        this._wait = wait || 0;
        // Allow true to be passed
        if (this._times === true) this._times = Infinity;
        return this;
    }
    loops(p) {
        const loopDuration = this._duration + this._wait;
        if (p == null) {
            const loopsDone = Math.floor(this._time / loopDuration);
            const relativeTime = this._time - loopsDone * loopDuration;
            const position = relativeTime / this._duration;
            return Math.min(loopsDone + position, this._times);
        }
        const whole = Math.floor(p);
        const partial = p % 1;
        const time = loopDuration * whole + this._duration * partial;
        return this.time(time);
    }
    persist(dtOrForever) {
        if (dtOrForever == null) return this._persist;
        this._persist = dtOrForever;
        return this;
    }
    position(p) {
        // Get all of the variables we need
        const x = this._time;
        const d = this._duration;
        const w = this._wait;
        const t = this._times;
        const s = this._swing;
        const r = this._reverse;
        let position;
        if (p == null) {
            /*
      This function converts a time to a position in the range [0, 1]
      The full explanation can be found in this desmos demonstration
        https://www.desmos.com/calculator/u4fbavgche
      The logic is slightly simplified here because we can use booleans
      */ // Figure out the value without thinking about the start or end time
            const f = function(x) {
                const swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));
                const backwards = swinging && !r || !swinging && r;
                const uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;
                const clipped = Math.max(Math.min(uncliped, 1), 0);
                return clipped;
            };
            // Figure out the value by incorporating the start time
            const endTime = t * (w + d) - w;
            position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));
            return position;
        }
        // Work out the loops done and add the position to the loops done
        const loopsDone = Math.floor(this.loops());
        const swingForward = s && loopsDone % 2 === 0;
        const forwards = swingForward && !r || r && swingForward;
        position = loopsDone + (forwards ? p : 1 - p);
        return this.loops(position);
    }
    progress(p) {
        if (p == null) return Math.min(1, this._time / this.duration());
        return this.time(p * this.duration());
    }
    /*
  Basic Functionality
  ===================
  These methods allow us to attach basic functions to the runner directly
  */ queue(initFn, runFn, retargetFn, isTransform) {
        this._queue.push({
            initialiser: initFn || noop,
            runner: runFn || noop,
            retarget: retargetFn,
            isTransform: isTransform,
            initialised: false,
            finished: false
        });
        const timeline = this.timeline();
        timeline && this.timeline()._continue();
        return this;
    }
    reset() {
        if (this._reseted) return this;
        this.time(0);
        this._reseted = true;
        return this;
    }
    reverse(reverse) {
        this._reverse = reverse == null ? !this._reverse : reverse;
        return this;
    }
    schedule(timeline, delay, when) {
        // The user doesn't need to pass a timeline if we already have one
        if (!(timeline instanceof Timeline)) {
            when = delay;
            delay = timeline;
            timeline = this.timeline();
        }
        // If there is no timeline, yell at the user...
        if (!timeline) throw Error('Runner cannot be scheduled without timeline');
        // Schedule the runner on the timeline provided
        timeline.schedule(this, delay, when);
        return this;
    }
    step(dt) {
        // If we are inactive, this stepper just gets skipped
        if (!this.enabled) return this;
        // Update the time and get the new position
        dt = dt == null ? 16 : dt;
        this._time += dt;
        const position = this.position();
        // Figure out if we need to run the stepper in this frame
        const running = this._lastPosition !== position && this._time >= 0;
        this._lastPosition = position;
        // Figure out if we just started
        const duration = this.duration();
        const justStarted = this._lastTime <= 0 && this._time > 0;
        const justFinished = this._lastTime < duration && this._time >= duration;
        this._lastTime = this._time;
        if (justStarted) this.fire('start', this);
        // Work out if the runner is finished set the done flag here so animations
        // know, that they are running in the last step (this is good for
        // transformations which can be merged)
        const declarative = this._isDeclarative;
        this.done = !declarative && !justFinished && this._time >= duration;
        // Runner is running. So its not in reset state anymore
        this._reseted = false;
        let converged = false;
        // Call initialise and the run function
        if (running || declarative) {
            this._initialise(running);
            // clear the transforms on this runner so they dont get added again and again
            this.transforms = new Matrix();
            converged = this._run(declarative ? dt : position);
            this.fire('step', this);
        }
        // correct the done flag here
        // declarative animations itself know when they converged
        this.done = this.done || converged && declarative;
        if (justFinished) this.fire('finished', this);
        return this;
    }
    /*
  Runner animation methods
  ========================
  Control how the animation plays
  */ time(time) {
        if (time == null) return this._time;
        const dt = time - this._time;
        this.step(dt);
        return this;
    }
    timeline(timeline) {
        // check explicitly for undefined so we can set the timeline to null
        if (typeof timeline === 'undefined') return this._timeline;
        this._timeline = timeline;
        return this;
    }
    unschedule() {
        const timeline = this.timeline();
        timeline && timeline.unschedule(this);
        return this;
    }
    // Run each initialise function in the runner if required
    _initialise(running) {
        // If we aren't running, we shouldn't initialise when not declarative
        if (!running && !this._isDeclarative) return;
        // Loop through all of the initialisers
        for(let i = 0, len = this._queue.length; i < len; ++i){
            // Get the current initialiser
            const current = this._queue[i];
            // Determine whether we need to initialise
            const needsIt = this._isDeclarative || !current.initialised && running;
            running = !current.finished;
            // Call the initialiser if we need to
            if (needsIt && running) {
                current.initialiser.call(this);
                current.initialised = true;
            }
        }
    }
    // Save a morpher to the morpher list so that we can retarget it later
    _rememberMorpher(method, morpher) {
        this._history[method] = {
            morpher: morpher,
            caller: this._queue[this._queue.length - 1]
        };
        // We have to resume the timeline in case a controller
        // is already done without being ever run
        // This can happen when e.g. this is done:
        //    anim = el.animate(new SVG.Spring)
        // and later
        //    anim.move(...)
        if (this._isDeclarative) {
            const timeline = this.timeline();
            timeline && timeline.play();
        }
    }
    // Try to set the target for a morpher if the morpher exists, otherwise
    // Run each run function for the position or dt given
    _run(positionOrDt) {
        // Run all of the _queue directly
        let allfinished = true;
        for(let i = 0, len = this._queue.length; i < len; ++i){
            // Get the current function to run
            const current = this._queue[i];
            // Run the function if its not finished, we keep track of the finished
            // flag for the sake of declarative _queue
            const converged = current.runner.call(this, positionOrDt);
            current.finished = current.finished || converged === true;
            allfinished = allfinished && current.finished;
        }
        // We report when all of the constructors are finished
        return allfinished;
    }
    // do nothing and return false
    _tryRetarget(method, target, extra) {
        if (this._history[method]) {
            // if the last method wasn't even initialised, throw it away
            if (!this._history[method].caller.initialised) {
                const index = this._queue.indexOf(this._history[method].caller);
                this._queue.splice(index, 1);
                return false;
            }
            // for the case of transformations, we use the special retarget function
            // which has access to the outer scope
            if (this._history[method].caller.retarget) this._history[method].caller.retarget.call(this, target, extra);
            else this._history[method].morpher.to(target);
            this._history[method].caller.finished = false;
            const timeline = this.timeline();
            timeline && timeline.play();
            return true;
        }
        return false;
    }
}
Runner.id = 0;
class FakeRunner {
    constructor(transforms = new Matrix(), id = -1, done = true){
        this.transforms = transforms;
        this.id = id;
        this.done = done;
    }
    clearTransformsFromQueue() {}
}
extend([
    Runner,
    FakeRunner
], {
    mergeWith (runner) {
        return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
    }
});
// FakeRunner.emptyRunner = new FakeRunner()
const lmultiply = (last, curr)=>last.lmultiplyO(curr);
const getRunnerTransform = (runner)=>runner.transforms;
function mergeTransforms() {
    // Find the matrix to apply to the element and apply it
    const runners = this._transformationRunners.runners;
    const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());
    this.transform(netTransform);
    this._transformationRunners.merge();
    if (this._transformationRunners.length() === 1) this._frameId = null;
}
class RunnerArray {
    constructor(){
        this.runners = [];
        this.ids = [];
    }
    add(runner) {
        if (this.runners.includes(runner)) return;
        const id = runner.id + 1;
        this.runners.push(runner);
        this.ids.push(id);
        return this;
    }
    clearBefore(id) {
        const deleteCnt = this.ids.indexOf(id + 1) || 1;
        this.ids.splice(0, deleteCnt, 0);
        this.runners.splice(0, deleteCnt, new FakeRunner()).forEach((r)=>r.clearTransformsFromQueue());
        return this;
    }
    edit(id, newRunner) {
        const index = this.ids.indexOf(id + 1);
        this.ids.splice(index, 1, id + 1);
        this.runners.splice(index, 1, newRunner);
        return this;
    }
    getByID(id) {
        return this.runners[this.ids.indexOf(id + 1)];
    }
    length() {
        return this.ids.length;
    }
    merge() {
        let lastRunner = null;
        for(let i = 0; i < this.runners.length; ++i){
            const runner = this.runners[i];
            const condition = lastRunner && runner.done && lastRunner.done && // don't merge runner when persisted on timeline
            (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));
            if (condition) {
                // the +1 happens in the function
                this.remove(runner.id);
                const newRunner = runner.mergeWith(lastRunner);
                this.edit(lastRunner.id, newRunner);
                lastRunner = newRunner;
                --i;
            } else lastRunner = runner;
        }
        return this;
    }
    remove(id) {
        const index = this.ids.indexOf(id + 1);
        this.ids.splice(index, 1);
        this.runners.splice(index, 1);
        return this;
    }
}
registerMethods({
    Element: {
        animate (duration, delay, when) {
            const o = Runner.sanitise(duration, delay, when);
            const timeline = this.timeline();
            return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);
        },
        delay (by, when) {
            return this.animate(0, by, when);
        },
        // this function searches for all runners on the element and deletes the ones
        // which run before the current one. This is because absolute transformations
        // overwrite anything anyway so there is no need to waste time computing
        // other runners
        _clearTransformRunnersBefore (currentRunner) {
            this._transformationRunners.clearBefore(currentRunner.id);
        },
        _currentTransform (current) {
            return this._transformationRunners.runners// we need the equal sign here to make sure, that also transformations
            // on the same runner which execute before the current transformation are
            // taken into account
            .filter((runner)=>runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix());
        },
        _addRunner (runner) {
            this._transformationRunners.add(runner);
            // Make sure that the runner merge is executed at the very end of
            // all Animator functions. That is why we use immediate here to execute
            // the merge right after all frames are run
            Animator.cancelImmediate(this._frameId);
            this._frameId = Animator.immediate(mergeTransforms.bind(this));
        },
        _prepareRunner () {
            if (this._frameId == null) this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));
        }
    }
});
// Will output the elements from array A that are not in the array B
const difference = (a, b)=>a.filter((x)=>!b.includes(x));
extend(Runner, {
    attr (a, v) {
        return this.styleAttr('attr', a, v);
    },
    // Add animatable styles
    css (s, v) {
        return this.styleAttr('css', s, v);
    },
    styleAttr (type, nameOrAttrs, val) {
        if (typeof nameOrAttrs === 'string') return this.styleAttr(type, {
            [nameOrAttrs]: val
        });
        let attrs = nameOrAttrs;
        if (this._tryRetarget(type, attrs)) return this;
        let morpher = new Morphable(this._stepper).to(attrs);
        let keys = Object.keys(attrs);
        this.queue(function() {
            morpher = morpher.from(this.element()[type](keys));
        }, function(pos) {
            this.element()[type](morpher.at(pos).valueOf());
            return morpher.done();
        }, function(newToAttrs) {
            // Check if any new keys were added
            const newKeys = Object.keys(newToAttrs);
            const differences = difference(newKeys, keys);
            // If their are new keys, initialize them and add them to morpher
            if (differences.length) {
                // Get the values
                const addedFromAttrs = this.element()[type](differences);
                // Get the already initialized values
                const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();
                // Merge old and new
                Object.assign(oldFromAttrs, addedFromAttrs);
                morpher.from(oldFromAttrs);
            }
            // Get the object from the morpher
            const oldToAttrs = new ObjectBag(morpher.to()).valueOf();
            // Merge in new attributes
            Object.assign(oldToAttrs, newToAttrs);
            // Change morpher target
            morpher.to(oldToAttrs);
            // Make sure that we save the work we did so we don't need it to do again
            keys = newKeys;
            attrs = newToAttrs;
        });
        this._rememberMorpher(type, morpher);
        return this;
    },
    zoom (level, point) {
        if (this._tryRetarget('zoom', level, point)) return this;
        let morpher = new Morphable(this._stepper).to(new SVGNumber(level));
        this.queue(function() {
            morpher = morpher.from(this.element().zoom());
        }, function(pos) {
            this.element().zoom(morpher.at(pos), point);
            return morpher.done();
        }, function(newLevel, newPoint) {
            point = newPoint;
            morpher.to(newLevel);
        });
        this._rememberMorpher('zoom', morpher);
        return this;
    },
    /**
   ** absolute transformations
   **/ //
    // M v -----|-----(D M v = F v)------|----->  T v
    //
    // 1. define the final state (T) and decompose it (once)
    //    t = [tx, ty, the, lam, sy, sx]
    // 2. on every frame: pull the current state of all previous transforms
    //    (M - m can change)
    //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
    // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
    //   - Note F(0) = M
    //   - Note F(1) = T
    // 4. Now you get the delta matrix as a result: D = F * inv(M)
    transform (transforms, relative, affine) {
        // If we have a declarative function, we should retarget it if possible
        relative = transforms.relative || relative;
        if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) return this;
        // Parse the parameters
        const isMatrix = Matrix.isMatrixLike(transforms);
        affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix;
        // Create a morpher and set its type
        const morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);
        let origin;
        let element;
        let current;
        let currentAngle;
        let startTransform;
        function setup() {
            // make sure element and origin is defined
            element = element || this.element();
            origin = origin || getOrigin(transforms, element);
            startTransform = new Matrix(relative ? undefined : element);
            // add the runner to the element so it can merge transformations
            element._addRunner(this);
            // Deactivate all transforms that have run so far if we are absolute
            if (!relative) element._clearTransformRunnersBefore(this);
        }
        function run(pos) {
            // clear all other transforms before this in case something is saved
            // on this runner. We are absolute. We dont need these!
            if (!relative) this.clearTransform();
            const { x, y } = new Point(origin).transform(element._currentTransform(this));
            let target = new Matrix({
                ...transforms,
                origin: [
                    x,
                    y
                ]
            });
            let start = this._isDeclarative && current ? current : startTransform;
            if (affine) {
                target = target.decompose(x, y);
                start = start.decompose(x, y);
                // Get the current and target angle as it was set
                const rTarget = target.rotate;
                const rCurrent = start.rotate;
                // Figure out the shortest path to rotate directly
                const possibilities = [
                    rTarget - 360,
                    rTarget,
                    rTarget + 360
                ];
                const distances = possibilities.map((a)=>Math.abs(a - rCurrent));
                const shortest = Math.min(...distances);
                const index = distances.indexOf(shortest);
                target.rotate = possibilities[index];
            }
            if (relative) {
                // we have to be careful here not to overwrite the rotation
                // with the rotate method of Matrix
                if (!isMatrix) target.rotate = transforms.rotate || 0;
                if (this._isDeclarative && currentAngle) start.rotate = currentAngle;
            }
            morpher.from(start);
            morpher.to(target);
            const affineParameters = morpher.at(pos);
            currentAngle = affineParameters.rotate;
            current = new Matrix(affineParameters);
            this.addTransform(current);
            element._addRunner(this);
            return morpher.done();
        }
        function retarget(newTransforms) {
            // only get a new origin if it changed since the last call
            if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) origin = getOrigin(newTransforms, element);
            // overwrite the old transformations with the new ones
            transforms = {
                ...newTransforms,
                origin
            };
        }
        this.queue(setup, run, retarget, true);
        this._isDeclarative && this._rememberMorpher('transform', morpher);
        return this;
    },
    // Animatable x-axis
    x (x) {
        return this._queueNumber('x', x);
    },
    // Animatable y-axis
    y (y) {
        return this._queueNumber('y', y);
    },
    ax (x) {
        return this._queueNumber('ax', x);
    },
    ay (y) {
        return this._queueNumber('ay', y);
    },
    dx (x = 0) {
        return this._queueNumberDelta('x', x);
    },
    dy (y = 0) {
        return this._queueNumberDelta('y', y);
    },
    dmove (x, y) {
        return this.dx(x).dy(y);
    },
    _queueNumberDelta (method, to) {
        to = new SVGNumber(to);
        // Try to change the target if we have this method already registered
        if (this._tryRetarget(method, to)) return this;
        // Make a morpher and queue the animation
        const morpher = new Morphable(this._stepper).to(to);
        let from = null;
        this.queue(function() {
            from = this.element()[method]();
            morpher.from(from);
            morpher.to(from + to);
        }, function(pos) {
            this.element()[method](morpher.at(pos));
            return morpher.done();
        }, function(newTo) {
            morpher.to(from + new SVGNumber(newTo));
        });
        // Register the morpher so that if it is changed again, we can retarget it
        this._rememberMorpher(method, morpher);
        return this;
    },
    _queueObject (method, to) {
        // Try to change the target if we have this method already registered
        if (this._tryRetarget(method, to)) return this;
        // Make a morpher and queue the animation
        const morpher = new Morphable(this._stepper).to(to);
        this.queue(function() {
            morpher.from(this.element()[method]());
        }, function(pos) {
            this.element()[method](morpher.at(pos));
            return morpher.done();
        });
        // Register the morpher so that if it is changed again, we can retarget it
        this._rememberMorpher(method, morpher);
        return this;
    },
    _queueNumber (method, value) {
        return this._queueObject(method, new SVGNumber(value));
    },
    // Animatable center x-axis
    cx (x) {
        return this._queueNumber('cx', x);
    },
    // Animatable center y-axis
    cy (y) {
        return this._queueNumber('cy', y);
    },
    // Add animatable move
    move (x, y) {
        return this.x(x).y(y);
    },
    amove (x, y) {
        return this.ax(x).ay(y);
    },
    // Add animatable center
    center (x, y) {
        return this.cx(x).cy(y);
    },
    // Add animatable size
    size (width, height) {
        // animate bbox based size for all other elements
        let box;
        if (!width || !height) box = this._element.bbox();
        if (!width) width = box.width / box.height * height;
        if (!height) height = box.height / box.width * width;
        return this.width(width).height(height);
    },
    // Add animatable width
    width (width) {
        return this._queueNumber('width', width);
    },
    // Add animatable height
    height (height) {
        return this._queueNumber('height', height);
    },
    // Add animatable plot
    plot (a, b, c, d) {
        // Lines can be plotted with 4 arguments
        if (arguments.length === 4) return this.plot([
            a,
            b,
            c,
            d
        ]);
        if (this._tryRetarget('plot', a)) return this;
        const morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);
        this.queue(function() {
            morpher.from(this._element.array());
        }, function(pos) {
            this._element.plot(morpher.at(pos));
            return morpher.done();
        });
        this._rememberMorpher('plot', morpher);
        return this;
    },
    // Add leading method
    leading (value) {
        return this._queueNumber('leading', value);
    },
    // Add animatable viewbox
    viewbox (x, y, width, height) {
        return this._queueObject('viewbox', new Box(x, y, width, height));
    },
    update (o) {
        if (typeof o !== 'object') return this.update({
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
        });
        if (o.opacity != null) this.attr('stop-opacity', o.opacity);
        if (o.color != null) this.attr('stop-color', o.color);
        if (o.offset != null) this.attr('offset', o.offset);
        return this;
    }
});
extend(Runner, {
    rx,
    ry,
    from,
    to
});
register(Runner, 'Runner');
class Svg extends Container {
    constructor(node, attrs = node){
        super(nodeOrNew('svg', node), attrs);
        this.namespace();
    }
    // Creates and returns defs element
    defs() {
        if (!this.isRoot()) return this.root().defs();
        return adopt(this.node.querySelector('defs')) || this.put(new Defs());
    }
    isRoot() {
        return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== '#document-fragment';
    }
    // Add namespaces
    namespace() {
        if (!this.isRoot()) return this.root().namespace();
        return this.attr({
            xmlns: svg,
            version: '1.1'
        }).attr('xmlns:xlink', xlink, xmlns);
    }
    removeNamespace() {
        return this.attr({
            xmlns: null,
            version: null
        }).attr('xmlns:xlink', null, xmlns).attr('xmlns:svgjs', null, xmlns);
    }
    // Check if this is a root svg
    // If not, call root() from this element
    root() {
        if (this.isRoot()) return this;
        return super.root();
    }
}
registerMethods({
    Container: {
        // Create nested svg document
        nested: wrapWithAttrCheck(function() {
            return this.put(new Svg());
        })
    }
});
register(Svg, 'Svg', true);
class Symbol extends Container {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('symbol', node), attrs);
    }
}
registerMethods({
    Container: {
        symbol: wrapWithAttrCheck(function() {
            return this.put(new Symbol());
        })
    }
});
register(Symbol, 'Symbol');
// Create plain text node
function plain(text) {
    // clear if build mode is disabled
    if (this._build === false) this.clear();
    // create text node
    this.node.appendChild(globals.document.createTextNode(text));
    return this;
}
// Get length of text element
function length() {
    return this.node.getComputedTextLength();
}
// Move over x-axis
// Text is moved by its bounding box
// text-anchor does NOT matter
function x$1(x, box = this.bbox()) {
    if (x == null) return box.x;
    return this.attr('x', this.attr('x') + x - box.x);
}
// Move over y-axis
function y$1(y, box = this.bbox()) {
    if (y == null) return box.y;
    return this.attr('y', this.attr('y') + y - box.y);
}
function move$1(x, y, box = this.bbox()) {
    return this.x(x, box).y(y, box);
}
// Move center over x-axis
function cx(x, box = this.bbox()) {
    if (x == null) return box.cx;
    return this.attr('x', this.attr('x') + x - box.cx);
}
// Move center over y-axis
function cy(y, box = this.bbox()) {
    if (y == null) return box.cy;
    return this.attr('y', this.attr('y') + y - box.cy);
}
function center(x, y, box = this.bbox()) {
    return this.cx(x, box).cy(y, box);
}
function ax(x) {
    return this.attr('x', x);
}
function ay(y) {
    return this.attr('y', y);
}
function amove(x, y) {
    return this.ax(x).ay(y);
}
// Enable / disable build mode
function build(build) {
    this._build = !!build;
    return this;
}
var textable = {
    __proto__: null,
    amove: amove,
    ax: ax,
    ay: ay,
    build: build,
    center: center,
    cx: cx,
    cy: cy,
    length: length,
    move: move$1,
    plain: plain,
    x: x$1,
    y: y$1
};
class Text extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('text', node), attrs);
        this.dom.leading = this.dom.leading ?? new SVGNumber(1.3); // store leading value for rebuilding
        this._rebuild = true; // enable automatic updating of dy values
        this._build = false; // disable build mode for adding multiple lines
    }
    // Set / get leading
    leading(value) {
        // act as getter
        if (value == null) return this.dom.leading;
        // act as setter
        this.dom.leading = new SVGNumber(value);
        return this.rebuild();
    }
    // Rebuild appearance type
    rebuild(rebuild) {
        // store new rebuild flag if given
        if (typeof rebuild === 'boolean') this._rebuild = rebuild;
        // define position of all lines
        if (this._rebuild) {
            const self = this;
            let blankLineOffset = 0;
            const leading = this.dom.leading;
            this.each(function(i) {
                if (isDescriptive(this.node)) return;
                const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
                const dy = leading * new SVGNumber(fontSize);
                if (this.dom.newLined) {
                    this.attr('x', self.attr('x'));
                    if (this.text() === '\n') blankLineOffset += dy;
                    else {
                        this.attr('dy', i ? dy + blankLineOffset : 0);
                        blankLineOffset = 0;
                    }
                }
            });
            this.fire('rebuild');
        }
        return this;
    }
    // overwrite method from parent to set data properly
    setData(o) {
        this.dom = o;
        this.dom.leading = new SVGNumber(o.leading || 1.3);
        return this;
    }
    writeDataToDom() {
        writeDataToDom(this, this.dom, {
            leading: 1.3
        });
        return this;
    }
    // Set the text content
    text(text) {
        // act as getter
        if (text === undefined) {
            const children = this.node.childNodes;
            let firstLine = 0;
            text = '';
            for(let i = 0, len = children.length; i < len; ++i){
                // skip textPaths - they are no lines
                if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {
                    if (i === 0) firstLine = i + 1;
                    continue;
                }
                // add newline if its not the first child and newLined is set to true
                if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) text += '\n';
                // add content of this node
                text += children[i].textContent;
            }
            return text;
        }
        // remove existing content
        this.clear().build(true);
        if (typeof text === 'function') // call block
        text.call(this, this);
        else {
            // store text and make sure text is not blank
            text = (text + '').split('\n');
            // build new lines
            for(let j = 0, jl = text.length; j < jl; j++)this.newLine(text[j]);
        }
        // disable build mode and rebuild lines
        return this.build(false).rebuild();
    }
}
extend(Text, textable);
registerMethods({
    Container: {
        // Create text element
        text: wrapWithAttrCheck(function(text = '') {
            return this.put(new Text()).text(text);
        }),
        // Create plain text element
        plain: wrapWithAttrCheck(function(text = '') {
            return this.put(new Text()).plain(text);
        })
    }
});
register(Text, 'Text');
class Tspan extends Shape {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('tspan', node), attrs);
        this._build = false; // disable build mode for adding multiple lines
    }
    // Shortcut dx
    dx(dx) {
        return this.attr('dx', dx);
    }
    // Shortcut dy
    dy(dy) {
        return this.attr('dy', dy);
    }
    // Create new line
    newLine() {
        // mark new line
        this.dom.newLined = true;
        // fetch parent
        const text = this.parent();
        // early return in case we are not in a text element
        if (!(text instanceof Text)) return this;
        const i = text.index(this);
        const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
        const dy = text.dom.leading * new SVGNumber(fontSize);
        // apply new position
        return this.dy(i ? dy : 0).attr('x', text.x());
    }
    // Set text content
    text(text) {
        if (text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');
        if (typeof text === 'function') {
            this.clear().build(true);
            text.call(this, this);
            this.build(false);
        } else this.plain(text);
        return this;
    }
}
extend(Tspan, textable);
registerMethods({
    Tspan: {
        tspan: wrapWithAttrCheck(function(text = '') {
            const tspan = new Tspan();
            // clear if build mode is disabled
            if (!this._build) this.clear();
            // add new tspan
            return this.put(tspan).text(text);
        })
    },
    Text: {
        newLine: function(text = '') {
            return this.tspan(text).newLine();
        }
    }
});
register(Tspan, 'Tspan');
class Circle extends Shape {
    constructor(node, attrs = node){
        super(nodeOrNew('circle', node), attrs);
    }
    radius(r) {
        return this.attr('r', r);
    }
    // Radius x value
    rx(rx) {
        return this.attr('r', rx);
    }
    // Alias radius x value
    ry(ry) {
        return this.rx(ry);
    }
    size(size) {
        return this.radius(new SVGNumber(size).divide(2));
    }
}
extend(Circle, {
    x: x$3,
    y: y$3,
    cx: cx$1,
    cy: cy$1,
    width: width$2,
    height: height$2
});
registerMethods({
    Container: {
        // Create circle element
        circle: wrapWithAttrCheck(function(size = 0) {
            return this.put(new Circle()).size(size).move(0, 0);
        })
    }
});
register(Circle, 'Circle');
class ClipPath extends Container {
    constructor(node, attrs = node){
        super(nodeOrNew('clipPath', node), attrs);
    }
    // Unclip all clipped elements and remove itself
    remove() {
        // unclip all targets
        this.targets().forEach(function(el) {
            el.unclip();
        });
        // remove clipPath from parent
        return super.remove();
    }
    targets() {
        return baseFind('svg [clip-path*=' + this.id() + ']');
    }
}
registerMethods({
    Container: {
        // Create clipping element
        clip: wrapWithAttrCheck(function() {
            return this.defs().put(new ClipPath());
        })
    },
    Element: {
        // Distribute clipPath to svg element
        clipper () {
            return this.reference('clip-path');
        },
        clipWith (element) {
            // use given clip or create a new one
            const clipper = element instanceof ClipPath ? element : this.parent().clip().add(element);
            // apply mask
            return this.attr('clip-path', 'url(#' + clipper.id() + ')');
        },
        // Unclip element
        unclip () {
            return this.attr('clip-path', null);
        }
    }
});
register(ClipPath, 'ClipPath');
class ForeignObject extends Element {
    constructor(node, attrs = node){
        super(nodeOrNew('foreignObject', node), attrs);
    }
}
registerMethods({
    Container: {
        foreignObject: wrapWithAttrCheck(function(width, height) {
            return this.put(new ForeignObject()).size(width, height);
        })
    }
});
register(ForeignObject, 'ForeignObject');
function dmove(dx, dy) {
    this.children().forEach((child)=>{
        let bbox;
        // We have to wrap this for elements that dont have a bbox
        // e.g. title and other descriptive elements
        try {
            // Get the childs bbox
            // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039
            // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs
            // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).
            // Funnily enough the broken behavior would work for us but that breaks it in chrome
            // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself
            bbox = child.node instanceof getWindow().SVGSVGElement ? new Box(child.attr([
                'x',
                'y',
                'width',
                'height'
            ])) : child.bbox();
        } catch (e) {
            return;
        }
        // Get childs matrix
        const m = new Matrix(child);
        // Translate childs matrix by amount and
        // transform it back into parents space
        const matrix = m.translate(dx, dy).transform(m.inverse());
        // Calculate new x and y from old box
        const p = new Point(bbox.x, bbox.y).transform(matrix);
        // Move element
        child.move(p.x, p.y);
    });
    return this;
}
function dx(dx) {
    return this.dmove(dx, 0);
}
function dy(dy) {
    return this.dmove(0, dy);
}
function height(height1, box = this.bbox()) {
    if (height1 == null) return box.height;
    return this.size(box.width, height1, box);
}
function move(x = 0, y = 0, box = this.bbox()) {
    const dx = x - box.x;
    const dy = y - box.y;
    return this.dmove(dx, dy);
}
function size(width, height, box = this.bbox()) {
    const p = proportionalSize(this, width, height, box);
    const scaleX = p.width / box.width;
    const scaleY = p.height / box.height;
    this.children().forEach((child)=>{
        const o = new Point(box).transform(new Matrix(child).inverse());
        child.scale(scaleX, scaleY, o.x, o.y);
    });
    return this;
}
function width(width1, box = this.bbox()) {
    if (width1 == null) return box.width;
    return this.size(width1, box.height, box);
}
function x(x1, box = this.bbox()) {
    if (x1 == null) return box.x;
    return this.move(x1, box.y, box);
}
function y(y1, box = this.bbox()) {
    if (y1 == null) return box.y;
    return this.move(box.x, y1, box);
}
var containerGeometry = {
    __proto__: null,
    dmove: dmove,
    dx: dx,
    dy: dy,
    height: height,
    move: move,
    size: size,
    width: width,
    x: x,
    y: y
};
class G extends Container {
    constructor(node, attrs = node){
        super(nodeOrNew('g', node), attrs);
    }
}
extend(G, containerGeometry);
registerMethods({
    Container: {
        // Create a group element
        group: wrapWithAttrCheck(function() {
            return this.put(new G());
        })
    }
});
register(G, 'G');
class A extends Container {
    constructor(node, attrs = node){
        super(nodeOrNew('a', node), attrs);
    }
    // Link target attribute
    target(target) {
        return this.attr('target', target);
    }
    // Link url
    to(url) {
        return this.attr('href', url, xlink);
    }
}
extend(A, containerGeometry);
registerMethods({
    Container: {
        // Create a hyperlink element
        link: wrapWithAttrCheck(function(url) {
            return this.put(new A()).to(url);
        })
    },
    Element: {
        unlink () {
            const link = this.linker();
            if (!link) return this;
            const parent = link.parent();
            if (!parent) return this.remove();
            const index = parent.index(link);
            parent.add(this, index);
            link.remove();
            return this;
        },
        linkTo (url) {
            // reuse old link if possible
            let link = this.linker();
            if (!link) {
                link = new A();
                this.wrap(link);
            }
            if (typeof url === 'function') url.call(link, link);
            else link.to(url);
            return this;
        },
        linker () {
            const link = this.parent();
            if (link && link.node.nodeName.toLowerCase() === 'a') return link;
            return null;
        }
    }
});
register(A, 'A');
class Mask extends Container {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('mask', node), attrs);
    }
    // Unmask all masked elements and remove itself
    remove() {
        // unmask all targets
        this.targets().forEach(function(el) {
            el.unmask();
        });
        // remove mask from parent
        return super.remove();
    }
    targets() {
        return baseFind('svg [mask*=' + this.id() + ']');
    }
}
registerMethods({
    Container: {
        mask: wrapWithAttrCheck(function() {
            return this.defs().put(new Mask());
        })
    },
    Element: {
        // Distribute mask to svg element
        masker () {
            return this.reference('mask');
        },
        maskWith (element) {
            // use given mask or create a new one
            const masker = element instanceof Mask ? element : this.parent().mask().add(element);
            // apply mask
            return this.attr('mask', 'url(#' + masker.id() + ')');
        },
        // Unmask element
        unmask () {
            return this.attr('mask', null);
        }
    }
});
register(Mask, 'Mask');
class Stop extends Element {
    constructor(node, attrs = node){
        super(nodeOrNew('stop', node), attrs);
    }
    // add color stops
    update(o) {
        if (typeof o === 'number' || o instanceof SVGNumber) o = {
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
        };
        // set attributes
        if (o.opacity != null) this.attr('stop-opacity', o.opacity);
        if (o.color != null) this.attr('stop-color', o.color);
        if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));
        return this;
    }
}
registerMethods({
    Gradient: {
        // Add a color stop
        stop: function(offset, color, opacity) {
            return this.put(new Stop()).update(offset, color, opacity);
        }
    }
});
register(Stop, 'Stop');
function cssRule(selector, rule) {
    if (!selector) return '';
    if (!rule) return selector;
    let ret = selector + '{';
    for(const i in rule)ret += unCamelCase(i) + ':' + rule[i] + ';';
    ret += '}';
    return ret;
}
class Style extends Element {
    constructor(node, attrs = node){
        super(nodeOrNew('style', node), attrs);
    }
    addText(w = '') {
        this.node.textContent += w;
        return this;
    }
    font(name, src, params = {}) {
        return this.rule('@font-face', {
            fontFamily: name,
            src: src,
            ...params
        });
    }
    rule(selector, obj) {
        return this.addText(cssRule(selector, obj));
    }
}
registerMethods('Dom', {
    style (selector, obj) {
        return this.put(new Style()).rule(selector, obj);
    },
    fontface (name, src, params) {
        return this.put(new Style()).font(name, src, params);
    }
});
register(Style, 'Style');
class TextPath extends Text {
    // Initialize node
    constructor(node, attrs = node){
        super(nodeOrNew('textPath', node), attrs);
    }
    // return the array of the path track element
    array() {
        const track = this.track();
        return track ? track.array() : null;
    }
    // Plot path if any
    plot(d) {
        const track = this.track();
        let pathArray = null;
        if (track) pathArray = track.plot(d);
        return d == null ? pathArray : this;
    }
    // Get the path element
    track() {
        return this.reference('href');
    }
}
registerMethods({
    Container: {
        textPath: wrapWithAttrCheck(function(text, path) {
            // Convert text to instance if needed
            if (!(text instanceof Text)) text = this.text(text);
            return text.path(path);
        })
    },
    Text: {
        // Create path for text to run on
        path: wrapWithAttrCheck(function(track, importNodes = true) {
            const textPath = new TextPath();
            // if track is a path, reuse it
            if (!(track instanceof Path)) // create path element
            track = this.defs().path(track);
            // link textPath to path and add content
            textPath.attr('href', '#' + track, xlink);
            // Transplant all nodes from text to textPath
            let node;
            if (importNodes) while(node = this.node.firstChild)textPath.node.appendChild(node);
            // add textPath element as child node and return textPath
            return this.put(textPath);
        }),
        // Get the textPath children
        textPath () {
            return this.findOne('textPath');
        }
    },
    Path: {
        // creates a textPath from this path
        text: wrapWithAttrCheck(function(text) {
            // Convert text to instance if needed
            if (!(text instanceof Text)) text = new Text().addTo(this.parent()).text(text);
            // Create textPath from text and path and return
            return text.path(this);
        }),
        targets () {
            return baseFind('svg textPath').filter((node)=>{
                return (node.attr('href') || '').includes(this.id());
            });
        // Does not work in IE11. Use when IE support is dropped
        // return baseFind('svg textPath[*|href*=' + this.id() + ']')
        }
    }
});
TextPath.prototype.MorphArray = PathArray;
register(TextPath, 'TextPath');
class Use extends Shape {
    constructor(node, attrs = node){
        super(nodeOrNew('use', node), attrs);
    }
    // Use element as a reference
    use(element, file) {
        // Set lined element
        return this.attr('href', (file || '') + '#' + element, xlink);
    }
}
registerMethods({
    Container: {
        // Create a use element
        use: wrapWithAttrCheck(function(element, file) {
            return this.put(new Use()).use(element, file);
        })
    }
});
register(Use, 'Use');
/* Optional Modules */ const SVG = makeInstance;
extend([
    Svg,
    Symbol,
    Image,
    Pattern,
    Marker
], getMethodsFor('viewbox'));
extend([
    Line,
    Polyline,
    Polygon,
    Path
], getMethodsFor('marker'));
extend(Text, getMethodsFor('Text'));
extend(Path, getMethodsFor('Path'));
extend(Defs, getMethodsFor('Defs'));
extend([
    Text,
    Tspan
], getMethodsFor('Tspan'));
extend([
    Rect,
    Ellipse,
    Gradient,
    Runner
], getMethodsFor('radius'));
extend(EventTarget, getMethodsFor('EventTarget'));
extend(Dom, getMethodsFor('Dom'));
extend(Element, getMethodsFor('Element'));
extend(Shape, getMethodsFor('Shape'));
extend([
    Container,
    Fragment
], getMethodsFor('Container'));
extend(Gradient, getMethodsFor('Gradient'));
extend(Runner, getMethodsFor('Runner'));
List.extend(getMethodNames());
registerMorphableType([
    SVGNumber,
    Color,
    Box,
    Matrix,
    SVGArray,
    PointArray,
    PathArray,
    Point
]);
makeMorphable();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"hjCRY":[function(require,module,exports,__globalThis) {
/*!
  * Bootstrap v5.3.7 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Alert", ()=>Alert);
parcelHelpers.export(exports, "Button", ()=>Button);
parcelHelpers.export(exports, "Carousel", ()=>Carousel);
parcelHelpers.export(exports, "Collapse", ()=>Collapse);
parcelHelpers.export(exports, "Dropdown", ()=>Dropdown);
parcelHelpers.export(exports, "Modal", ()=>Modal);
parcelHelpers.export(exports, "Offcanvas", ()=>Offcanvas);
parcelHelpers.export(exports, "Popover", ()=>Popover);
parcelHelpers.export(exports, "ScrollSpy", ()=>ScrollSpy);
parcelHelpers.export(exports, "Tab", ()=>Tab);
parcelHelpers.export(exports, "Toast", ()=>Toast);
parcelHelpers.export(exports, "Tooltip", ()=>Tooltip);
var _core = require("@popperjs/core");
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const elementMap = new Map();
const Data = {
    set (element, key, instance) {
        if (!elementMap.has(element)) elementMap.set(element, new Map());
        const instanceMap = elementMap.get(element);
        // make it clear we only want one instance per element
        // can be removed later when multiple key/instances are fine to be used
        if (!instanceMap.has(key) && instanceMap.size !== 0) {
            // eslint-disable-next-line no-console
            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
            return;
        }
        instanceMap.set(key, instance);
    },
    get (element, key) {
        if (elementMap.has(element)) return elementMap.get(element).get(key) || null;
        return null;
    },
    remove (element, key) {
        if (!elementMap.has(element)) return;
        const instanceMap = elementMap.get(element);
        instanceMap.delete(key);
        // free up element references if there are no instances left for an element
        if (instanceMap.size === 0) elementMap.delete(element);
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = 'transitionend';
/**
 * Properly escape IDs selectors to handle weird IDs
 * @param {string} selector
 * @returns {string}
 */ const parseSelector = (selector)=>{
    if (selector && window.CSS && window.CSS.escape) // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
    selector = selector.replace(/#([^\s"#']+)/g, (match, id)=>`#${CSS.escape(id)}`);
    return selector;
};
// Shout-out Angus Croll (https://goo.gl/pxwQGp)
const toType = (object)=>{
    if (object === null || object === undefined) return `${object}`;
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
 * Public Util API
 */ const getUID = (prefix)=>{
    do prefix += Math.floor(Math.random() * MAX_UID);
    while (document.getElementById(prefix));
    return prefix;
};
const getTransitionDurationFromElement = (element)=>{
    if (!element) return 0;
    // Get transition-duration of the element
    let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    // Return 0 if element or transition duration is not found
    if (!floatTransitionDuration && !floatTransitionDelay) return 0;
    // If multiple durations are defined, take the first
    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = (element)=>{
    element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = (object)=>{
    if (!object || typeof object !== 'object') return false;
    if (typeof object.jquery !== 'undefined') object = object[0];
    return typeof object.nodeType !== 'undefined';
};
const getElement = (object)=>{
    // it's a jQuery object or a node element
    if (isElement(object)) return object.jquery ? object[0] : object;
    if (typeof object === 'string' && object.length > 0) return document.querySelector(parseSelector(object));
    return null;
};
const isVisible = (element)=>{
    if (!isElement(element) || element.getClientRects().length === 0) return false;
    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
    // Handle `details` element as its content may falsie appear visible when it is closed
    const closedDetails = element.closest('details:not([open])');
    if (!closedDetails) return elementIsVisible;
    if (closedDetails !== element) {
        const summary = element.closest('summary');
        if (summary && summary.parentNode !== closedDetails) return false;
        if (summary === null) return false;
    }
    return elementIsVisible;
};
const isDisabled = (element)=>{
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return true;
    if (element.classList.contains('disabled')) return true;
    if (typeof element.disabled !== 'undefined') return element.disabled;
    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};
const findShadowRoot = (element)=>{
    if (!document.documentElement.attachShadow) return null;
    // Can find the shadow root otherwise it'll return the document
    if (typeof element.getRootNode === 'function') {
        const root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) return element;
    // when we don't find a shadow root
    if (!element.parentNode) return null;
    return findShadowRoot(element.parentNode);
};
const noop = ()=>{};
/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */ const reflow = (element)=>{
    element.offsetHeight; // eslint-disable-line no-unused-expressions
};
const getjQuery = ()=>{
    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) return window.jQuery;
    return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = (callback)=>{
    if (document.readyState === 'loading') {
        // add listener on the first call when the document is in loading state
        if (!DOMContentLoadedCallbacks.length) document.addEventListener('DOMContentLoaded', ()=>{
            for (const callback of DOMContentLoadedCallbacks)callback();
        });
        DOMContentLoadedCallbacks.push(callback);
    } else callback();
};
const isRTL = ()=>document.documentElement.dir === 'rtl';
const defineJQueryPlugin = (plugin)=>{
    onDOMContentLoaded(()=>{
        const $ = getjQuery();
        /* istanbul ignore if */ if ($) {
            const name = plugin.NAME;
            const JQUERY_NO_CONFLICT = $.fn[name];
            $.fn[name] = plugin.jQueryInterface;
            $.fn[name].Constructor = plugin;
            $.fn[name].noConflict = ()=>{
                $.fn[name] = JQUERY_NO_CONFLICT;
                return plugin.jQueryInterface;
            };
        }
    });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback)=>{
    return typeof possibleCallback === 'function' ? possibleCallback.call(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{
    if (!waitForTransition) {
        execute(callback);
        return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({ target })=>{
        if (target !== transitionElement) return;
        called = true;
        transitionElement.removeEventListener(TRANSITION_END, handler);
        execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(()=>{
        if (!called) triggerTransitionEnd(transitionElement);
    }, emulatedDuration);
};
/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    // if the element does not exist in the list return an element
    // depending on the direction and if cycle is allowed
    if (index === -1) return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) index = (index + listLength) % listLength;
    return list[Math.max(0, Math.min(index, listLength - 1))];
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage
let uidEvent = 1;
const customEvents = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
};
const nativeEvents = new Set([
    'click',
    'dblclick',
    'mouseup',
    'mousedown',
    'contextmenu',
    'mousewheel',
    'DOMMouseScroll',
    'mouseover',
    'mouseout',
    'mousemove',
    'selectstart',
    'selectend',
    'keydown',
    'keypress',
    'keyup',
    'orientationchange',
    'touchstart',
    'touchmove',
    'touchend',
    'touchcancel',
    'pointerdown',
    'pointermove',
    'pointerup',
    'pointerleave',
    'pointercancel',
    'gesturestart',
    'gesturechange',
    'gestureend',
    'focus',
    'blur',
    'change',
    'reset',
    'select',
    'submit',
    'focusin',
    'focusout',
    'load',
    'unload',
    'beforeunload',
    'resize',
    'move',
    'DOMContentLoaded',
    'readystatechange',
    'error',
    'abort',
    'scroll'
]);
/**
 * Private methods
 */ function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
    return function handler(event) {
        hydrateObj(event, {
            delegateTarget: element
        });
        if (handler.oneOff) EventHandler.off(element, event.type, fn);
        return fn.apply(element, [
            event
        ]);
    };
}
function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
        const domElements = element.querySelectorAll(selector);
        for(let { target } = event; target && target !== this; target = target.parentNode)for (const domElement of domElements){
            if (domElement !== target) continue;
            hydrateObj(event, {
                delegateTarget: target
            });
            if (handler.oneOff) EventHandler.off(element, event.type, selector, fn);
            return fn.apply(target, [
                event
            ]);
        }
    };
}
function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === 'string';
    // TODO: tooltip passes `false` instead of selector, so we need to check
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) typeEvent = originalTypeEvent;
    return [
        isDelegated,
        callable,
        typeEvent
    ];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) return;
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    if (originalTypeEvent in customEvents) {
        const wrapFunction = (fn)=>{
            return function(event) {
                if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) return fn.call(this, event);
            };
        };
        callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
        previousFunction.oneOff = previousFunction.oneOff && oneOff;
        return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) return;
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent))if (handlerKey.includes(namespace)) removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
}
function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents[event] || event;
}
const EventHandler = {
    on (element, event, handler, delegationFunction) {
        addHandler(element, event, handler, delegationFunction, false);
    },
    one (element, event, handler, delegationFunction) {
        addHandler(element, event, handler, delegationFunction, true);
    },
    off (element, originalTypeEvent, handler, delegationFunction) {
        if (typeof originalTypeEvent !== 'string' || !element) return;
        const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
        const inNamespace = typeEvent !== originalTypeEvent;
        const events = getElementEvents(element);
        const storeElementEvent = events[typeEvent] || {};
        const isNamespace = originalTypeEvent.startsWith('.');
        if (typeof callable !== 'undefined') {
            // Simplest case: handler is passed, remove that listener ONLY.
            if (!Object.keys(storeElementEvent).length) return;
            removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
            return;
        }
        if (isNamespace) for (const elementEvent of Object.keys(events))removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        for (const [keyHandlers, event] of Object.entries(storeElementEvent)){
            const handlerKey = keyHandlers.replace(stripUidRegex, '');
            if (!inNamespace || originalTypeEvent.includes(handlerKey)) removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
    },
    trigger (element, event, args) {
        if (typeof event !== 'string' || !element) return null;
        const $ = getjQuery();
        const typeEvent = getTypeEvent(event);
        const inNamespace = event !== typeEvent;
        let jQueryEvent = null;
        let bubbles = true;
        let nativeDispatch = true;
        let defaultPrevented = false;
        if (inNamespace && $) {
            jQueryEvent = $.Event(event, args);
            $(element).trigger(jQueryEvent);
            bubbles = !jQueryEvent.isPropagationStopped();
            nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
            defaultPrevented = jQueryEvent.isDefaultPrevented();
        }
        const evt = hydrateObj(new Event(event, {
            bubbles,
            cancelable: true
        }), args);
        if (defaultPrevented) evt.preventDefault();
        if (nativeDispatch) element.dispatchEvent(evt);
        if (evt.defaultPrevented && jQueryEvent) jQueryEvent.preventDefault();
        return evt;
    }
};
function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta))try {
        obj[key] = value;
    } catch (_unused) {
        Object.defineProperty(obj, key, {
            configurable: true,
            get () {
                return value;
            }
        });
    }
    return obj;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ function normalizeData(value) {
    if (value === 'true') return true;
    if (value === 'false') return false;
    if (value === Number(value).toString()) return Number(value);
    if (value === '' || value === 'null') return null;
    if (typeof value !== 'string') return value;
    try {
        return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
        return value;
    }
}
function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);
}
const Manipulator = {
    setDataAttribute (element, key, value) {
        element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute (element, key) {
        element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes (element) {
        if (!element) return {};
        const attributes = {};
        const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith('bs') && !key.startsWith('bsConfig'));
        for (const key of bsKeys){
            let pureKey = key.replace(/^bs/, '');
            pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
            attributes[pureKey] = normalizeData(element.dataset[key]);
        }
        return attributes;
    },
    getDataAttribute (element, key) {
        return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/config.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Class definition
 */ class Config {
    // Getters
    static get Default() {
        return {};
    }
    static get DefaultType() {
        return {};
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
    }
    _configAfterMerge(config) {
        return config;
    }
    _mergeConfigObj(config, element) {
        const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse
        return {
            ...this.constructor.Default,
            ...typeof jsonConfig === 'object' ? jsonConfig : {},
            ...isElement(element) ? Manipulator.getDataAttributes(element) : {},
            ...typeof config === 'object' ? config : {}
        };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
        for (const [property, expectedTypes] of Object.entries(configTypes)){
            const value = config[property];
            const valueType = isElement(value) ? 'element' : toType(value);
            if (!new RegExp(expectedTypes).test(valueType)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const VERSION = '5.3.7';
/**
 * Class definition
 */ class BaseComponent extends Config {
    constructor(element, config){
        super();
        element = getElement(element);
        if (!element) return;
        this._element = element;
        this._config = this._getConfig(config);
        Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
        Data.remove(this._element, this.constructor.DATA_KEY);
        EventHandler.off(this._element, this.constructor.EVENT_KEY);
        for (const propertyName of Object.getOwnPropertyNames(this))this[propertyName] = null;
    }
    // Private
    _queueCallback(callback, element, isAnimated = true) {
        executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
        config = this._mergeConfigObj(config, this._element);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
    }
    // Static
    static getInstance(element) {
        return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
        return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
    }
    static get VERSION() {
        return VERSION;
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
        return `${name}${this.EVENT_KEY}`;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const getSelector = (element)=>{
    let selector = element.getAttribute('data-bs-target');
    if (!selector || selector === '#') {
        let hrefAttribute = element.getAttribute('href');
        // The only valid content that could double as a selector are IDs or classes,
        // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
        // `document.querySelector` will rightfully complain it is invalid.
        // See https://github.com/twbs/bootstrap/issues/32273
        if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) return null;
        // Just in case some CMS puts out a full URL with the anchor appended
        if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
        selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
    }
    return selector ? selector.split(',').map((sel)=>parseSelector(sel)).join(',') : null;
};
const SelectorEngine = {
    find (selector, element = document.documentElement) {
        return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne (selector, element = document.documentElement) {
        return Element.prototype.querySelector.call(element, selector);
    },
    children (element, selector) {
        return [].concat(...element.children).filter((child)=>child.matches(selector));
    },
    parents (element, selector) {
        const parents = [];
        let ancestor = element.parentNode.closest(selector);
        while(ancestor){
            parents.push(ancestor);
            ancestor = ancestor.parentNode.closest(selector);
        }
        return parents;
    },
    prev (element, selector) {
        let previous = element.previousElementSibling;
        while(previous){
            if (previous.matches(selector)) return [
                previous
            ];
            previous = previous.previousElementSibling;
        }
        return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next (element, selector) {
        let next = element.nextElementSibling;
        while(next){
            if (next.matches(selector)) return [
                next
            ];
            next = next.nextElementSibling;
        }
        return [];
    },
    focusableChildren (element) {
        const focusables = [
            'a',
            'button',
            'input',
            'textarea',
            'select',
            'details',
            '[tabindex]',
            '[contenteditable="true"]'
        ].map((selector)=>`${selector}:not([tabindex^="-"])`).join(',');
        return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement (element) {
        const selector = getSelector(element);
        if (selector) return SelectorEngine.findOne(selector) ? selector : null;
        return null;
    },
    getElementFromSelector (element) {
        const selector = getSelector(element);
        return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector (element) {
        const selector = getSelector(element);
        return selector ? SelectorEngine.find(selector) : [];
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const enableDismissTrigger = (component, method = 'hide')=>{
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
        if ([
            'A',
            'AREA'
        ].includes(this.tagName)) event.preventDefault();
        if (isDisabled(this)) return;
        const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
        const instance = component.getOrCreateInstance(target);
        // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
        instance[method]();
    });
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$f = 'alert';
const DATA_KEY$a = 'bs.alert';
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = 'fade';
const CLASS_NAME_SHOW$8 = 'show';
/**
 * Class definition
 */ class Alert extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$f;
    }
    // Public
    close() {
        const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
        if (closeEvent.defaultPrevented) return;
        this._element.classList.remove(CLASS_NAME_SHOW$8);
        const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
        this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);
    }
    // Private
    _destroyElement() {
        this._element.remove();
        EventHandler.trigger(this._element, EVENT_CLOSED);
        this.dispose();
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Alert.getOrCreateInstance(this);
            if (typeof config !== 'string') return;
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
            data[config](this);
        });
    }
}
/**
 * Data API implementation
 */ enableDismissTrigger(Alert, 'close');
/**
 * jQuery
 */ defineJQueryPlugin(Alert);
/**
 * --------------------------------------------------------------------------
 * Bootstrap button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$e = 'button';
const DATA_KEY$9 = 'bs.button';
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = '.data-api';
const CLASS_NAME_ACTIVE$3 = 'active';
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
/**
 * Class definition
 */ class Button extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$e;
    }
    // Public
    toggle() {
        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Button.getOrCreateInstance(this);
            if (config === 'toggle') data[config]();
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
});
/**
 * jQuery
 */ defineJQueryPlugin(Button);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/swipe.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$d = 'swipe';
const EVENT_KEY$9 = '.bs.swipe';
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = 'touch';
const POINTER_TYPE_PEN = 'pen';
const CLASS_NAME_POINTER_EVENT = 'pointer-event';
const SWIPE_THRESHOLD = 40;
const Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
};
const DefaultType$c = {
    endCallback: '(function|null)',
    leftCallback: '(function|null)',
    rightCallback: '(function|null)'
};
/**
 * Class definition
 */ class Swipe extends Config {
    constructor(element, config){
        super();
        this._element = element;
        if (!element || !Swipe.isSupported()) return;
        this._config = this._getConfig(config);
        this._deltaX = 0;
        this._supportPointerEvents = Boolean(window.PointerEvent);
        this._initEvents();
    }
    // Getters
    static get Default() {
        return Default$c;
    }
    static get DefaultType() {
        return DefaultType$c;
    }
    static get NAME() {
        return NAME$d;
    }
    // Public
    dispose() {
        EventHandler.off(this._element, EVENT_KEY$9);
    }
    // Private
    _start(event) {
        if (!this._supportPointerEvents) {
            this._deltaX = event.touches[0].clientX;
            return;
        }
        if (this._eventIsPointerPenTouch(event)) this._deltaX = event.clientX;
    }
    _end(event) {
        if (this._eventIsPointerPenTouch(event)) this._deltaX = event.clientX - this._deltaX;
        this._handleSwipe();
        execute(this._config.endCallback);
    }
    _move(event) {
        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
        const absDeltaX = Math.abs(this._deltaX);
        if (absDeltaX <= SWIPE_THRESHOLD) return;
        const direction = absDeltaX / this._deltaX;
        this._deltaX = 0;
        if (!direction) return;
        execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
        if (this._supportPointerEvents) {
            EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));
            EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));
            this._element.classList.add(CLASS_NAME_POINTER_EVENT);
        } else {
            EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));
            EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));
            EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));
        }
    }
    _eventIsPointerPenTouch(event) {
        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }
    // Static
    static isSupported() {
        return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$c = 'carousel';
const DATA_KEY$8 = 'bs.carousel';
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = '.data-api';
const ARROW_LEFT_KEY$1 = 'ArrowLeft';
const ARROW_RIGHT_KEY$1 = 'ArrowRight';
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
const ORDER_NEXT = 'next';
const ORDER_PREV = 'prev';
const DIRECTION_LEFT = 'left';
const DIRECTION_RIGHT = 'right';
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = 'carousel';
const CLASS_NAME_ACTIVE$2 = 'active';
const CLASS_NAME_SLIDE = 'slide';
const CLASS_NAME_END = 'carousel-item-end';
const CLASS_NAME_START = 'carousel-item-start';
const CLASS_NAME_NEXT = 'carousel-item-next';
const CLASS_NAME_PREV = 'carousel-item-prev';
const SELECTOR_ACTIVE = '.active';
const SELECTOR_ITEM = '.carousel-item';
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = '.carousel-item img';
const SELECTOR_INDICATORS = '.carousel-indicators';
const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
    interval: 5000,
    keyboard: true,
    pause: 'hover',
    ride: false,
    touch: true,
    wrap: true
};
const DefaultType$b = {
    interval: '(number|boolean)',
    // TODO:v6 remove boolean support
    keyboard: 'boolean',
    pause: '(string|boolean)',
    ride: '(boolean|string)',
    touch: 'boolean',
    wrap: 'boolean'
};
/**
 * Class definition
 */ class Carousel extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._interval = null;
        this._activeElement = null;
        this._isSliding = false;
        this.touchTimeout = null;
        this._swipeHelper = null;
        this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
        this._addEventListeners();
        if (this._config.ride === CLASS_NAME_CAROUSEL) this.cycle();
    }
    // Getters
    static get Default() {
        return Default$b;
    }
    static get DefaultType() {
        return DefaultType$b;
    }
    static get NAME() {
        return NAME$c;
    }
    // Public
    next() {
        this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
        // FIXME TODO use `document.visibilityState`
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && isVisible(this._element)) this.next();
    }
    prev() {
        this._slide(ORDER_PREV);
    }
    pause() {
        if (this._isSliding) triggerTransitionEnd(this._element);
        this._clearInterval();
    }
    cycle() {
        this._clearInterval();
        this._updateInterval();
        this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
        if (!this._config.ride) return;
        if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());
            return;
        }
        this.cycle();
    }
    to(index) {
        const items = this._getItems();
        if (index > items.length - 1 || index < 0) return;
        if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));
            return;
        }
        const activeIndex = this._getItemIndex(this._getActive());
        if (activeIndex === index) return;
        const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
        this._slide(order, items[index]);
    }
    dispose() {
        if (this._swipeHelper) this._swipeHelper.dispose();
        super.dispose();
    }
    // Private
    _configAfterMerge(config) {
        config.defaultInterval = config.interval;
        return config;
    }
    _addEventListeners() {
        if (this._config.keyboard) EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));
        if (this._config.pause === 'hover') {
            EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());
            EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());
        }
        if (this._config.touch && Swipe.isSupported()) this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
        for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element))EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());
        const endCallBack = ()=>{
            if (this._config.pause !== 'hover') return;
            // If it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            this.pause();
            if (this.touchTimeout) clearTimeout(this.touchTimeout);
            this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
        };
        const swipeConfig = {
            leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),
            rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),
            endCallback: endCallBack
        };
        this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) return;
        const direction = KEY_TO_DIRECTION[event.key];
        if (direction) {
            event.preventDefault();
            this._slide(this._directionToOrder(direction));
        }
    }
    _getItemIndex(element) {
        return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
        if (!this._indicatorsElement) return;
        const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
        activeIndicator.removeAttribute('aria-current');
        const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
        if (newActiveIndicator) {
            newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
            newActiveIndicator.setAttribute('aria-current', 'true');
        }
    }
    _updateInterval() {
        const element = this._activeElement || this._getActive();
        if (!element) return;
        const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
        this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order, element = null) {
        if (this._isSliding) return;
        const activeElement = this._getActive();
        const isNext = order === ORDER_NEXT;
        const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
        if (nextElement === activeElement) return;
        const nextElementIndex = this._getItemIndex(nextElement);
        const triggerEvent = (eventName)=>{
            return EventHandler.trigger(this._element, eventName, {
                relatedTarget: nextElement,
                direction: this._orderToDirection(order),
                from: this._getItemIndex(activeElement),
                to: nextElementIndex
            });
        };
        const slideEvent = triggerEvent(EVENT_SLIDE);
        if (slideEvent.defaultPrevented) return;
        if (!activeElement || !nextElement) // Some weirdness is happening, so we bail
        // TODO: change tests that use empty divs to avoid this check
        return;
        const isCycling = Boolean(this._interval);
        this.pause();
        this._isSliding = true;
        this._setActiveIndicatorElement(nextElementIndex);
        this._activeElement = nextElement;
        const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
        const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
        nextElement.classList.add(orderClassName);
        reflow(nextElement);
        activeElement.classList.add(directionalClassName);
        nextElement.classList.add(directionalClassName);
        const completeCallBack = ()=>{
            nextElement.classList.remove(directionalClassName, orderClassName);
            nextElement.classList.add(CLASS_NAME_ACTIVE$2);
            activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
            this._isSliding = false;
            triggerEvent(EVENT_SLID);
        };
        this._queueCallback(completeCallBack, activeElement, this._isAnimated());
        if (isCycling) this.cycle();
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
        return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
        if (this._interval) {
            clearInterval(this._interval);
            this._interval = null;
        }
    }
    _directionToOrder(direction) {
        if (isRTL()) return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order) {
        if (isRTL()) return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Carousel.getOrCreateInstance(this, config);
            if (typeof config === 'number') {
                data.to(config);
                return;
            }
            if (typeof config === 'string') {
                if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) return;
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute('data-bs-slide-to');
    if (slideIndex) {
        carousel.to(slideIndex);
        carousel._maybeEnableCycle();
        return;
    }
    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
        carousel.next();
        carousel._maybeEnableCycle();
        return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels)Carousel.getOrCreateInstance(carousel);
});
/**
 * jQuery
 */ defineJQueryPlugin(Carousel);
/**
 * --------------------------------------------------------------------------
 * Bootstrap collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$b = 'collapse';
const DATA_KEY$7 = 'bs.collapse';
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = '.data-api';
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = 'show';
const CLASS_NAME_COLLAPSE = 'collapse';
const CLASS_NAME_COLLAPSING = 'collapsing';
const CLASS_NAME_COLLAPSED = 'collapsed';
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
const WIDTH = 'width';
const HEIGHT = 'height';
const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
    parent: null,
    toggle: true
};
const DefaultType$a = {
    parent: '(null|element)',
    toggle: 'boolean'
};
/**
 * Class definition
 */ class Collapse extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._isTransitioning = false;
        this._triggerArray = [];
        const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
        for (const elem of toggleList){
            const selector = SelectorEngine.getSelectorFromElement(elem);
            const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);
            if (selector !== null && filterElement.length) this._triggerArray.push(elem);
        }
        this._initializeChildren();
        if (!this._config.parent) this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
        if (this._config.toggle) this.toggle();
    }
    // Getters
    static get Default() {
        return Default$a;
    }
    static get DefaultType() {
        return DefaultType$a;
    }
    static get NAME() {
        return NAME$b;
    }
    // Public
    toggle() {
        if (this._isShown()) this.hide();
        else this.show();
    }
    show() {
        if (this._isTransitioning || this._isShown()) return;
        let activeChildren = [];
        // find active children
        if (this._config.parent) activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {
                toggle: false
            }));
        if (activeChildren.length && activeChildren[0]._isTransitioning) return;
        const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
        if (startEvent.defaultPrevented) return;
        for (const activeInstance of activeChildren)activeInstance.hide();
        const dimension = this._getDimension();
        this._element.classList.remove(CLASS_NAME_COLLAPSE);
        this._element.classList.add(CLASS_NAME_COLLAPSING);
        this._element.style[dimension] = 0;
        this._addAriaAndCollapsedClass(this._triggerArray, true);
        this._isTransitioning = true;
        const complete = ()=>{
            this._isTransitioning = false;
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
            this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
            this._element.style[dimension] = '';
            EventHandler.trigger(this._element, EVENT_SHOWN$6);
        };
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        this._queueCallback(complete, this._element, true);
        this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
        if (this._isTransitioning || !this._isShown()) return;
        const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
        if (startEvent.defaultPrevented) return;
        const dimension = this._getDimension();
        this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_COLLAPSING);
        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        for (const trigger of this._triggerArray){
            const element = SelectorEngine.getElementFromSelector(trigger);
            if (element && !this._isShown(element)) this._addAriaAndCollapsedClass([
                trigger
            ], false);
        }
        this._isTransitioning = true;
        const complete = ()=>{
            this._isTransitioning = false;
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
            this._element.classList.add(CLASS_NAME_COLLAPSE);
            EventHandler.trigger(this._element, EVENT_HIDDEN$6);
        };
        this._element.style[dimension] = '';
        this._queueCallback(complete, this._element, true);
    }
    // Private
    _isShown(element = this._element) {
        return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    _configAfterMerge(config) {
        config.toggle = Boolean(config.toggle); // Coerce string values
        config.parent = getElement(config.parent);
        return config;
    }
    _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
        if (!this._config.parent) return;
        const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
        for (const element of children){
            const selected = SelectorEngine.getElementFromSelector(element);
            if (selected) this._addAriaAndCollapsedClass([
                element
            ], this._isShown(selected));
        }
    }
    _getFirstLevelChildren(selector) {
        const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
        // remove children if greater depth
        return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
        if (!triggerArray.length) return;
        for (const element of triggerArray){
            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
            element.setAttribute('aria-expanded', isOpen);
        }
    }
    // Static
    static jQueryInterface(config) {
        const _config = {};
        if (typeof config === 'string' && /show|hide/.test(config)) _config.toggle = false;
        return this.each(function() {
            const data = Collapse.getOrCreateInstance(this, _config);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') event.preventDefault();
    for (const element of SelectorEngine.getMultipleElementsFromSelector(this))Collapse.getOrCreateInstance(element, {
        toggle: false
    }).toggle();
});
/**
 * jQuery
 */ defineJQueryPlugin(Collapse);
/**
 * --------------------------------------------------------------------------
 * Bootstrap dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$a = 'dropdown';
const DATA_KEY$6 = 'bs.dropdown';
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = '.data-api';
const ESCAPE_KEY$2 = 'Escape';
const TAB_KEY$1 = 'Tab';
const ARROW_UP_KEY$1 = 'ArrowUp';
const ARROW_DOWN_KEY$1 = 'ArrowDown';
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button
const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = 'show';
const CLASS_NAME_DROPUP = 'dropup';
const CLASS_NAME_DROPEND = 'dropend';
const CLASS_NAME_DROPSTART = 'dropstart';
const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = '.dropdown-menu';
const SELECTOR_NAVBAR = '.navbar';
const SELECTOR_NAVBAR_NAV = '.navbar-nav';
const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
const PLACEMENT_TOPCENTER = 'top';
const PLACEMENT_BOTTOMCENTER = 'bottom';
const Default$9 = {
    autoClose: true,
    boundary: 'clippingParents',
    display: 'dynamic',
    offset: [
        0,
        2
    ],
    popperConfig: null,
    reference: 'toggle'
};
const DefaultType$9 = {
    autoClose: '(boolean|string)',
    boundary: '(string|element)',
    display: 'string',
    offset: '(array|string|function)',
    popperConfig: '(null|object|function)',
    reference: '(string|element|object)'
};
/**
 * Class definition
 */ class Dropdown extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._popper = null;
        this._parent = this._element.parentNode; // dropdown wrapper
        // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
        this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
        this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
        return Default$9;
    }
    static get DefaultType() {
        return DefaultType$9;
    }
    static get NAME() {
        return NAME$a;
    }
    // Public
    toggle() {
        return this._isShown() ? this.hide() : this.show();
    }
    show() {
        if (isDisabled(this._element) || this._isShown()) return;
        const relatedTarget = {
            relatedTarget: this._element
        };
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
        if (showEvent.defaultPrevented) return;
        this._createPopper();
        // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) for (const element of [].concat(...document.body.children))EventHandler.on(element, 'mouseover', noop);
        this._element.focus();
        this._element.setAttribute('aria-expanded', true);
        this._menu.classList.add(CLASS_NAME_SHOW$6);
        this._element.classList.add(CLASS_NAME_SHOW$6);
        EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
        if (isDisabled(this._element) || !this._isShown()) return;
        const relatedTarget = {
            relatedTarget: this._element
        };
        this._completeHide(relatedTarget);
    }
    dispose() {
        if (this._popper) this._popper.destroy();
        super.dispose();
    }
    update() {
        this._inNavbar = this._detectNavbar();
        if (this._popper) this._popper.update();
    }
    // Private
    _completeHide(relatedTarget) {
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
        if (hideEvent.defaultPrevented) return;
        // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) for (const element of [].concat(...document.body.children))EventHandler.off(element, 'mouseover', noop);
        if (this._popper) this._popper.destroy();
        this._menu.classList.remove(CLASS_NAME_SHOW$6);
        this._element.classList.remove(CLASS_NAME_SHOW$6);
        this._element.setAttribute('aria-expanded', 'false');
        Manipulator.removeDataAttribute(this._menu, 'popper');
        EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
        // Explicitly return focus to the trigger element
        this._element.focus();
    }
    _getConfig(config) {
        config = super._getConfig(config);
        if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return config;
    }
    _createPopper() {
        if (typeof _core === 'undefined') throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org/docs/v2/)');
        let referenceElement = this._element;
        if (this._config.reference === 'parent') referenceElement = this._parent;
        else if (isElement(this._config.reference)) referenceElement = getElement(this._config.reference);
        else if (typeof this._config.reference === 'object') referenceElement = this._config.reference;
        const popperConfig = this._getPopperConfig();
        this._popper = _core.createPopper(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
        return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
        const parentDropdown = this._parent;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) return PLACEMENT_TOPCENTER;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) return PLACEMENT_BOTTOMCENTER;
        // We need to trim the value because custom properties can also include spaces
        const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
        return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
        const { offset } = this._config;
        if (typeof offset === 'string') return offset.split(',').map((value)=>Number.parseInt(value, 10));
        if (typeof offset === 'function') return (popperData)=>offset(popperData, this._element);
        return offset;
    }
    _getPopperConfig() {
        const defaultBsPopperConfig = {
            placement: this._getPlacement(),
            modifiers: [
                {
                    name: 'preventOverflow',
                    options: {
                        boundary: this._config.boundary
                    }
                },
                {
                    name: 'offset',
                    options: {
                        offset: this._getOffset()
                    }
                }
            ]
        };
        // Disable Popper if we have a static display or Dropdown is in Navbar
        if (this._inNavbar || this._config.display === 'static') {
            Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove
            defaultBsPopperConfig.modifiers = [
                {
                    name: 'applyStyles',
                    enabled: false
                }
            ];
        }
        return {
            ...defaultBsPopperConfig,
            ...execute(this._config.popperConfig, [
                undefined,
                defaultBsPopperConfig
            ])
        };
    }
    _selectMenuItem({ key, target }) {
        const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));
        if (!items.length) return;
        // if target isn't included in items (e.g. when expanding the dropdown)
        // allow cycling to get the last item in case key equals ARROW_UP_KEY
        getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Dropdown.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
    static clearMenus(event) {
        if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) return;
        const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
        for (const toggle of openToggles){
            const context = Dropdown.getInstance(toggle);
            if (!context || context._config.autoClose === false) continue;
            const composedPath = event.composedPath();
            const isMenuTarget = composedPath.includes(context._menu);
            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) continue;
            // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) continue;
            const relatedTarget = {
                relatedTarget: context._element
            };
            if (event.type === 'click') relatedTarget.clickEvent = event;
            context._completeHide(relatedTarget);
        }
    }
    static dataApiKeydownHandler(event) {
        // If not an UP | DOWN | ESCAPE key => not a dropdown command
        // If input/textarea && if key is other than ESCAPE => not a dropdown command
        const isInput = /input|textarea/i.test(event.target.tagName);
        const isEscapeEvent = event.key === ESCAPE_KEY$2;
        const isUpOrDownEvent = [
            ARROW_UP_KEY$1,
            ARROW_DOWN_KEY$1
        ].includes(event.key);
        if (!isUpOrDownEvent && !isEscapeEvent) return;
        if (isInput && !isEscapeEvent) return;
        event.preventDefault();
        // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
        const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
        const instance = Dropdown.getOrCreateInstance(getToggleButton);
        if (isUpOrDownEvent) {
            event.stopPropagation();
            instance.show();
            instance._selectMenuItem(event);
            return;
        }
        if (instance._isShown()) {
            // else is escape and we check if it is shown
            event.stopPropagation();
            instance.hide();
            getToggleButton.focus();
        }
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
});
/**
 * jQuery
 */ defineJQueryPlugin(Dropdown);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$9 = 'backdrop';
const CLASS_NAME_FADE$4 = 'fade';
const CLASS_NAME_SHOW$5 = 'show';
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
    className: 'modal-backdrop',
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: 'body' // give the choice to place backdrop under different elements
};
const DefaultType$8 = {
    className: 'string',
    clickCallback: '(function|null)',
    isAnimated: 'boolean',
    isVisible: 'boolean',
    rootElement: '(element|string)'
};
/**
 * Class definition
 */ class Backdrop extends Config {
    constructor(config){
        super();
        this._config = this._getConfig(config);
        this._isAppended = false;
        this._element = null;
    }
    // Getters
    static get Default() {
        return Default$8;
    }
    static get DefaultType() {
        return DefaultType$8;
    }
    static get NAME() {
        return NAME$9;
    }
    // Public
    show(callback) {
        if (!this._config.isVisible) {
            execute(callback);
            return;
        }
        this._append();
        const element = this._getElement();
        if (this._config.isAnimated) reflow(element);
        element.classList.add(CLASS_NAME_SHOW$5);
        this._emulateAnimation(()=>{
            execute(callback);
        });
    }
    hide(callback) {
        if (!this._config.isVisible) {
            execute(callback);
            return;
        }
        this._getElement().classList.remove(CLASS_NAME_SHOW$5);
        this._emulateAnimation(()=>{
            this.dispose();
            execute(callback);
        });
    }
    dispose() {
        if (!this._isAppended) return;
        EventHandler.off(this._element, EVENT_MOUSEDOWN);
        this._element.remove();
        this._isAppended = false;
    }
    // Private
    _getElement() {
        if (!this._element) {
            const backdrop = document.createElement('div');
            backdrop.className = this._config.className;
            if (this._config.isAnimated) backdrop.classList.add(CLASS_NAME_FADE$4);
            this._element = backdrop;
        }
        return this._element;
    }
    _configAfterMerge(config) {
        // use getElement() with the default "body" to get a fresh Element on each instantiation
        config.rootElement = getElement(config.rootElement);
        return config;
    }
    _append() {
        if (this._isAppended) return;
        const element = this._getElement();
        this._config.rootElement.append(element);
        EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{
            execute(this._config.clickCallback);
        });
        this._isAppended = true;
    }
    _emulateAnimation(callback) {
        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$8 = 'focustrap';
const DATA_KEY$5 = 'bs.focustrap';
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = 'Tab';
const TAB_NAV_FORWARD = 'forward';
const TAB_NAV_BACKWARD = 'backward';
const Default$7 = {
    autofocus: true,
    trapElement: null // The element to trap focus inside of
};
const DefaultType$7 = {
    autofocus: 'boolean',
    trapElement: 'element'
};
/**
 * Class definition
 */ class FocusTrap extends Config {
    constructor(config){
        super();
        this._config = this._getConfig(config);
        this._isActive = false;
        this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
        return Default$7;
    }
    static get DefaultType() {
        return DefaultType$7;
    }
    static get NAME() {
        return NAME$8;
    }
    // Public
    activate() {
        if (this._isActive) return;
        if (this._config.autofocus) this._config.trapElement.focus();
        EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
        EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));
        EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));
        this._isActive = true;
    }
    deactivate() {
        if (!this._isActive) return;
        this._isActive = false;
        EventHandler.off(document, EVENT_KEY$5);
    }
    // Private
    _handleFocusin(event) {
        const { trapElement } = this._config;
        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) return;
        const elements = SelectorEngine.focusableChildren(trapElement);
        if (elements.length === 0) trapElement.focus();
        else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) elements[elements.length - 1].focus();
        else elements[0].focus();
    }
    _handleKeydown(event) {
        if (event.key !== TAB_KEY) return;
        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
const SELECTOR_STICKY_CONTENT = '.sticky-top';
const PROPERTY_PADDING = 'padding-right';
const PROPERTY_MARGIN = 'margin-right';
/**
 * Class definition
 */ class ScrollBarHelper {
    constructor(){
        this._element = document.body;
    }
    // Public
    getWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        const documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
        const width = this.getWidth();
        this._disableOverFlow();
        // give padding to element to balance the hidden scrollbar width
        this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);
        // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
        this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);
        this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);
    }
    reset() {
        this._resetElementAttributes(this._element, 'overflow');
        this._resetElementAttributes(this._element, PROPERTY_PADDING);
        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
        return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, 'overflow');
        this._element.style.overflow = 'hidden';
    }
    _setElementAttributes(selector, styleProperty, callback) {
        const scrollbarWidth = this.getWidth();
        const manipulationCallBack = (element)=>{
            if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) return;
            this._saveInitialAttribute(element, styleProperty);
            const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
            element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
        const actualValue = element.style.getPropertyValue(styleProperty);
        if (actualValue) Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
    _resetElementAttributes(selector, styleProperty) {
        const manipulationCallBack = (element)=>{
            const value = Manipulator.getDataAttribute(element, styleProperty);
            // We only want to remove the property if the value is `null`; the value can also be zero
            if (value === null) {
                element.style.removeProperty(styleProperty);
                return;
            }
            Manipulator.removeDataAttribute(element, styleProperty);
            element.style.setProperty(styleProperty, value);
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
        if (isElement(selector)) {
            callBack(selector);
            return;
        }
        for (const sel of SelectorEngine.find(selector, this._element))callBack(sel);
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$7 = 'modal';
const DATA_KEY$4 = 'bs.modal';
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = '.data-api';
const ESCAPE_KEY$1 = 'Escape';
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = 'modal-open';
const CLASS_NAME_FADE$3 = 'fade';
const CLASS_NAME_SHOW$4 = 'show';
const CLASS_NAME_STATIC = 'modal-static';
const OPEN_SELECTOR$1 = '.modal.show';
const SELECTOR_DIALOG = '.modal-dialog';
const SELECTOR_MODAL_BODY = '.modal-body';
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
};
const DefaultType$6 = {
    backdrop: '(boolean|string)',
    focus: 'boolean',
    keyboard: 'boolean'
};
/**
 * Class definition
 */ class Modal extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._isShown = false;
        this._isTransitioning = false;
        this._scrollBar = new ScrollBarHelper();
        this._addEventListeners();
    }
    // Getters
    static get Default() {
        return Default$6;
    }
    static get DefaultType() {
        return DefaultType$6;
    }
    static get NAME() {
        return NAME$7;
    }
    // Public
    toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
        if (this._isShown || this._isTransitioning) return;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
            relatedTarget
        });
        if (showEvent.defaultPrevented) return;
        this._isShown = true;
        this._isTransitioning = true;
        this._scrollBar.hide();
        document.body.classList.add(CLASS_NAME_OPEN);
        this._adjustDialog();
        this._backdrop.show(()=>this._showElement(relatedTarget));
    }
    hide() {
        if (!this._isShown || this._isTransitioning) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
        if (hideEvent.defaultPrevented) return;
        this._isShown = false;
        this._isTransitioning = true;
        this._focustrap.deactivate();
        this._element.classList.remove(CLASS_NAME_SHOW$4);
        this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
        EventHandler.off(window, EVENT_KEY$4);
        EventHandler.off(this._dialog, EVENT_KEY$4);
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
    }
    handleUpdate() {
        this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
        return new Backdrop({
            isVisible: Boolean(this._config.backdrop),
            // 'static' option will be translated to true, and booleans will keep their value,
            isAnimated: this._isAnimated()
        });
    }
    _initializeFocusTrap() {
        return new FocusTrap({
            trapElement: this._element
        });
    }
    _showElement(relatedTarget) {
        // try to append dynamic modal
        if (!document.body.contains(this._element)) document.body.append(this._element);
        this._element.style.display = 'block';
        this._element.removeAttribute('aria-hidden');
        this._element.setAttribute('aria-modal', true);
        this._element.setAttribute('role', 'dialog');
        this._element.scrollTop = 0;
        const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
        if (modalBody) modalBody.scrollTop = 0;
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOW$4);
        const transitionComplete = ()=>{
            if (this._config.focus) this._focustrap.activate();
            this._isTransitioning = false;
            EventHandler.trigger(this._element, EVENT_SHOWN$4, {
                relatedTarget
            });
        };
        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{
            if (event.key !== ESCAPE_KEY$1) return;
            if (this._config.keyboard) {
                this.hide();
                return;
            }
            this._triggerBackdropTransition();
        });
        EventHandler.on(window, EVENT_RESIZE$1, ()=>{
            if (this._isShown && !this._isTransitioning) this._adjustDialog();
        });
        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{
            // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
            EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{
                if (this._element !== event.target || this._element !== event2.target) return;
                if (this._config.backdrop === 'static') {
                    this._triggerBackdropTransition();
                    return;
                }
                if (this._config.backdrop) this.hide();
            });
        });
    }
    _hideModal() {
        this._element.style.display = 'none';
        this._element.setAttribute('aria-hidden', true);
        this._element.removeAttribute('aria-modal');
        this._element.removeAttribute('role');
        this._isTransitioning = false;
        this._backdrop.hide(()=>{
            document.body.classList.remove(CLASS_NAME_OPEN);
            this._resetAdjustments();
            this._scrollBar.reset();
            EventHandler.trigger(this._element, EVENT_HIDDEN$4);
        });
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
        if (hideEvent.defaultPrevented) return;
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const initialOverflowY = this._element.style.overflowY;
        // return if the following background transition hasn't yet completed
        if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) return;
        if (!isModalOverflowing) this._element.style.overflowY = 'hidden';
        this._element.classList.add(CLASS_NAME_STATIC);
        this._queueCallback(()=>{
            this._element.classList.remove(CLASS_NAME_STATIC);
            this._queueCallback(()=>{
                this._element.style.overflowY = initialOverflowY;
            }, this._dialog);
        }, this._dialog);
        this._element.focus();
    }
    /**
   * The following methods are used to handle overflowing modals
   */ _adjustDialog() {
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const scrollbarWidth = this._scrollBar.getWidth();
        const isBodyOverflowing = scrollbarWidth > 0;
        if (isBodyOverflowing && !isModalOverflowing) {
            const property = isRTL() ? 'paddingLeft' : 'paddingRight';
            this._element.style[property] = `${scrollbarWidth}px`;
        }
        if (!isBodyOverflowing && isModalOverflowing) {
            const property = isRTL() ? 'paddingRight' : 'paddingLeft';
            this._element.style[property] = `${scrollbarWidth}px`;
        }
    }
    _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
    }
    // Static
    static jQueryInterface(config, relatedTarget) {
        return this.each(function() {
            const data = Modal.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config](relatedTarget);
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if ([
        'A',
        'AREA'
    ].includes(this.tagName)) event.preventDefault();
    EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{
        if (showEvent.defaultPrevented) // only register focus restorer if modal will actually get shown
        return;
        EventHandler.one(target, EVENT_HIDDEN$4, ()=>{
            if (isVisible(this)) this.focus();
        });
    });
    // avoid conflict when clicking modal toggler while another one is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) Modal.getInstance(alreadyOpen).hide();
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
});
enableDismissTrigger(Modal);
/**
 * jQuery
 */ defineJQueryPlugin(Modal);
/**
 * --------------------------------------------------------------------------
 * Bootstrap offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$6 = 'offcanvas';
const DATA_KEY$3 = 'bs.offcanvas';
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = '.data-api';
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = 'Escape';
const CLASS_NAME_SHOW$3 = 'show';
const CLASS_NAME_SHOWING$1 = 'showing';
const CLASS_NAME_HIDING = 'hiding';
const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
const OPEN_SELECTOR = '.offcanvas.show';
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
};
const DefaultType$5 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    scroll: 'boolean'
};
/**
 * Class definition
 */ class Offcanvas extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._isShown = false;
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._addEventListeners();
    }
    // Getters
    static get Default() {
        return Default$5;
    }
    static get DefaultType() {
        return DefaultType$5;
    }
    static get NAME() {
        return NAME$6;
    }
    // Public
    toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
        if (this._isShown) return;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
            relatedTarget
        });
        if (showEvent.defaultPrevented) return;
        this._isShown = true;
        this._backdrop.show();
        if (!this._config.scroll) new ScrollBarHelper().hide();
        this._element.setAttribute('aria-modal', true);
        this._element.setAttribute('role', 'dialog');
        this._element.classList.add(CLASS_NAME_SHOWING$1);
        const completeCallBack = ()=>{
            if (!this._config.scroll || this._config.backdrop) this._focustrap.activate();
            this._element.classList.add(CLASS_NAME_SHOW$3);
            this._element.classList.remove(CLASS_NAME_SHOWING$1);
            EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                relatedTarget
            });
        };
        this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
        if (!this._isShown) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
        if (hideEvent.defaultPrevented) return;
        this._focustrap.deactivate();
        this._element.blur();
        this._isShown = false;
        this._element.classList.add(CLASS_NAME_HIDING);
        this._backdrop.hide();
        const completeCallback = ()=>{
            this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
            this._element.removeAttribute('aria-modal');
            this._element.removeAttribute('role');
            if (!this._config.scroll) new ScrollBarHelper().reset();
            EventHandler.trigger(this._element, EVENT_HIDDEN$3);
        };
        this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
    }
    // Private
    _initializeBackDrop() {
        const clickCallback = ()=>{
            if (this._config.backdrop === 'static') {
                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                return;
            }
            this.hide();
        };
        // 'static' option will be translated to true, and booleans will keep their value
        const isVisible = Boolean(this._config.backdrop);
        return new Backdrop({
            className: CLASS_NAME_BACKDROP,
            isVisible,
            isAnimated: true,
            rootElement: this._element.parentNode,
            clickCallback: isVisible ? clickCallback : null
        });
    }
    _initializeFocusTrap() {
        return new FocusTrap({
            trapElement: this._element
        });
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{
            if (event.key !== ESCAPE_KEY) return;
            if (this._config.keyboard) {
                this.hide();
                return;
            }
            EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        });
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Offcanvas.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
            data[config](this);
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if ([
        'A',
        'AREA'
    ].includes(this.tagName)) event.preventDefault();
    if (isDisabled(this)) return;
    EventHandler.one(target, EVENT_HIDDEN$3, ()=>{
        // focus on trigger when it is closed
        if (isVisible(this)) this.focus();
    });
    // avoid conflict when clicking a toggler of an offcanvas, while another is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) Offcanvas.getInstance(alreadyOpen).hide();
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{
    for (const selector of SelectorEngine.find(OPEN_SELECTOR))Offcanvas.getOrCreateInstance(selector).show();
});
EventHandler.on(window, EVENT_RESIZE, ()=>{
    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]'))if (getComputedStyle(element).position !== 'fixed') Offcanvas.getOrCreateInstance(element).hide();
});
enableDismissTrigger(Offcanvas);
/**
 * jQuery
 */ defineJQueryPlugin(Offcanvas);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ // js-docs-start allow-list
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    '*': [
        'class',
        'dir',
        'id',
        'lang',
        'role',
        ARIA_ATTRIBUTE_PATTERN
    ],
    a: [
        'target',
        'href',
        'title',
        'rel'
    ],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: [
        'src',
        'srcset',
        'alt',
        'title',
        'width',
        'height'
    ],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
};
// js-docs-end allow-list
const uriAttributes = new Set([
    'background',
    'cite',
    'href',
    'itemtype',
    'longdesc',
    'poster',
    'src',
    'xlink:href'
]);
/**
 * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
 * contexts.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
 */ const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
const allowedAttribute = (attribute, allowedAttributeList)=>{
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
        if (uriAttributes.has(attributeName)) return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
        return true;
    }
    // Check if a regular expression validates the attribute.
    return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) return unsafeHtml;
    if (sanitizeFunction && typeof sanitizeFunction === 'function') return sanitizeFunction(unsafeHtml);
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
    for (const element of elements){
        const elementName = element.nodeName.toLowerCase();
        if (!Object.keys(allowList).includes(elementName)) {
            element.remove();
            continue;
        }
        const attributeList = [].concat(...element.attributes);
        const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
        for (const attribute of attributeList)if (!allowedAttribute(attribute, allowedAttributes)) element.removeAttribute(attribute.nodeName);
    }
    return createdDocument.body.innerHTML;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/template-factory.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$5 = 'TemplateFactory';
const Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: '',
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: '<div></div>'
};
const DefaultType$4 = {
    allowList: 'object',
    content: 'object',
    extraClass: '(string|function)',
    html: 'boolean',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    template: 'string'
};
const DefaultContentType = {
    entry: '(string|element|function|null)',
    selector: '(string|element)'
};
/**
 * Class definition
 */ class TemplateFactory extends Config {
    constructor(config){
        super();
        this._config = this._getConfig(config);
    }
    // Getters
    static get Default() {
        return Default$4;
    }
    static get DefaultType() {
        return DefaultType$4;
    }
    static get NAME() {
        return NAME$5;
    }
    // Public
    getContent() {
        return Object.values(this._config.content).map((config)=>this._resolvePossibleFunction(config)).filter(Boolean);
    }
    hasContent() {
        return this.getContent().length > 0;
    }
    changeContent(content) {
        this._checkContent(content);
        this._config.content = {
            ...this._config.content,
            ...content
        };
        return this;
    }
    toHtml() {
        const templateWrapper = document.createElement('div');
        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
        for (const [selector, text] of Object.entries(this._config.content))this._setContent(templateWrapper, text, selector);
        const template = templateWrapper.children[0];
        const extraClass = this._resolvePossibleFunction(this._config.extraClass);
        if (extraClass) template.classList.add(...extraClass.split(' '));
        return template;
    }
    // Private
    _typeCheckConfig(config) {
        super._typeCheckConfig(config);
        this._checkContent(config.content);
    }
    _checkContent(arg) {
        for (const [selector, content] of Object.entries(arg))super._typeCheckConfig({
            selector,
            entry: content
        }, DefaultContentType);
    }
    _setContent(template, content, selector) {
        const templateElement = SelectorEngine.findOne(selector, template);
        if (!templateElement) return;
        content = this._resolvePossibleFunction(content);
        if (!content) {
            templateElement.remove();
            return;
        }
        if (isElement(content)) {
            this._putElementInTemplate(getElement(content), templateElement);
            return;
        }
        if (this._config.html) {
            templateElement.innerHTML = this._maybeSanitize(content);
            return;
        }
        templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
        return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
        return execute(arg, [
            undefined,
            this
        ]);
    }
    _putElementInTemplate(element, templateElement) {
        if (this._config.html) {
            templateElement.innerHTML = '';
            templateElement.append(element);
            return;
        }
        templateElement.textContent = element.textContent;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$4 = 'tooltip';
const DISALLOWED_ATTRIBUTES = new Set([
    'sanitize',
    'allowList',
    'sanitizeFn'
]);
const CLASS_NAME_FADE$2 = 'fade';
const CLASS_NAME_MODAL = 'modal';
const CLASS_NAME_SHOW$2 = 'show';
const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = 'hide.bs.modal';
const TRIGGER_HOVER = 'hover';
const TRIGGER_FOCUS = 'focus';
const TRIGGER_CLICK = 'click';
const TRIGGER_MANUAL = 'manual';
const EVENT_HIDE$2 = 'hide';
const EVENT_HIDDEN$2 = 'hidden';
const EVENT_SHOW$2 = 'show';
const EVENT_SHOWN$2 = 'shown';
const EVENT_INSERTED = 'inserted';
const EVENT_CLICK$1 = 'click';
const EVENT_FOCUSIN$1 = 'focusin';
const EVENT_FOCUSOUT$1 = 'focusout';
const EVENT_MOUSEENTER = 'mouseenter';
const EVENT_MOUSELEAVE = 'mouseleave';
const AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: isRTL() ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: isRTL() ? 'right' : 'left'
};
const Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: 'clippingParents',
    container: false,
    customClass: '',
    delay: 0,
    fallbackPlacements: [
        'top',
        'right',
        'bottom',
        'left'
    ],
    html: false,
    offset: [
        0,
        6
    ],
    placement: 'top',
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: '',
    trigger: 'hover focus'
};
const DefaultType$3 = {
    allowList: 'object',
    animation: 'boolean',
    boundary: '(string|element)',
    container: '(string|element|boolean)',
    customClass: '(string|function)',
    delay: '(number|object)',
    fallbackPlacements: 'array',
    html: 'boolean',
    offset: '(array|string|function)',
    placement: '(string|function)',
    popperConfig: '(null|object|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    selector: '(string|boolean)',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string'
};
/**
 * Class definition
 */ class Tooltip extends BaseComponent {
    constructor(element, config){
        if (typeof _core === 'undefined') throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org/docs/v2/)');
        super(element, config);
        // Private
        this._isEnabled = true;
        this._timeout = 0;
        this._isHovered = null;
        this._activeTrigger = {};
        this._popper = null;
        this._templateFactory = null;
        this._newContent = null;
        // Protected
        this.tip = null;
        this._setListeners();
        if (!this._config.selector) this._fixTitle();
    }
    // Getters
    static get Default() {
        return Default$3;
    }
    static get DefaultType() {
        return DefaultType$3;
    }
    static get NAME() {
        return NAME$4;
    }
    // Public
    enable() {
        this._isEnabled = true;
    }
    disable() {
        this._isEnabled = false;
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled;
    }
    toggle() {
        if (!this._isEnabled) return;
        if (this._isShown()) {
            this._leave();
            return;
        }
        this._enter();
    }
    dispose() {
        clearTimeout(this._timeout);
        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
        if (this._element.getAttribute('data-bs-original-title')) this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
        this._disposePopper();
        super.dispose();
    }
    show() {
        if (this._element.style.display === 'none') throw new Error('Please use show on visible elements');
        if (!(this._isWithContent() && this._isEnabled)) return;
        const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
        const shadowRoot = findShadowRoot(this._element);
        const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
        if (showEvent.defaultPrevented || !isInTheDom) return;
        // TODO: v6 remove this or make it optional
        this._disposePopper();
        const tip = this._getTipElement();
        this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
        const { container } = this._config;
        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
            container.append(tip);
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
        }
        this._popper = this._createPopper(tip);
        tip.classList.add(CLASS_NAME_SHOW$2);
        // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ('ontouchstart' in document.documentElement) for (const element of [].concat(...document.body.children))EventHandler.on(element, 'mouseover', noop);
        const complete = ()=>{
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
            if (this._isHovered === false) this._leave();
            this._isHovered = false;
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
        if (!this._isShown()) return;
        const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
        if (hideEvent.defaultPrevented) return;
        const tip = this._getTipElement();
        tip.classList.remove(CLASS_NAME_SHOW$2);
        // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) for (const element of [].concat(...document.body.children))EventHandler.off(element, 'mouseover', noop);
        this._activeTrigger[TRIGGER_CLICK] = false;
        this._activeTrigger[TRIGGER_FOCUS] = false;
        this._activeTrigger[TRIGGER_HOVER] = false;
        this._isHovered = null; // it is a trick to support manual triggering
        const complete = ()=>{
            if (this._isWithActiveTrigger()) return;
            if (!this._isHovered) this._disposePopper();
            this._element.removeAttribute('aria-describedby');
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
        if (this._popper) this._popper.update();
    }
    // Protected
    _isWithContent() {
        return Boolean(this._getTitle());
    }
    _getTipElement() {
        if (!this.tip) this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
        return this.tip;
    }
    _createTipElement(content) {
        const tip = this._getTemplateFactory(content).toHtml();
        // TODO: remove this check in v6
        if (!tip) return null;
        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
        // TODO: v6 the following can be achieved with CSS only
        tip.classList.add(`bs-${this.constructor.NAME}-auto`);
        const tipId = getUID(this.constructor.NAME).toString();
        tip.setAttribute('id', tipId);
        if (this._isAnimated()) tip.classList.add(CLASS_NAME_FADE$2);
        return tip;
    }
    setContent(content) {
        this._newContent = content;
        if (this._isShown()) {
            this._disposePopper();
            this.show();
        }
    }
    _getTemplateFactory(content) {
        if (this._templateFactory) this._templateFactory.changeContent(content);
        else this._templateFactory = new TemplateFactory({
            ...this._config,
            // the `content` var has to be after `this._config`
            // to override config.content in case of popover
            content,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
        return this._templateFactory;
    }
    _getContentForTemplate() {
        return {
            [SELECTOR_TOOLTIP_INNER]: this._getTitle()
        };
    }
    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
    }
    // Private
    _initializeOnDelegatedTarget(event) {
        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
        const placement = execute(this._config.placement, [
            this,
            tip,
            this._element
        ]);
        const attachment = AttachmentMap[placement.toUpperCase()];
        return _core.createPopper(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
        const { offset } = this._config;
        if (typeof offset === 'string') return offset.split(',').map((value)=>Number.parseInt(value, 10));
        if (typeof offset === 'function') return (popperData)=>offset(popperData, this._element);
        return offset;
    }
    _resolvePossibleFunction(arg) {
        return execute(arg, [
            this._element,
            this._element
        ]);
    }
    _getPopperConfig(attachment) {
        const defaultBsPopperConfig = {
            placement: attachment,
            modifiers: [
                {
                    name: 'flip',
                    options: {
                        fallbackPlacements: this._config.fallbackPlacements
                    }
                },
                {
                    name: 'offset',
                    options: {
                        offset: this._getOffset()
                    }
                },
                {
                    name: 'preventOverflow',
                    options: {
                        boundary: this._config.boundary
                    }
                },
                {
                    name: 'arrow',
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                },
                {
                    name: 'preSetPlacement',
                    enabled: true,
                    phase: 'beforeMain',
                    fn: (data)=>{
                        // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
                        // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
                        this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
                    }
                }
            ]
        };
        return {
            ...defaultBsPopperConfig,
            ...execute(this._config.popperConfig, [
                undefined,
                defaultBsPopperConfig
            ])
        };
    }
    _setListeners() {
        const triggers = this._config.trigger.split(' ');
        for (const trigger of triggers){
            if (trigger === 'click') EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{
                const context = this._initializeOnDelegatedTarget(event);
                context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);
                context.toggle();
            });
            else if (trigger !== TRIGGER_MANUAL) {
                const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
                const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
                EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{
                    const context = this._initializeOnDelegatedTarget(event);
                    context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                    context._enter();
                });
                EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{
                    const context = this._initializeOnDelegatedTarget(event);
                    context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
                    context._leave();
                });
            }
        }
        this._hideModalHandler = ()=>{
            if (this._element) this.hide();
        };
        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
        const title = this._element.getAttribute('title');
        if (!title) return;
        if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) this._element.setAttribute('aria-label', title);
        this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
        this._element.removeAttribute('title');
    }
    _enter() {
        if (this._isShown() || this._isHovered) {
            this._isHovered = true;
            return;
        }
        this._isHovered = true;
        this._setTimeout(()=>{
            if (this._isHovered) this.show();
        }, this._config.delay.show);
    }
    _leave() {
        if (this._isWithActiveTrigger()) return;
        this._isHovered = false;
        this._setTimeout(()=>{
            if (!this._isHovered) this.hide();
        }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
        const dataAttributes = Manipulator.getDataAttributes(this._element);
        for (const dataAttribute of Object.keys(dataAttributes))if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) delete dataAttributes[dataAttribute];
        config = {
            ...dataAttributes,
            ...typeof config === 'object' && config ? config : {}
        };
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
    }
    _configAfterMerge(config) {
        config.container = config.container === false ? document.body : getElement(config.container);
        if (typeof config.delay === 'number') config.delay = {
            show: config.delay,
            hide: config.delay
        };
        if (typeof config.title === 'number') config.title = config.title.toString();
        if (typeof config.content === 'number') config.content = config.content.toString();
        return config;
    }
    _getDelegateConfig() {
        const config = {};
        for (const [key, value] of Object.entries(this._config))if (this.constructor.Default[key] !== value) config[key] = value;
        config.selector = false;
        config.trigger = 'manual';
        // In the future can be replaced with:
        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
        // `Object.fromEntries(keysWithDifferentValues)`
        return config;
    }
    _disposePopper() {
        if (this._popper) {
            this._popper.destroy();
            this._popper = null;
        }
        if (this.tip) {
            this.tip.remove();
            this.tip = null;
        }
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Tooltip.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * jQuery
 */ defineJQueryPlugin(Tooltip);
/**
 * --------------------------------------------------------------------------
 * Bootstrap popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$3 = 'popover';
const SELECTOR_TITLE = '.popover-header';
const SELECTOR_CONTENT = '.popover-body';
const Default$2 = {
    ...Tooltip.Default,
    content: '',
    offset: [
        0,
        8
    ],
    placement: 'right',
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: 'click'
};
const DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: '(null|string|element|function)'
};
/**
 * Class definition
 */ class Popover extends Tooltip {
    // Getters
    static get Default() {
        return Default$2;
    }
    static get DefaultType() {
        return DefaultType$2;
    }
    static get NAME() {
        return NAME$3;
    }
    // Overrides
    _isWithContent() {
        return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
        return {
            [SELECTOR_TITLE]: this._getTitle(),
            [SELECTOR_CONTENT]: this._getContent()
        };
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Popover.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * jQuery
 */ defineJQueryPlugin(Popover);
/**
 * --------------------------------------------------------------------------
 * Bootstrap scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$2 = 'scrollspy';
const DATA_KEY$2 = 'bs.scrollspy';
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = '.data-api';
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
const CLASS_NAME_ACTIVE$1 = 'active';
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = '[href]';
const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
const SELECTOR_NAV_LINKS = '.nav-link';
const SELECTOR_NAV_ITEMS = '.nav-item';
const SELECTOR_LIST_ITEMS = '.list-group-item';
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = '.dropdown';
const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
const Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: '0px 0px -25%',
    smoothScroll: false,
    target: null,
    threshold: [
        0.1,
        0.5,
        1
    ]
};
const DefaultType$1 = {
    offset: '(number|null)',
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: 'string',
    smoothScroll: 'boolean',
    target: 'element',
    threshold: 'array'
};
/**
 * Class definition
 */ class ScrollSpy extends BaseComponent {
    constructor(element, config){
        super(element, config);
        // this._element is the observablesContainer and config.target the menu links wrapper
        this._targetLinks = new Map();
        this._observableSections = new Map();
        this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
        this._activeTarget = null;
        this._observer = null;
        this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0
        };
        this.refresh(); // initialize
    }
    // Getters
    static get Default() {
        return Default$1;
    }
    static get DefaultType() {
        return DefaultType$1;
    }
    static get NAME() {
        return NAME$2;
    }
    // Public
    refresh() {
        this._initializeTargetsAndObservables();
        this._maybeEnableSmoothScroll();
        if (this._observer) this._observer.disconnect();
        else this._observer = this._getNewObserver();
        for (const section of this._observableSections.values())this._observer.observe(section);
    }
    dispose() {
        this._observer.disconnect();
        super.dispose();
    }
    // Private
    _configAfterMerge(config) {
        // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
        config.target = getElement(config.target) || document.body;
        // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
        config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
        if (typeof config.threshold === 'string') config.threshold = config.threshold.split(',').map((value)=>Number.parseFloat(value));
        return config;
    }
    _maybeEnableSmoothScroll() {
        if (!this._config.smoothScroll) return;
        // unregister any previous listeners
        EventHandler.off(this._config.target, EVENT_CLICK);
        EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{
            const observableSection = this._observableSections.get(event.target.hash);
            if (observableSection) {
                event.preventDefault();
                const root = this._rootElement || window;
                const height = observableSection.offsetTop - this._element.offsetTop;
                if (root.scrollTo) {
                    root.scrollTo({
                        top: height,
                        behavior: 'smooth'
                    });
                    return;
                }
                // Chrome 60 doesn't support `scrollTo`
                root.scrollTop = height;
            }
        });
    }
    _getNewObserver() {
        const options = {
            root: this._rootElement,
            threshold: this._config.threshold,
            rootMargin: this._config.rootMargin
        };
        return new IntersectionObserver((entries)=>this._observerCallback(entries), options);
    }
    // The logic of selection
    _observerCallback(entries) {
        const targetElement = (entry)=>this._targetLinks.get(`#${entry.target.id}`);
        const activate = (entry)=>{
            this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
            this._process(targetElement(entry));
        };
        const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
        const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = parentScrollTop;
        for (const entry of entries){
            if (!entry.isIntersecting) {
                this._activeTarget = null;
                this._clearActiveClass(targetElement(entry));
                continue;
            }
            const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            // if we are scrolling down, pick the bigger offsetTop
            if (userScrollsDown && entryIsLowerThanPrevious) {
                activate(entry);
                // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
                if (!parentScrollTop) return;
                continue;
            }
            // if we are scrolling up, pick the smallest offsetTop
            if (!userScrollsDown && !entryIsLowerThanPrevious) activate(entry);
        }
    }
    _initializeTargetsAndObservables() {
        this._targetLinks = new Map();
        this._observableSections = new Map();
        const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
        for (const anchor of targetLinks){
            // ensure that the anchor has an id and is not disabled
            if (!anchor.hash || isDisabled(anchor)) continue;
            const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
            // ensure that the observableSection exists & is visible
            if (isVisible(observableSection)) {
                this._targetLinks.set(decodeURI(anchor.hash), anchor);
                this._observableSections.set(anchor.hash, observableSection);
            }
        }
    }
    _process(target) {
        if (this._activeTarget === target) return;
        this._clearActiveClass(this._config.target);
        this._activeTarget = target;
        target.classList.add(CLASS_NAME_ACTIVE$1);
        this._activateParents(target);
        EventHandler.trigger(this._element, EVENT_ACTIVATE, {
            relatedTarget: target
        });
    }
    _activateParents(target) {
        // Activate dropdown parents
        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
            SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
            return;
        }
        for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP))// Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS))item.classList.add(CLASS_NAME_ACTIVE$1);
    }
    _clearActiveClass(parent) {
        parent.classList.remove(CLASS_NAME_ACTIVE$1);
        const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
        for (const node of activeNodes)node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = ScrollSpy.getOrCreateInstance(this, config);
            if (typeof config !== 'string') return;
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY))ScrollSpy.getOrCreateInstance(spy);
});
/**
 * jQuery
 */ defineJQueryPlugin(ScrollSpy);
/**
 * --------------------------------------------------------------------------
 * Bootstrap tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$1 = 'tab';
const DATA_KEY$1 = 'bs.tab';
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = 'ArrowLeft';
const ARROW_RIGHT_KEY = 'ArrowRight';
const ARROW_UP_KEY = 'ArrowUp';
const ARROW_DOWN_KEY = 'ArrowDown';
const HOME_KEY = 'Home';
const END_KEY = 'End';
const CLASS_NAME_ACTIVE = 'active';
const CLASS_NAME_FADE$1 = 'fade';
const CLASS_NAME_SHOW$1 = 'show';
const CLASS_DROPDOWN = 'dropdown';
const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = '.nav-item, .list-group-item';
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
/**
 * Class definition
 */ class Tab extends BaseComponent {
    constructor(element){
        super(element);
        this._parent = this._element.closest(SELECTOR_TAB_PANEL);
        if (!this._parent) return;
        // Set up initial aria attributes
        this._setInitialAttributes(this._parent, this._getChildren());
        EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));
    }
    // Getters
    static get NAME() {
        return NAME$1;
    }
    // Public
    show() {
        // Shows this elem and deactivate the active sibling if exists
        const innerElem = this._element;
        if (this._elemIsActive(innerElem)) return;
        // Search for active tab on same parent to deactivate it
        const active = this._getActiveElem();
        const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
            relatedTarget: innerElem
        }) : null;
        const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
            relatedTarget: active
        });
        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) return;
        this._deactivate(active, innerElem);
        this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
        if (!element) return;
        element.classList.add(CLASS_NAME_ACTIVE);
        this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section
        const complete = ()=>{
            if (element.getAttribute('role') !== 'tab') {
                element.classList.add(CLASS_NAME_SHOW$1);
                return;
            }
            element.removeAttribute('tabindex');
            element.setAttribute('aria-selected', true);
            this._toggleDropDown(element, true);
            EventHandler.trigger(element, EVENT_SHOWN$1, {
                relatedTarget: relatedElem
            });
        };
        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
        if (!element) return;
        element.classList.remove(CLASS_NAME_ACTIVE);
        element.blur();
        this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too
        const complete = ()=>{
            if (element.getAttribute('role') !== 'tab') {
                element.classList.remove(CLASS_NAME_SHOW$1);
                return;
            }
            element.setAttribute('aria-selected', false);
            element.setAttribute('tabindex', '-1');
            this._toggleDropDown(element, false);
            EventHandler.trigger(element, EVENT_HIDDEN$1, {
                relatedTarget: relatedElem
            });
        };
        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
        if (![
            ARROW_LEFT_KEY,
            ARROW_RIGHT_KEY,
            ARROW_UP_KEY,
            ARROW_DOWN_KEY,
            HOME_KEY,
            END_KEY
        ].includes(event.key)) return;
        event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
        event.preventDefault();
        const children = this._getChildren().filter((element)=>!isDisabled(element));
        let nextActiveElement;
        if ([
            HOME_KEY,
            END_KEY
        ].includes(event.key)) nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
        else {
            const isNext = [
                ARROW_RIGHT_KEY,
                ARROW_DOWN_KEY
            ].includes(event.key);
            nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
        }
        if (nextActiveElement) {
            nextActiveElement.focus({
                preventScroll: true
            });
            Tab.getOrCreateInstance(nextActiveElement).show();
        }
    }
    _getChildren() {
        // collection of inner elements
        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
        return this._getChildren().find((child)=>this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
        this._setAttributeIfNotExists(parent, 'role', 'tablist');
        for (const child of children)this._setInitialAttributesOnChild(child);
    }
    _setInitialAttributesOnChild(child) {
        child = this._getInnerElement(child);
        const isActive = this._elemIsActive(child);
        const outerElem = this._getOuterElement(child);
        child.setAttribute('aria-selected', isActive);
        if (outerElem !== child) this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
        if (!isActive) child.setAttribute('tabindex', '-1');
        this._setAttributeIfNotExists(child, 'role', 'tab');
        // set attributes to the related panel too
        this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
        const target = SelectorEngine.getElementFromSelector(child);
        if (!target) return;
        this._setAttributeIfNotExists(target, 'role', 'tabpanel');
        if (child.id) this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);
    }
    _toggleDropDown(element, open) {
        const outerElem = this._getOuterElement(element);
        if (!outerElem.classList.contains(CLASS_DROPDOWN)) return;
        const toggle = (selector, className)=>{
            const element = SelectorEngine.findOne(selector, outerElem);
            if (element) element.classList.toggle(className, open);
        };
        toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
        toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
        outerElem.setAttribute('aria-expanded', open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
        if (!element.hasAttribute(attribute)) element.setAttribute(attribute, value);
    }
    _elemIsActive(elem) {
        return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
        return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
        return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Tab.getOrCreateInstance(this);
            if (typeof config !== 'string') return;
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if ([
        'A',
        'AREA'
    ].includes(this.tagName)) event.preventDefault();
    if (isDisabled(this)) return;
    Tab.getOrCreateInstance(this).show();
});
/**
 * Initialize on focus
 */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE))Tab.getOrCreateInstance(element);
});
/**
 * jQuery
 */ defineJQueryPlugin(Tab);
/**
 * --------------------------------------------------------------------------
 * Bootstrap toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME = 'toast';
const DATA_KEY = 'bs.toast';
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = 'fade';
const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
const CLASS_NAME_SHOW = 'show';
const CLASS_NAME_SHOWING = 'showing';
const DefaultType = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
};
const Default = {
    animation: true,
    autohide: true,
    delay: 5000
};
/**
 * Class definition
 */ class Toast extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._timeout = null;
        this._hasMouseInteraction = false;
        this._hasKeyboardInteraction = false;
        this._setListeners();
    }
    // Getters
    static get Default() {
        return Default;
    }
    static get DefaultType() {
        return DefaultType;
    }
    static get NAME() {
        return NAME;
    }
    // Public
    show() {
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
        if (showEvent.defaultPrevented) return;
        this._clearTimeout();
        if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
        const complete = ()=>{
            this._element.classList.remove(CLASS_NAME_SHOWING);
            EventHandler.trigger(this._element, EVENT_SHOWN);
            this._maybeScheduleHide();
        };
        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
        this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
        if (!this.isShown()) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
        if (hideEvent.defaultPrevented) return;
        const complete = ()=>{
            this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
            this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
            EventHandler.trigger(this._element, EVENT_HIDDEN);
        };
        this._element.classList.add(CLASS_NAME_SHOWING);
        this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
        this._clearTimeout();
        if (this.isShown()) this._element.classList.remove(CLASS_NAME_SHOW);
        super.dispose();
    }
    isShown() {
        return this._element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _maybeScheduleHide() {
        if (!this._config.autohide) return;
        if (this._hasMouseInteraction || this._hasKeyboardInteraction) return;
        this._timeout = setTimeout(()=>{
            this.hide();
        }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
        switch(event.type){
            case 'mouseover':
            case 'mouseout':
                this._hasMouseInteraction = isInteracting;
                break;
            case 'focusin':
            case 'focusout':
                this._hasKeyboardInteraction = isInteracting;
                break;
        }
        if (isInteracting) {
            this._clearTimeout();
            return;
        }
        const nextElement = event.relatedTarget;
        if (this._element === nextElement || this._element.contains(nextElement)) return;
        this._maybeScheduleHide();
    }
    _setListeners() {
        EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));
        EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));
        EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));
        EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));
    }
    _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Toast.getOrCreateInstance(this, config);
            if (typeof config === 'string') {
                if (typeof data[config] === 'undefined') throw new TypeError(`No method named "${config}"`);
                data[config](this);
            }
        });
    }
}
/**
 * Data API implementation
 */ enableDismissTrigger(Toast);
/**
 * jQuery
 */ defineJQueryPlugin(Toast);

},{"@popperjs/core":"gYaaZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gYaaZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
parcelHelpers.export(exports, "createPopperBase", ()=>(0, _createPopperJs.createPopper));
parcelHelpers.export(exports, "createPopper", ()=>(0, _popperJs.createPopper)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopperLite", ()=>(0, _popperLiteJs.createPopper));
var _enumsJs = require("./enums.js");
parcelHelpers.exportAll(_enumsJs, exports);
var _indexJs = require("./modifiers/index.js"); // eslint-disable-next-line import/no-unused-modules
parcelHelpers.exportAll(_indexJs, exports);
var _createPopperJs = require("./createPopper.js");
var _popperJs = require("./popper.js");
var _popperLiteJs = require("./popper-lite.js");

},{"./enums.js":"jVhmu","./modifiers/index.js":"e2tRe","./createPopper.js":"3NuA9","./popper.js":"aM4Q6","./popper-lite.js":"cK1Kf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jVhmu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "top", ()=>top);
parcelHelpers.export(exports, "bottom", ()=>bottom);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "auto", ()=>auto);
parcelHelpers.export(exports, "basePlacements", ()=>basePlacements);
parcelHelpers.export(exports, "start", ()=>start);
parcelHelpers.export(exports, "end", ()=>end);
parcelHelpers.export(exports, "clippingParents", ()=>clippingParents);
parcelHelpers.export(exports, "viewport", ()=>viewport);
parcelHelpers.export(exports, "popper", ()=>popper);
parcelHelpers.export(exports, "reference", ()=>reference);
parcelHelpers.export(exports, "variationPlacements", ()=>variationPlacements);
parcelHelpers.export(exports, "placements", ()=>placements);
parcelHelpers.export(exports, "beforeRead", ()=>beforeRead);
parcelHelpers.export(exports, "read", ()=>read);
parcelHelpers.export(exports, "afterRead", ()=>afterRead);
parcelHelpers.export(exports, "beforeMain", ()=>beforeMain);
parcelHelpers.export(exports, "main", ()=>main);
parcelHelpers.export(exports, "afterMain", ()=>afterMain);
parcelHelpers.export(exports, "beforeWrite", ()=>beforeWrite);
parcelHelpers.export(exports, "write", ()=>write);
parcelHelpers.export(exports, "afterWrite", ()=>afterWrite);
parcelHelpers.export(exports, "modifierPhases", ()=>modifierPhases);
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /*#__PURE__*/ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []); // modifiers that need to read the DOM
var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers
var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)
var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e2tRe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyStyles", ()=>(0, _applyStylesJsDefault.default));
parcelHelpers.export(exports, "arrow", ()=>(0, _arrowJsDefault.default));
parcelHelpers.export(exports, "computeStyles", ()=>(0, _computeStylesJsDefault.default));
parcelHelpers.export(exports, "eventListeners", ()=>(0, _eventListenersJsDefault.default));
parcelHelpers.export(exports, "flip", ()=>(0, _flipJsDefault.default));
parcelHelpers.export(exports, "hide", ()=>(0, _hideJsDefault.default));
parcelHelpers.export(exports, "offset", ()=>(0, _offsetJsDefault.default));
parcelHelpers.export(exports, "popperOffsets", ()=>(0, _popperOffsetsJsDefault.default));
parcelHelpers.export(exports, "preventOverflow", ()=>(0, _preventOverflowJsDefault.default));
var _applyStylesJs = require("./applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _arrowJs = require("./arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _computeStylesJs = require("./computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _eventListenersJs = require("./eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _hideJs = require("./hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _offsetJs = require("./offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _popperOffsetsJs = require("./popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _preventOverflowJs = require("./preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);

},{"./applyStyles.js":"k3FfN","./arrow.js":"5tq5K","./computeStyles.js":"cU0Y8","./eventListeners.js":"b3l2h","./flip.js":"8TrBc","./hide.js":"1DgVf","./offset.js":"fv6qu","./popperOffsets.js":"iQIBA","./preventOverflow.js":"hksGy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k3FfN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("../dom-utils/getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements
        if (!(0, _instanceOfJs.isHTMLElement)(element) || !(0, _getNodeNameJsDefault.default)(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? '' : value);
        });
    });
}
function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
        },
        arrow: {
            position: 'absolute'
        },
        reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style = styleProperties.reduce(function(style, property) {
                style[property] = '';
                return style;
            }, {}); // arrow is optional + virtual elements
            if (!(0, _instanceOfJs.isHTMLElement)(element) || !(0, _getNodeNameJsDefault.default)(element)) return;
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect,
    requires: [
        'computeStyles'
    ]
};

},{"../dom-utils/getNodeName.js":"4Hnqb","../dom-utils/instanceOf.js":"ipye8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Hnqb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getNodeName);
function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ipye8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isElement", ()=>isElement);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function isElement(node) {
    var OwnElement = (0, _getWindowJsDefault.default)(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = (0, _getWindowJsDefault.default)(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') return false;
    var OwnElement = (0, _getWindowJsDefault.default)(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":"fYC42","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fYC42":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getWindow);
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5tq5K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _containsJs = require("../dom-utils/contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _withinJs = require("../utils/within.js");
var _mergePaddingObjectJs = require("../utils/mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("../utils/expandToHashMap.js");
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
    })) : padding;
    return (0, _mergePaddingObjectJsDefault.default)(typeof padding !== 'number' ? padding : (0, _expandToHashMapJsDefault.default)(padding, (0, _enumsJs.basePlacements)));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = (0, _getBasePlacementJsDefault.default)(state.placement);
    var axis = (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement);
    var isVertical = [
        (0, _enumsJs.left),
        (0, _enumsJs.right)
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = (0, _getLayoutRectJsDefault.default)(arrowElement);
    var minProp = axis === 'y' ? (0, _enumsJs.top) : (0, _enumsJs.left);
    var maxProp = axis === 'y' ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = (0, _getOffsetParentJsDefault.default)(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = (0, _withinJs.within)(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!(0, _containsJsDefault.default)(state.elements.popper, arrowElement)) return;
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect,
    requires: [
        'popperOffsets'
    ],
    requiresIfExists: [
        'preventOverflow'
    ]
};

},{"../utils/getBasePlacement.js":"eyEpU","../dom-utils/getLayoutRect.js":"76Hja","../dom-utils/contains.js":"dndqI","../dom-utils/getOffsetParent.js":"fac6D","../utils/getMainAxisFromPlacement.js":"lqRR4","../utils/within.js":"82Rs6","../utils/mergePaddingObject.js":"4nxAg","../utils/expandToHashMap.js":"57Ue6","../enums.js":"jVhmu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eyEpU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getBasePlacement);
var _enumsJs = require("../enums.js");
function getBasePlacement(placement) {
    return placement.split('-')[0];
}

},{"../enums.js":"jVhmu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"76Hja":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getLayoutRect);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js"); // Returns the layout rect of an element relative to its offsetParent. Layout
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
function getLayoutRect(element) {
    var clientRect = (0, _getBoundingClientRectJsDefault.default)(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}

},{"./getBoundingClientRect.js":"8WtHW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8WtHW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getBoundingClientRect);
var _instanceOfJs = require("./instanceOf.js");
var _mathJs = require("../utils/math.js");
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isLayoutViewportJs = require("./isLayoutViewport.js");
var _isLayoutViewportJsDefault = parcelHelpers.interopDefault(_isLayoutViewportJs);
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) includeScale = false;
    if (isFixedStrategy === void 0) isFixedStrategy = false;
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && (0, _instanceOfJs.isHTMLElement)(element)) {
        scaleX = element.offsetWidth > 0 ? (0, _mathJs.round)(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? (0, _mathJs.round)(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = (0, _instanceOfJs.isElement)(element) ? (0, _getWindowJsDefault.default)(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !(0, _isLayoutViewportJsDefault.default)() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
    };
}

},{"./instanceOf.js":"ipye8","../utils/math.js":"aHRaj","./getWindow.js":"fYC42","./isLayoutViewport.js":"lbQUA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aHRaj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "round", ()=>round);
var max = Math.max;
var min = Math.min;
var round = Math.round;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lbQUA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isLayoutViewport);
var _userAgentJs = require("../utils/userAgent.js");
var _userAgentJsDefault = parcelHelpers.interopDefault(_userAgentJs);
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test((0, _userAgentJsDefault.default)());
}

},{"../utils/userAgent.js":"cKJ5P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cKJ5P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUAString);
function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
    }).join(' ');
    return navigator.userAgent;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dndqI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>contains);
var _instanceOfJs = require("./instanceOf.js");
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && (0, _instanceOfJs.isShadowRoot)(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next);
    } // Give up, the result is false
    return false;
}

},{"./instanceOf.js":"ipye8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fac6D":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getOffsetParent);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _isTableElementJs = require("./isTableElement.js");
var _isTableElementJsDefault = parcelHelpers.interopDefault(_isTableElementJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _userAgentJs = require("../utils/userAgent.js");
var _userAgentJsDefault = parcelHelpers.interopDefault(_userAgentJs);
function getTrueOffsetParent(element) {
    if (!(0, _instanceOfJs.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
    (0, _getComputedStyleJsDefault.default)(element).position === 'fixed') return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element) {
    var isFirefox = /firefox/i.test((0, _userAgentJsDefault.default)());
    var isIE = /Trident/i.test((0, _userAgentJsDefault.default)());
    if (isIE && (0, _instanceOfJs.isHTMLElement)(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = (0, _getComputedStyleJsDefault.default)(element);
        if (elementCss.position === 'fixed') return null;
    }
    var currentNode = (0, _getParentNodeJsDefault.default)(element);
    if ((0, _instanceOfJs.isShadowRoot)(currentNode)) currentNode = currentNode.host;
    while((0, _instanceOfJs.isHTMLElement)(currentNode) && [
        'html',
        'body'
    ].indexOf((0, _getNodeNameJsDefault.default)(currentNode)) < 0){
        var css = (0, _getComputedStyleJsDefault.default)(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || [
            'transform',
            'perspective'
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
function getOffsetParent(element) {
    var window = (0, _getWindowJsDefault.default)(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && (0, _isTableElementJsDefault.default)(offsetParent) && (0, _getComputedStyleJsDefault.default)(offsetParent).position === 'static')offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && ((0, _getNodeNameJsDefault.default)(offsetParent) === 'html' || (0, _getNodeNameJsDefault.default)(offsetParent) === 'body' && (0, _getComputedStyleJsDefault.default)(offsetParent).position === 'static')) return window;
    return offsetParent || getContainingBlock(element) || window;
}

},{"./getWindow.js":"fYC42","./getNodeName.js":"4Hnqb","./getComputedStyle.js":"jbfT5","./instanceOf.js":"ipye8","./isTableElement.js":"7W8QO","./getParentNode.js":"aEx5x","../utils/userAgent.js":"cKJ5P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jbfT5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getComputedStyle);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getComputedStyle(element) {
    return (0, _getWindowJsDefault.default)(element).getComputedStyle(element);
}

},{"./getWindow.js":"fYC42","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7W8QO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isTableElement);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
function isTableElement(element) {
    return [
        'table',
        'td',
        'th'
    ].indexOf((0, _getNodeNameJsDefault.default)(element)) >= 0;
}

},{"./getNodeName.js":"4Hnqb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aEx5x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getParentNode);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _instanceOfJs = require("./instanceOf.js");
function getParentNode(element) {
    if ((0, _getNodeNameJsDefault.default)(element) === 'html') return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ((0, _instanceOfJs.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElementJsDefault.default)(element) // fallback
    );
}

},{"./getNodeName.js":"4Hnqb","./getDocumentElement.js":"av3Bt","./instanceOf.js":"ipye8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"av3Bt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDocumentElement);
var _instanceOfJs = require("./instanceOf.js");
function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return (((0, _instanceOfJs.isElement)(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

},{"./instanceOf.js":"ipye8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lqRR4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getMainAxisFromPlacement);
function getMainAxisFromPlacement(placement) {
    return [
        'top',
        'bottom'
    ].indexOf(placement) >= 0 ? 'x' : 'y';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"82Rs6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "within", ()=>within);
parcelHelpers.export(exports, "withinMaxClamp", ()=>withinMaxClamp);
var _mathJs = require("./math.js");
function within(min, value, max) {
    return (0, _mathJs.max)(min, (0, _mathJs.min)(value, max));
}
function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
}

},{"./math.js":"aHRaj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4nxAg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergePaddingObject);
var _getFreshSideObjectJs = require("./getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
function mergePaddingObject(paddingObject) {
    return Object.assign({}, (0, _getFreshSideObjectJsDefault.default)(), paddingObject);
}

},{"./getFreshSideObject.js":"il3RZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"il3RZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getFreshSideObject);
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"57Ue6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>expandToHashMap);
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cU0Y8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToStyles", ()=>mapToStyles);
var _enumsJs = require("../enums.js");
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getWindowJs = require("../dom-utils/getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("../dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _mathJs = require("../utils/math.js"); // eslint-disable-next-line import/no-unused-modules
var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: (0, _mathJs.round)(x * dpr) / dpr || 0,
        y: (0, _mathJs.round)(y * dpr) / dpr || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = (0, _enumsJs.left);
    var sideY = (0, _enumsJs.top);
    var win = window;
    if (adaptive) {
        var offsetParent = (0, _getOffsetParentJsDefault.default)(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';
        if (offsetParent === (0, _getWindowJsDefault.default)(popper)) {
            offsetParent = (0, _getDocumentElementJsDefault.default)(popper);
            if ((0, _getComputedStyleJsDefault.default)(offsetParent).position !== 'static' && position === 'absolute') {
                heightProp = 'scrollHeight';
                widthProp = 'scrollWidth';
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        offsetParent;
        if (placement === (0, _enumsJs.top) || (placement === (0, _enumsJs.left) || placement === (0, _enumsJs.right)) && variation === (0, _enumsJs.end)) {
            sideY = (0, _enumsJs.bottom);
            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === (0, _enumsJs.left) || (placement === (0, _enumsJs.top) || placement === (0, _enumsJs.bottom)) && variation === (0, _enumsJs.end)) {
            sideX = (0, _enumsJs.right);
            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
    }, (0, _getWindowJsDefault.default)(popper)) : {
        x: x,
        y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
        placement: (0, _getBasePlacementJsDefault.default)(state.placement),
        variation: (0, _getVariationJsDefault.default)(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
};

},{"../enums.js":"jVhmu","../dom-utils/getOffsetParent.js":"fac6D","../dom-utils/getWindow.js":"fYC42","../dom-utils/getDocumentElement.js":"av3Bt","../dom-utils/getComputedStyle.js":"jbfT5","../utils/getBasePlacement.js":"eyEpU","../utils/getVariation.js":"4mx8J","../utils/math.js":"aHRaj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4mx8J":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getVariation);
function getVariation(placement) {
    return placement.split('-')[1];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b3l2h":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("../dom-utils/getWindow.js"); // eslint-disable-next-line import/no-unused-modules
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var passive = {
    passive: true
};
function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window = (0, _getWindowJsDefault.default)(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
    });
    if (resize) window.addEventListener('resize', instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
        });
        if (resize) window.removeEventListener('resize', instance.update, passive);
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
};

},{"../dom-utils/getWindow.js":"fYC42","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8TrBc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getOppositePlacementJs = require("../utils/getOppositePlacement.js");
var _getOppositePlacementJsDefault = parcelHelpers.interopDefault(_getOppositePlacementJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getOppositeVariationPlacementJs = require("../utils/getOppositeVariationPlacement.js");
var _getOppositeVariationPlacementJsDefault = parcelHelpers.interopDefault(_getOppositeVariationPlacementJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _computeAutoPlacementJs = require("../utils/computeAutoPlacement.js");
var _computeAutoPlacementJsDefault = parcelHelpers.interopDefault(_computeAutoPlacementJs);
var _enumsJs = require("../enums.js");
var _getVariationJs = require("../utils/getVariation.js"); // eslint-disable-next-line import/no-unused-modules
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
function getExpandedFallbackPlacements(placement) {
    if ((0, _getBasePlacementJsDefault.default)(placement) === (0, _enumsJs.auto)) return [];
    var oppositePlacement = (0, _getOppositePlacementJsDefault.default)(placement);
    return [
        (0, _getOppositeVariationPlacementJsDefault.default)(placement),
        oppositePlacement,
        (0, _getOppositeVariationPlacementJsDefault.default)(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = (0, _getBasePlacementJsDefault.default)(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        (0, _getOppositePlacementJsDefault.default)(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat((0, _getBasePlacementJsDefault.default)(placement) === (0, _enumsJs.auto) ? (0, _computeAutoPlacementJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement = placements[i];
        var _basePlacement = (0, _getBasePlacementJsDefault.default)(placement);
        var isStartVariation = (0, _getVariationJsDefault.default)(placement) === (0, _enumsJs.start);
        var isVertical = [
            (0, _enumsJs.top),
            (0, _enumsJs.bottom)
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = (0, _detectOverflowJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? (0, _enumsJs.right) : (0, _enumsJs.left) : isStartVariation ? (0, _enumsJs.bottom) : (0, _enumsJs.top);
        if (referenceRect[len] > popperRect[len]) mainVariationSide = (0, _getOppositePlacementJsDefault.default)(mainVariationSide);
        var altVariationSide = (0, _getOppositePlacementJsDefault.default)(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i = numberOfChecks; _i > 0; _i--){
            var _ret = _loop(_i);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: [
        'offset'
    ],
    data: {
        _skip: false
    }
};

},{"../utils/getOppositePlacement.js":"98Iju","../utils/getBasePlacement.js":"eyEpU","../utils/getOppositeVariationPlacement.js":"l3jQn","../utils/detectOverflow.js":"2YWVs","../utils/computeAutoPlacement.js":"2ataH","../enums.js":"jVhmu","../utils/getVariation.js":"4mx8J","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"98Iju":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getOppositePlacement);
var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l3jQn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getOppositeVariationPlacement);
var hash = {
    start: 'end',
    end: 'start'
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2YWVs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>detectOverflow);
var _getClippingRectJs = require("../dom-utils/getClippingRect.js");
var _getClippingRectJsDefault = parcelHelpers.interopDefault(_getClippingRectJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getBoundingClientRectJs = require("../dom-utils/getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _computeOffsetsJs = require("./computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
var _rectToClientRectJs = require("./rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js");
var _mergePaddingObjectJs = require("./mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("./expandToHashMap.js"); // eslint-disable-next-line import/no-unused-modules
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
function detectOverflow(state, options) {
    if (options === void 0) options = {};
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? (0, _enumsJs.clippingParents) : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? (0, _enumsJs.viewport) : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? (0, _enumsJs.popper) : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = (0, _mergePaddingObjectJsDefault.default)(typeof padding !== 'number' ? padding : (0, _expandToHashMapJsDefault.default)(padding, (0, _enumsJs.basePlacements)));
    var altContext = elementContext === (0, _enumsJs.popper) ? (0, _enumsJs.reference) : (0, _enumsJs.popper);
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = (0, _getClippingRectJsDefault.default)((0, _instanceOfJs.isElement)(element) ? element : element.contextElement || (0, _getDocumentElementJsDefault.default)(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = (0, _getBoundingClientRectJsDefault.default)(state.elements.reference);
    var popperOffsets = (0, _computeOffsetsJsDefault.default)({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
    });
    var popperClientRect = (0, _rectToClientRectJsDefault.default)(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === (0, _enumsJs.popper) ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === (0, _enumsJs.popper) && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                (0, _enumsJs.right),
                (0, _enumsJs.bottom)
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                (0, _enumsJs.top),
                (0, _enumsJs.bottom)
            ].indexOf(key) >= 0 ? 'y' : 'x';
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}

},{"../dom-utils/getClippingRect.js":"heMj5","../dom-utils/getDocumentElement.js":"av3Bt","../dom-utils/getBoundingClientRect.js":"8WtHW","./computeOffsets.js":"hCFQM","./rectToClientRect.js":"h62Ik","../enums.js":"jVhmu","../dom-utils/instanceOf.js":"ipye8","./mergePaddingObject.js":"4nxAg","./expandToHashMap.js":"57Ue6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"heMj5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getClippingRect);
var _enumsJs = require("../enums.js");
var _getViewportRectJs = require("./getViewportRect.js");
var _getViewportRectJsDefault = parcelHelpers.interopDefault(_getViewportRectJs);
var _getDocumentRectJs = require("./getDocumentRect.js");
var _getDocumentRectJsDefault = parcelHelpers.interopDefault(_getDocumentRectJs);
var _listScrollParentsJs = require("./listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _rectToClientRectJs = require("../utils/rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _mathJs = require("../utils/math.js");
function getInnerBoundingClientRect(element, strategy) {
    var rect = (0, _getBoundingClientRectJsDefault.default)(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === (0, _enumsJs.viewport) ? (0, _rectToClientRectJsDefault.default)((0, _getViewportRectJsDefault.default)(element, strategy)) : (0, _instanceOfJs.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0, _rectToClientRectJsDefault.default)((0, _getDocumentRectJsDefault.default)((0, _getDocumentElementJsDefault.default)(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element) {
    var clippingParents = (0, _listScrollParentsJsDefault.default)((0, _getParentNodeJsDefault.default)(element));
    var canEscapeClipping = [
        'absolute',
        'fixed'
    ].indexOf((0, _getComputedStyleJsDefault.default)(element).position) >= 0;
    var clipperElement = canEscapeClipping && (0, _instanceOfJs.isHTMLElement)(element) ? (0, _getOffsetParentJsDefault.default)(element) : element;
    if (!(0, _instanceOfJs.isElement)(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return (0, _instanceOfJs.isElement)(clippingParent) && (0, _containsJsDefault.default)(clippingParent, clipperElement) && (0, _getNodeNameJsDefault.default)(clippingParent) !== 'body';
    });
} // Gets the maximum area that the element is visible in due to any number of
function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = (0, _mathJs.max)(rect.top, accRect.top);
        accRect.right = (0, _mathJs.min)(rect.right, accRect.right);
        accRect.bottom = (0, _mathJs.min)(rect.bottom, accRect.bottom);
        accRect.left = (0, _mathJs.max)(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}

},{"../enums.js":"jVhmu","./getViewportRect.js":"fBHZw","./getDocumentRect.js":"1pyhi","./listScrollParents.js":"b5rfb","./getOffsetParent.js":"fac6D","./getDocumentElement.js":"av3Bt","./getComputedStyle.js":"jbfT5","./instanceOf.js":"ipye8","./getBoundingClientRect.js":"8WtHW","./getParentNode.js":"aEx5x","./contains.js":"dndqI","./getNodeName.js":"4Hnqb","../utils/rectToClientRect.js":"h62Ik","../utils/math.js":"aHRaj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fBHZw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getViewportRect);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _isLayoutViewportJs = require("./isLayoutViewport.js");
var _isLayoutViewportJsDefault = parcelHelpers.interopDefault(_isLayoutViewportJs);
function getViewportRect(element, strategy) {
    var win = (0, _getWindowJsDefault.default)(element);
    var html = (0, _getDocumentElementJsDefault.default)(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = (0, _isLayoutViewportJsDefault.default)();
        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + (0, _getWindowScrollBarXJsDefault.default)(element),
        y: y
    };
}

},{"./getWindow.js":"fYC42","./getDocumentElement.js":"av3Bt","./getWindowScrollBarX.js":"dZ6cX","./isLayoutViewport.js":"lbQUA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dZ6cX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getWindowScrollBarX);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return (0, _getBoundingClientRectJsDefault.default)((0, _getDocumentElementJsDefault.default)(element)).left + (0, _getWindowScrollJsDefault.default)(element).scrollLeft;
}

},{"./getBoundingClientRect.js":"8WtHW","./getDocumentElement.js":"av3Bt","./getWindowScroll.js":"28xxo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"28xxo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getWindowScroll);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getWindowScroll(node) {
    var win = (0, _getWindowJsDefault.default)(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}

},{"./getWindow.js":"fYC42","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1pyhi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDocumentRect);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _mathJs = require("../utils/math.js"); // Gets the entire size of the scrollable document area, even extending outside
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = (0, _getDocumentElementJsDefault.default)(element);
    var winScroll = (0, _getWindowScrollJsDefault.default)(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = (0, _mathJs.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = (0, _mathJs.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + (0, _getWindowScrollBarXJsDefault.default)(element);
    var y = -winScroll.scrollTop;
    if ((0, _getComputedStyleJsDefault.default)(body || html).direction === 'rtl') x += (0, _mathJs.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}

},{"./getDocumentElement.js":"av3Bt","./getComputedStyle.js":"jbfT5","./getWindowScrollBarX.js":"dZ6cX","./getWindowScroll.js":"28xxo","../utils/math.js":"aHRaj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b5rfb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>listScrollParents);
var _getScrollParentJs = require("./getScrollParent.js");
var _getScrollParentJsDefault = parcelHelpers.interopDefault(_getScrollParentJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = (0, _getScrollParentJsDefault.default)(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = (0, _getWindowJsDefault.default)(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], (0, _isScrollParentJsDefault.default)(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents((0, _getParentNodeJsDefault.default)(target)));
}

},{"./getScrollParent.js":"jG2vI","./getParentNode.js":"aEx5x","./getWindow.js":"fYC42","./isScrollParent.js":"kF6fv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jG2vI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getScrollParent);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
function getScrollParent(node) {
    if ([
        'html',
        'body',
        '#document'
    ].indexOf((0, _getNodeNameJsDefault.default)(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if ((0, _instanceOfJs.isHTMLElement)(node) && (0, _isScrollParentJsDefault.default)(node)) return node;
    return getScrollParent((0, _getParentNodeJsDefault.default)(node));
}

},{"./getParentNode.js":"aEx5x","./isScrollParent.js":"kF6fv","./getNodeName.js":"4Hnqb","./instanceOf.js":"ipye8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kF6fv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isScrollParent);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = (0, _getComputedStyleJsDefault.default)(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

},{"./getComputedStyle.js":"jbfT5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h62Ik":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rectToClientRect);
function rectToClientRect(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hCFQM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>computeOffsets);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getMainAxisFromPlacementJs = require("./getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _enumsJs = require("../enums.js");
function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? (0, _getBasePlacementJsDefault.default)(placement) : null;
    var variation = placement ? (0, _getVariationJsDefault.default)(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case 0, _enumsJs.top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case 0, _enumsJs.bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 0, _enumsJs.right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 0, _enumsJs.left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';
        switch(variation){
            case 0, _enumsJs.start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case 0, _enumsJs.end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}

},{"./getBasePlacement.js":"eyEpU","./getVariation.js":"4mx8J","./getMainAxisFromPlacement.js":"lqRR4","../enums.js":"jVhmu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2ataH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>computeAutoPlacement);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("./detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {};
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? (0, _enumsJs.placements) : _options$allowedAutoP;
    var variation = (0, _getVariationJsDefault.default)(placement);
    var placements = variation ? flipVariations ? (0, _enumsJs.variationPlacements) : (0, _enumsJs.variationPlacements).filter(function(placement) {
        return (0, _getVariationJsDefault.default)(placement) === variation;
    }) : (0, _enumsJs.basePlacements);
    var allowedPlacements = placements.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) allowedPlacements = placements;
     // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = (0, _detectOverflowJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[(0, _getBasePlacementJsDefault.default)(placement)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}

},{"./getVariation.js":"4mx8J","../enums.js":"jVhmu","./detectOverflow.js":"2YWVs","./getBasePlacement.js":"eyEpU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1DgVf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function isAnySideFullyClipped(overflow) {
    return [
        (0, _enumsJs.top),
        (0, _enumsJs.right),
        (0, _enumsJs.bottom),
        (0, _enumsJs.left)
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = (0, _detectOverflowJsDefault.default)(state, {
        elementContext: 'reference'
    });
    var popperAltOverflow = (0, _detectOverflowJsDefault.default)(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: [
        'preventOverflow'
    ],
    fn: hide
};

},{"../enums.js":"jVhmu","../utils/detectOverflow.js":"2YWVs","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fv6qu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distanceAndSkiddingToXY", ()=>distanceAndSkiddingToXY);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = (0, _getBasePlacementJsDefault.default)(placement);
    var invertDistance = [
        (0, _enumsJs.left),
        (0, _enumsJs.top)
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
    })) : offset, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        (0, _enumsJs.left),
        (0, _enumsJs.right)
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = (0, _enumsJs.placements).reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: [
        'popperOffsets'
    ],
    fn: offset
};

},{"../utils/getBasePlacement.js":"eyEpU","../enums.js":"jVhmu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iQIBA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeOffsetsJs = require("../utils/computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = (0, _computeOffsetsJsDefault.default)({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
};

},{"../utils/computeOffsets.js":"hCFQM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hksGy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _getAltAxisJs = require("../utils/getAltAxis.js");
var _getAltAxisJsDefault = parcelHelpers.interopDefault(_getAltAxisJs);
var _withinJs = require("../utils/within.js");
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getFreshSideObjectJs = require("../utils/getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
var _mathJs = require("../utils/math.js");
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = (0, _detectOverflowJsDefault.default)(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = (0, _getBasePlacementJsDefault.default)(state.placement);
    var variation = (0, _getVariationJsDefault.default)(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement);
    var altAxis = (0, _getAltAxisJsDefault.default)(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === 'y' ? (0, _enumsJs.top) : (0, _enumsJs.left);
        var altSide = mainAxis === 'y' ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === (0, _enumsJs.start) ? referenceRect[len] : popperRect[len];
        var maxLen = variation === (0, _enumsJs.start) ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? (0, _getLayoutRectJsDefault.default)(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0, _getFreshSideObjectJsDefault.default)();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = (0, _withinJs.within)(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParentJsDefault.default)(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = (0, _withinJs.within)(tether ? (0, _mathJs.min)(min, tetherMin) : min, offset, tether ? (0, _mathJs.max)(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === 'x' ? (0, _enumsJs.top) : (0, _enumsJs.left);
        var _altSide = mainAxis === 'x' ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === 'y' ? 'height' : 'width';
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            (0, _enumsJs.top),
            (0, _enumsJs.left)
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? (0, _withinJs.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _withinJs.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: [
        'offset'
    ]
};

},{"../enums.js":"jVhmu","../utils/getBasePlacement.js":"eyEpU","../utils/getMainAxisFromPlacement.js":"lqRR4","../utils/getAltAxis.js":"hB6bd","../utils/within.js":"82Rs6","../dom-utils/getLayoutRect.js":"76Hja","../dom-utils/getOffsetParent.js":"fac6D","../utils/detectOverflow.js":"2YWVs","../utils/getVariation.js":"4mx8J","../utils/getFreshSideObject.js":"il3RZ","../utils/math.js":"aHRaj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hB6bd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getAltAxis);
function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3NuA9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>popperGenerator);
parcelHelpers.export(exports, "createPopper", ()=>createPopper);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _detectOverflowJsDefault.default));
var _getCompositeRectJs = require("./dom-utils/getCompositeRect.js");
var _getCompositeRectJsDefault = parcelHelpers.interopDefault(_getCompositeRectJs);
var _getLayoutRectJs = require("./dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _listScrollParentsJs = require("./dom-utils/listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _orderModifiersJs = require("./utils/orderModifiers.js");
var _orderModifiersJsDefault = parcelHelpers.interopDefault(_orderModifiersJs);
var _debounceJs = require("./utils/debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _mergeByNameJs = require("./utils/mergeByName.js");
var _mergeByNameJsDefault = parcelHelpers.interopDefault(_mergeByNameJs);
var _detectOverflowJs = require("./utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _instanceOfJs = require("./dom-utils/instanceOf.js");
var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {};
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
        if (options === void 0) options = defaultOptions;
        var state = {
            placement: 'bottom',
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference,
                popper: popper
            },
            attributes: {},
            styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options);
                state.scrollParents = {
                    reference: (0, _instanceOfJs.isElement)(reference) ? (0, _listScrollParentsJsDefault.default)(reference) : reference.contextElement ? (0, _listScrollParentsJsDefault.default)(reference.contextElement) : [],
                    popper: (0, _listScrollParentsJsDefault.default)(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = (0, _orderModifiersJsDefault.default)((0, _mergeByNameJsDefault.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers
                state.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                });
                runModifierEffects();
                return instance.update();
            },
            // Sync update  it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!areValidElements(reference, popper)) return;
                 // Store the reference and popper rects to be read by modifiers
                state.rects = {
                    reference: (0, _getCompositeRectJsDefault.default)(reference, (0, _getOffsetParentJsDefault.default)(popper), state.options.strategy === 'fixed'),
                    popper: (0, _getLayoutRectJsDefault.default)(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state.orderedModifiers.forEach(function(modifier) {
                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                for(var index = 0; index < state.orderedModifiers.length; index++){
                    if (state.reset === true) {
                        state.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === 'function') state = fn({
                        state: state,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state;
                }
            },
            // Async and optimistically optimized update  it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: (0, _debounceJsDefault.default)(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference, popper)) return instance;
        instance.setOptions(options).then(function(state) {
            if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref) {
                var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;
                if (typeof effect === 'function') {
                    var cleanupFn = effect({
                        state: state,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var createPopper = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":"ghVTw","./dom-utils/getLayoutRect.js":"76Hja","./dom-utils/listScrollParents.js":"b5rfb","./dom-utils/getOffsetParent.js":"fac6D","./utils/orderModifiers.js":"6x9qu","./utils/debounce.js":"gWj20","./utils/mergeByName.js":"8Xt9o","./utils/detectOverflow.js":"2YWVs","./dom-utils/instanceOf.js":"ipye8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ghVTw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCompositeRect);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getNodeScrollJs = require("./getNodeScroll.js");
var _getNodeScrollJsDefault = parcelHelpers.interopDefault(_getNodeScrollJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _mathJs = require("../utils/math.js");
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = (0, _mathJs.round)(rect.width) / element.offsetWidth || 1;
    var scaleY = (0, _mathJs.round)(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = (0, _instanceOfJs.isHTMLElement)(offsetParent);
    var offsetParentIsScaled = (0, _instanceOfJs.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
    var documentElement = (0, _getDocumentElementJsDefault.default)(offsetParent);
    var rect = (0, _getBoundingClientRectJsDefault.default)(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, _getNodeNameJsDefault.default)(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        (0, _isScrollParentJsDefault.default)(documentElement)) scroll = (0, _getNodeScrollJsDefault.default)(offsetParent);
        if ((0, _instanceOfJs.isHTMLElement)(offsetParent)) {
            offsets = (0, _getBoundingClientRectJsDefault.default)(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = (0, _getWindowScrollBarXJsDefault.default)(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}

},{"./getBoundingClientRect.js":"8WtHW","./getNodeScroll.js":"DCVjT","./getNodeName.js":"4Hnqb","./instanceOf.js":"ipye8","./getWindowScrollBarX.js":"dZ6cX","./getDocumentElement.js":"av3Bt","./isScrollParent.js":"kF6fv","../utils/math.js":"aHRaj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"DCVjT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getNodeScroll);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _instanceOfJs = require("./instanceOf.js");
var _getHTMLElementScrollJs = require("./getHTMLElementScroll.js");
var _getHTMLElementScrollJsDefault = parcelHelpers.interopDefault(_getHTMLElementScrollJs);
function getNodeScroll(node) {
    if (node === (0, _getWindowJsDefault.default)(node) || !(0, _instanceOfJs.isHTMLElement)(node)) return (0, _getWindowScrollJsDefault.default)(node);
    else return (0, _getHTMLElementScrollJsDefault.default)(node);
}

},{"./getWindowScroll.js":"28xxo","./getWindow.js":"fYC42","./instanceOf.js":"ipye8","./getHTMLElementScroll.js":"lJ0P1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lJ0P1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getHTMLElementScroll);
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6x9qu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>orderModifiers);
var _enumsJs = require("../enums.js"); // source: https://stackoverflow.com/questions/49875255
function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase
    return (0, _enumsJs.modifierPhases).reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}

},{"../enums.js":"jVhmu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gWj20":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>debounce);
function debounce(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Xt9o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeByName);
function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
    }, {}); // IE11 does not support Object.values
    return Object.keys(merged).map(function(key) {
        return merged[key];
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aM4Q6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopperLite", ()=>(0, _popperLiteJs.createPopper)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopper", ()=>createPopper) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator));
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _offsetJs = require("./modifiers/offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _flipJs = require("./modifiers/flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _preventOverflowJs = require("./modifiers/preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);
var _arrowJs = require("./modifiers/arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _hideJs = require("./modifiers/hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _popperLiteJs = require("./popper-lite.js");
var _indexJs = require("./modifiers/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var defaultModifiers = [
    (0, _eventListenersJsDefault.default),
    (0, _popperOffsetsJsDefault.default),
    (0, _computeStylesJsDefault.default),
    (0, _applyStylesJsDefault.default),
    (0, _offsetJsDefault.default),
    (0, _flipJsDefault.default),
    (0, _preventOverflowJsDefault.default),
    (0, _arrowJsDefault.default),
    (0, _hideJsDefault.default)
];
var createPopper = /*#__PURE__*/ (0, _createPopperJs.popperGenerator)({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"3NuA9","./modifiers/eventListeners.js":"b3l2h","./modifiers/popperOffsets.js":"iQIBA","./modifiers/computeStyles.js":"cU0Y8","./modifiers/applyStyles.js":"k3FfN","./modifiers/offset.js":"fv6qu","./modifiers/flip.js":"8TrBc","./modifiers/preventOverflow.js":"hksGy","./modifiers/arrow.js":"5tq5K","./modifiers/hide.js":"1DgVf","./popper-lite.js":false,"./modifiers/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cK1Kf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper);
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator));
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var defaultModifiers = [
    (0, _eventListenersJsDefault.default),
    (0, _popperOffsetsJsDefault.default),
    (0, _computeStylesJsDefault.default),
    (0, _applyStylesJsDefault.default)
];
var createPopper = /*#__PURE__*/ (0, _createPopperJs.popperGenerator)({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"3NuA9","./modifiers/eventListeners.js":"b3l2h","./modifiers/popperOffsets.js":"iQIBA","./modifiers/computeStyles.js":"cU0Y8","./modifiers/applyStyles.js":"k3FfN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iUHL8":[function(require,module,exports,__globalThis) {
/**
 * Adds useful functions both to SVG.Number and SVG.Point.
 *
 * @module impSVGNumber
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts number alike values to a plain `number` in the unit pixel.
 *
 * @function ensureInPx
 * @memberof SVG.Number
 * @static
 * @param {string|Number|number|SVG.Number} number
 * @returns {number} a plain `number` in px
 */ parcelHelpers.export(exports, "ensureInPx", ()=>ensureInPx);
parcelHelpers.export(exports, "closestPointOnLine", ()=>closestPointOnLine);
var _svgJs = require("@svgdotjs/svg.js");
var _selectionHelper = require("./selectionHelper");
/**
 * Conversion constants from/to any svg unit.
 *
 * @readonly
 * @enum {ToUnit}
 */ const unitConvertMap = {
    px: {
        px: 1,
        in: 1 / 96,
        cm: 127 / 4800,
        mm: 127 / 480,
        pt: 3 / 4,
        pc: 1 / 16
    },
    in: {
        px: 96,
        in: 1,
        cm: 2.54,
        mm: 25.4,
        pt: 72,
        pc: 6
    },
    cm: {
        px: 4800 / 127,
        in: 50 / 127,
        cm: 1,
        mm: 10,
        pt: 3600 / 127,
        pc: 300 / 127
    },
    mm: {
        px: 480 / 127,
        in: 5 / 127,
        cm: 0.1,
        mm: 1,
        pt: 360 / 127,
        pc: 30 / 127
    },
    pt: {
        px: 4 / 3,
        in: 1 / 72,
        cm: 127 / 3600,
        mm: 127 / 360,
        pt: 1,
        pc: 1 / 12
    },
    pc: {
        px: 16,
        in: 1 / 6,
        cm: 127 / 300,
        mm: 127 / 30,
        pt: 12,
        pc: 1
    }
};
/**
 * List of unit names. The unit with the lowest index is the most preferred one.
 *
 * @type {string[]}
 */ const unitPriority = [
    "px",
    "in",
    "pt",
    "pc",
    "cm",
    "mm"
];
/**
 * Convert two values to the same unit. The priority for unit is determined using {@link unitPriority}.
 * If the second number is not a instance of {@link SVG.Number}, it is assumed, that both numbers have the same unit.
 *
 * @param {SVG.Number} thisNumber - the first number; this number will be cloned
 * @param {SVG.Number | number} otherNumber - the second number
 * @returns {SVG.Number[]} an array of both numbers
 */ function toSameUnit(thisNumber, otherNumber) {
    const thisNumberUnit = thisNumber.unit || "px"; // Empty == "px"
    const otherNumberUnit = otherNumber instanceof _svgJs.Number ? otherNumber.unit || "px" : "px";
    let numberA = new _svgJs.Number(thisNumber);
    let numberB;
    if (!(otherNumber instanceof _svgJs.Number)) numberB = new _svgJs.Number(otherNumber, thisNumberUnit); // assume same unit
    else if (thisNumberUnit !== otherNumberUnit) {
        const thisNumberPrio = unitPriority.indexOf(thisNumberUnit);
        const otherNumberPrio = unitPriority.indexOf(otherNumberUnit);
        numberB = new _svgJs.Number(otherNumber);
        if (thisNumberPrio < otherNumberPrio) numberB = numberB.convertToUnit(thisNumberUnit);
        else numberA = numberA.convertToUnit(otherNumberUnit);
    } else numberB = new _svgJs.Number(otherNumber);
    return [
        numberA,
        numberB
    ];
}
_svgJs.extend(_svgJs.Number, {
    /**
     * Convert a SVGNumber to another unit. Does actually change the value.
     *
     * @function convertToUnit
     * @memberof SVG.Number
     * @instance
     * @this {SVG.Number}
     * @param {"px"|"in"|"cm"|"mm"|"pt"|"pc"} unit - the unit to convert to
     * @returns {SVG.Number}
     */ convertToUnit (unit) {
        /** @type {ToUnit} */ const factors = unitConvertMap[this.unit || "px"] || null;
        const factor = factors?.[unit] ?? null;
        if (factor !== null) return new _svgJs.Number(this.value * factor, unit);
        else throw new Error("Invalid unit");
    },
    /**
     * Divides this number by another svg number.
     * Returns a new instance.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the divisor
     * @returns {SVG.Number} the result
     */ divide (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        thisNumber.value /= otherNumber.value;
        return thisNumber;
    },
    /**
     * Subtracts another svg number.
     * Returns a new instance.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the subtrahend
     * @returns {SVG.Number} the result
     */ minus (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        thisNumber.value -= otherNumber.value;
        return thisNumber;
    },
    /**
     * Calculates the sum of this number and another svg number.
     * Returns a new instance.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other summand
     * @returns {SVG.Number} the result
     */ plus (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        thisNumber.value += otherNumber.value;
        return thisNumber;
    },
    /**
     * Multiplies this number with another svg number.
     * Returns a new instance.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other operand
     * @returns {SVG.Number} the result
     */ times (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        thisNumber.value *= otherNumber.value;
        return thisNumber;
    },
    /**
     * Calculates the exponentiation using this number as base.
     * Returns a new instance.
     *
     * @this {SVG.Number}
     * @param {number} exponent - the exponent
     * @returns {SVG.Number} the result
     */ pow (exponent) {
        let thisNumber = new _svgJs.Number(this);
        thisNumber.value **= exponent;
        return thisNumber;
    },
    /**
     * Calculates the remainder (modulo) of an division.
     * Returns a new instance.
     *
     * @this {SVG.Number}
     * @param {number} number - the divisor
     * @returns {SVG.Number} the result
     */ mod (number) {
        let thisNumber = new _svgJs.Number(this);
        thisNumber.value %= number;
        return thisNumber;
    },
    /**
     * Checks if this svg number is greater than the other one.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other number
     * @returns {boolean} the result
     */ gt (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        return thisNumber.value > otherNumber.value;
    },
    /**
     * Checks if this svg number is greater than the other one or equal.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other number
     * @returns {boolean} the result
     */ gte (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        return thisNumber.value >= otherNumber.value;
    },
    /**
     * Checks if this svg number is less than the other one.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other number
     * @returns {boolean} the result
     */ lt (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        return thisNumber.value < otherNumber.value;
    },
    /**
     * Checks if this svg number is less than the other one or equal.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other number
     * @returns {boolean} the result
     */ lte (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        return thisNumber.value <= otherNumber.value;
    },
    /**
     * Checks if this svg number is equal the other one.
     *
     * @this {SVG.Number}
     * @param {SVG.Number|number} number - the other number
     * @returns {boolean} the result
     */ eq (number) {
        let [thisNumber, otherNumber] = toSameUnit(this, number);
        return thisNumber.value == otherNumber.value;
    }
});
function ensureInPx(nmbr) {
    if (nmbr instanceof _svgJs.Number) return nmbr.convertToUnit("px").value;
    let num = Number(nmbr);
    if (Number.isNaN(num)) {
        if (typeof nmbr === "string") return new _svgJs.Number(nmbr).convertToUnit("px").value;
        else if (typeof nmbr === "number") return new _svgJs.Number(nmbr).convertToUnit("px").value;
        else {
            nmbr.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);
            return nmbr.value;
        }
    } else return num;
}
_svgJs.extend(_svgJs.Point, {
    /**
     * Calculate the squared distance of two points.
     *
     * @this {SVG.Point}
     * @param {SVG.Point} other - the other point
     * @returns {number} the squared distance (px^2)
     */ distanceSquared (other) {
        return (this.x - other.x) ** 2 + (this.y - other.y) ** 2;
    },
    /**
     * Calculate the distance of two points.
     *
     * @this {SVG.Point}
     * @param {SVG.Point} other - the other point
     * @returns {number} the squared distance (px)
     */ distance (other) {
        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
    },
    /**
     * Calculate the length of the vector resp. the distance from (0|0).
     *
     * @this {SVG.Point}
     * @returns {number} the squared length (px^2)
     */ absSquared () {
        return this.x ** 2 + this.y ** 2;
    },
    /**
     * Calculate the length of the vector resp. the distance from (0|0).
     *
     * @this {SVG.Point}
     * @returns {number} the length (px)
     */ abs () {
        return Math.sqrt(this.x ** 2 + this.y ** 2);
    },
    /**
     * Subtracts another svg point.
     * Returns a new instance.
     *
     * @this {SVG.Point}
     * @param {SVG.Point|number} other - the subtrahend
     * @returns {SVG.Point} the result
     */ sub (other) {
        if (other instanceof _svgJs.Point) return new _svgJs.Point(this.x - other.x, this.y - other.y);
        else return new _svgJs.Point(this.x - other, this.y - other);
    },
    /**
     * Calculates the sum of this and another svg point.
     * Returns a new instance.
     *
     * @this {SVG.Point}
     * @param {SVG.Point|number} other - the other summand
     * @returns {SVG.Point} the result
     */ add (other) {
        if (other instanceof _svgJs.Point) return new _svgJs.Point(this.x + other.x, this.y + other.y);
        else return new _svgJs.Point(this.x + other, this.y + other);
    },
    /**
     * Calculates the multiplication of this point and another svg point or number (elementwise).
     * Returns a new instance.
     */ mul (other) {
        if (other instanceof _svgJs.Point) return new _svgJs.Point(this.x * other.x, this.y * other.y);
        else return new _svgJs.Point(this.x * other, this.y * other);
    },
    /**
     * Calculates the division of this point and another svg point or number (elementwise).
     * Returns a new instance.
     */ div (other) {
        if (other instanceof _svgJs.Point) return new _svgJs.Point(this.x / other.x, this.y / other.y);
        else return new _svgJs.Point(this.x / other, this.y / other);
    },
    /**
     * calculates the dot product between this point and the other point
     */ dot (other) {
        return this.x * other.x + this.y * other.y;
    },
    /**
     * Rotate the Coordinate around `centerCoord`. The rotation is counter clockwise, like the default mathematical
     * rotation.
     *
     * @this {SVG.Point}
     * @param {number} angle - rotation angle in degrees or radians
     * @param {SVG.Point} [centerCoord] - center of rotation
     * @param {boolean} [inRad=false] - set to `true`, if the angle is in radians
     * @returns {SVG.Point} the result
     */ rotate (angle, centerCoord, inRad = false) {
        let result = centerCoord ? this.sub(centerCoord) : this.clone();
        const oldX = result.x;
        const oldY = result.y;
        const radians = inRad ? angle : Math.PI / 180 * angle, cos = Math.cos(radians), sin = Math.sin(radians);
        result.x = cos * oldX + sin * oldY;
        result.y = -sin * oldX + cos * oldY;
        if (!!centerCoord) {
            result.x += centerCoord.x;
            result.y += centerCoord.y;
        }
        return result;
    },
    /**
     * Checks if to points are equal up to a given epsilon(how far the Xs and Ys can be apart to still count as being equal)
     *
     * @param other the other point
     * @param [eps=1e-7] how far the points can be apart
     * @returns true if the points are equal
     */ eq (other, eps = 1e-7) {
        if (this.x > other.x - eps && this.x < other.x + eps && this.y > other.y - eps && this.y < other.y + eps) return true;
        return false;
    },
    /**
     * Formats the point for usage with (Circui)TikZ.
     *
     * Converts from px to cm and rounds to 2 digits after the decimal point.
     *
     * @this {SVG.Point}
     * @returns {string} the TikZ representation, e.g. "(0.1, 1.23)"
     */ toTikzString (noParantheses = false) {
        if (noParantheses) return `${(0, _selectionHelper.roundTikz)(this.x * unitConvertMap.px.cm)}, ${(0, _selectionHelper.roundTikz)(-this.y * unitConvertMap.px.cm)}`;
        else return `(${(0, _selectionHelper.roundTikz)(this.x * unitConvertMap.px.cm)}, ${(0, _selectionHelper.roundTikz)(-this.y * unitConvertMap.px.cm)})`;
    },
    toSVGPathString () {
        return this.x + " " + this.y;
    },
    simplifyForJson (digits = 3) {
        let factor = 10 ** digits;
        return new _svgJs.Point(Math.round(this.x * factor) / factor, Math.round(this.y * factor) / factor);
    }
});
_svgJs.extend(_svgJs.Color, {
    toTikzString () {
        let color = this.rgb();
        return `{rgb,255:red,${color.r.toFixed(0)};green,${color.g.toFixed(0)};blue,${color.b.toFixed(0)}}`;
    }
});
const closestPointOnLine = (P, A, B)=>{
    let dir = B.sub(A);
    let t = P.sub(A).dot(dir) / dir.dot(dir);
    return [
        A.add(dir.mul(t)),
        t
    ];
};

},{"@svgdotjs/svg.js":"fFByv","./selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"joOxp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "selectedBoxWidth", ()=>selectedBoxWidth);
parcelHelpers.export(exports, "selectionColor", ()=>selectionColor);
parcelHelpers.export(exports, "referenceColor", ()=>referenceColor);
parcelHelpers.export(exports, "hoverColor", ()=>hoverColor);
parcelHelpers.export(exports, "selectionSize", ()=>selectionSize);
parcelHelpers.export(exports, "pathPointSVG", ()=>pathPointSVG);
parcelHelpers.export(exports, "resizeSVG", ()=>resizeSVG);
parcelHelpers.export(exports, "roundTikz", ()=>roundTikz);
/**
 *
 * @param {[[number,number], [number,number]]|SVG.line} line1
 * @param {[[number,number], [number,number]]|SVG.Line} line2
 */ parcelHelpers.export(exports, "linelineIntersection", ()=>linelineIntersection);
parcelHelpers.export(exports, "lineRectIntersection", ()=>lineRectIntersection);
/**
 * check if two rectangles intersect
 * @param {SVG.Box} rect1
 * @param {SVG.Box} rect2
 * @returns {boolean}
 */ parcelHelpers.export(exports, "rectRectIntersection", ()=>rectRectIntersection);
parcelHelpers.export(exports, "pointInsideRect", ()=>pointInsideRect);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
const selectedBoxWidth = 1;
const selectionColor = "var(--bs-red)";
const referenceColor = "var(--bs-cyan)";
const hoverColor = "#FF00FF"; // magenta
const selectionSize = 16;
function pathPointSVG() {
    let circle = (0, _internal.CanvasController).instance.canvas.circle(selectionSize).fill("transparent");
    circle.node.classList.add("pathPoint");
    return circle;
}
function resizeSVG() {
    let g = (0, _internal.CanvasController).instance.canvas.group();
    g.add((0, _internal.CanvasController).instance.canvas.rect(10, 10).fill("transparent").stroke("none"));
    g.add((0, _internal.CanvasController).instance.canvas.rect(5, 5).fill("var(--bs-cyan)").stroke("none").move(2.5, 2.5));
    return g;
}
function roundTikz(n) {
    return n.toLocaleString("en", {
        maximumFractionDigits: 3,
        notation: "standard"
    });
}
function linelineIntersection(line1, line2) {
    let l1 = line1 instanceof _svgJs.Line ? line1.array() : line1;
    let l2 = line2 instanceof _svgJs.Line ? line2.array() : line2;
    let det = (l1[0][0] - l1[1][0]) * (l2[0][1] - l2[1][1]) - (l1[0][1] - l1[1][1]) * (l2[0][0] - l2[1][0]);
    if (det == 0) return false;
    let t = ((l1[0][0] - l2[0][0]) * (l2[0][1] - l2[1][1]) - (l1[0][1] - l2[0][1]) * (l2[0][0] - l2[1][0])) / det;
    let u = -((l1[0][0] - l1[1][0]) * (l1[0][1] - l2[0][1]) - (l1[0][1] - l1[1][1]) * (l1[0][0] - l2[0][0])) / det;
    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}
function lineRectIntersection(line, rect) {
    let boxPoints = [
        [
            rect.x,
            rect.y
        ],
        [
            rect.x2,
            rect.y
        ],
        [
            rect.x2,
            rect.y2
        ],
        [
            rect.x,
            rect.y2
        ],
        [
            rect.x,
            rect.y
        ]
    ];
    // line and any line of rect intersect?
    for(let index = 0; index < boxPoints.length - 1; index++){
        if (linelineIntersection(line, [
            boxPoints[index],
            boxPoints[index + 1]
        ])) return true;
    }
    // line inside rect?
    if (pointInsideRect(line instanceof _svgJs.Line ? new _svgJs.Point(line.cx(), line.cy()) : line[0], rect)) return true;
    return false;
}
function rectRectIntersection(rect1, rect2, rotationDeg1 = 0) {
    if (rotationDeg1 == 0) {
        let l1 = new _svgJs.Point(rect1.x, rect1.y);
        let r1 = new _svgJs.Point(rect1.x2, rect1.y2);
        let l2 = new _svgJs.Point(rect2.x, rect2.y);
        let r2 = new _svgJs.Point(rect2.x2, rect2.y2);
        // If one rectangle is on left side of other
        if (l1.x > r2.x || l2.x > r1.x) return false;
        // If one rectangle is above other
        if (r1.y < l2.y || r2.y < l1.y) return false;
        return true;
    }
    const rect1Center = new _svgJs.Point(rect1.cx, rect1.cy);
    // rect2 center inside rect1?
    if (pointInsideRect(new _svgJs.Point(rect2.cx, rect2.cy).rotate(-rotationDeg1, rect1Center), rect1)) return true;
    let boxPoints = [
        [
            rect1.x,
            rect1.y
        ],
        [
            rect1.x2,
            rect1.y
        ],
        [
            rect1.x2,
            rect1.y2
        ],
        [
            rect1.x,
            rect1.y2
        ]
    ];
    const points = boxPoints.map((point)=>new _svgJs.Point(point[0], point[1]).rotate(rotationDeg1, rect1Center));
    for(let index = 0; index < points.length - 1; index++){
        const A = points[index];
        const B = points[(index + 1) % points.length];
        if (lineRectIntersection([
            [
                A.x,
                A.y
            ],
            [
                B.x,
                B.y
            ]
        ], rect2)) return true;
    }
}
function pointInsideRect(point, rect) {
    let p = point instanceof _svgJs.Point ? [
        point.x,
        point.y
    ] : point;
    return p[0] >= rect.x && p[0] <= rect.x2 && p[1] >= rect.y && p[1] <= rect.y2;
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2YEDM":[function(require,module,exports,__globalThis) {
/**
 * Functions for waiting on DOM loading/DOM changes applying.
 *
 * @module DOMWatcher
 */ /**
 * Wait for a document load state.
 * Does by default wait for the `"interactive"` state (DOM loaded), but the `targetState` can also be set to
 * `"complete"` (document fully loaded).
 *
 * @param {Document} [doc=document] - the document to check the `readyState`
 * @param {"interactive"|"complete"} [targetState="complete"] - the "minimum" state to wait for
 * @returns {Promise<Document>} the loaded document
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "waitForDOMLoaded", ()=>waitForDOMLoaded);
/**
 * Wait for an element to be done loading.
 *
 * Supported elements:
 *
 * 	- {@link HTMLScriptElement}: waits on entire document to be complete
 * 	- {@link HTMLImageElement}: fully supported
 * 	- {@link HTMLObjectElement}: fully supported for object containing XML-like data
 *
 * @template {HTMLElement|string} T
 * @param {T} id - the element or its id
 * @param {Document} [doc=document] - the containing document
 * @returns {Promise<T extends HTMLElement ? (T|null) : HTMLElement>} the element
 */ parcelHelpers.export(exports, "waitForElementLoaded", ()=>waitForElementLoaded);
/**
 * @todo Test & document
 * @template {Element} T
 * @param {T} element
 * @returns {Promise<T>}
 */ parcelHelpers.export(exports, "waitForElementHasChildren", ()=>waitForElementHasChildren);
async function waitForDOMLoaded(doc = document, targetState = "interactive") {
    /** @type {DocumentReadyState[]} */ const targetStates = targetState == "complete" ? [
        "complete"
    ] : [
        "interactive",
        "complete"
    ];
    if (!targetStates.includes(doc.readyState)) // not yet loaded
    return new Promise((resolve)=>{
        const eventListener = (/** @type {Event} */ event)=>{
            if (targetStates.includes(event.target.readyState)) {
                // DOM loaded
                doc.removeEventListener("readystatechange", eventListener);
                resolve(event.target);
            }
        };
        doc.addEventListener("readystatechange", eventListener);
    });
    return doc;
}
async function waitForElementLoaded(id, doc = document) {
    /** @type {HTMLElement|null} */ let element;
    if (id instanceof HTMLElement) element = id;
    else {
        // Minimum document state: DOM loaded
        doc = await waitForDOMLoaded(doc, "interactive");
        element = doc.getElementById(id);
        if (!element) return element; // Not found
    }
    // There is no good solution for scripts --> entire document should be loaded completely
    if (element instanceof HTMLScriptElement) return waitForDOMLoaded(doc, "complete").then(()=>element);
    const objDocumentStates = [
        "inactive",
        "complete"
    ];
    const SVG_MIME = "image/svg+xml";
    if (!(element instanceof HTMLImageElement || element instanceof HTMLObjectElement) || // element without external source? --> done
    element instanceof HTMLImageElement && element.complete || // <-- for images
    element instanceof HTMLObjectElement && (!element.data || element.type === SVG_MIME && objDocumentStates.includes(element.getSVGDocument?.()?.readyState ?? "") || element.type !== SVG_MIME && objDocumentStates.includes(element.contentDocument?.readyState ?? ""))) return element;
    return new Promise((resolve)=>element.addEventListener("load", ()=>resolve(element), {
            once: true
        }));
}
function waitForElementHasChildren(element) {
    return new Promise((resolve)=>{
        if (element.children && element.children.length > 0) resolve(element);
        window.requestAnimationFrame(()=>waitForElementHasChildren(element).then(()=>resolve(element)));
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7tDMU":[function(require,module,exports,__globalThis) {
/**! 
 * hotkeys-js v3.13.15 
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. 
 * 
 * Copyright (c) 2025 kenny wong <wowohoo@qq.com> 
 * https://github.com/jaywcjlove/hotkeys-js.git 
 * 
 * @website: https://jaywcjlove.github.io/hotkeys-js
 
 * Licensed under the MIT license 
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>hotkeys);
const isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false;
/** Bind event */ function addEvent(object, event, method, useCapture) {
    if (object.addEventListener) object.addEventListener(event, method, useCapture);
    else if (object.attachEvent) object.attachEvent("on".concat(event), method);
}
function removeEvent(object, event, method, useCapture) {
    if (object.removeEventListener) object.removeEventListener(event, method, useCapture);
    else if (object.detachEvent) object.detachEvent("on".concat(event), method);
}
/** Convert modifier keys to their corresponding key codes */ function getMods(modifier, key) {
    const mods = key.slice(0, key.length - 1);
    for(let i = 0; i < mods.length; i++)mods[i] = modifier[mods[i].toLowerCase()];
    return mods;
}
/** Process the input key string and convert it to an array */ function getKeys(key) {
    if (typeof key !== 'string') key = '';
    key = key.replace(/\s/g, ''); // Match any whitespace character, including spaces, tabs, form feeds, etc.
    const keys = key.split(','); // Allow multiple shortcuts separated by ','
    let index = keys.lastIndexOf('');
    // Shortcut may include ','  special handling needed
    for(; index >= 0;){
        keys[index - 1] += ',';
        keys.splice(index, 1);
        index = keys.lastIndexOf('');
    }
    return keys;
}
/** Compare arrays of modifier keys */ function compareArray(a1, a2) {
    const arr1 = a1.length >= a2.length ? a1 : a2;
    const arr2 = a1.length >= a2.length ? a2 : a1;
    let isIndex = true;
    for(let i = 0; i < arr1.length; i++)if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
    return isIndex;
}
// Special Keys
const _keyMap = {
    backspace: 8,
    "\u232B": 8,
    tab: 9,
    clear: 12,
    enter: 13,
    "\u21A9": 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    /// https://w3c.github.io/uievents/#events-keyboard-key-location
    arrowup: 38,
    arrowdown: 40,
    arrowleft: 37,
    arrowright: 39,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ',': 188,
    '.': 190,
    '/': 191,
    '`': 192,
    '-': isff ? 173 : 189,
    '=': isff ? 61 : 187,
    ';': isff ? 59 : 186,
    '\'': 222,
    '{': 219,
    '}': 221,
    '[': 219,
    ']': 221,
    '\\': 220
};
// Modifier Keys
const _modifier = {
    // shiftKey
    "\u21E7": 16,
    shift: 16,
    // altKey
    "\u2325": 18,
    alt: 18,
    option: 18,
    // ctrlKey
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    // metaKey
    "\u2318": 91,
    cmd: 91,
    meta: 91,
    command: 91
};
const modifierMap = {
    16: 'shiftKey',
    18: 'altKey',
    17: 'ctrlKey',
    91: 'metaKey',
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
};
const _mods = {
    16: false,
    18: false,
    17: false,
    91: false
};
const _handlers = {};
// F1~F12 special key
for(let k = 1; k < 20; k++)_keyMap["f".concat(k)] = 111 + k;
/** Record the pressed keys */ let _downKeys = [];
/** Whether the window has already listened to the focus event */ let winListendFocus = null;
/** Default hotkey scope */ let _scope = 'all';
/** Map to record elements with bound events */ const elementEventMap = new Map();
/** Return key code */ const code = (x)=>_keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
const getKey = (x)=>Object.keys(_keyMap).find((k)=>_keyMap[k] === x);
const getModifier = (x)=>Object.keys(_modifier).find((k)=>_modifier[k] === x);
/** Set or get the current scope (defaults to 'all') */ function setScope(scope) {
    _scope = scope || 'all';
}
/** Get the current scope */ function getScope() {
    return _scope || 'all';
}
/** Get the key codes of the currently pressed keys */ function getPressedKeyCodes() {
    return _downKeys.slice(0);
}
function getPressedKeyString() {
    return _downKeys.map((c)=>getKey(c) || getModifier(c) || String.fromCharCode(c));
}
function getAllKeyCodes() {
    const result = [];
    Object.keys(_handlers).forEach((k)=>{
        _handlers[k].forEach((_ref)=>{
            let { key, scope, mods, shortcut } = _ref;
            result.push({
                scope,
                shortcut,
                mods,
                keys: key.split('+').map((v)=>code(v))
            });
        });
    });
    return result;
}
/** hotkey is effective only when filter return true */ function filter(event) {
    const target = event.target || event.srcElement;
    const { tagName } = target;
    let flag = true;
    const isInput = tagName === 'INPUT' && ![
        'checkbox',
        'radio',
        'range',
        'button',
        'file',
        'reset',
        'submit',
        'color'
    ].includes(target.type);
    // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>
    if (target.isContentEditable || (isInput || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) flag = false;
    return flag;
}
/** Determine whether the pressed key matches a specific key, returns true or false */ function isPressed(keyCode) {
    if (typeof keyCode === 'string') keyCode = code(keyCode); // Convert to key code
    return _downKeys.indexOf(keyCode) !== -1;
}
/** Loop through and delete all handlers with the specified scope */ function deleteScope(scope, newScope) {
    let handlers;
    let i;
    // If no scope is specified, get the current scope
    if (!scope) scope = getScope();
    for(const key in _handlers)if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];
        for(i = 0; i < handlers.length;)if (handlers[i].scope === scope) {
            const deleteItems = handlers.splice(i, 1);
            deleteItems.forEach((_ref2)=>{
                let { element } = _ref2;
                return removeKeyEvent(element);
            });
        } else i++;
    }
    // If the current scope has been deleted, reset the scope to 'all'
    if (getScope() === scope) setScope(newScope || 'all');
}
/** Clear modifier keys */ function clearModifier(event) {
    let key = event.keyCode || event.which || event.charCode;
    if (event.key && event.key.toLowerCase() === 'capslock') // Ensure that when capturing keystrokes in modern browsers,
    // uppercase and lowercase letters (such as R and r) return the same key value.
    // https://github.com/jaywcjlove/hotkeys-js/pull/514
    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
    key = code(event.key);
    const i = _downKeys.indexOf(key);
    // Remove the pressed key from the list
    if (i >= 0) _downKeys.splice(i, 1);
    // Special handling for the command key: fix the issue where keyup only triggers once for command combos
    if (event.key && event.key.toLowerCase() === 'meta') _downKeys.splice(0, _downKeys.length);
    // Clear modifier keys: shiftKey, altKey, ctrlKey, (command || metaKey)
    if (key === 93 || key === 224) key = 91;
    if (key in _mods) {
        _mods[key] = false;
        // Reset the modifier key status to false
        for(const k in _modifier)if (_modifier[k] === key) hotkeys[k] = false;
    }
}
function unbind(keysInfo) {
    // unbind(), unbind all keys
    if (typeof keysInfo === 'undefined') {
        Object.keys(_handlers).forEach((key)=>{
            Array.isArray(_handlers[key]) && _handlers[key].forEach((info)=>eachUnbind(info));
            delete _handlers[key];
        });
        removeKeyEvent(null);
    } else if (Array.isArray(keysInfo)) // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])
    keysInfo.forEach((info)=>{
        if (info.key) eachUnbind(info);
    });
    else if (typeof keysInfo === 'object') // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})
    {
        if (keysInfo.key) eachUnbind(keysInfo);
    } else if (typeof keysInfo === 'string') {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        // support old method
        // eslint-disable-line
        let [scope, method] = args;
        if (typeof scope === 'function') {
            method = scope;
            scope = '';
        }
        eachUnbind({
            key: keysInfo,
            scope,
            method,
            splitKey: '+'
        });
    }
}
/** Unbind hotkeys for a specific scope */ const eachUnbind = (_ref3)=>{
    let { key, scope, method, splitKey = '+' } = _ref3;
    const multipleKeys = getKeys(key);
    multipleKeys.forEach((originKey)=>{
        const unbindKeys = originKey.split(splitKey);
        const len = unbindKeys.length;
        const lastKey = unbindKeys[len - 1];
        const keyCode = lastKey === '*' ? '*' : code(lastKey);
        if (!_handlers[keyCode]) return;
        // If scope is not provided, get the current scope
        if (!scope) scope = getScope();
        const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
        const unbindElements = [];
        _handlers[keyCode] = _handlers[keyCode].filter((record)=>{
            // Check if the method matches; if method is provided, must be equal to unbind
            const isMatchingMethod = method ? record.method === method : true;
            const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
            if (isUnbind) unbindElements.push(record.element);
            return !isUnbind;
        });
        unbindElements.forEach((element)=>removeKeyEvent(element));
    });
};
/** Handle the callback function for the corresponding hotkey */ function eventHandler(event, handler, scope, element) {
    if (handler.element !== element) return;
    let modifiersMatch;
    // Check if it is within the current scope
    if (handler.scope === scope || handler.scope === 'all') {
        // Check whether modifier keys match (returns true if they do)
        modifiersMatch = handler.mods.length > 0;
        for(const y in _mods){
            if (Object.prototype.hasOwnProperty.call(_mods, y)) {
                if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) modifiersMatch = false;
            }
        }
        // Call the handler function; ignore if it's only a modifier key
        if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {
            handler.keys = [];
            handler.keys = handler.keys.concat(_downKeys);
            if (handler.method(event, handler) === false) {
                if (event.preventDefault) event.preventDefault();
                else event.returnValue = false;
                if (event.stopPropagation) event.stopPropagation();
                if (event.cancelBubble) event.cancelBubble = true;
            }
        }
    }
}
/** Handle the keydown event */ function dispatch(event, element) {
    const asterisk = _handlers['*'];
    let key = event.keyCode || event.which || event.charCode;
    // Ensure that when capturing keystrokes in modern browsers,
    // uppercase and lowercase letters (such as R and r) return the same key value.
    // https://github.com/jaywcjlove/hotkeys-js/pull/514
    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
    // CapsLock key
    // There's an issue where `keydown` and `keyup` events are not triggered after CapsLock is enabled to activate uppercase.
    if (event.key && event.key.toLowerCase() === 'capslock') return;
    // Form control filter: by default, shortcut keys are not triggered in form elements
    if (!hotkeys.filter.call(this, event)) return;
    // In Gecko (Firefox), the command key code is 224; unify it with WebKit (Chrome)
    // In WebKit, left and right command keys have different codes
    if (key === 93 || key === 224) key = 91;
    /**
   * Collect bound keys
   * If an Input Method Editor is processing key input and the event is keydown, return 229.
   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229
   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
   */ if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
    /**
   * Jest test cases are required.
   * ===============================
   */ [
        'metaKey',
        'ctrlKey',
        'altKey',
        'shiftKey'
    ].forEach((keyName)=>{
        const keyNum = modifierMap[keyName];
        if (event[keyName] && _downKeys.indexOf(keyNum) === -1) _downKeys.push(keyNum);
        else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) _downKeys.splice(_downKeys.indexOf(keyNum), 1);
        else if (keyName === 'metaKey' && event[keyName]) // If the command key is pressed, clear all non-modifier keys except the current event key.
        // This is because keyup for non-modifier keys will NEVER be triggered when command is pressed.
        // This is a known browser limitation.
        _downKeys = _downKeys.filter((k)=>k in modifierMap || k === key);
    });
    /**
   * -------------------------------
   */ if (key in _mods) {
        _mods[key] = true;
        // Register special modifier keys to the `hotkeys` object
        for(const k in _modifier)if (Object.prototype.hasOwnProperty.call(_modifier, k)) {
            const eventKey = modifierMap[_modifier[k]];
            hotkeys[k] = event[eventKey];
        }
        if (!asterisk) return;
    }
    // Bind the modifier keys in modifierMap to the event
    for(const e in _mods)if (Object.prototype.hasOwnProperty.call(_mods, e)) _mods[e] = event[modifierMap[e]];
    /**
   * https://github.com/jaywcjlove/hotkeys/pull/129
   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.
   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type .
   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate
   */ if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {
        if (_downKeys.indexOf(17) === -1) _downKeys.push(17);
        if (_downKeys.indexOf(18) === -1) _downKeys.push(18);
        _mods[17] = true;
        _mods[18] = true;
    }
    // Get the current scope (defaults to 'all')
    const scope = getScope();
    // Handle any hotkeys registered as '*'
    if (asterisk) {
        for(let i = 0; i < asterisk.length; i++)if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) eventHandler(event, asterisk[i], scope, element);
    }
    // If the key is not registered, return
    if (!(key in _handlers)) return;
    const handlerKey = _handlers[key];
    const keyLen = handlerKey.length;
    for(let i = 0; i < keyLen; i++){
        if (event.type === 'keydown' && handlerKey[i].keydown || event.type === 'keyup' && handlerKey[i].keyup) {
            if (handlerKey[i].key) {
                const record = handlerKey[i];
                const { splitKey } = record;
                const keyShortcut = record.key.split(splitKey);
                const _downKeysCurrent = []; // Store the current key codes
                for(let a = 0; a < keyShortcut.length; a++)_downKeysCurrent.push(code(keyShortcut[a]));
                if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) // Match found, call the handler
                eventHandler(event, record, scope, element);
            }
        }
    }
}
function hotkeys(key, option, method) {
    _downKeys = [];
    /** List of hotkeys to handle */ const keys = getKeys(key);
    let mods = [];
    /** Default scope is 'all', meaning effective in all scopes */ let scope = 'all';
    /** Element to which the hotkey events are bound */ let element = document;
    let i = 0;
    let keyup = false;
    let keydown = true;
    let splitKey = '+';
    let capture = false;
    /** Allow only a single callback */ let single = false;
    // Determine if the second argument is a function (no options provided)
    if (method === undefined && typeof option === 'function') method = option;
    // Parse options object
    if (Object.prototype.toString.call(option) === '[object Object]') {
        if (option.scope) scope = option.scope; // Set scope
        if (option.element) element = option.element; // Set binding element
        if (option.keyup) keyup = option.keyup;
        if (option.keydown !== undefined) keydown = option.keydown;
        if (option.capture !== undefined) capture = option.capture;
        if (typeof option.splitKey === 'string') splitKey = option.splitKey;
        if (option.single === true) single = true;
    }
    if (typeof option === 'string') scope = option;
    // If only one callback is allowed, unbind the existing one first
    if (single) unbind(key, scope);
    // Handle each hotkey
    for(; i < keys.length; i++){
        key = keys[i].split(splitKey); // Split into individual keys
        mods = [];
        // If it's a combination, extract modifier keys
        if (key.length > 1) mods = getMods(_modifier, key);
        // Convert non-modifier key to key code
        key = key[key.length - 1];
        key = key === '*' ? '*' : code(key); // '*' means match all hotkeys
        // Initialize handler array if this key has no handlers yet
        if (!(key in _handlers)) _handlers[key] = [];
        _handlers[key].push({
            keyup,
            keydown,
            scope,
            mods,
            shortcut: keys[i],
            method,
            key: keys[i],
            splitKey,
            element
        });
    }
    // Register hotkey event listeners on the global document
    if (typeof element !== 'undefined' && window) {
        if (!elementEventMap.has(element)) {
            const keydownListener = function() {
                let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;
                return dispatch(event, element);
            };
            const keyupListenr = function() {
                let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;
                dispatch(event, element);
                clearModifier(event);
            };
            elementEventMap.set(element, {
                keydownListener,
                keyupListenr,
                capture
            });
            addEvent(element, 'keydown', keydownListener, capture);
            addEvent(element, 'keyup', keyupListenr, capture);
        }
        // Register focus event listener once to clear pressed keys on window focus
        if (!winListendFocus) {
            const listener = ()=>{
                _downKeys = [];
            };
            winListendFocus = {
                listener,
                capture
            };
            addEvent(window, 'focus', listener, capture);
        }
    }
}
function trigger(shortcut) {
    let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
    Object.keys(_handlers).forEach((key)=>{
        const dataList = _handlers[key].filter((item)=>item.scope === scope && item.shortcut === shortcut);
        dataList.forEach((data)=>{
            if (data && data.method) data.method();
        });
    });
}
/** Clean up event listeners. After unbinding, check whether the element still has any hotkeys bound. If not, remove its event listeners. */ function removeKeyEvent(element) {
    const values = Object.values(_handlers).flat();
    const findindex = values.findIndex((_ref4)=>{
        let { element: el } = _ref4;
        return el === element;
    });
    if (findindex < 0) {
        const { keydownListener, keyupListenr, capture } = elementEventMap.get(element) || {};
        if (keydownListener && keyupListenr) {
            removeEvent(element, 'keyup', keyupListenr, capture);
            removeEvent(element, 'keydown', keydownListener, capture);
            elementEventMap.delete(element);
        }
    }
    if (values.length <= 0 || elementEventMap.size <= 0) {
        // Remove all event listeners from all elements
        const eventKeys = Object.keys(elementEventMap);
        eventKeys.forEach((el)=>{
            const { keydownListener, keyupListenr, capture } = elementEventMap.get(el) || {};
            if (keydownListener && keyupListenr) {
                removeEvent(el, 'keyup', keyupListenr, capture);
                removeEvent(el, 'keydown', keydownListener, capture);
                elementEventMap.delete(el);
            }
        });
        // Clear the elementEventMap
        elementEventMap.clear();
        // Clear all handlers
        Object.keys(_handlers).forEach((key)=>delete _handlers[key]);
        // Remove the global window focus event listener
        if (winListendFocus) {
            const { listener, capture } = winListendFocus;
            removeEvent(window, 'focus', listener, capture);
            winListendFocus = null;
        }
    }
}
const _api = {
    getPressedKeyString,
    setScope,
    getScope,
    deleteScope,
    getPressedKeyCodes,
    getAllKeyCodes,
    isPressed,
    filter,
    trigger,
    unbind,
    keyMap: _keyMap,
    modifier: _modifier,
    modifierMap
};
for(const a in _api)if (Object.prototype.hasOwnProperty.call(_api, a)) hotkeys[a] = _api[a];
if (typeof window !== 'undefined') {
    const _hotkeys = window.hotkeys;
    hotkeys.noConflict = (deep)=>{
        if (deep && window.hotkeys === hotkeys) window.hotkeys = _hotkeys;
        return hotkeys;
    };
    window.hotkeys = hotkeys;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c3hj5":[function(require,module,exports,__globalThis) {
module.exports = JSON.parse('{"name":"circutikz-designer","version":"8.0.1","private":"true","description":"An interactive, visual, online editor for creating electrical circuit diagrams for LaTeX/CircuiTikZ with ease.","license":"GPL-3.0-only","author":"Manuel Kirzinger","contributors":[{"name":"Philipp Wiedemann","email":"jan.p.wiedemann@fau.de"},{"name":"Christof Pfannenm\xfcller","email":"christof.pfannenmueller@fau.de"}],"source":"src/pages/index.html","main":"src/scripts/main.js","targets":{"main":false},"scripts":{"build":"parcel build --public-url ./","update":"npx npm-check-updates -u","prepack":"npm run build","start":"parcel serve --lazy","postversion":"git push && git push origin tag $(git describe --tags --abbrev=0)","standalone":"electron-forge start","electron":"npm run build && electron .","package":"electron-forge package","make":"electron-forge make"},"browserslist":"> 0.5%, last 2 versions, not dead","dependencies":{"@prettier/plugin-xml":"^3.4.2","@svgdotjs/svg.draggable.js":"^3.0.6","@svgdotjs/svg.js":"^3.2.4","@svgdotjs/svg.panzoom.js":"^2.1.2","bootstrap":"^5.3.7","electron-squirrel-startup":"^1.0.1","file-saver":"^2.0.5","hotkeys-js":"^3.13.15","prettier":"^3.6.2","text-to-svg":"^3.1.5"},"devDependencies":{"@electron-forge/cli":"^7.8.2","@electron-forge/maker-deb":"^7.8.2","@electron-forge/maker-rpm":"^7.8.2","@electron-forge/maker-squirrel":"^7.8.2","@electron-forge/maker-wix":"^7.8.2","@electron-forge/maker-zip":"^7.8.2","@electron-forge/plugin-auto-unpack-natives":"^7.8.2","@electron-forge/plugin-fuses":"^7.8.2","@electron/fuses":"^2.0.0","@parcel/config-default":"^2.15.4","@parcel/packager-raw-url":"^2.16.1","@parcel/plugin":"^2.15.4","@parcel/transformer-css":"^2.15.4","@parcel/transformer-html":"^2.15.4","@parcel/transformer-js":"^2.15.4","@parcel/transformer-posthtml":"^2.15.4","@parcel/transformer-sass":"^2.15.4","@parcel/transformer-svg":"^2.15.4","@parcel/transformer-typescript-tsc":"^2.15.4","@parcel/transformer-webmanifest":"^2.16.1","@parcel/transformer-xml":"^2.15.4","@types/bootstrap":"^5.2.10","@types/file-saver":"^2.0.7","@types/text-to-svg":"^3.1.4","buffer":"^6.0.3","electron":"^37.2.5","parcel":"^2.15.4","path-browserify":"^1.0.1","posthtml-include":"^2.0.1","process":"^0.11.10","sass":"^1.89.2","typescript":"^5.9.2"}}');

},{}],"3nlqp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Controller for the SVG canvas. Enables/disables zooming and panning. Manages selections
 * @class
 */ parcelHelpers.export(exports, "CanvasController", ()=>CanvasController);
var _svgJs = require("@svgdotjs/svg.js");
var _svgPanzoomJs = require("@svgdotjs/svg.panzoom.js");
var _internal = require("../internal");
class CanvasController {
    /**
     * Static variable holding the instance.
     */ static instance;
    /**
     * The (root) SVG Element. All lines and components are children of this element.
     */ canvas;
    /**
     * The background (grid)
     */ paper;
    /**
     * The line marking the x axis
     */ xAxis;
    /**
     * The line marking the y axis
     */ yAxis;
    /** Distance between major grid lines
     */ majorGridSizecm = 1;
    /** How many minor grid lines are drawn for every major grid line
     */ majorGridSubdivisions = 4;
    gridVisible = true;
    /**
     * Needed for window size changes to reconstruct the old zoom level.
     */ canvasBounds = null;
    invScreenCTM = null;
    /** zoom parameters; small zoomFactor for more granular control
     */ zoomFactor = 0.1;
    zoomMin = 0.25;
    zoomMax = 10;
    zoomCurrent = 2;
    get currentZoom() {
        return this.zoomCurrent;
    }
    /**
     * the last point on the canvas
     */ lastCanvasPoint = new _svgJs.Point(0, 0);
    /**
     * set this to the input element where a drag started to prevent the svg canvas from stealing the focus off the input element
     */ draggingFromInput = null;
    /**
     * Create the canvas controller.
     * @param {SVG.Svg} canvas - the (wrapped) svg element
     */ constructor(canvas){
        if (CanvasController.instance) return;
        localStorage.removeItem("circuitikz-designer-view");
        CanvasController.instance = this;
        this.canvas = canvas;
        this.paper = _svgJs.SVG("#grid");
        this.xAxis = _svgJs.SVG("#xAxis");
        this.yAxis = _svgJs.SVG("#yAxis");
        document.addEventListener("mouseup", (ev)=>{
            CanvasController.instance.draggingFromInput = null;
        });
        const panFactor = 20;
        let body = document.getElementsByTagName("body")[0];
        document.addEventListener("keydown", (ev)=>{
            // pan canvas manually/ move selection slightly
            if (!ev.key) return;
            if (ev.key.startsWith("Arrow") && ev.target == body) {
                let direction = new _svgJs.Point();
                direction.x = ev.key == "ArrowRight" ? 1 : ev.key == "ArrowLeft" ? -1 : 0;
                direction.y = ev.key == "ArrowUp" ? -1 : ev.key == "ArrowDown" ? 1 : 0;
                if ((0, _internal.SelectionController).instance.hasSelection()) (0, _internal.SelectionController).instance.moveSelectionRel(direction.mul(1 / this.zoomCurrent));
                else {
                    //move canvas
                    let currentViewBox = this.canvas.viewbox();
                    let newPos = new _svgJs.Point(currentViewBox.x, currentViewBox.y).add(direction.mul(panFactor / this.zoomCurrent));
                    // this.canvas.zoom(this.zoomCurrent,newPos)
                    this.canvas.viewbox(newPos.x, newPos.y, currentViewBox.w, currentViewBox.h);
                    this.movePaper({
                        detail: {}
                    });
                }
            }
        });
        this.onResizeCanvas();
        this.resetView();
        // observe page size change
        new ResizeObserver(this.onResizeCanvas.bind(this)).observe(this.canvas.node);
        // init pan & zoom
        this.activatePanning();
        // Drag picture with mouse
        canvas.on("panning", this.movePaper, this, {
            passive: false
        });
        // Mouse wheel OR pinch zoom
        // Wheel zoom is fired before the actual change and has no detail.box and is thus ignored. It will be handled by wheel.panZoom.
        canvas.on("zoom", this.movePaper, this, {
            passive: true
        });
        canvas.on("mousemove", (evt)=>{
            this.lastCanvasPoint = CanvasController.eventToPoint(evt, false);
        });
        canvas.on("touchmove", (evt)=>{
            this.lastCanvasPoint = CanvasController.eventToPoint(evt, false);
        });
        const oldViewBoxFunction = this.canvas.viewbox;
        this.canvas.viewbox = (...args)=>{
            if (arguments.length > 0) this.invScreenCTM = null;
            return oldViewBoxFunction.apply(this.canvas, args);
        };
        const oldZoomFunction = this.canvas.zoom;
        this.canvas.zoom = (...args)=>{
            if (arguments.length > 0) this.invScreenCTM = null;
            return oldZoomFunction.apply(this.canvas, args);
        };
        let gridVisibleToggle = document.getElementById("gridVisible");
        gridVisibleToggle.addEventListener("change", (ev)=>{
            this.gridVisible = gridVisibleToggle.checked;
            if (this.gridVisible) {
                if (this.paper.hasClass("d-none")) this.paper.removeClass("d-none");
            } else this.paper.addClass("d-none");
        });
    }
    setSettings(settings) {
        this.majorGridSizecm = settings.majorGridSizecm || this.majorGridSizecm;
        this.majorGridSubdivisions = settings.majorGridSubdivisions || this.majorGridSubdivisions;
        (0, _internal.PropertyController).instance.setSliderValues(this.majorGridSizecm, this.majorGridSubdivisions);
        this.gridVisible = settings.gridVisible || this.gridVisible;
        let gridVisibleToggle = document.getElementById("gridVisible");
        gridVisibleToggle.checked = this.gridVisible;
        if (!this.gridVisible) this.paper.addClass("d-none");
        if (settings.viewBox) {
            this.canvas.viewbox(settings.viewBox);
            this.canvas.zoom(settings.viewZoom, new _svgJs.Point());
            this.zoomCurrent = settings.viewZoom;
            this.onResizeCanvas();
        }
    }
    resetView() {
        // shift whole canvas down such that the origin is in the bottom left corner
        let box = this.canvas.viewbox();
        box.x = 0;
        box.y = 0;
        box.y -= box.h;
        // shift canvas up right to see the axes with the default view
        let moveAmount = Math.max(0.05 * Math.min(box.w, box.h), 10);
        box.x -= moveAmount;
        box.y += moveAmount;
        this.canvas.viewbox(box);
        this.zoomCurrent = 2;
        this.canvas.zoom(this.zoomCurrent, new _svgJs.Point());
        this.onResizeCanvas();
    }
    fitView() {
        let bbox = null;
        for (const component of (0, _internal.MainController).instance.circuitComponents){
            let compBBox = component.visualization.bbox();
            if (bbox) bbox = bbox.merge(compBBox);
            else bbox = compBBox;
        }
        if (bbox) {
            let canvasBox = this.canvas.viewbox();
            let zoomFactor = Math.min(canvasBox.w / bbox.w, canvasBox.h / bbox.h) * 0.98; // sligtly more zoomed out
            if (zoomFactor * this.zoomCurrent > this.zoomMax) zoomFactor = this.zoomMax / this.zoomCurrent;
            else if (zoomFactor * this.zoomCurrent < this.zoomMin) zoomFactor = this.zoomMin / this.zoomCurrent;
            let newSize = new _svgJs.Point(canvasBox.w, canvasBox.h).mul(zoomFactor);
            canvasBox = new _svgJs.Box(bbox.cx - newSize.x / 2, bbox.cy - newSize.y / 2, newSize.x, newSize.y);
            this.canvas.viewbox(canvasBox);
            this.zoomCurrent *= zoomFactor;
            this.canvas.zoom(this.zoomCurrent, new _svgJs.Point(bbox.cx, bbox.cy));
            this.onResizeCanvas();
        } else this.resetView();
    }
    moveComponentsForward(components) {
        if ((0, _internal.MainController).instance.circuitComponents.length < 2 || components.length == 0) return;
        let idxComps = components.map((c)=>{
            return {
                idx: (0, _internal.MainController).instance.circuitComponents.findIndex((cc)=>cc === c),
                component: c
            };
        });
        idxComps.sort((a, b)=>a.idx - b.idx).reverse();
        let lastSelectedIndex = (0, _internal.MainController).instance.circuitComponents.length;
        let switched = false;
        for (const idxComp of idxComps)if (idxComp.idx !== lastSelectedIndex - 1) {
            //switch the components
            let switchComponent = (0, _internal.MainController).instance.circuitComponents[idxComp.idx + 1];
            idxComp.component.visualization.insertAfter(switchComponent.visualization);
            (0, _internal.MainController).instance.circuitComponents[idxComp.idx] = switchComponent;
            (0, _internal.MainController).instance.circuitComponents[idxComp.idx + 1] = idxComp.component;
            lastSelectedIndex = idxComp.idx + 1;
            switched = true;
        } else lastSelectedIndex = idxComp.idx;
        if (switched) (0, _internal.Undo).addState();
    }
    moveComponentsBackward(components) {
        if ((0, _internal.MainController).instance.circuitComponents.length < 2 || components.length == 0) return;
        let idxComps = components.map((c)=>{
            return {
                idx: (0, _internal.MainController).instance.circuitComponents.findIndex((cc)=>cc === c),
                component: c
            };
        });
        idxComps.sort((a, b)=>a.idx - b.idx);
        let lastSelectedIndex = -1;
        let switched = false;
        for (const idxComp of idxComps)if (idxComp.idx !== lastSelectedIndex + 1) {
            //switch the components
            let switchComponent = (0, _internal.MainController).instance.circuitComponents[idxComp.idx - 1];
            idxComp.component.visualization.insertBefore(switchComponent.visualization);
            (0, _internal.MainController).instance.circuitComponents[idxComp.idx] = switchComponent;
            (0, _internal.MainController).instance.circuitComponents[idxComp.idx - 1] = idxComp.component;
            lastSelectedIndex = idxComp.idx - 1;
            switched = true;
        } else lastSelectedIndex = idxComp.idx;
        if (switched) (0, _internal.Undo).addState();
    }
    componentsToForeground(components) {
        if ((0, _internal.MainController).instance.circuitComponents.length < 2 || components.length == 0) return;
        let idxComps = components.map((c)=>{
            return {
                idx: (0, _internal.MainController).instance.circuitComponents.findIndex((cc)=>cc === c),
                component: c
            };
        });
        idxComps.sort((a, b)=>a.idx - b.idx);
        if (components.length < (0, _internal.MainController).instance.circuitComponents.length - idxComps[0].idx) {
            for (const idxComp of idxComps){
                idxComp.component.visualization.insertAfter((0, _internal.MainController).instance.circuitComponents.at(-1).visualization);
                (0, _internal.MainController).instance.circuitComponents.push(...(0, _internal.MainController).instance.circuitComponents.splice(idxComp.idx, 1));
            }
            (0, _internal.Undo).addState();
        }
    }
    componentsToBackground(components) {
        if ((0, _internal.MainController).instance.circuitComponents.length < 2 || components.length == 0) return;
        let idxComps = components.map((c)=>{
            return {
                idx: (0, _internal.MainController).instance.circuitComponents.findIndex((cc)=>cc === c),
                component: c
            };
        });
        idxComps.sort((a, b)=>a.idx - b.idx).reverse();
        if (components.length <= idxComps[0].idx) {
            let offset = 0;
            for (const idxComp of idxComps){
                idxComp.component.visualization.insertBefore((0, _internal.MainController).instance.circuitComponents[0].visualization);
                (0, _internal.MainController).instance.circuitComponents = (0, _internal.MainController).instance.circuitComponents.splice(idxComp.idx + offset, 1).concat((0, _internal.MainController).instance.circuitComponents);
                offset++;
            }
            (0, _internal.Undo).addState();
        }
    }
    /**
     * Deactivate the mouse and touch panning feature temporary.
     *
     * Removes listeners from the canvas.
     */ deactivatePanning() {
        // this listener must be inserted after the normal panZoom listeners --> unregister first
        this.canvas.off("wheel.panZoom", this.movePaper);
        // re-init pan & zoom
        this.canvas.panZoom({
            panning: false,
            pinchZoom: true,
            wheelZoom: true,
            panButton: 99,
            oneFingerPan: false,
            zoomFactor: this.zoomFactor,
            zoomMin: this.zoomMin,
            zoomMax: this.zoomMax
        });
        // Listens for same event as svg.panzoom.js, but is added thereafter. Thus this gets called after panzoom is
        // done moving the picture.
        // @param {WheelEvent} evt
        this.canvas.on("wheel.panZoom", this.movePaper, this, {
            passive: true
        });
    }
    /**
     * Activate the mouse and touch panning  feature. The initial state is active. Call this function only, if you
     * previously called {@link deactivatePanning}.
     *
     * Adds listeners to the canvas.
     */ activatePanning() {
        // this listener must be inserted after the normal panZoom listeners --> unregister first
        this.canvas.off("wheel.panZoom", this.movePaper);
        // init pan & zoom
        this.canvas.panZoom({
            panning: true,
            pinchZoom: true,
            wheelZoom: true,
            panButton: 2,
            oneFingerPan: false,
            zoomFactor: this.zoomFactor,
            zoomMin: this.zoomMin,
            zoomMax: this.zoomMax
        });
        // Listens for same event as svg.panzoom.js, but is added thereafter. Thus this gets called after panzoom is
        // done moving the picture.
        // @param {WheelEvent} evt
        this.canvas.on("wheel.panZoom", this.movePaper, this, {
            passive: true
        });
    }
    /**
     * Converts a point from an event to the SVG coordinate system.
     *
     * @param {PointerEvent|MouseEvent|TouchEvent} event
     * @param {boolean} snap if the pointer should check if snapping should be done
     * @returns {SVG.Point}
     */ static eventToPoint(event, snap = true) {
        //                touchstart/-move             touchend             mouse*
        //               /----------------\    /-----------------------\    /---\
        // clientXY = event.touches?.[0] ?? event.changedTouches?.[0] ?? event;
        let clientXY;
        if (window.TouchEvent && event instanceof TouchEvent) {
            let touch = event.touches.item(0) ?? event.changedTouches.item(0);
            clientXY = new _svgJs.Point(touch.clientX, touch.clientY);
        } else //@ts-ignore
        clientXY = new _svgJs.Point(event.clientX, event.clientY);
        if (!CanvasController.instance.invScreenCTM) CanvasController.instance.invScreenCTM = CanvasController.instance.canvas.screenCTM().inverseO();
        let pt = new _svgJs.Point(clientXY.x, clientXY.y).transformO(CanvasController.instance.invScreenCTM);
        return event instanceof MouseEvent && event.shiftKey || !snap ? pt : (0, _internal.SnapController).instance.snapPoint(pt, undefined);
    }
    /** how the grid should be drawn
     * @param {number} majorSizecm the distance between two major grid lines in cm
     * @param {int} majorSubdivisions how many minor grid lines are drawn per major grid line (>=1)
     */ changeGrid(majorSizecm, majorSubdivisions) {
        this.majorGridSubdivisions = majorSubdivisions;
        this.majorGridSizecm = majorSizecm;
        let minorGridDistance = majorSizecm / majorSubdivisions;
        const snapDistanceNum = new _svgJs.Number(minorGridDistance, "cm").toString();
        const snapDistancePx = new _svgJs.Number(minorGridDistance, "cm").convertToUnit("px").value;
        const majorDistanceNum = new _svgJs.Number(majorSizecm, "cm").toString();
        const majorDistancePx = new _svgJs.Number(majorSizecm, "cm").convertToUnit("px").value;
        // change small grid
        const minorGrid = document.getElementById("smallGridPattern");
        minorGrid.setAttribute("width", snapDistanceNum);
        minorGrid.setAttribute("height", snapDistanceNum);
        minorGrid.children[0]?.setAttribute("d", `M ${snapDistancePx} 0 L 0 0 0 ${snapDistancePx}`);
        // change large grid
        const majorGrid = document.getElementById("gridPattern");
        majorGrid.setAttribute("width", majorDistanceNum);
        majorGrid.setAttribute("height", majorDistanceNum);
        majorGrid.children[0]?.setAttribute("width", majorDistanceNum);
        majorGrid.children[0]?.setAttribute("height", majorDistanceNum);
        majorGrid.children[1]?.setAttribute("d", `M ${majorDistancePx} 0 L 0 0 0 ${majorDistancePx}`);
    }
    /**
     * Called if the window/page is resized.
     *
     * Corrects the canvas viewBox. Also calls `#movePaper` to fix the axis.
     */ onResizeCanvas() {
        const newCanvasBounds = this.canvas.node.getBoundingClientRect();
        /** @type {SVG.Box} */ const oldViewbox = this.canvas.viewbox() || new _svgJs.Box();
        const zoom = !this.canvasBounds ? 1 : Math.max(0.25, Math.min(10, this.canvasBounds.width / oldViewbox.width, this.canvasBounds.height / oldViewbox.height));
        const newViewbox = new _svgJs.Box(oldViewbox.x, oldViewbox.y, newCanvasBounds.width / zoom, newCanvasBounds.height / zoom);
        this.canvas.viewbox(newViewbox);
        let customEvent = new CustomEvent("", {
            detail: {
                box: newViewbox,
                event: null
            }
        });
        this.movePaper(customEvent); // fixes axis
        this.canvasBounds = newCanvasBounds;
    }
    /**
     * Move paper/grid and axis on zoom/pan.
     */ movePaper(evt) {
        if (evt.detail instanceof Object && "level" in evt.detail) this.zoomCurrent = evt.detail.level;
        let box = this.canvas.viewbox();
        this.paper.move(box.x, box.y);
        this.xAxis.attr({
            x1: box.x,
            x2: box.x2
        });
        this.yAxis.attr({
            y1: box.y,
            y2: box.y2
        });
    }
}

},{"@svgdotjs/svg.js":"fFByv","@svgdotjs/svg.panzoom.js":"6iP5x","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6iP5x":[function(require,module,exports,__globalThis) {
/*!
* @svgdotjs/svg.panzoom.js - A plugin for svg.js that enables panzoom for viewport elements
* @version 2.1.2
* https://github.com/svgdotjs/svg.panzoom.js#readme
*
* @copyright undefined
* @license MIT
*
* BUILT: Thu Jul 22 2021 14:51:35 GMT+0200 (Mitteleuropische Sommerzeit)
*/ var _svgJs = require("@svgdotjs/svg.js");
var normalizeEvent = function normalizeEvent(ev) {
    return ev.touches || [
        {
            clientX: ev.clientX,
            clientY: ev.clientY
        }
    ];
};
(0, _svgJs.extend)((0, _svgJs.Svg), {
    panZoom: function panZoom(options) {
        var _options, _options$zoomFactor, _options$zoomMin, _options$zoomMax, _options$wheelZoom, _options$pinchZoom, _options$panning, _options$panButton, _options$oneFingerPan, _options$margins, _options$wheelZoomDel, _options$wheelZoomDel2, _this = this;
        this.off('.panZoom'); // when called with false, disable panZoom
        if (options === false) return this;
        options = (_options = options) != null ? _options : {};
        var zoomFactor = (_options$zoomFactor = options.zoomFactor) != null ? _options$zoomFactor : 2;
        var zoomMin = (_options$zoomMin = options.zoomMin) != null ? _options$zoomMin : Number.MIN_VALUE;
        var zoomMax = (_options$zoomMax = options.zoomMax) != null ? _options$zoomMax : Number.MAX_VALUE;
        var doWheelZoom = (_options$wheelZoom = options.wheelZoom) != null ? _options$wheelZoom : true;
        var doPinchZoom = (_options$pinchZoom = options.pinchZoom) != null ? _options$pinchZoom : true;
        var doPanning = (_options$panning = options.panning) != null ? _options$panning : true;
        var panButton = (_options$panButton = options.panButton) != null ? _options$panButton : 0;
        var oneFingerPan = (_options$oneFingerPan = options.oneFingerPan) != null ? _options$oneFingerPan : false;
        var margins = (_options$margins = options.margins) != null ? _options$margins : false;
        var wheelZoomDeltaModeLinePixels = (_options$wheelZoomDel = options.wheelZoomDeltaModeLinePixels) != null ? _options$wheelZoomDel : 17;
        var wheelZoomDeltaModeScreenPixels = (_options$wheelZoomDel2 = options.wheelZoomDeltaModeScreenPixels) != null ? _options$wheelZoomDel2 : 53;
        var lastP;
        var lastTouches;
        var zoomInProgress = false;
        var viewbox = this.viewbox();
        var restrictToMargins = function restrictToMargins(box) {
            if (!margins) return box;
            var top = margins.top, left = margins.left, bottom = margins.bottom, right = margins.right;
            var _this$attr = _this.attr([
                'width',
                'height'
            ]), width = _this$attr.width, height = _this$attr.height;
            var preserveAspectRatio = _this.node.preserveAspectRatio.baseVal; // The current viewport (exactly what is shown on the screen, what we ultimately want to restrict)
            // is not always exactly the same as current viewbox. They are different when the viewbox aspectRatio and the svg aspectRatio
            // are different and preserveAspectRatio is not "none". These offsets represent the difference in user coordinates
            // between the side of the viewbox and the side of the viewport.
            var viewportLeftOffset = 0;
            var viewportRightOffset = 0;
            var viewportTopOffset = 0;
            var viewportBottomOffset = 0; // preserveAspectRatio none has no offsets
            if (preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE) {
                var svgAspectRatio = width / height;
                var viewboxAspectRatio = viewbox.width / viewbox.height; // when aspectRatios are the same, there are no offsets
                if (viewboxAspectRatio !== svgAspectRatio) {
                    // aspectRatio unknown is like meet because that's the default
                    var isMeet = preserveAspectRatio.meetOrSlice !== preserveAspectRatio.SVG_MEETORSLICE_SLICE;
                    var changedAxis = svgAspectRatio > viewboxAspectRatio ? 'width' : 'height';
                    var isWidth = changedAxis === 'width';
                    var changeHorizontal = isMeet && isWidth || !isMeet && !isWidth;
                    var ratio = changeHorizontal ? svgAspectRatio / viewboxAspectRatio : viewboxAspectRatio / svgAspectRatio;
                    var offset = box[changedAxis] - box[changedAxis] * ratio;
                    if (changeHorizontal) {
                        if (preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX) {
                            viewportLeftOffset = offset / 2;
                            viewportRightOffset = -offset / 2;
                        } else if (preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX) viewportRightOffset = -offset;
                        else if (preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX) viewportLeftOffset = offset;
                    } else {
                        if (preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID) {
                            viewportTopOffset = offset / 2;
                            viewportBottomOffset = -offset / 2;
                        } else if (preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN) viewportBottomOffset = -offset;
                        else if (preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX || preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX) viewportTopOffset = offset;
                    }
                }
            } // when box.x == leftLimit, the image is panned to the left,
            // i.e the current box is to the right of the initial viewbox,
            // and only the right part of the initial image is visible, i.e.
            // the right side of the initial viewbox minus left margin (viewbox.x+viewbox.width-left)
            // is aligned with the left side of the viewport (box.x + viewportLeftOffset):
            // viewbox.width + viewbox.x - left = box.x + viewportLeftOffset
            // viewbox.width + viewbox.x - left - viewportLeftOffset = box.x (= leftLimit)
            var leftLimit = viewbox.width + viewbox.x - left - viewportLeftOffset; // when box.x == rightLimit, the image is panned to the right,
            // i.e the current box is to the left of the initial viewbox
            // and only the left part of the initial image is visible, i.e
            // the left side of the initial viewbox plus right margin (viewbox.x + right)
            // is aligned with the right side of the viewport (box.x + box.width + viewportRightOffset)
            // viewbox.x + right = box.x + box.width + viewportRightOffset
            // viewbox.x + right - box.width - viewportRightOffset = box.x (= rightLimit)
            var rightLimit = viewbox.x + right - box.width - viewportRightOffset; // same with top and bottom
            var topLimit = viewbox.height + viewbox.y - top - viewportTopOffset;
            var bottomLimit = viewbox.y + bottom - box.height - viewportBottomOffset;
            box.x = Math.min(leftLimit, Math.max(rightLimit, box.x)); // enforce rightLimit <= box.x <= leftLimit
            box.y = Math.min(topLimit, Math.max(bottomLimit, box.y)); // enforce bottomLimit <= box.y <= topLimit
            return box;
        };
        var wheelZoom = function wheelZoom(ev) {
            ev.preventDefault(); // When wheeling on a mouse,
            // - chrome by default uses deltaY = 53, deltaMode = 0 (pixel)
            // - firefox by default uses deltaY = 3, deltaMode = 1 (line)
            // - chrome and firefox on windows after configuring "One screen at a time"
            //   use deltaY = 1, deltaMode = 2 (screen)
            //
            // Note that when when wheeling on a touchpad, deltaY depends on how fast
            // you swipe, but the deltaMode is still different between the browsers.
            //
            // Normalize everything so that zooming speed is approximately the same in all cases
            var normalizedPixelDeltaY;
            switch(ev.deltaMode){
                case 1:
                    normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeLinePixels;
                    break;
                case 2:
                    normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeScreenPixels;
                    break;
                default:
                    // 0 (already pixels) or new mode (avoid crashing)
                    normalizedPixelDeltaY = ev.deltaY;
                    break;
            }
            var lvl = Math.pow(1 + zoomFactor, -1 * normalizedPixelDeltaY / 100) * this.zoom();
            var p = this.point(ev.clientX, ev.clientY);
            if (lvl > zoomMax) lvl = zoomMax;
            if (lvl < zoomMin) lvl = zoomMin;
            if (this.dispatch('zoom', {
                level: lvl,
                focus: p
            }).defaultPrevented) return this;
            this.zoom(lvl, p);
            if (margins) {
                var box = restrictToMargins(this.viewbox());
                this.viewbox(box);
            }
        };
        var pinchZoomStart = function pinchZoomStart(ev) {
            lastTouches = normalizeEvent(ev); // Start panning in case only one touch is found
            if (lastTouches.length < 2) {
                if (doPanning && oneFingerPan) panStart.call(this, ev);
                return;
            } // Stop panning for more than one touch
            if (doPanning && oneFingerPan) panStop.call(this, ev);
             // We call it so late, so the user is still able to scroll / reload the page via gesture
            // In case oneFingerPan is not active
            ev.preventDefault();
            if (this.dispatch('pinchZoomStart', {
                event: ev
            }).defaultPrevented) return;
            this.off('touchstart.panZoom', pinchZoomStart);
            zoomInProgress = true;
            (0, _svgJs.on)(document, 'touchmove.panZoom', pinchZoom, this, {
                passive: false
            });
            (0, _svgJs.on)(document, 'touchend.panZoom', pinchZoomStop, this, {
                passive: false
            });
        };
        var pinchZoomStop = function pinchZoomStop(ev) {
            ev.preventDefault();
            var currentTouches = normalizeEvent(ev);
            if (currentTouches.length > 1) return;
            zoomInProgress = false;
            this.dispatch('pinchZoomEnd', {
                event: ev
            });
            (0, _svgJs.off)(document, 'touchmove.panZoom', pinchZoom);
            (0, _svgJs.off)(document, 'touchend.panZoom', pinchZoomStop);
            this.on('touchstart.panZoom', pinchZoomStart);
            if (currentTouches.length && doPanning && oneFingerPan) panStart.call(this, ev);
        };
        var pinchZoom = function pinchZoom(ev) {
            ev.preventDefault();
            var currentTouches = normalizeEvent(ev);
            var zoom = this.zoom(); // Distance Formula
            var lastDelta = Math.sqrt(Math.pow(lastTouches[0].clientX - lastTouches[1].clientX, 2) + Math.pow(lastTouches[0].clientY - lastTouches[1].clientY, 2));
            var currentDelta = Math.sqrt(Math.pow(currentTouches[0].clientX - currentTouches[1].clientX, 2) + Math.pow(currentTouches[0].clientY - currentTouches[1].clientY, 2));
            var zoomAmount = lastDelta / currentDelta;
            if (zoom < zoomMin && zoomAmount > 1 || zoom > zoomMax && zoomAmount < 1) zoomAmount = 1;
            var currentFocus = {
                x: currentTouches[0].clientX + 0.5 * (currentTouches[1].clientX - currentTouches[0].clientX),
                y: currentTouches[0].clientY + 0.5 * (currentTouches[1].clientY - currentTouches[0].clientY)
            };
            var lastFocus = {
                x: lastTouches[0].clientX + 0.5 * (lastTouches[1].clientX - lastTouches[0].clientX),
                y: lastTouches[0].clientY + 0.5 * (lastTouches[1].clientY - lastTouches[0].clientY)
            };
            var p = this.point(currentFocus.x, currentFocus.y);
            var focusP = this.point(2 * currentFocus.x - lastFocus.x, 2 * currentFocus.y - lastFocus.y);
            var box = new (0, _svgJs.Box)(this.viewbox()).transform(new (0, _svgJs.Matrix)().translate(-focusP.x, -focusP.y).scale(zoomAmount, 0, 0).translate(p.x, p.y));
            restrictToMargins(box);
            this.viewbox(box);
            lastTouches = currentTouches;
            this.dispatch('zoom', {
                box: box,
                focus: focusP
            });
        };
        var panStart = function panStart(ev) {
            var isMouse = ev.type.indexOf('mouse') > -1; // In case panStart is called with touch, ev.button is undefined
            if (isMouse && ev.button !== panButton && ev.which !== panButton + 1) return;
            ev.preventDefault();
            this.off('mousedown.panZoom', panStart);
            lastTouches = normalizeEvent(ev);
            if (zoomInProgress) return;
            this.dispatch('panStart', {
                event: ev
            });
            lastP = {
                x: lastTouches[0].clientX,
                y: lastTouches[0].clientY
            };
            (0, _svgJs.on)(document, 'touchmove.panZoom mousemove.panZoom', panning, this, {
                passive: false
            });
            (0, _svgJs.on)(document, 'touchend.panZoom mouseup.panZoom', panStop, this, {
                passive: false
            });
        };
        var panStop = function panStop(ev) {
            ev.preventDefault();
            (0, _svgJs.off)(document, 'touchmove.panZoom mousemove.panZoom', panning);
            (0, _svgJs.off)(document, 'touchend.panZoom mouseup.panZoom', panStop);
            this.on('mousedown.panZoom', panStart);
            this.dispatch('panEnd', {
                event: ev
            });
        };
        var panning = function panning(ev) {
            ev.preventDefault();
            var currentTouches = normalizeEvent(ev);
            var currentP = {
                x: currentTouches[0].clientX,
                y: currentTouches[0].clientY
            };
            var p1 = this.point(currentP.x, currentP.y);
            var p2 = this.point(lastP.x, lastP.y);
            var deltaP = [
                p2.x - p1.x,
                p2.y - p1.y
            ];
            if (!deltaP[0] && !deltaP[1]) return;
            var box = new (0, _svgJs.Box)(this.viewbox()).transform(new (0, _svgJs.Matrix)().translate(deltaP[0], deltaP[1]));
            lastP = currentP;
            restrictToMargins(box);
            if (this.dispatch('panning', {
                box: box,
                event: ev
            }).defaultPrevented) return;
            this.viewbox(box);
        };
        if (doWheelZoom) this.on('wheel.panZoom', wheelZoom, this, {
            passive: false
        });
        if (doPinchZoom) this.on('touchstart.panZoom', pinchZoomStart, this, {
            passive: false
        });
        if (doPanning) this.on('mousedown.panZoom', panStart, this, {
            passive: false
        });
        return this;
    }
});

},{"@svgdotjs/svg.js":"fFByv"}],"bYHDp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Controller for the erase function/mode.
 */ parcelHelpers.export(exports, "EraseController", ()=>EraseController);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
class EraseController {
    static _instance;
    constructor(){
        this.moveStart = this.moveStart.bind(this);
        this.moveListener = this.moveListener.bind(this);
        this.addUndo = this.addUndo.bind(this);
    }
    static get instance() {
        if (!EraseController._instance) EraseController._instance = new EraseController();
        return EraseController._instance;
    }
    dragging = false;
    didErase = false;
    deactivate() {
        // unregister move listener
        (0, _internal.CanvasController).instance.canvas.node.classList.remove("eraseCursor");
        (0, _internal.CanvasController).instance.canvas.off("mousedown", this.moveStart);
        (0, _internal.CanvasController).instance.canvas.off("touchdown", this.moveStart);
        (0, _internal.CanvasController).instance.canvas.off("mousemove", this.moveListener);
        (0, _internal.CanvasController).instance.canvas.off("touchmove", this.moveListener);
        (0, _internal.CanvasController).instance.canvas.off("mouseup", this.addUndo);
        (0, _internal.CanvasController).instance.canvas.off("touchend", this.addUndo);
    }
    activate() {
        (0, _internal.CanvasController).instance.canvas.node.classList.add("eraseCursor");
        (0, _internal.CanvasController).instance.canvas.on("mousedown", this.moveStart);
        (0, _internal.CanvasController).instance.canvas.on("touchstart", this.moveStart);
        (0, _internal.CanvasController).instance.canvas.on("mousemove", this.moveListener);
        (0, _internal.CanvasController).instance.canvas.on("touchmove", this.moveListener);
        (0, _internal.CanvasController).instance.canvas.on("mouseup", this.addUndo);
        (0, _internal.CanvasController).instance.canvas.on("touchend", this.addUndo);
    }
    moveStart(event) {
        if (event instanceof MouseEvent && event.button !== 0) return;
        if (window.TouchEvent && event instanceof TouchEvent && event.touches.length !== 1) return;
        this.dragging = true;
    }
    moveListener(event) {
        if (!this.dragging) return;
        if (event instanceof MouseEvent && (event.buttons & 1 || event.type !== "mousemove" && event.button === 0) || window.TouchEvent && event instanceof TouchEvent && window.TouchEvent && event.touches.length === 1) this.findAndErase((0, _internal.CanvasController).eventToPoint(event, false));
    }
    addUndo(event) {
        if (event instanceof MouseEvent && event.button !== 0) return;
        if (window.TouchEvent && event instanceof TouchEvent && event.touches.length !== 0) return;
        if (this.didErase) {
            (0, _internal.Undo).addState();
            this.didErase = false;
        }
        this.dragging = false;
    }
    findAndErase(pos) {
        let intersectionRect = new _svgJs.Box(pos.x - 5, pos.y - 5, 10, 10);
        for (const component of (0, _internal.MainController).instance.circuitComponents)if (component.isInsideSelectionRectangle(intersectionRect)) {
            (0, _internal.MainController).instance.removeComponent(component);
            this.didErase = true;
            break;
        }
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5kipo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Contains export functions and controls the "exportModal" (~dialog).
 * @class
 */ parcelHelpers.export(exports, "ExportController", ()=>ExportController);
var _bootstrap = require("bootstrap");
var _internal = require("../internal");
var _fileSaver = require("file-saver");
var _fileSaverDefault = parcelHelpers.interopDefault(_fileSaver);
var _prettier = require("prettier");
var _svgJs = require("@svgdotjs/svg.js");
const parserXML = require("914ed7aa87aa981d").default;
class ExportController {
    static _instance;
    static get instance() {
        if (!ExportController._instance) ExportController._instance = new ExportController();
        return ExportController._instance;
    }
    modalElement;
    modal;
    heading;
    exportedContent;
    fileBasename;
    fileExtension;
    fileExtensionDropdown;
    copyButton;
    saveButton;
    imagePreview;
    imagePreviewCanvas;
    copyTooltip;
    defaultDisplay;
    exportImageCanvas = null;
    usedIDs;
    createExportID(prefix = "N") {
        let currentID;
        if (this.usedIDs.has(prefix)) {
            currentID = this.usedIDs.get(prefix);
            currentID++;
        } else currentID = 1;
        while(this.isIDUsed(prefix + currentID))currentID++;
        this.usedIDs.set(prefix, currentID);
        return prefix + currentID;
    }
    isIDUsed(id) {
        for (const component of (0, _internal.MainController).instance.circuitComponents)// check if another component with the same name already exists
        if ("name" in component) {
            let name = component.name;
            if (name.value == id) return true;
        }
        return false;
    }
    /**
     * Init the ExportController
     */ constructor(){
        this.modalElement = document.getElementById("exportModal");
        this.modal = new (0, _bootstrap.Modal)(this.modalElement);
        this.heading = document.getElementById("exportModalLabel");
        this.exportedContent = document.getElementById("exportedContent");
        this.fileBasename = document.getElementById("exportModalFileBasename");
        this.fileExtension = document.getElementById("exportModalFileExtension");
        this.fileExtensionDropdown = document.getElementById("exportModalFileExtensionDropdown");
        this.copyButton = document.getElementById("copyExportedContent");
        this.saveButton = document.getElementById("exportModalSave");
        this.imagePreview = document.getElementById("exportImagePreview");
        this.imagePreviewCanvas = document.getElementById("exportImagePreviewCanvas");
        this.defaultDisplay = this.exportedContent.parentElement.style.display;
        let copyButtonDefaultTooltipText = "Copy to clipboard!";
        this.copyButton.addEventListener("hidden.bs.tooltip", (evt)=>{
            this.copyButton.setAttribute("data-bs-title", copyButtonDefaultTooltipText);
            this.copyTooltip.dispose();
            this.copyTooltip = new (0, _bootstrap.Tooltip)(this.copyButton);
        });
        this.copyButton.setAttribute("data-bs-toggle", "tooltip");
        this.copyButton.setAttribute("data-bs-title", copyButtonDefaultTooltipText);
        this.copyTooltip = new (0, _bootstrap.Tooltip)(this.copyButton);
        this.usedIDs = new Map();
    }
    exportJSON(text) {
        this.heading.textContent = "Save JSON";
        // create extension select list
        const extensions = [
            ".json",
            ".txt"
        ];
        this.exportedContent.rows = Math.max(text.split("\n").length, 2);
        this.exportedContent.value = text;
        this.export(extensions);
    }
    /**
     * Shows the exportModal with the CitcuiTikZ code.
     */ exportCircuiTikZ() {
        this.heading.innerHTML = "Export CircuiTi<i>k</i>Z code";
        this.exportedContent.parentElement.style.display = this.defaultDisplay;
        // create extension select list
        const extensions = [
            ".tikz",
            ".tex",
            ".pgf"
        ];
        // actually export/create the string
        {
            let circuitElements = [];
            let requiredTikzLibraries = new Set();
            for (const circuitElement of (0, _internal.MainController).instance.circuitComponents){
                circuitElement.requiredTikzLibraries().forEach((item)=>requiredTikzLibraries.add(item));
                circuitElements.push("\t" + circuitElement.toTikzString());
            }
            let libraryStr = requiredTikzLibraries.size > 0 ? "\\usetikzlibrary{" + requiredTikzLibraries.values().toArray().join(", ") + "}" : "";
            let arr = [
                "\\begin{tikzpicture}",
                "\t% Paths, nodes and wires:",
                ...circuitElements,
                "\\end{tikzpicture}"
            ];
            if (libraryStr) arr = [
                libraryStr
            ].concat(arr);
            this.exportedContent.rows = arr.length;
            this.exportedContent.value = arr.join("\n");
        }
        this.usedIDs.clear();
        this.export(extensions);
    }
    /**
     * Shows the exportModal with the SVG code.
     */ exportSVG() {
        this.heading.textContent = "Export SVG";
        this.exportedContent.parentElement.style.display = this.defaultDisplay;
        // prepare selection and bounding box
        (0, _internal.SelectionController).instance.selectAll();
        (0, _internal.SelectionController).instance.deactivateSelection();
        let colorTheme = (0, _internal.MainController).instance.darkMode;
        (0, _internal.MainController).instance.darkMode = false;
        (0, _internal.MainController).instance.updateTheme();
        //Get the canvas
        let svgObj = new _svgJs.Svg();
        svgObj.node.style.fontSize = "10pt";
        svgObj.node.style.overflow = "visible";
        // get all used node/symbol names
        let defsMap = new Map();
        let components = [];
        for (const instance of (0, _internal.MainController).instance.circuitComponents)components.push(instance.toSVG(defsMap));
        // add to defs
        if (defsMap.size > 0) {
            const defs = new _svgJs.Defs();
            for (const element of defsMap)defs.add(element[1]);
            svgObj.add(defs);
        }
        for (const component of components)svgObj.add(component);
        //basic cleanup of invisible components (fill and stroke both need to be invisible)
        for (const removeElement of svgObj.find(':is([fill-opacity="0"],[fill="none"],[fill="transparent"]):is([stroke-opacity="0"],[stroke="none"],[stroke-width="0"],[stroke="transparent"])'))removeElement.remove();
        //basic draggable class
        for (const removeClass of svgObj.find(".draggable"))removeClass.removeClass("draggable");
        // bounding box to include all elements
        let bbox = svgObj.bbox();
        if (bbox) {
            //make bbox 2px larger in every direction to not cut of tiny bits of some objects
            bbox.x -= 2;
            bbox.y -= 2;
            bbox.width += 4;
            bbox.height += 4;
            svgObj.viewbox(bbox);
        }
        // convert to text and make pretty
        let tempDiv = document.createElement("div");
        tempDiv.appendChild(svgObj.node);
        tempDiv.innerHTML = tempDiv.innerHTML.replaceAll((0, _internal.defaultStroke), "#000").replaceAll((0, _internal.defaultFill), "#fff");
        _prettier.format(tempDiv.innerHTML.replaceAll("<br>", "<br/>"), {
            parser: "xml",
            plugins: [
                parserXML
            ],
            tabWidth: 4,
            singleAttributePerLine: true,
            xmlWhitespaceSensitivity: "preserve"
        }).then((textContent)=>{
            this.exportedContent.rows = textContent.split("\n").length;
            this.exportedContent.value = textContent;
            const extensions = [
                ".svg",
                ".txt"
            ];
            this.export(extensions);
            (0, _internal.SelectionController).instance.activateSelection();
            tempDiv.remove();
        });
        (0, _internal.MainController).instance.darkMode = colorTheme;
        (0, _internal.MainController).instance.updateTheme();
    }
    /**
     * Exports the circuit as an image (PNG or JPG).
     * Converts SVG to raster image format using Canvas API.
     */ exportImage() {
        this.heading.textContent = "Export Image";
        this.exportedContent.parentElement.style.display = "none"; // Hide textarea for image export
        this.imagePreview.style.display = "block"; // Show image preview
        // prepare selection and bounding box
        (0, _internal.SelectionController).instance.selectAll();
        (0, _internal.SelectionController).instance.deactivateSelection();
        let colorTheme = (0, _internal.MainController).instance.darkMode;
        (0, _internal.MainController).instance.darkMode = false;
        (0, _internal.MainController).instance.updateTheme();
        //Get the canvas
        let svgObj = new _svgJs.Svg();
        svgObj.node.style.fontSize = "10pt";
        svgObj.node.style.overflow = "visible";
        // get all used node/symbol names
        let defsMap = new Map();
        let components = [];
        for (const instance of (0, _internal.MainController).instance.circuitComponents)components.push(instance.toSVG(defsMap));
        // add to defs
        if (defsMap.size > 0) {
            const defs = new _svgJs.Defs();
            for (const element of defsMap)defs.add(element[1]);
            svgObj.add(defs);
        }
        for (const component of components)svgObj.add(component);
        //basic cleanup of invisible components (fill and stroke both need to be invisible)
        for (const removeElement of svgObj.find(':is([fill-opacity="0"],[fill="none"],[fill="transparent"]):is([stroke-opacity="0"],[stroke="none"],[stroke-width="0"],[stroke="transparent"])'))removeElement.remove();
        //basic draggable class
        for (const removeClass of svgObj.find(".draggable"))removeClass.removeClass("draggable");
        // bounding box to include all elements
        let bbox = svgObj.bbox();
        if (!bbox || bbox.width === 0 || bbox.height === 0) // If no valid bbox, use default size
        bbox = {
            x: 0,
            y: 0,
            width: 800,
            height: 600
        };
        else {
            //make bbox 2px larger in every direction to not cut of tiny bits of some objects
            bbox.x -= 2;
            bbox.y -= 2;
            bbox.width += 4;
            bbox.height += 4;
        }
        svgObj.viewbox(bbox);
        // convert SVG to image
        let tempDiv = document.createElement("div");
        tempDiv.appendChild(svgObj.node);
        let svgString = tempDiv.innerHTML.replaceAll((0, _internal.defaultStroke), "#000").replaceAll((0, _internal.defaultFill), "#fff");
        // Add XML namespace if not present
        if (!svgString.includes('xmlns="http://www.w3.org/2000/svg"')) svgString = svgString.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
        console.log("SVG String length:", svgString.length);
        console.log("SVG preview:", svgString.substring(0, 200));
        // Create image from SVG
        const img = new Image();
        img.crossOrigin = "anonymous";
        const svgBlob = new Blob([
            svgString
        ], {
            type: "image/svg+xml;charset=utf-8"
        });
        const url = URL.createObjectURL(svgBlob);
        console.log("Blob URL created:", url);
        img.onload = ()=>{
            try {
                console.log("Image loaded successfully, bbox:", bbox);
                // Create canvas with appropriate size
                // Use higher scale for small circuits to prevent blurry images
                // Minimum dimension of 800px to ensure good quality even for single components
                const minDimension = 800;
                const baseScale = 4; // Higher base scale for better quality
                let scale = baseScale;
                // If bbox is very small, scale up more to reach minimum dimension
                if (bbox.width * scale < minDimension || bbox.height * scale < minDimension) {
                    const scaleForWidth = minDimension / bbox.width;
                    const scaleForHeight = minDimension / bbox.height;
                    scale = Math.max(scaleForWidth, scaleForHeight);
                }
                const canvas = document.createElement("canvas");
                canvas.width = bbox.width * scale;
                canvas.height = bbox.height * scale;
                const ctx = canvas.getContext("2d");
                if (!ctx) {
                    console.error("Failed to get canvas context");
                    return;
                }
                console.log("Canvas created:", canvas.width, "x", canvas.height);
                // Fill with white background
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Draw image
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                console.log("Image drawn to canvas");
                // Store canvas for export
                this.exportedContent.value = ""; // Clear text content
                this.exportImageCanvas = canvas;
                // Show preview
                const previewCtx = this.imagePreviewCanvas.getContext("2d");
                this.imagePreviewCanvas.width = canvas.width;
                this.imagePreviewCanvas.height = canvas.height;
                if (previewCtx) previewCtx.drawImage(canvas, 0, 0);
                const extensions = [
                    ".png",
                    ".jpg"
                ];
                this.export(extensions);
                // Cleanup
                URL.revokeObjectURL(url);
                (0, _internal.SelectionController).instance.activateSelection();
                tempDiv.remove();
                (0, _internal.MainController).instance.darkMode = colorTheme;
                (0, _internal.MainController).instance.updateTheme();
            } catch (error) {
                console.error("Error creating image:", error);
                URL.revokeObjectURL(url);
                (0, _internal.SelectionController).instance.activateSelection();
                tempDiv.remove();
                (0, _internal.MainController).instance.darkMode = colorTheme;
                (0, _internal.MainController).instance.updateTheme();
            }
        };
        img.onerror = (error)=>{
            console.error("Error loading SVG image:", error);
            URL.revokeObjectURL(url);
            (0, _internal.SelectionController).instance.activateSelection();
            tempDiv.remove();
            (0, _internal.MainController).instance.darkMode = colorTheme;
            (0, _internal.MainController).instance.updateTheme();
        };
        img.src = url;
    }
    export(extensions) {
        const isImageExport = this.exportImageCanvas !== null;
        // copy text and adjust tooltip for feedback (only for text exports)
        const copyText = ()=>{
            if (!isImageExport) navigator.clipboard.writeText(this.exportedContent.value).then(()=>{
                this.copyButton.setAttribute("data-bs-title", "Copied!");
                this.copyTooltip.dispose();
                this.copyTooltip = new (0, _bootstrap.Tooltip)(this.copyButton);
                this.copyTooltip.show();
            });
        };
        // create listeners
        const saveFile = (()=>{
            const filename = (this.fileBasename.value.trim() || (0, _internal.MainController).instance.designName.value).replace(/[^a-z0-9]/gi, "_") || "Circuit";
            if (isImageExport && this.exportImageCanvas) // Export as image
            this.exportImageCanvas.toBlob((blob)=>{
                if (blob) (0, _fileSaverDefault.default).saveAs(blob, filename + this.fileExtension.value);
            }, this.fileExtension.value === ".png" ? "image/png" : "image/jpeg", 0.95);
            else // Export as text
            (0, _fileSaverDefault.default).saveAs(new Blob([
                this.exportedContent.value
            ], {
                type: "text/x-tex;charset=utf-8"
            }), filename + this.fileExtension.value);
        }).bind(this);
        const hideListener = (()=>{
            this.exportedContent.value = ""; // free memory
            this.exportImageCanvas = null; // clear canvas reference
            this.imagePreview.style.display = "none"; // hide image preview
            this.exportedContent.parentElement.style.display = this.defaultDisplay; // restore textarea
            this.copyButton.removeEventListener("click", copyText);
            this.saveButton.removeEventListener("click", saveFile);
            this.fileExtensionDropdown.replaceChildren();
            // "once" is not always supported:
            this.modalElement.removeEventListener("hidden.bs.modal", hideListener);
        }).bind(this);
        this.modalElement.addEventListener("hidden.bs.modal", hideListener, {
            passive: true,
            once: true
        });
        // create extension select list
        this.fileExtension.value = extensions[0];
        this.fileExtensionDropdown.replaceChildren(...extensions.map((ext)=>{
            const link = document.createElement("a");
            link.textContent = ext;
            link.classList.add("dropdown-item");
            link.addEventListener("click", ()=>this.fileExtension.value = ext, {
                passive: true
            });
            const listElement = document.createElement("li");
            listElement.appendChild(link);
            return listElement;
        }));
        // Hide/show copy button based on export type
        if (isImageExport) this.copyButton.style.display = "none";
        else this.copyButton.style.display = "";
        // add listeners & show modal
        this.copyButton.addEventListener("click", copyText, {
            passive: true
        });
        this.saveButton.addEventListener("click", saveFile, {
            passive: true
        });
        this.modal.show();
    }
}

},{"bootstrap":"hjCRY","../internal":"f6vBb","file-saver":"apCnQ","prettier":"6PPT6","@svgdotjs/svg.js":"fFByv","914ed7aa87aa981d":"6VKVS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"apCnQ":[function(require,module,exports,__globalThis) {
var global = arguments[3];
(function(a, b) {
    if ("function" == typeof define && define.amd) define([], b);
    else b();
})(this, function() {
    "use strict";
    function b(a, b) {
        return "undefined" == typeof b ? b = {
            autoBom: !1
        } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([
            "\uFEFF",
            a
        ], {
            type: a.type
        }) : a;
    }
    function c(a, b, c) {
        var d = new XMLHttpRequest;
        d.open("GET", a), d.responseType = "blob", d.onload = function() {
            g(d.response, b, c);
        }, d.onerror = function() {
            console.error("could not download file");
        }, d.send();
    }
    function d(a) {
        var b = new XMLHttpRequest;
        b.open("HEAD", a, !1);
        try {
            b.send();
        } catch (a) {}
        return 200 <= b.status && 299 >= b.status;
    }
    function e(a) {
        try {
            a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {} : "download" in HTMLAnchorElement.prototype && !a ? function(b, g, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function() {
            i.revokeObjectURL(j.href);
        }, 4E4), setTimeout(function() {
            e(j);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);
        else if (d(f)) c(f, g, h);
        else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function() {
                e(i);
            });
        }
    } : function(b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
        var h = "application/octet-stream" === b.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader;
            k.onloadend = function() {
                var a = k.result;
                a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
            }, k.readAsDataURL(b);
        } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b);
            g ? g.location = m : location.href = m, g = null, setTimeout(function() {
                l.revokeObjectURL(m);
            }, 4E4);
        }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
});

},{}],"6PPT6":[function(require,module,exports,__globalThis) {
(function(t) {
    function e() {
        var o = t();
        return o.default || o;
    }
    var f;
    module.exports = e();
})(function() {
    "use strict";
    var Fu = Object.create;
    var Ue = Object.defineProperty;
    var pu = Object.getOwnPropertyDescriptor;
    var du = Object.getOwnPropertyNames;
    var mu = Object.getPrototypeOf, Eu = Object.prototype.hasOwnProperty;
    var Zt = (e)=>{
        throw TypeError(e);
    };
    var Cu = (e, t)=>()=>(t || e((t = {
                exports: {}
            }).exports, t), t.exports), dt = (e, t)=>{
        for(var r in t)Ue(e, r, {
            get: t[r],
            enumerable: !0
        });
    }, er = (e, t, r, n)=>{
        if (t && typeof t == "object" || typeof t == "function") for (let u of du(t))!Eu.call(e, u) && u !== r && Ue(e, u, {
            get: ()=>t[u],
            enumerable: !(n = pu(t, u)) || n.enumerable
        });
        return e;
    };
    var hu = (e, t, r)=>(r = e != null ? Fu(mu(e)) : {}, er(t || !e || !e.__esModule ? Ue(r, "default", {
            value: e,
            enumerable: !0
        }) : r, e)), gu = (e)=>er(Ue({}, "__esModule", {
            value: !0
        }), e);
    var yu = (e, t, r)=>t.has(e) || Zt("Cannot " + r);
    var tr = (e, t, r)=>t.has(e) ? Zt("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
    var fe = (e, t, r)=>(yu(e, t, "access private method"), r);
    var Pn = Cu((Mt)=>{
        "use strict";
        Object.defineProperty(Mt, "__esModule", {
            value: !0
        });
        function Co() {
            return new Proxy({}, {
                get: ()=>(e)=>e
            });
        }
        var On = /\r\n|[\n\r\u2028\u2029]/;
        function ho(e, t, r) {
            let n = Object.assign({
                column: 0,
                line: -1
            }, e.start), u = Object.assign({}, n, e.end), { linesAbove: o = 2, linesBelow: i = 3 } = r || {}, s = n.line, a = n.column, c = u.line, D = u.column, p = Math.max(s - (o + 1), 0), l = Math.min(t.length, c + i);
            s === -1 && (p = 0), c === -1 && (l = t.length);
            let F = c - s, f = {};
            if (F) for(let d = 0; d <= F; d++){
                let m = d + s;
                if (!a) f[m] = !0;
                else if (d === 0) {
                    let C = t[m - 1].length;
                    f[m] = [
                        a,
                        C - a + 1
                    ];
                } else if (d === F) f[m] = [
                    0,
                    D
                ];
                else {
                    let C = t[m - d].length;
                    f[m] = [
                        0,
                        C
                    ];
                }
            }
            else a === D ? a ? f[s] = [
                a,
                0
            ] : f[s] = !0 : f[s] = [
                a,
                D - a
            ];
            return {
                start: p,
                end: l,
                markerLines: f
            };
        }
        function go(e, t, r = {}) {
            let u = Co(!1), o = e.split(On), { start: i, end: s, markerLines: a } = ho(t, o, r), c = t.start && typeof t.start.column == "number", D = String(s).length, l = e.split(On, s).slice(i, s).map((F, f)=>{
                let d = i + 1 + f, C = ` ${` ${d}`.slice(-D)} |`, E = a[d], h = !a[d + 1];
                if (E) {
                    let x = "";
                    if (Array.isArray(E)) {
                        let A = F.slice(0, Math.max(E[0] - 1, 0)).replace(/[^\t]/g, " "), $ = E[1] || 1;
                        x = [
                            `
 `,
                            u.gutter(C.replace(/\d/g, " ")),
                            " ",
                            A,
                            u.marker("^").repeat($)
                        ].join(""), h && r.message && (x += " " + u.message(r.message));
                    }
                    return [
                        u.marker(">"),
                        u.gutter(C),
                        F.length > 0 ? ` ${F}` : "",
                        x
                    ].join("");
                } else return ` ${u.gutter(C)}${F.length > 0 ? ` ${F}` : ""}`;
            }).join(`
`);
            return r.message && !c && (l = `${" ".repeat(D + 1)}${r.message}
${l}`), l;
        }
        Mt.codeFrameColumns = go;
    });
    var oi = {};
    dt(oi, {
        __debug: ()=>ui,
        check: ()=>ri,
        doc: ()=>qt,
        format: ()=>fu,
        formatWithCursor: ()=>cu,
        getSupportInfo: ()=>ni,
        util: ()=>Qt,
        version: ()=>tu
    });
    var Au = (e, t, r, n)=>{
        if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    }, te = Au;
    var _e = class {
        diff(t, r, n = {}) {
            let u;
            typeof n == "function" ? (u = n, n = {}) : "callback" in n && (u = n.callback);
            let o = this.castInput(t, n), i = this.castInput(r, n), s = this.removeEmpty(this.tokenize(o, n)), a = this.removeEmpty(this.tokenize(i, n));
            return this.diffWithOptionsObj(s, a, n, u);
        }
        diffWithOptionsObj(t, r, n, u) {
            var o;
            let i = (E)=>{
                if (E = this.postProcess(E, n), u) {
                    setTimeout(function() {
                        u(E);
                    }, 0);
                    return;
                } else return E;
            }, s = r.length, a = t.length, c = 1, D = s + a;
            n.maxEditLength != null && (D = Math.min(D, n.maxEditLength));
            let p = (o = n.timeout) !== null && o !== void 0 ? o : 1 / 0, l = Date.now() + p, F = [
                {
                    oldPos: -1,
                    lastComponent: void 0
                }
            ], f = this.extractCommon(F[0], r, t, 0, n);
            if (F[0].oldPos + 1 >= a && f + 1 >= s) return i(this.buildValues(F[0].lastComponent, r, t));
            let d = -1 / 0, m = 1 / 0, C = ()=>{
                for(let E = Math.max(d, -c); E <= Math.min(m, c); E += 2){
                    let h, x = F[E - 1], A = F[E + 1];
                    x && (F[E - 1] = void 0);
                    let $ = !1;
                    if (A) {
                        let Be = A.oldPos - E;
                        $ = A && 0 <= Be && Be < s;
                    }
                    let ue = x && x.oldPos + 1 < a;
                    if (!$ && !ue) {
                        F[E] = void 0;
                        continue;
                    }
                    if (!ue || $ && x.oldPos < A.oldPos ? h = this.addToPath(A, !0, !1, 0, n) : h = this.addToPath(x, !1, !0, 1, n), f = this.extractCommon(h, r, t, E, n), h.oldPos + 1 >= a && f + 1 >= s) return i(this.buildValues(h.lastComponent, r, t)) || !0;
                    F[E] = h, h.oldPos + 1 >= a && (m = Math.min(m, E - 1)), f + 1 >= s && (d = Math.max(d, E + 1));
                }
                c++;
            };
            if (u) (function E() {
                setTimeout(function() {
                    if (c > D || Date.now() > l) return u(void 0);
                    C() || E();
                }, 0);
            })();
            else for(; c <= D && Date.now() <= l;){
                let E = C();
                if (E) return E;
            }
        }
        addToPath(t, r, n, u, o) {
            let i = t.lastComponent;
            return i && !o.oneChangePerToken && i.added === r && i.removed === n ? {
                oldPos: t.oldPos + u,
                lastComponent: {
                    count: i.count + 1,
                    added: r,
                    removed: n,
                    previousComponent: i.previousComponent
                }
            } : {
                oldPos: t.oldPos + u,
                lastComponent: {
                    count: 1,
                    added: r,
                    removed: n,
                    previousComponent: i
                }
            };
        }
        extractCommon(t, r, n, u, o) {
            let i = r.length, s = n.length, a = t.oldPos, c = a - u, D = 0;
            for(; c + 1 < i && a + 1 < s && this.equals(n[a + 1], r[c + 1], o);)c++, a++, D++, o.oneChangePerToken && (t.lastComponent = {
                count: 1,
                previousComponent: t.lastComponent,
                added: !1,
                removed: !1
            });
            return D && !o.oneChangePerToken && (t.lastComponent = {
                count: D,
                previousComponent: t.lastComponent,
                added: !1,
                removed: !1
            }), t.oldPos = a, c;
        }
        equals(t, r, n) {
            return n.comparator ? n.comparator(t, r) : t === r || !!n.ignoreCase && t.toLowerCase() === r.toLowerCase();
        }
        removeEmpty(t) {
            let r = [];
            for(let n = 0; n < t.length; n++)t[n] && r.push(t[n]);
            return r;
        }
        castInput(t, r) {
            return t;
        }
        tokenize(t, r) {
            return Array.from(t);
        }
        join(t) {
            return t.join("");
        }
        postProcess(t, r) {
            return t;
        }
        get useLongestToken() {
            return !1;
        }
        buildValues(t, r, n) {
            let u = [], o;
            for(; t;)u.push(t), o = t.previousComponent, delete t.previousComponent, t = o;
            u.reverse();
            let i = u.length, s = 0, a = 0, c = 0;
            for(; s < i; s++){
                let D = u[s];
                if (D.removed) D.value = this.join(n.slice(c, c + D.count)), c += D.count;
                else {
                    if (!D.added && this.useLongestToken) {
                        let p = r.slice(a, a + D.count);
                        p = p.map(function(l, F) {
                            let f = n[c + F];
                            return f.length > l.length ? f : l;
                        }), D.value = this.join(p);
                    } else D.value = this.join(r.slice(a, a + D.count));
                    a += D.count, D.added || (c += D.count);
                }
            }
            return u;
        }
    };
    var mt = class extends _e {
        tokenize(t) {
            return t.slice();
        }
        join(t) {
            return t;
        }
        removeEmpty(t) {
            return t;
        }
    }, rr = new mt;
    function Et(e, t, r) {
        return rr.diff(e, t, r);
    }
    function nr(e) {
        let t = e.indexOf("\r");
        return t !== -1 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
    }
    function xe(e) {
        switch(e){
            case "cr":
                return "\r";
            case "crlf":
                return `\r
`;
            default:
                return `
`;
        }
    }
    function Ct(e, t) {
        let r;
        switch(t){
            case `
`:
                r = /\n/gu;
                break;
            case "\r":
                r = /\r/gu;
                break;
            case `\r
`:
                r = /\r\n/gu;
                break;
            default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
        }
        let n = e.match(r);
        return n ? n.length : 0;
    }
    function ur(e) {
        return te(!1, e, /\r\n?/gu, `
`);
    }
    var W = "string", Y = "array", j = "cursor", N = "indent", O = "align", P = "trim", B = "group", k = "fill", _ = "if-break", v = "indent-if-break", L = "line-suffix", I = "line-suffix-boundary", g = "line", S = "label", w = "break-parent", Ve = new Set([
        j,
        N,
        O,
        P,
        B,
        k,
        _,
        v,
        L,
        I,
        g,
        S,
        w
    ]);
    var Bu = (e, t, r)=>{
        if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
    }, y = Bu;
    function or(e) {
        let t = e.length;
        for(; t > 0 && (e[t - 1] === "\r" || e[t - 1] === `
`);)t--;
        return t < e.length ? e.slice(0, t) : e;
    }
    function _u(e) {
        if (typeof e == "string") return W;
        if (Array.isArray(e)) return Y;
        if (!e) return;
        let { type: t } = e;
        if (Ve.has(t)) return t;
    }
    var M = _u;
    var xu = (e)=>new Intl.ListFormat("en-US", {
            type: "disjunction"
        }).format(e);
    function wu(e) {
        let t = e === null ? "null" : typeof e;
        if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
        if (M(e)) throw new Error("doc is valid.");
        let r = Object.prototype.toString.call(e);
        if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
        let n = xu([
            ...Ve
        ].map((u)=>`'${u}'`));
        return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
    }
    var ht = class extends Error {
        name = "InvalidDocError";
        constructor(t){
            super(wu(t)), this.doc = t;
        }
    }, q = ht;
    var ir = {};
    function bu(e, t, r, n) {
        let u = [
            e
        ];
        for(; u.length > 0;){
            let o = u.pop();
            if (o === ir) {
                r(u.pop());
                continue;
            }
            r && u.push(o, ir);
            let i = M(o);
            if (!i) throw new q(o);
            if ((t == null ? void 0 : t(o)) !== !1) switch(i){
                case Y:
                case k:
                    {
                        let s = i === Y ? o : o.parts;
                        for(let a = s.length, c = a - 1; c >= 0; --c)u.push(s[c]);
                        break;
                    }
                case _:
                    u.push(o.flatContents, o.breakContents);
                    break;
                case B:
                    if (n && o.expandedStates) for(let s = o.expandedStates.length, a = s - 1; a >= 0; --a)u.push(o.expandedStates[a]);
                    else u.push(o.contents);
                    break;
                case O:
                case N:
                case v:
                case S:
                case L:
                    u.push(o.contents);
                    break;
                case W:
                case j:
                case P:
                case I:
                case g:
                case w:
                    break;
                default:
                    throw new q(o);
            }
        }
    }
    var le = bu;
    function be(e, t) {
        if (typeof e == "string") return t(e);
        let r = new Map;
        return n(e);
        function n(o) {
            if (r.has(o)) return r.get(o);
            let i = u(o);
            return r.set(o, i), i;
        }
        function u(o) {
            switch(M(o)){
                case Y:
                    return t(o.map(n));
                case k:
                    return t({
                        ...o,
                        parts: o.parts.map(n)
                    });
                case _:
                    return t({
                        ...o,
                        breakContents: n(o.breakContents),
                        flatContents: n(o.flatContents)
                    });
                case B:
                    {
                        let { expandedStates: i, contents: s } = o;
                        return i ? (i = i.map(n), s = i[0]) : s = n(s), t({
                            ...o,
                            contents: s,
                            expandedStates: i
                        });
                    }
                case O:
                case N:
                case v:
                case S:
                case L:
                    return t({
                        ...o,
                        contents: n(o.contents)
                    });
                case W:
                case j:
                case P:
                case I:
                case g:
                case w:
                    return t(o);
                default:
                    throw new q(o);
            }
        }
    }
    function $e(e, t, r) {
        let n = r, u = !1;
        function o(i) {
            if (u) return !1;
            let s = t(i);
            s !== void 0 && (u = !0, n = s);
        }
        return le(e, o), n;
    }
    function ku(e) {
        if (e.type === B && e.break || e.type === g && e.hard || e.type === w) return !0;
    }
    function Dr(e) {
        return $e(e, ku, !1);
    }
    function sr(e) {
        if (e.length > 0) {
            let t = y(!1, e, -1);
            !t.expandedStates && !t.break && (t.break = "propagated");
        }
        return null;
    }
    function cr(e) {
        let t = new Set, r = [];
        function n(o) {
            if (o.type === w && sr(r), o.type === B) {
                if (r.push(o), t.has(o)) return !1;
                t.add(o);
            }
        }
        function u(o) {
            o.type === B && r.pop().break && sr(r);
        }
        le(e, n, u, !0);
    }
    function Su(e) {
        return e.type === g && !e.hard ? e.soft ? "" : " " : e.type === _ ? e.flatContents : e;
    }
    function fr(e) {
        return be(e, Su);
    }
    function ar(e) {
        for(e = [
            ...e
        ]; e.length >= 2 && y(!1, e, -2).type === g && y(!1, e, -1).type === w;)e.length -= 2;
        if (e.length > 0) {
            let t = we(y(!1, e, -1));
            e[e.length - 1] = t;
        }
        return e;
    }
    function we(e) {
        switch(M(e)){
            case N:
            case v:
            case B:
            case L:
            case S:
                {
                    let t = we(e.contents);
                    return {
                        ...e,
                        contents: t
                    };
                }
            case _:
                return {
                    ...e,
                    breakContents: we(e.breakContents),
                    flatContents: we(e.flatContents)
                };
            case k:
                return {
                    ...e,
                    parts: ar(e.parts)
                };
            case Y:
                return ar(e);
            case W:
                return or(e);
            case O:
            case j:
            case P:
            case I:
            case g:
            case w:
                break;
            default:
                throw new q(e);
        }
        return e;
    }
    function We(e) {
        return we(Nu(e));
    }
    function Tu(e) {
        switch(M(e)){
            case k:
                if (e.parts.every((t)=>t === "")) return "";
                break;
            case B:
                if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
                if (e.contents.type === B && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
                break;
            case O:
            case N:
            case v:
            case L:
                if (!e.contents) return "";
                break;
            case _:
                if (!e.flatContents && !e.breakContents) return "";
                break;
            case Y:
                {
                    let t = [];
                    for (let r of e){
                        if (!r) continue;
                        let [n, ...u] = Array.isArray(r) ? r : [
                            r
                        ];
                        typeof n == "string" && typeof y(!1, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...u);
                    }
                    return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
                }
            case W:
            case j:
            case P:
            case I:
            case g:
            case S:
            case w:
                break;
            default:
                throw new q(e);
        }
        return e;
    }
    function Nu(e) {
        return be(e, (t)=>Tu(t));
    }
    function lr(e, t = Me) {
        return be(e, (r)=>typeof r == "string" ? ke(t, r.split(`
`)) : r);
    }
    function Ou(e) {
        if (e.type === g) return !0;
    }
    function Fr(e) {
        return $e(e, Ou, !1);
    }
    function Fe(e, t) {
        return e.type === S ? {
            ...e,
            contents: t(e.contents)
        } : t(e);
    }
    var gt = ()=>{}, K = gt, yt = gt, pr = gt;
    function ie(e) {
        return K(e), {
            type: N,
            contents: e
        };
    }
    function oe(e, t) {
        return K(t), {
            type: O,
            contents: t,
            n: e
        };
    }
    function At(e, t = {}) {
        return K(e), yt(t.expandedStates, !0), {
            type: B,
            id: t.id,
            contents: e,
            break: !!t.shouldBreak,
            expandedStates: t.expandedStates
        };
    }
    function dr(e) {
        return oe(Number.NEGATIVE_INFINITY, e);
    }
    function mr(e) {
        return oe({
            type: "root"
        }, e);
    }
    function Er(e) {
        return oe(-1, e);
    }
    function Cr(e, t) {
        return At(e[0], {
            ...t,
            expandedStates: e
        });
    }
    function hr(e) {
        return pr(e), {
            type: k,
            parts: e
        };
    }
    function gr(e, t = "", r = {}) {
        return K(e), t !== "" && K(t), {
            type: _,
            breakContents: e,
            flatContents: t,
            groupId: r.groupId
        };
    }
    function yr(e, t) {
        return K(e), {
            type: v,
            contents: e,
            groupId: t.groupId,
            negate: t.negate
        };
    }
    function Se(e) {
        return K(e), {
            type: L,
            contents: e
        };
    }
    var Ar = {
        type: I
    }, pe = {
        type: w
    }, Br = {
        type: P
    }, Te = {
        type: g,
        hard: !0
    }, Bt = {
        type: g,
        hard: !0,
        literal: !0
    }, Ge = {
        type: g
    }, _r = {
        type: g,
        soft: !0
    }, z = [
        Te,
        pe
    ], Me = [
        Bt,
        pe
    ], X = {
        type: j
    };
    function ke(e, t) {
        K(e), yt(t);
        let r = [];
        for(let n = 0; n < t.length; n++)n !== 0 && r.push(e), r.push(t[n]);
        return r;
    }
    function Ke(e, t, r) {
        K(e);
        let n = e;
        if (t > 0) {
            for(let u = 0; u < Math.floor(t / r); ++u)n = ie(n);
            n = oe(t % r, n), n = oe(Number.NEGATIVE_INFINITY, n);
        }
        return n;
    }
    function xr(e, t) {
        return K(t), e ? {
            type: S,
            label: e,
            contents: t
        } : t;
    }
    function Q(e) {
        var t;
        if (!e) return "";
        if (Array.isArray(e)) {
            let r = [];
            for (let n of e)if (Array.isArray(n)) r.push(...Q(n));
            else {
                let u = Q(n);
                u !== "" && r.push(u);
            }
            return r;
        }
        return e.type === _ ? {
            ...e,
            breakContents: Q(e.breakContents),
            flatContents: Q(e.flatContents)
        } : e.type === B ? {
            ...e,
            contents: Q(e.contents),
            expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(Q)
        } : e.type === k ? {
            type: "fill",
            parts: e.parts.map(Q)
        } : e.contents ? {
            ...e,
            contents: Q(e.contents)
        } : e;
    }
    function wr(e) {
        let t = Object.create(null), r = new Set;
        return n(Q(e));
        function n(o, i, s) {
            var a, c;
            if (typeof o == "string") return JSON.stringify(o);
            if (Array.isArray(o)) {
                let D = o.map(n).filter(Boolean);
                return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
            }
            if (o.type === g) {
                let D = ((a = s == null ? void 0 : s[i + 1]) == null ? void 0 : a.type) === w;
                return o.literal ? D ? "literalline" : "literallineWithoutBreakParent" : o.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : o.soft ? "softline" : "line";
            }
            if (o.type === w) return ((c = s == null ? void 0 : s[i - 1]) == null ? void 0 : c.type) === g && s[i - 1].hard ? void 0 : "breakParent";
            if (o.type === P) return "trim";
            if (o.type === N) return "indent(" + n(o.contents) + ")";
            if (o.type === O) return o.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(o.contents) + ")" : o.n < 0 ? "dedent(" + n(o.contents) + ")" : o.n.type === "root" ? "markAsRoot(" + n(o.contents) + ")" : "align(" + JSON.stringify(o.n) + ", " + n(o.contents) + ")";
            if (o.type === _) return "ifBreak(" + n(o.breakContents) + (o.flatContents ? ", " + n(o.flatContents) : "") + (o.groupId ? (o.flatContents ? "" : ', ""') + `, { groupId: ${u(o.groupId)} }` : "") + ")";
            if (o.type === v) {
                let D = [];
                o.negate && D.push("negate: true"), o.groupId && D.push(`groupId: ${u(o.groupId)}`);
                let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                return `indentIfBreak(${n(o.contents)}${p})`;
            }
            if (o.type === B) {
                let D = [];
                o.break && o.break !== "propagated" && D.push("shouldBreak: true"), o.id && D.push(`id: ${u(o.id)}`);
                let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                return o.expandedStates ? `conditionalGroup([${o.expandedStates.map((l)=>n(l)).join(",")}]${p})` : `group(${n(o.contents)}${p})`;
            }
            if (o.type === k) return `fill([${o.parts.map((D)=>n(D)).join(", ")}])`;
            if (o.type === L) return "lineSuffix(" + n(o.contents) + ")";
            if (o.type === I) return "lineSuffixBoundary";
            if (o.type === S) return `label(${JSON.stringify(o.label)}, ${n(o.contents)})`;
            if (o.type === j) return "cursor";
            throw new Error("Unknown doc type " + o.type);
        }
        function u(o) {
            if (typeof o != "symbol") return JSON.stringify(String(o));
            if (o in t) return t[o];
            let i = o.description || "symbol";
            for(let s = 0;; s++){
                let a = i + (s > 0 ? ` #${s}` : "");
                if (!r.has(a)) return r.add(a), t[o] = `Symbol.for(${JSON.stringify(a)})`;
            }
        }
    }
    var br = ()=>/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    function kr(e) {
        return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
    }
    function Sr(e) {
        return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
    }
    var Tr = (e)=>!(kr(e) || Sr(e));
    var Pu = /[^\x20-\x7F]/u;
    function vu(e) {
        if (!e) return 0;
        if (!Pu.test(e)) return e.length;
        e = e.replace(br(), "  ");
        let t = 0;
        for (let r of e){
            let n = r.codePointAt(0);
            n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += Tr(n) ? 1 : 2);
        }
        return t;
    }
    var Ne = vu;
    var R = Symbol("MODE_BREAK"), H = Symbol("MODE_FLAT"), de = Symbol("cursor"), _t = Symbol("DOC_FILL_PRINTED_LENGTH");
    function Nr() {
        return {
            value: "",
            length: 0,
            queue: []
        };
    }
    function Lu(e, t) {
        return xt(e, {
            type: "indent"
        }, t);
    }
    function Iu(e, t, r) {
        return t === Number.NEGATIVE_INFINITY ? e.root || Nr() : t < 0 ? xt(e, {
            type: "dedent"
        }, r) : t ? t.type === "root" ? {
            ...e,
            root: e
        } : xt(e, {
            type: typeof t == "string" ? "stringAlign" : "numberAlign",
            n: t
        }, r) : e;
    }
    function xt(e, t, r) {
        let n = t.type === "dedent" ? e.queue.slice(0, -1) : [
            ...e.queue,
            t
        ], u = "", o = 0, i = 0, s = 0;
        for (let f of n)switch(f.type){
            case "indent":
                D(), r.useTabs ? a(1) : c(r.tabWidth);
                break;
            case "stringAlign":
                D(), u += f.n, o += f.n.length;
                break;
            case "numberAlign":
                i += 1, s += f.n;
                break;
            default:
                throw new Error(`Unexpected type '${f.type}'`);
        }
        return l(), {
            ...e,
            value: u,
            length: o,
            queue: n
        };
        function a(f) {
            u += "	".repeat(f), o += r.tabWidth * f;
        }
        function c(f) {
            u += " ".repeat(f), o += f;
        }
        function D() {
            r.useTabs ? p() : l();
        }
        function p() {
            i > 0 && a(i), F();
        }
        function l() {
            s > 0 && c(s), F();
        }
        function F() {
            i = 0, s = 0;
        }
    }
    function wt(e) {
        let t = 0, r = 0, n = e.length;
        e: for(; n--;){
            let u = e[n];
            if (u === de) {
                r++;
                continue;
            }
            for(let o = u.length - 1; o >= 0; o--){
                let i = u[o];
                if (i === " " || i === "	") t++;
                else {
                    e[n] = u.slice(0, o + 1);
                    break e;
                }
            }
        }
        if (t > 0 || r > 0) for(e.length = n + 1; r-- > 0;)e.push(de);
        return t;
    }
    function ze(e, t, r, n, u, o) {
        if (r === Number.POSITIVE_INFINITY) return !0;
        let i = t.length, s = [
            e
        ], a = [];
        for(; r >= 0;){
            if (s.length === 0) {
                if (i === 0) return !0;
                s.push(t[--i]);
                continue;
            }
            let { mode: c, doc: D } = s.pop(), p = M(D);
            switch(p){
                case W:
                    a.push(D), r -= Ne(D);
                    break;
                case Y:
                case k:
                    {
                        let l = p === Y ? D : D.parts, F = D[_t] ?? 0;
                        for(let f = l.length - 1; f >= F; f--)s.push({
                            mode: c,
                            doc: l[f]
                        });
                        break;
                    }
                case N:
                case O:
                case v:
                case S:
                    s.push({
                        mode: c,
                        doc: D.contents
                    });
                    break;
                case P:
                    r += wt(a);
                    break;
                case B:
                    {
                        if (o && D.break) return !1;
                        let l = D.break ? R : c, F = D.expandedStates && l === R ? y(!1, D.expandedStates, -1) : D.contents;
                        s.push({
                            mode: l,
                            doc: F
                        });
                        break;
                    }
                case _:
                    {
                        let F = (D.groupId ? u[D.groupId] || H : c) === R ? D.breakContents : D.flatContents;
                        F && s.push({
                            mode: c,
                            doc: F
                        });
                        break;
                    }
                case g:
                    if (c === R || D.hard) return !0;
                    D.soft || (a.push(" "), r--);
                    break;
                case L:
                    n = !0;
                    break;
                case I:
                    if (n) return !1;
                    break;
            }
        }
        return !1;
    }
    function me(e, t) {
        let r = {}, n = t.printWidth, u = xe(t.endOfLine), o = 0, i = [
            {
                ind: Nr(),
                mode: R,
                doc: e
            }
        ], s = [], a = !1, c = [], D = 0;
        for(cr(e); i.length > 0;){
            let { ind: l, mode: F, doc: f } = i.pop();
            switch(M(f)){
                case W:
                    {
                        let d = u !== `
` ? te(!1, f, `
`, u) : f;
                        s.push(d), i.length > 0 && (o += Ne(d));
                        break;
                    }
                case Y:
                    for(let d = f.length - 1; d >= 0; d--)i.push({
                        ind: l,
                        mode: F,
                        doc: f[d]
                    });
                    break;
                case j:
                    if (D >= 2) throw new Error("There are too many 'cursor' in doc.");
                    s.push(de), D++;
                    break;
                case N:
                    i.push({
                        ind: Lu(l, t),
                        mode: F,
                        doc: f.contents
                    });
                    break;
                case O:
                    i.push({
                        ind: Iu(l, f.n, t),
                        mode: F,
                        doc: f.contents
                    });
                    break;
                case P:
                    o -= wt(s);
                    break;
                case B:
                    switch(F){
                        case H:
                            if (!a) {
                                i.push({
                                    ind: l,
                                    mode: f.break ? R : H,
                                    doc: f.contents
                                });
                                break;
                            }
                        case R:
                            {
                                a = !1;
                                let d = {
                                    ind: l,
                                    mode: H,
                                    doc: f.contents
                                }, m = n - o, C = c.length > 0;
                                if (!f.break && ze(d, i, m, C, r)) i.push(d);
                                else if (f.expandedStates) {
                                    let E = y(!1, f.expandedStates, -1);
                                    if (f.break) {
                                        i.push({
                                            ind: l,
                                            mode: R,
                                            doc: E
                                        });
                                        break;
                                    } else for(let h = 1; h < f.expandedStates.length + 1; h++)if (h >= f.expandedStates.length) {
                                        i.push({
                                            ind: l,
                                            mode: R,
                                            doc: E
                                        });
                                        break;
                                    } else {
                                        let x = f.expandedStates[h], A = {
                                            ind: l,
                                            mode: H,
                                            doc: x
                                        };
                                        if (ze(A, i, m, C, r)) {
                                            i.push(A);
                                            break;
                                        }
                                    }
                                } else i.push({
                                    ind: l,
                                    mode: R,
                                    doc: f.contents
                                });
                                break;
                            }
                    }
                    f.id && (r[f.id] = y(!1, i, -1).mode);
                    break;
                case k:
                    {
                        let d = n - o, m = f[_t] ?? 0, { parts: C } = f, E = C.length - m;
                        if (E === 0) break;
                        let h = C[m + 0], x = C[m + 1], A = {
                            ind: l,
                            mode: H,
                            doc: h
                        }, $ = {
                            ind: l,
                            mode: R,
                            doc: h
                        }, ue = ze(A, [], d, c.length > 0, r, !0);
                        if (E === 1) {
                            ue ? i.push(A) : i.push($);
                            break;
                        }
                        let Be = {
                            ind: l,
                            mode: H,
                            doc: x
                        }, Ft = {
                            ind: l,
                            mode: R,
                            doc: x
                        };
                        if (E === 2) {
                            ue ? i.push(Be, A) : i.push(Ft, $);
                            break;
                        }
                        let lu = C[m + 2], pt = {
                            ind: l,
                            mode: F,
                            doc: {
                                ...f,
                                [_t]: m + 2
                            }
                        };
                        ze({
                            ind: l,
                            mode: H,
                            doc: [
                                h,
                                x,
                                lu
                            ]
                        }, [], d, c.length > 0, r, !0) ? i.push(pt, Be, A) : ue ? i.push(pt, Ft, A) : i.push(pt, Ft, $);
                        break;
                    }
                case _:
                case v:
                    {
                        let d = f.groupId ? r[f.groupId] : F;
                        if (d === R) {
                            let m = f.type === _ ? f.breakContents : f.negate ? f.contents : ie(f.contents);
                            m && i.push({
                                ind: l,
                                mode: F,
                                doc: m
                            });
                        }
                        if (d === H) {
                            let m = f.type === _ ? f.flatContents : f.negate ? ie(f.contents) : f.contents;
                            m && i.push({
                                ind: l,
                                mode: F,
                                doc: m
                            });
                        }
                        break;
                    }
                case L:
                    c.push({
                        ind: l,
                        mode: F,
                        doc: f.contents
                    });
                    break;
                case I:
                    c.length > 0 && i.push({
                        ind: l,
                        mode: F,
                        doc: Te
                    });
                    break;
                case g:
                    switch(F){
                        case H:
                            if (f.hard) a = !0;
                            else {
                                f.soft || (s.push(" "), o += 1);
                                break;
                            }
                        case R:
                            if (c.length > 0) {
                                i.push({
                                    ind: l,
                                    mode: F,
                                    doc: f
                                }, ...c.reverse()), c.length = 0;
                                break;
                            }
                            f.literal ? l.root ? (s.push(u, l.root.value), o = l.root.length) : (s.push(u), o = 0) : (o -= wt(s), s.push(u + l.value), o = l.length);
                            break;
                    }
                    break;
                case S:
                    i.push({
                        ind: l,
                        mode: F,
                        doc: f.contents
                    });
                    break;
                case w:
                    break;
                default:
                    throw new q(f);
            }
            i.length === 0 && c.length > 0 && (i.push(...c.reverse()), c.length = 0);
        }
        let p = s.indexOf(de);
        if (p !== -1) {
            let l = s.indexOf(de, p + 1);
            if (l === -1) return {
                formatted: s.filter((m)=>m !== de).join("")
            };
            let F = s.slice(0, p).join(""), f = s.slice(p + 1, l).join(""), d = s.slice(l + 1).join("");
            return {
                formatted: F + f + d,
                cursorNodeStart: F.length,
                cursorNodeText: f
            };
        }
        return {
            formatted: s.join("")
        };
    }
    function Ru(e, t, r = 0) {
        let n = 0;
        for(let u = r; u < e.length; ++u)e[u] === "	" ? n = n + t - n % t : n++;
        return n;
    }
    var Ee = Ru;
    var Z, kt, He, bt = class {
        constructor(t){
            tr(this, Z);
            this.stack = [
                t
            ];
        }
        get key() {
            let { stack: t, siblings: r } = this;
            return y(!1, t, r === null ? -2 : -4) ?? null;
        }
        get index() {
            return this.siblings === null ? null : y(!1, this.stack, -2);
        }
        get node() {
            return y(!1, this.stack, -1);
        }
        get parent() {
            return this.getNode(1);
        }
        get grandparent() {
            return this.getNode(2);
        }
        get isInArray() {
            return this.siblings !== null;
        }
        get siblings() {
            let { stack: t } = this, r = y(!1, t, -3);
            return Array.isArray(r) ? r : null;
        }
        get next() {
            let { siblings: t } = this;
            return t === null ? null : t[this.index + 1];
        }
        get previous() {
            let { siblings: t } = this;
            return t === null ? null : t[this.index - 1];
        }
        get isFirst() {
            return this.index === 0;
        }
        get isLast() {
            let { siblings: t, index: r } = this;
            return t !== null && r === t.length - 1;
        }
        get isRoot() {
            return this.stack.length === 1;
        }
        get root() {
            return this.stack[0];
        }
        get ancestors() {
            return [
                ...fe(this, Z, He).call(this)
            ];
        }
        getName() {
            let { stack: t } = this, { length: r } = t;
            return r > 1 ? y(!1, t, -2) : null;
        }
        getValue() {
            return y(!1, this.stack, -1);
        }
        getNode(t = 0) {
            let r = fe(this, Z, kt).call(this, t);
            return r === -1 ? null : this.stack[r];
        }
        getParentNode(t = 0) {
            return this.getNode(t + 1);
        }
        call(t, ...r) {
            let { stack: n } = this, { length: u } = n, o = y(!1, n, -1);
            for (let i of r)o = o[i], n.push(i, o);
            try {
                return t(this);
            } finally{
                n.length = u;
            }
        }
        callParent(t, r = 0) {
            let n = fe(this, Z, kt).call(this, r + 1), u = this.stack.splice(n + 1);
            try {
                return t(this);
            } finally{
                this.stack.push(...u);
            }
        }
        each(t, ...r) {
            let { stack: n } = this, { length: u } = n, o = y(!1, n, -1);
            for (let i of r)o = o[i], n.push(i, o);
            try {
                for(let i = 0; i < o.length; ++i)n.push(i, o[i]), t(this, i, o), n.length -= 2;
            } finally{
                n.length = u;
            }
        }
        map(t, ...r) {
            let n = [];
            return this.each((u, o, i)=>{
                n[o] = t(u, o, i);
            }, ...r), n;
        }
        match(...t) {
            let r = this.stack.length - 1, n = null, u = this.stack[r--];
            for (let o of t){
                if (u === void 0) return !1;
                let i = null;
                if (typeof n == "number" && (i = n, n = this.stack[r--], u = this.stack[r--]), o && !o(u, n, i)) return !1;
                n = this.stack[r--], u = this.stack[r--];
            }
            return !0;
        }
        findAncestor(t) {
            for (let r of fe(this, Z, He).call(this))if (t(r)) return r;
        }
        hasAncestor(t) {
            for (let r of fe(this, Z, He).call(this))if (t(r)) return !0;
            return !1;
        }
    };
    Z = new WeakSet, kt = function(t) {
        let { stack: r } = this;
        for(let n = r.length - 1; n >= 0; n -= 2)if (!Array.isArray(r[n]) && --t < 0) return n;
        return -1;
    }, He = function*() {
        let { stack: t } = this;
        for(let r = t.length - 3; r >= 0; r -= 2){
            let n = t[r];
            Array.isArray(n) || (yield n);
        }
    };
    var Or = bt;
    var Pr = new Proxy(()=>{}, {
        get: ()=>Pr
    }), Oe = Pr;
    function Yu(e) {
        return e !== null && typeof e == "object";
    }
    var vr = Yu;
    function* Ce(e, t) {
        let { getVisitorKeys: r, filter: n = ()=>!0 } = t, u = (o)=>vr(o) && n(o);
        for (let o of r(e)){
            let i = e[o];
            if (Array.isArray(i)) for (let s of i)u(s) && (yield s);
            else u(i) && (yield i);
        }
    }
    function* Lr(e, t) {
        let r = [
            e
        ];
        for(let n = 0; n < r.length; n++){
            let u = r[n];
            for (let o of Ce(u, t))yield o, r.push(o);
        }
    }
    function Ir(e, t) {
        return Ce(e, t).next().done;
    }
    function he(e) {
        return (t, r, n)=>{
            let u = !!(n != null && n.backwards);
            if (r === !1) return !1;
            let { length: o } = t, i = r;
            for(; i >= 0 && i < o;){
                let s = t.charAt(i);
                if (e instanceof RegExp) {
                    if (!e.test(s)) return i;
                } else if (!e.includes(s)) return i;
                u ? i-- : i++;
            }
            return i === -1 || i === o ? i : !1;
        };
    }
    var Rr = he(/\s/u), T = he(" 	"), Je = he(",; 	"), qe = he(/[^\n\r]/u);
    function ju(e, t, r) {
        let n = !!(r != null && r.backwards);
        if (t === !1) return !1;
        let u = e.charAt(t);
        if (n) {
            if (e.charAt(t - 1) === "\r" && u === `
`) return t - 2;
            if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t - 1;
        } else {
            if (u === "\r" && e.charAt(t + 1) === `
`) return t + 2;
            if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t + 1;
        }
        return t;
    }
    var U = ju;
    function Uu(e, t, r = {}) {
        let n = T(e, r.backwards ? t - 1 : t, r), u = U(e, n, r);
        return n !== u;
    }
    var G = Uu;
    function Vu(e) {
        return Array.isArray(e) && e.length > 0;
    }
    var Xe = Vu;
    var Yr = new Set([
        "tokens",
        "comments",
        "parent",
        "enclosingNode",
        "precedingNode",
        "followingNode"
    ]), $u = (e)=>Object.keys(e).filter((t)=>!Yr.has(t));
    function Wu(e) {
        return e ? (t)=>e(t, Yr) : $u;
    }
    var J = Wu;
    function Mu(e) {
        let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
        return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
    }
    function St(e, t) {
        (e.comments ?? (e.comments = [])).push(t), t.printed = !1, t.nodeDescription = Mu(e);
    }
    function se(e, t) {
        t.leading = !0, t.trailing = !1, St(e, t);
    }
    function ee(e, t, r) {
        t.leading = !1, t.trailing = !1, r && (t.marker = r), St(e, t);
    }
    function ae(e, t) {
        t.leading = !1, t.trailing = !0, St(e, t);
    }
    var Tt = new WeakMap;
    function Qe(e, t) {
        if (Tt.has(e)) return Tt.get(e);
        let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: o, locEnd: i } = t;
        if (!n) return [];
        let s = ((r == null ? void 0 : r(e, t)) ?? [
            ...Ce(e, {
                getVisitorKeys: J(u)
            })
        ]).flatMap((a)=>n(a) ? [
                a
            ] : Qe(a, t));
        return s.sort((a, c)=>o(a) - o(c) || i(a) - i(c)), Tt.set(e, s), s;
    }
    function Ur(e, t, r, n) {
        let { locStart: u, locEnd: o } = r, i = u(t), s = o(t), a = Qe(e, r), c, D, p = 0, l = a.length;
        for(; p < l;){
            let F = p + l >> 1, f = a[F], d = u(f), m = o(f);
            if (d <= i && s <= m) return Ur(f, t, r, f);
            if (m <= i) {
                c = f, p = F + 1;
                continue;
            }
            if (s <= d) {
                D = f, l = F;
                continue;
            }
            throw new Error("Comment location overlaps with node location");
        }
        if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
            let { quasis: F } = n, f = Ot(F, t, r);
            c && Ot(F, c, r) !== f && (c = null), D && Ot(F, D, r) !== f && (D = null);
        }
        return {
            enclosingNode: n,
            precedingNode: c,
            followingNode: D
        };
    }
    var Nt = ()=>!1;
    function Vr(e, t) {
        let { comments: r } = e;
        if (delete e.comments, !Xe(r) || !t.printer.canAttachComment) return;
        let n = [], { printer: { experimentalFeatures: { avoidAstMutation: u = !1 } = {}, handleComments: o = {} }, originalText: i } = t, { ownLine: s = Nt, endOfLine: a = Nt, remaining: c = Nt } = o, D = r.map((p, l)=>({
                ...Ur(e, p, t),
                comment: p,
                text: i,
                options: t,
                ast: e,
                isLastComment: r.length - 1 === l
            }));
        for (let [p, l] of D.entries()){
            let { comment: F, precedingNode: f, enclosingNode: d, followingNode: m, text: C, options: E, ast: h, isLastComment: x } = l, A;
            if (u ? A = [
                l
            ] : (F.enclosingNode = d, F.precedingNode = f, F.followingNode = m, A = [
                F,
                C,
                E,
                h,
                x
            ]), Gu(C, E, D, p)) F.placement = "ownLine", s(...A) || (m ? se(m, F) : f ? ae(f, F) : d ? ee(d, F) : ee(h, F));
            else if (Ku(C, E, D, p)) F.placement = "endOfLine", a(...A) || (f ? ae(f, F) : m ? se(m, F) : d ? ee(d, F) : ee(h, F));
            else if (F.placement = "remaining", !c(...A)) {
                if (f && m) {
                    let $ = n.length;
                    $ > 0 && n[$ - 1].followingNode !== m && jr(n, E), n.push(l);
                } else f ? ae(f, F) : m ? se(m, F) : d ? ee(d, F) : ee(h, F);
            }
        }
        if (jr(n, t), !u) for (let p of r)delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
    }
    var $r = (e)=>!/[\S\n\u2028\u2029]/u.test(e);
    function Gu(e, t, r, n) {
        let { comment: u, precedingNode: o } = r[n], { locStart: i, locEnd: s } = t, a = i(u);
        if (o) for(let c = n - 1; c >= 0; c--){
            let { comment: D, precedingNode: p } = r[c];
            if (p !== o || !$r(e.slice(s(D), a))) break;
            a = i(D);
        }
        return G(e, a, {
            backwards: !0
        });
    }
    function Ku(e, t, r, n) {
        let { comment: u, followingNode: o } = r[n], { locStart: i, locEnd: s } = t, a = s(u);
        if (o) for(let c = n + 1; c < r.length; c++){
            let { comment: D, followingNode: p } = r[c];
            if (p !== o || !$r(e.slice(a, i(D)))) break;
            a = s(D);
        }
        return G(e, a);
    }
    function jr(e, t) {
        var s, a;
        let r = e.length;
        if (r === 0) return;
        let { precedingNode: n, followingNode: u } = e[0], o = t.locStart(u), i;
        for(i = r; i > 0; --i){
            let { comment: c, precedingNode: D, followingNode: p } = e[i - 1];
            Oe.strictEqual(D, n), Oe.strictEqual(p, u);
            let l = t.originalText.slice(t.locEnd(c), o);
            if (((a = (s = t.printer).isGap) == null ? void 0 : a.call(s, l, t)) ?? /^[\s(]*$/u.test(l)) o = t.locStart(c);
            else break;
        }
        for (let [c, { comment: D }] of e.entries())c < i ? ae(n, D) : se(u, D);
        for (let c of [
            n,
            u
        ])c.comments && c.comments.length > 1 && c.comments.sort((D, p)=>t.locStart(D) - t.locStart(p));
        e.length = 0;
    }
    function Ot(e, t, r) {
        let n = r.locStart(t) - 1;
        for(let u = 1; u < e.length; ++u)if (n < r.locStart(e[u])) return u - 1;
        return 0;
    }
    function zu(e, t) {
        let r = t - 1;
        r = T(e, r, {
            backwards: !0
        }), r = U(e, r, {
            backwards: !0
        }), r = T(e, r, {
            backwards: !0
        });
        let n = U(e, r, {
            backwards: !0
        });
        return r !== n;
    }
    var Pe = zu;
    function Wr(e, t) {
        let r = e.node;
        return r.printed = !0, t.printer.printComment(e, t);
    }
    function Hu(e, t) {
        var D;
        let r = e.node, n = [
            Wr(e, t)
        ], { printer: u, originalText: o, locStart: i, locEnd: s } = t;
        if ((D = u.isBlockComment) == null ? void 0 : D.call(u, r)) {
            let p = G(o, s(r)) ? G(o, i(r), {
                backwards: !0
            }) ? z : Ge : " ";
            n.push(p);
        } else n.push(z);
        let c = U(o, T(o, s(r)));
        return c !== !1 && G(o, c) && n.push(z), n;
    }
    function Ju(e, t, r) {
        var c;
        let n = e.node, u = Wr(e, t), { printer: o, originalText: i, locStart: s } = t, a = (c = o.isBlockComment) == null ? void 0 : c.call(o, n);
        if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || G(i, s(n), {
            backwards: !0
        })) {
            let D = Pe(i, s(n));
            return {
                doc: Se([
                    z,
                    D ? z : "",
                    u
                ]),
                isBlock: a,
                hasLineSuffix: !0
            };
        }
        return !a || r != null && r.hasLineSuffix ? {
            doc: [
                Se([
                    " ",
                    u
                ]),
                pe
            ],
            isBlock: a,
            hasLineSuffix: !0
        } : {
            doc: [
                " ",
                u
            ],
            isBlock: a,
            hasLineSuffix: !1
        };
    }
    function qu(e, t) {
        let r = e.node;
        if (!r) return {};
        let n = t[Symbol.for("printedComments")];
        if ((r.comments || []).filter((a)=>!n.has(a)).length === 0) return {
            leading: "",
            trailing: ""
        };
        let o = [], i = [], s;
        return e.each(()=>{
            let a = e.node;
            if (n != null && n.has(a)) return;
            let { leading: c, trailing: D } = a;
            c ? o.push(Hu(e, t)) : D && (s = Ju(e, t, s), i.push(s.doc));
        }, "comments"), {
            leading: o,
            trailing: i
        };
    }
    function Mr(e, t, r) {
        let { leading: n, trailing: u } = qu(e, r);
        return !n && !u ? t : Fe(t, (o)=>[
                n,
                o,
                u
            ]);
    }
    function Gr(e) {
        let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
        for (let n of t){
            if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
            delete n.printed;
        }
    }
    function Xu(e) {
        return ()=>{};
    }
    var Kr = Xu;
    var ve = class extends Error {
        name = "ConfigError";
    }, Le = class extends Error {
        name = "UndefinedParserError";
    };
    var zr = {
        checkIgnorePragma: {
            category: "Special",
            type: "boolean",
            default: !1,
            description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.",
            cliCategory: "Other"
        },
        cursorOffset: {
            category: "Special",
            type: "int",
            default: -1,
            range: {
                start: -1,
                end: 1 / 0,
                step: 1
            },
            description: "Print (to stderr) where a cursor at the given position would move to after formatting.",
            cliCategory: "Editor"
        },
        endOfLine: {
            category: "Global",
            type: "choice",
            default: "lf",
            description: "Which end of line characters to apply.",
            choices: [
                {
                    value: "lf",
                    description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
                },
                {
                    value: "crlf",
                    description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
                },
                {
                    value: "cr",
                    description: "Carriage Return character only (\\r), used very rarely"
                },
                {
                    value: "auto",
                    description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`
                }
            ]
        },
        filepath: {
            category: "Special",
            type: "path",
            description: "Specify the input filepath. This will be used to do parser inference.",
            cliName: "stdin-filepath",
            cliCategory: "Other",
            cliDescription: "Path to the file to pretend that stdin comes from."
        },
        insertPragma: {
            category: "Special",
            type: "boolean",
            default: !1,
            description: "Insert @format pragma into file's first docblock comment.",
            cliCategory: "Other"
        },
        parser: {
            category: "Global",
            type: "choice",
            default: void 0,
            description: "Which parser to use.",
            exception: (e)=>typeof e == "string" || typeof e == "function",
            choices: [
                {
                    value: "flow",
                    description: "Flow"
                },
                {
                    value: "babel",
                    description: "JavaScript"
                },
                {
                    value: "babel-flow",
                    description: "Flow"
                },
                {
                    value: "babel-ts",
                    description: "TypeScript"
                },
                {
                    value: "typescript",
                    description: "TypeScript"
                },
                {
                    value: "acorn",
                    description: "JavaScript"
                },
                {
                    value: "espree",
                    description: "JavaScript"
                },
                {
                    value: "meriyah",
                    description: "JavaScript"
                },
                {
                    value: "css",
                    description: "CSS"
                },
                {
                    value: "less",
                    description: "Less"
                },
                {
                    value: "scss",
                    description: "SCSS"
                },
                {
                    value: "json",
                    description: "JSON"
                },
                {
                    value: "json5",
                    description: "JSON5"
                },
                {
                    value: "jsonc",
                    description: "JSON with Comments"
                },
                {
                    value: "json-stringify",
                    description: "JSON.stringify"
                },
                {
                    value: "graphql",
                    description: "GraphQL"
                },
                {
                    value: "markdown",
                    description: "Markdown"
                },
                {
                    value: "mdx",
                    description: "MDX"
                },
                {
                    value: "vue",
                    description: "Vue"
                },
                {
                    value: "yaml",
                    description: "YAML"
                },
                {
                    value: "glimmer",
                    description: "Ember / Handlebars"
                },
                {
                    value: "html",
                    description: "HTML"
                },
                {
                    value: "angular",
                    description: "Angular"
                },
                {
                    value: "lwc",
                    description: "Lightning Web Components"
                },
                {
                    value: "mjml",
                    description: "MJML"
                }
            ]
        },
        plugins: {
            type: "path",
            array: !0,
            default: [
                {
                    value: []
                }
            ],
            category: "Global",
            description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
            exception: (e)=>typeof e == "string" || typeof e == "object",
            cliName: "plugin",
            cliCategory: "Config"
        },
        printWidth: {
            category: "Global",
            type: "int",
            default: 80,
            description: "The line length where Prettier will try wrap.",
            range: {
                start: 0,
                end: 1 / 0,
                step: 1
            }
        },
        rangeEnd: {
            category: "Special",
            type: "int",
            default: 1 / 0,
            range: {
                start: 0,
                end: 1 / 0,
                step: 1
            },
            description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`,
            cliCategory: "Editor"
        },
        rangeStart: {
            category: "Special",
            type: "int",
            default: 0,
            range: {
                start: 0,
                end: 1 / 0,
                step: 1
            },
            description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`,
            cliCategory: "Editor"
        },
        requirePragma: {
            category: "Special",
            type: "boolean",
            default: !1,
            description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.",
            cliCategory: "Other"
        },
        tabWidth: {
            type: "int",
            category: "Global",
            default: 2,
            description: "Number of spaces per indentation level.",
            range: {
                start: 0,
                end: 1 / 0,
                step: 1
            }
        },
        useTabs: {
            category: "Global",
            type: "boolean",
            default: !1,
            description: "Indent with tabs instead of spaces."
        },
        embeddedLanguageFormatting: {
            category: "Global",
            type: "choice",
            default: "auto",
            description: "Control how Prettier formats quoted code embedded in the file.",
            choices: [
                {
                    value: "auto",
                    description: "Format embedded code if Prettier can automatically identify it."
                },
                {
                    value: "off",
                    description: "Never automatically format embedded code."
                }
            ]
        }
    };
    function Ze({ plugins: e = [], showDeprecated: t = !1 } = {}) {
        let r = e.flatMap((u)=>u.languages ?? []), n = [];
        for (let u of Zu(Object.assign({}, ...e.map(({ options: o })=>o), zr)))!t && u.deprecated || (Array.isArray(u.choices) && (t || (u.choices = u.choices.filter((o)=>!o.deprecated)), u.name === "parser" && (u.choices = [
            ...u.choices,
            ...Qu(u.choices, r, e)
        ])), u.pluginDefaults = Object.fromEntries(e.filter((o)=>{
            var i;
            return ((i = o.defaultOptions) == null ? void 0 : i[u.name]) !== void 0;
        }).map((o)=>[
                o.name,
                o.defaultOptions[u.name]
            ])), n.push(u));
        return {
            languages: r,
            options: n
        };
    }
    function* Qu(e, t, r) {
        let n = new Set(e.map((u)=>u.value));
        for (let u of t)if (u.parsers) {
            for (let o of u.parsers)if (!n.has(o)) {
                n.add(o);
                let i = r.find((a)=>a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, o)), s = u.name;
                i != null && i.name && (s += ` (plugin: ${i.name})`), yield {
                    value: o,
                    description: s
                };
            }
        }
    }
    function Zu(e) {
        let t = [];
        for (let [r, n] of Object.entries(e)){
            let u = {
                name: r,
                ...n
            };
            Array.isArray(u.default) && (u.default = y(!1, u.default, -1).value), t.push(u);
        }
        return t;
    }
    var eo = (e, t)=>{
        if (!(e && t == null)) return t.toReversed || !Array.isArray(t) ? t.toReversed() : [
            ...t
        ].reverse();
    }, Hr = eo;
    var Jr, qr, Xr, Qr, Zr, to = ((Jr = globalThis.Deno) == null ? void 0 : Jr.build.os) === "windows" || ((Xr = (qr = globalThis.navigator) == null ? void 0 : qr.platform) == null ? void 0 : Xr.startsWith("Win")) || ((Zr = (Qr = globalThis.process) == null ? void 0 : Qr.platform) == null ? void 0 : Zr.startsWith("win")) || !1;
    function en(e) {
        if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
        return e;
    }
    function ro(e) {
        return e = en(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    }
    function no(e) {
        e = en(e);
        let t = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
        return e.hostname !== "" && (t = `\\\\${e.hostname}${t}`), t;
    }
    function tn(e) {
        return to ? no(e) : ro(e);
    }
    var rn = tn;
    var uo = (e)=>String(e).split(/[/\\]/u).pop();
    function nn(e, t) {
        if (!t) return;
        let r = uo(t).toLowerCase();
        return e.find(({ filenames: n })=>n == null ? void 0 : n.some((u)=>u.toLowerCase() === r)) ?? e.find(({ extensions: n })=>n == null ? void 0 : n.some((u)=>r.endsWith(u)));
    }
    function oo(e, t) {
        if (t) return e.find(({ name: r })=>r.toLowerCase() === t) ?? e.find(({ aliases: r })=>r == null ? void 0 : r.includes(t)) ?? e.find(({ extensions: r })=>r == null ? void 0 : r.includes(`.${t}`));
    }
    function un(e, t) {
        if (t) {
            if (String(t).startsWith("file:")) try {
                t = rn(t);
            } catch  {
                return;
            }
            if (typeof t == "string") return e.find(({ isSupported: r })=>r == null ? void 0 : r({
                    filepath: t
                }));
        }
    }
    function io(e, t) {
        let r = Hr(!1, e.plugins).flatMap((u)=>u.languages ?? []), n = oo(r, t.language) ?? nn(r, t.physicalFile) ?? nn(r, t.file) ?? un(r, t.physicalFile) ?? un(r, t.file) ?? (t.physicalFile, void 0);
        return n == null ? void 0 : n.parsers[0];
    }
    var on = io;
    var re = {
        key: (e)=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e),
        value (e) {
            if (e === null || typeof e != "object") return JSON.stringify(e);
            if (Array.isArray(e)) return `[${e.map((r)=>re.value(r)).join(", ")}]`;
            let t = Object.keys(e);
            return t.length === 0 ? "{}" : `{ ${t.map((r)=>`${re.key(r)}: ${re.value(e[r])}`).join(", ")} }`;
        },
        pair: ({ key: e, value: t })=>re.value({
                [e]: t
            })
    };
    var sn = new Proxy(String, {
        get: ()=>sn
    }), V = sn;
    var an = (e, t, { descriptor: r })=>{
        let n = [
            `${V.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`
        ];
        return t && n.push(`we now treat it as ${V.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
    };
    var et = Symbol.for("vnopts.VALUE_NOT_EXIST"), ge = Symbol.for("vnopts.VALUE_UNCHANGED");
    var Dn = " ".repeat(2), fn = (e, t, r)=>{
        let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), o = [];
        return n && o.push(cn(e, t, n, r.descriptor)), u && o.push([
            cn(e, t, u.title, r.descriptor)
        ].concat(u.values.map((i)=>ln(i, r.loggerPrintWidth))).join(`
`)), Fn(o, r.loggerPrintWidth);
    };
    function cn(e, t, r, n) {
        return [
            `Invalid ${V.red(n.key(e))} value.`,
            `Expected ${V.blue(r)},`,
            `but received ${t === et ? V.gray("nothing") : V.red(n.value(t))}.`
        ].join(" ");
    }
    function ln({ text: e, list: t }, r) {
        let n = [];
        return e && n.push(`- ${V.blue(e)}`), t && n.push([
            `- ${V.blue(t.title)}:`
        ].concat(t.values.map((u)=>ln(u, r - Dn.length).replace(/^|\n/g, `$&${Dn}`))).join(`
`)), Fn(n, r);
    }
    function Fn(e, t) {
        if (e.length === 1) return e[0];
        let [r, n] = e, [u, o] = e.map((i)=>i.split(`
`, 1)[0].length);
        return u > t && u > o ? n : r;
    }
    var Pt = [], pn = [];
    function vt(e, t) {
        if (e === t) return 0;
        let r = e;
        e.length > t.length && (e = t, t = r);
        let n = e.length, u = t.length;
        for(; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-u);)n--, u--;
        let o = 0;
        for(; o < n && e.charCodeAt(o) === t.charCodeAt(o);)o++;
        if (n -= o, u -= o, n === 0) return u;
        let i, s, a, c, D = 0, p = 0;
        for(; D < n;)pn[D] = e.charCodeAt(o + D), Pt[D] = ++D;
        for(; p < u;)for(i = t.charCodeAt(o + p), a = p++, s = p, D = 0; D < n; D++)c = i === pn[D] ? a : a + 1, a = Pt[D], s = Pt[D] = a > s ? c > s ? s + 1 : c : c > a ? a + 1 : c;
        return s;
    }
    var tt = (e, t, { descriptor: r, logger: n, schemas: u })=>{
        let o = [
            `Ignored unknown option ${V.yellow(r.pair({
                key: e,
                value: t
            }))}.`
        ], i = Object.keys(u).sort().find((s)=>vt(e, s) < 3);
        i && o.push(`Did you mean ${V.blue(r.key(i))}?`), n.warn(o.join(" "));
    };
    var so = [
        "default",
        "expected",
        "validate",
        "deprecated",
        "forward",
        "redirect",
        "overlap",
        "preprocess",
        "postprocess"
    ];
    function ao(e, t) {
        let r = new e(t), n = Object.create(r);
        for (let u of so)u in t && (n[u] = Do(t[u], r, b.prototype[u].length));
        return n;
    }
    var b = class {
        static create(t) {
            return ao(this, t);
        }
        constructor(t){
            this.name = t.name;
        }
        default(t) {}
        expected(t) {
            return "nothing";
        }
        validate(t, r) {
            return !1;
        }
        deprecated(t, r) {
            return !1;
        }
        forward(t, r) {}
        redirect(t, r) {}
        overlap(t, r, n) {
            return t;
        }
        preprocess(t, r) {
            return t;
        }
        postprocess(t, r) {
            return ge;
        }
    };
    function Do(e, t, r) {
        return typeof e == "function" ? (...n)=>e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : ()=>e;
    }
    var rt = class extends b {
        constructor(t){
            super(t), this._sourceName = t.sourceName;
        }
        expected(t) {
            return t.schemas[this._sourceName].expected(t);
        }
        validate(t, r) {
            return r.schemas[this._sourceName].validate(t, r);
        }
        redirect(t, r) {
            return this._sourceName;
        }
    };
    var nt = class extends b {
        expected() {
            return "anything";
        }
        validate() {
            return !0;
        }
    };
    var ut = class extends b {
        constructor({ valueSchema: t, name: r = t.name, ...n }){
            super({
                ...n,
                name: r
            }), this._valueSchema = t;
        }
        expected(t) {
            let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
            return {
                text: r && `an array of ${r}`,
                list: n && {
                    title: "an array of the following values",
                    values: [
                        {
                            list: n
                        }
                    ]
                }
            };
        }
        validate(t, r) {
            if (!Array.isArray(t)) return !1;
            let n = [];
            for (let u of t){
                let o = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
                o !== !0 && n.push(o.value);
            }
            return n.length === 0 ? !0 : {
                value: n
            };
        }
        deprecated(t, r) {
            let n = [];
            for (let u of t){
                let o = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
                o !== !1 && n.push(...o.map(({ value: i })=>({
                        value: [
                            i
                        ]
                    })));
            }
            return n;
        }
        forward(t, r) {
            let n = [];
            for (let u of t){
                let o = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
                n.push(...o.map(dn));
            }
            return n;
        }
        redirect(t, r) {
            let n = [], u = [];
            for (let o of t){
                let i = r.normalizeRedirectResult(this._valueSchema.redirect(o, r), o);
                "remain" in i && n.push(i.remain), u.push(...i.redirect.map(dn));
            }
            return n.length === 0 ? {
                redirect: u
            } : {
                redirect: u,
                remain: n
            };
        }
        overlap(t, r) {
            return t.concat(r);
        }
    };
    function dn({ from: e, to: t }) {
        return {
            from: [
                e
            ],
            to: t
        };
    }
    var ot = class extends b {
        expected() {
            return "true or false";
        }
        validate(t) {
            return typeof t == "boolean";
        }
    };
    function En(e, t) {
        let r = Object.create(null);
        for (let n of e){
            let u = n[t];
            if (r[u]) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
            r[u] = n;
        }
        return r;
    }
    function Cn(e, t) {
        let r = new Map;
        for (let n of e){
            let u = n[t];
            if (r.has(u)) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
            r.set(u, n);
        }
        return r;
    }
    function hn() {
        let e = Object.create(null);
        return (t)=>{
            let r = JSON.stringify(t);
            return e[r] ? !0 : (e[r] = !0, !1);
        };
    }
    function gn(e, t) {
        let r = [], n = [];
        for (let u of e)t(u) ? r.push(u) : n.push(u);
        return [
            r,
            n
        ];
    }
    function yn(e) {
        return e === Math.floor(e);
    }
    function An(e, t) {
        if (e === t) return 0;
        let r = typeof e, n = typeof t, u = [
            "undefined",
            "object",
            "boolean",
            "number",
            "string"
        ];
        return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
    }
    function Bn(e) {
        return (...t)=>{
            let r = e(...t);
            return typeof r == "string" ? new Error(r) : r;
        };
    }
    function Lt(e) {
        return e === void 0 ? {} : e;
    }
    function It(e) {
        if (typeof e == "string") return {
            text: e
        };
        let { text: t, list: r } = e;
        return co((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? {
            text: t,
            list: {
                title: r.title,
                values: r.values.map(It)
            }
        } : {
            text: t
        };
    }
    function Rt(e, t) {
        return e === !0 ? !0 : e === !1 ? {
            value: t
        } : e;
    }
    function Yt(e, t, r = !1) {
        return e === !1 ? !1 : e === !0 ? r ? !0 : [
            {
                value: t
            }
        ] : "value" in e ? [
            e
        ] : e.length === 0 ? !1 : e;
    }
    function mn(e, t) {
        return typeof e == "string" || "key" in e ? {
            from: t,
            to: e
        } : "from" in e ? {
            from: e.from,
            to: e.to
        } : {
            from: t,
            to: e.to
        };
    }
    function it(e, t) {
        return e === void 0 ? [] : Array.isArray(e) ? e.map((r)=>mn(r, t)) : [
            mn(e, t)
        ];
    }
    function jt(e, t) {
        let r = it(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
        return r.length === 0 ? {
            remain: t,
            redirect: r
        } : typeof e == "object" && "remain" in e ? {
            remain: e.remain,
            redirect: r
        } : {
            redirect: r
        };
    }
    function co(e, t) {
        if (!e) throw new Error(t);
    }
    var st = class extends b {
        constructor(t){
            super(t), this._choices = Cn(t.choices.map((r)=>r && typeof r == "object" ? r : {
                    value: r
                }), "value");
        }
        expected({ descriptor: t }) {
            let r = Array.from(this._choices.keys()).map((i)=>this._choices.get(i)).filter(({ hidden: i })=>!i).map((i)=>i.value).sort(An).map(t.value), n = r.slice(0, -2), u = r.slice(-2);
            return {
                text: n.concat(u.join(" or ")).join(", "),
                list: {
                    title: "one of the following values",
                    values: r
                }
            };
        }
        validate(t) {
            return this._choices.has(t);
        }
        deprecated(t) {
            let r = this._choices.get(t);
            return r && r.deprecated ? {
                value: t
            } : !1;
        }
        forward(t) {
            let r = this._choices.get(t);
            return r ? r.forward : void 0;
        }
        redirect(t) {
            let r = this._choices.get(t);
            return r ? r.redirect : void 0;
        }
    };
    var at = class extends b {
        expected() {
            return "a number";
        }
        validate(t, r) {
            return typeof t == "number";
        }
    };
    var Dt = class extends at {
        expected() {
            return "an integer";
        }
        validate(t, r) {
            return r.normalizeValidateResult(super.validate(t, r), t) === !0 && yn(t);
        }
    };
    var Ie = class extends b {
        expected() {
            return "a string";
        }
        validate(t) {
            return typeof t == "string";
        }
    };
    var _n = re, xn = tt, wn = fn, bn = an;
    var ct = class {
        constructor(t, r){
            let { logger: n = console, loggerPrintWidth: u = 80, descriptor: o = _n, unknown: i = xn, invalid: s = wn, deprecated: a = bn, missing: c = ()=>!1, required: D = ()=>!1, preprocess: p = (F)=>F, postprocess: l = ()=>ge } = r || {};
            this._utils = {
                descriptor: o,
                logger: n || {
                    warn: ()=>{}
                },
                loggerPrintWidth: u,
                schemas: En(t, "name"),
                normalizeDefaultResult: Lt,
                normalizeExpectedResult: It,
                normalizeDeprecatedResult: Yt,
                normalizeForwardResult: it,
                normalizeRedirectResult: jt,
                normalizeValidateResult: Rt
            }, this._unknownHandler = i, this._invalidHandler = Bn(s), this._deprecatedHandler = a, this._identifyMissing = (F, f)=>!(F in f) || c(F, f), this._identifyRequired = D, this._preprocess = p, this._postprocess = l, this.cleanHistory();
        }
        cleanHistory() {
            this._hasDeprecationWarned = hn();
        }
        normalize(t) {
            let r = {}, u = [
                this._preprocess(t, this._utils)
            ], o = ()=>{
                for(; u.length !== 0;){
                    let i = u.shift(), s = this._applyNormalization(i, r);
                    u.push(...s);
                }
            };
            o();
            for (let i of Object.keys(this._utils.schemas)){
                let s = this._utils.schemas[i];
                if (!(i in r)) {
                    let a = Lt(s.default(this._utils));
                    "value" in a && u.push({
                        [i]: a.value
                    });
                }
            }
            o();
            for (let i of Object.keys(this._utils.schemas)){
                if (!(i in r)) continue;
                let s = this._utils.schemas[i], a = r[i], c = s.postprocess(a, this._utils);
                c !== ge && (this._applyValidation(c, i, s), r[i] = c);
            }
            return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
        }
        _applyNormalization(t, r) {
            let n = [], { knownKeys: u, unknownKeys: o } = this._partitionOptionKeys(t);
            for (let i of u){
                let s = this._utils.schemas[i], a = s.preprocess(t[i], this._utils);
                this._applyValidation(a, i, s);
                let c = ({ from: F, to: f })=>{
                    n.push(typeof f == "string" ? {
                        [f]: F
                    } : {
                        [f.key]: f.value
                    });
                }, D = ({ value: F, redirectTo: f })=>{
                    let d = Yt(s.deprecated(F, this._utils), a, !0);
                    if (d !== !1) {
                        if (d === !0) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, f, this._utils));
                        else for (let { value: m } of d){
                            let C = {
                                key: i,
                                value: m
                            };
                            if (!this._hasDeprecationWarned(C)) {
                                let E = typeof f == "string" ? {
                                    key: f,
                                    value: m
                                } : f;
                                this._utils.logger.warn(this._deprecatedHandler(C, E, this._utils));
                            }
                        }
                    }
                };
                it(s.forward(a, this._utils), a).forEach(c);
                let l = jt(s.redirect(a, this._utils), a);
                if (l.redirect.forEach(c), "remain" in l) {
                    let F = l.remain;
                    r[i] = i in r ? s.overlap(r[i], F, this._utils) : F, D({
                        value: F
                    });
                }
                for (let { from: F, to: f } of l.redirect)D({
                    value: F,
                    redirectTo: f
                });
            }
            for (let i of o){
                let s = t[i];
                this._applyUnknownHandler(i, s, r, (a, c)=>{
                    n.push({
                        [a]: c
                    });
                });
            }
            return n;
        }
        _applyRequiredCheck(t) {
            for (let r of Object.keys(this._utils.schemas))if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, et, this._utils);
        }
        _partitionOptionKeys(t) {
            let [r, n] = gn(Object.keys(t).filter((u)=>!this._identifyMissing(u, t)), (u)=>u in this._utils.schemas);
            return {
                knownKeys: r,
                unknownKeys: n
            };
        }
        _applyValidation(t, r, n) {
            let u = Rt(n.validate(t, this._utils), t);
            if (u !== !0) throw this._invalidHandler(r, u.value, this._utils);
        }
        _applyUnknownHandler(t, r, n, u) {
            let o = this._unknownHandler(t, r, this._utils);
            if (o) for (let i of Object.keys(o)){
                if (this._identifyMissing(i, o)) continue;
                let s = o[i];
                i in this._utils.schemas ? u(i, s) : n[i] = s;
            }
        }
        _applyPostprocess(t) {
            let r = this._postprocess(t, this._utils);
            if (r !== ge) {
                if (r.delete) for (let n of r.delete)delete t[n];
                if (r.override) {
                    let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
                    for (let o of n){
                        let i = r.override[o];
                        this._applyValidation(i, o, this._utils.schemas[o]), t[o] = i;
                    }
                    for (let o of u){
                        let i = r.override[o];
                        this._applyUnknownHandler(o, i, t, (s, a)=>{
                            let c = this._utils.schemas[s];
                            this._applyValidation(a, s, c), t[s] = a;
                        });
                    }
                }
            }
        }
    };
    var Ut;
    function lo(e, t, { logger: r = !1, isCLI: n = !1, passThrough: u = !1, FlagSchema: o, descriptor: i } = {}) {
        if (n) {
            if (!o) throw new Error("'FlagSchema' option is required.");
            if (!i) throw new Error("'descriptor' option is required.");
        } else i = re;
        let s = u ? Array.isArray(u) ? (l, F)=>u.includes(l) ? {
                [l]: F
            } : void 0 : (l, F)=>({
                [l]: F
            }) : (l, F, f)=>{
            let { _: d, ...m } = f.schemas;
            return tt(l, F, {
                ...f,
                schemas: m
            });
        }, a = Fo(t, {
            isCLI: n,
            FlagSchema: o
        }), c = new ct(a, {
            logger: r,
            unknown: s,
            descriptor: i
        }), D = r !== !1;
        D && Ut && (c._hasDeprecationWarned = Ut);
        let p = c.normalize(e);
        return D && (Ut = c._hasDeprecationWarned), p;
    }
    function Fo(e, { isCLI: t, FlagSchema: r }) {
        let n = [];
        t && n.push(nt.create({
            name: "_"
        }));
        for (let u of e)n.push(po(u, {
            isCLI: t,
            optionInfos: e,
            FlagSchema: r
        })), u.alias && t && n.push(rt.create({
            name: u.alias,
            sourceName: u.name
        }));
        return n;
    }
    function po(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
        let { name: u } = e, o = {
            name: u
        }, i, s = {};
        switch(e.type){
            case "int":
                i = Dt, t && (o.preprocess = Number);
                break;
            case "string":
                i = Ie;
                break;
            case "choice":
                i = st, o.choices = e.choices.map((a)=>a != null && a.redirect ? {
                        ...a,
                        redirect: {
                            to: {
                                key: e.name,
                                value: a.redirect
                            }
                        }
                    } : a);
                break;
            case "boolean":
                i = ot;
                break;
            case "flag":
                i = n, o.flags = r.flatMap((a)=>[
                        a.alias,
                        a.description && a.name,
                        a.oppositeDescription && `no-${a.name}`
                    ].filter(Boolean));
                break;
            case "path":
                i = Ie;
                break;
            default:
                throw new Error(`Unexpected type ${e.type}`);
        }
        if (e.exception ? o.validate = (a, c, D)=>e.exception(a) || c.validate(a, D) : o.validate = (a, c, D)=>a === void 0 || c.validate(a, D), e.redirect && (s.redirect = (a)=>a ? {
                to: typeof e.redirect == "string" ? e.redirect : {
                    key: e.redirect.option,
                    value: e.redirect.value
                }
            } : void 0), e.deprecated && (s.deprecated = !0), t && !e.array) {
            let a = o.preprocess || ((c)=>c);
            o.preprocess = (c, D, p)=>D.preprocess(a(Array.isArray(c) ? y(!1, c, -1) : c), p);
        }
        return e.array ? ut.create({
            ...t ? {
                preprocess: (a)=>Array.isArray(a) ? a : [
                        a
                    ]
            } : {},
            ...s,
            valueSchema: i.create(o)
        }) : i.create({
            ...o,
            ...s
        });
    }
    var kn = lo;
    var mo = (e, t, r)=>{
        if (!(e && t == null)) {
            if (t.findLast) return t.findLast(r);
            for(let n = t.length - 1; n >= 0; n--){
                let u = t[n];
                if (r(u, n, t)) return u;
            }
        }
    }, Vt = mo;
    function $t(e, t) {
        if (!t) throw new Error("parserName is required.");
        let r = Vt(!1, e, (u)=>u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t));
        if (r) return r;
        let n = `Couldn't resolve parser "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new ve(n);
    }
    function Sn(e, t) {
        if (!t) throw new Error("astFormat is required.");
        let r = Vt(!1, e, (u)=>u.printers && Object.prototype.hasOwnProperty.call(u.printers, t));
        if (r) return r;
        let n = `Couldn't find plugin for AST format "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new ve(n);
    }
    function Re({ plugins: e, parser: t }) {
        let r = $t(e, t);
        return Wt(r, t);
    }
    function Wt(e, t) {
        let r = e.parsers[t];
        return typeof r == "function" ? r() : r;
    }
    function Tn(e, t) {
        let r = e.printers[t];
        return typeof r == "function" ? r() : r;
    }
    var Nn = {
        astFormat: "estree",
        printer: {},
        originalText: void 0,
        locStart: null,
        locEnd: null
    };
    async function Eo(e, t = {}) {
        var p;
        let r = {
            ...e
        };
        if (!r.parser) {
            if (r.filepath) {
                if (r.parser = on(r, {
                    physicalFile: r.filepath
                }), !r.parser) throw new Le(`No parser could be inferred for file "${r.filepath}".`);
            } else throw new Le("No parser and no file path given, couldn't infer a parser.");
        }
        let n = Ze({
            plugins: e.plugins,
            showDeprecated: !0
        }).options, u = {
            ...Nn,
            ...Object.fromEntries(n.filter((l)=>l.default !== void 0).map((l)=>[
                    l.name,
                    l.default
                ]))
        }, o = $t(r.plugins, r.parser), i = await Wt(o, r.parser);
        r.astFormat = i.astFormat, r.locEnd = i.locEnd, r.locStart = i.locStart;
        let s = (p = o.printers) != null && p[i.astFormat] ? o : Sn(r.plugins, i.astFormat), a = await Tn(s, i.astFormat);
        r.printer = a;
        let c = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l])=>l !== void 0)) : {}, D = {
            ...u,
            ...c
        };
        for (let [l, F] of Object.entries(D))(r[l] === null || r[l] === void 0) && (r[l] = F);
        return r.parser === "json" && (r.trailingComma = "none"), kn(r, n, {
            passThrough: Object.keys(Nn),
            ...t
        });
    }
    var ne = Eo;
    var vn = hu(Pn(), 1);
    async function yo(e, t) {
        let r = await Re(t), n = r.preprocess ? r.preprocess(e, t) : e;
        t.originalText = n;
        let u;
        try {
            u = await r.parse(n, t, t);
        } catch (o) {
            Ao(o, e);
        }
        return {
            text: n,
            ast: u
        };
    }
    function Ao(e, t) {
        let { loc: r } = e;
        if (r) {
            let n = (0, vn.codeFrameColumns)(t, r, {
                highlightCode: !0
            });
            throw e.message += `
` + n, e.codeFrame = n, e;
        }
        throw e;
    }
    var De = yo;
    async function Ln(e, t, r, n, u) {
        let { embeddedLanguageFormatting: o, printer: { embed: i, hasPrettierIgnore: s = ()=>!1, getVisitorKeys: a } } = r;
        if (!i || o !== "auto") return;
        if (i.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
        let c = J(i.getVisitorKeys ?? a), D = [];
        F();
        let p = e.stack;
        for (let { print: f, node: d, pathStack: m } of D)try {
            e.stack = m;
            let C = await f(l, t, e, r);
            C && u.set(d, C);
        } catch (C) {
            if (globalThis.PRETTIER_DEBUG) throw C;
        }
        e.stack = p;
        function l(f, d) {
            return Bo(f, d, r, n);
        }
        function F() {
            let { node: f } = e;
            if (f === null || typeof f != "object" || s(e)) return;
            for (let m of c(f))Array.isArray(f[m]) ? e.each(F, m) : e.call(F, m);
            let d = i(e, r);
            if (d) {
                if (typeof d == "function") {
                    D.push({
                        print: d,
                        node: f,
                        pathStack: [
                            ...e.stack
                        ]
                    });
                    return;
                }
                u.set(f, d);
            }
        }
    }
    async function Bo(e, t, r, n) {
        let u = await ne({
            ...r,
            ...t,
            parentParser: r.parser,
            originalText: e,
            cursorOffset: void 0,
            rangeStart: void 0,
            rangeEnd: void 0
        }, {
            passThrough: !0
        }), { ast: o } = await De(e, u), i = await n(o, u);
        return We(i);
    }
    function _o(e, t) {
        let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: o, [Symbol.for("printedComments")]: i } = t, { node: s } = e, a = u(s), c = o(s);
        for (let D of n)u(D) >= a && o(D) <= c && i.add(D);
        return r.slice(a, c);
    }
    var In = _o;
    async function Ye(e, t) {
        ({ ast: e } = await Gt(e, t));
        let r = new Map, n = new Or(e), u = Kr(t), o = new Map;
        await Ln(n, s, t, Ye, o);
        let i = await Rn(n, t, s, void 0, o);
        if (Gr(t), t.cursorOffset >= 0) {
            if (t.nodeAfterCursor && !t.nodeBeforeCursor) return [
                X,
                i
            ];
            if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [
                i,
                X
            ];
        }
        return i;
        function s(c, D) {
            return c === void 0 || c === n ? a(D) : Array.isArray(c) ? n.call(()=>a(D), ...c) : n.call(()=>a(D), c);
        }
        function a(c) {
            u(n);
            let D = n.node;
            if (D == null) return "";
            let p = D && typeof D == "object" && c === void 0;
            if (p && r.has(D)) return r.get(D);
            let l = Rn(n, t, s, c, o);
            return p && r.set(D, l), l;
        }
    }
    function Rn(e, t, r, n, u) {
        var a;
        let { node: o } = e, { printer: i } = t, s;
        switch((a = i.hasPrettierIgnore) != null && a.call(i, e) ? s = In(e, t) : u.has(o) ? s = u.get(o) : s = i.print(e, t, r, n), o){
            case t.cursorNode:
                s = Fe(s, (c)=>[
                        X,
                        c,
                        X
                    ]);
                break;
            case t.nodeBeforeCursor:
                s = Fe(s, (c)=>[
                        c,
                        X
                    ]);
                break;
            case t.nodeAfterCursor:
                s = Fe(s, (c)=>[
                        X,
                        c
                    ]);
                break;
        }
        return i.printComment && (!i.willPrintOwnComments || !i.willPrintOwnComments(e, t)) && (s = Mr(e, s, t)), s;
    }
    async function Gt(e, t) {
        let r = e.comments ?? [];
        t[Symbol.for("comments")] = r, t[Symbol.for("printedComments")] = new Set, Vr(e, t);
        let { printer: { preprocess: n } } = t;
        return e = n ? await n(e, t) : e, {
            ast: e,
            comments: r
        };
    }
    function xo(e, t) {
        let { cursorOffset: r, locStart: n, locEnd: u } = t, o = J(t.printer.getVisitorKeys), i = (F)=>n(F) <= r && u(F) >= r, s = e, a = [
            e
        ];
        for (let F of Lr(e, {
            getVisitorKeys: o,
            filter: i
        }))a.push(F), s = F;
        if (Ir(s, {
            getVisitorKeys: o
        })) return {
            cursorNode: s
        };
        let c, D, p = -1, l = Number.POSITIVE_INFINITY;
        for(; a.length > 0 && (c === void 0 || D === void 0);){
            s = a.pop();
            let F = c !== void 0, f = D !== void 0;
            for (let d of Ce(s, {
                getVisitorKeys: o
            })){
                if (!F) {
                    let m = u(d);
                    m <= r && m > p && (c = d, p = m);
                }
                if (!f) {
                    let m = n(d);
                    m >= r && m < l && (D = d, l = m);
                }
            }
        }
        return {
            nodeBeforeCursor: c,
            nodeAfterCursor: D
        };
    }
    var Kt = xo;
    function wo(e, t) {
        let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
        if (!r) return e;
        let u = J(n), o = r.ignoredProperties ?? new Set;
        return i(e);
        function i(s, a) {
            if (!(s !== null && typeof s == "object")) return s;
            if (Array.isArray(s)) return s.map((l)=>i(l, a)).filter(Boolean);
            let c = {}, D = new Set(u(s));
            for(let l in s)!Object.prototype.hasOwnProperty.call(s, l) || o.has(l) || (D.has(l) ? c[l] = i(s[l], s) : c[l] = s[l]);
            let p = r(s, c, a);
            if (p !== null) return p ?? c;
        }
    }
    var Yn = wo;
    var bo = (e, t, r)=>{
        if (!(e && t == null)) {
            if (t.findLastIndex) return t.findLastIndex(r);
            for(let n = t.length - 1; n >= 0; n--){
                let u = t[n];
                if (r(u, n, t)) return n;
            }
            return -1;
        }
    }, jn = bo;
    var ko = ({ parser: e })=>e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
    function So(e, t) {
        let r = [
            e.node,
            ...e.parentNodes
        ], n = new Set([
            t.node,
            ...t.parentNodes
        ]);
        return r.find((u)=>$n.has(u.type) && n.has(u));
    }
    function Un(e) {
        let t = jn(!1, e, (r)=>r.type !== "Program" && r.type !== "File");
        return t === -1 ? e : e.slice(0, t + 1);
    }
    function To(e, t, { locStart: r, locEnd: n }) {
        let u = e.node, o = t.node;
        if (u === o) return {
            startNode: u,
            endNode: o
        };
        let i = r(e.node);
        for (let a of Un(t.parentNodes))if (r(a) >= i) o = a;
        else break;
        let s = n(t.node);
        for (let a of Un(e.parentNodes)){
            if (n(a) <= s) u = a;
            else break;
            if (u === o) break;
        }
        return {
            startNode: u,
            endNode: o
        };
    }
    function zt(e, t, r, n, u = [], o) {
        let { locStart: i, locEnd: s } = r, a = i(e), c = s(e);
        if (!(t > c || t < a || o === "rangeEnd" && t === a || o === "rangeStart" && t === c)) {
            for (let D of Qe(e, r)){
                let p = zt(D, t, r, n, [
                    e,
                    ...u
                ], o);
                if (p) return p;
            }
            if (!n || n(e, u[0])) return {
                node: e,
                parentNodes: u
            };
        }
    }
    function No(e, t) {
        return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
    }
    var $n = new Set([
        "JsonRoot",
        "ObjectExpression",
        "ArrayExpression",
        "StringLiteral",
        "NumericLiteral",
        "BooleanLiteral",
        "NullLiteral",
        "UnaryExpression",
        "TemplateLiteral"
    ]), Oo = new Set([
        "OperationDefinition",
        "FragmentDefinition",
        "VariableDefinition",
        "TypeExtensionDefinition",
        "ObjectTypeDefinition",
        "FieldDefinition",
        "DirectiveDefinition",
        "EnumTypeDefinition",
        "EnumValueDefinition",
        "InputValueDefinition",
        "InputObjectTypeDefinition",
        "SchemaDefinition",
        "OperationTypeDefinition",
        "InterfaceTypeDefinition",
        "UnionTypeDefinition",
        "ScalarTypeDefinition"
    ]);
    function Vn(e, t, r) {
        if (!t) return !1;
        switch(e.parser){
            case "flow":
            case "hermes":
            case "babel":
            case "babel-flow":
            case "babel-ts":
            case "typescript":
            case "acorn":
            case "espree":
            case "meriyah":
            case "oxc":
            case "oxc-ts":
            case "__babel_estree":
                return No(t.type, r == null ? void 0 : r.type);
            case "json":
            case "json5":
            case "jsonc":
            case "json-stringify":
                return $n.has(t.type);
            case "graphql":
                return Oo.has(t.kind);
            case "vue":
                return t.tag !== "root";
        }
        return !1;
    }
    function Wn(e, t, r) {
        let { rangeStart: n, rangeEnd: u, locStart: o, locEnd: i } = t;
        Oe.ok(u > n);
        let s = e.slice(n, u).search(/\S/u), a = s === -1;
        if (!a) for(n += s; u > n && !/\S/u.test(e[u - 1]); --u);
        let c = zt(r, n, t, (F, f)=>Vn(t, F, f), [], "rangeStart"), D = a ? c : zt(r, u, t, (F)=>Vn(t, F), [], "rangeEnd");
        if (!c || !D) return {
            rangeStart: 0,
            rangeEnd: 0
        };
        let p, l;
        if (ko(t)) {
            let F = So(c, D);
            p = F, l = F;
        } else ({ startNode: p, endNode: l } = To(c, D, t));
        return {
            rangeStart: Math.min(o(p), o(l)),
            rangeEnd: Math.max(i(p), i(l))
        };
    }
    var zn = "\uFEFF", Mn = Symbol("cursor");
    async function Hn(e, t, r = 0) {
        if (!e || e.trim().length === 0) return {
            formatted: "",
            cursorOffset: -1,
            comments: []
        };
        let { ast: n, text: u } = await De(e, t);
        t.cursorOffset >= 0 && (t = {
            ...t,
            ...Kt(n, t)
        });
        let o = await Ye(n, t, r);
        r > 0 && (o = Ke([
            z,
            o
        ], r, t.tabWidth));
        let i = me(o, t);
        if (r > 0) {
            let a = i.formatted.trim();
            i.cursorNodeStart !== void 0 && (i.cursorNodeStart -= i.formatted.indexOf(a), i.cursorNodeStart < 0 && (i.cursorNodeStart = 0, i.cursorNodeText = i.cursorNodeText.trimStart()), i.cursorNodeStart + i.cursorNodeText.length > a.length && (i.cursorNodeText = i.cursorNodeText.trimEnd())), i.formatted = a + xe(t.endOfLine);
        }
        let s = t[Symbol.for("comments")];
        if (t.cursorOffset >= 0) {
            let a, c, D, p;
            if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && i.cursorNodeText) {
                if (D = i.cursorNodeStart, p = i.cursorNodeText, t.cursorNode) a = t.locStart(t.cursorNode), c = u.slice(a, t.locEnd(t.cursorNode));
                else {
                    if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
                    a = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
                    let C = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : u.length;
                    c = u.slice(a, C);
                }
            } else a = 0, c = u, D = 0, p = i.formatted;
            let l = t.cursorOffset - a;
            if (c === p) return {
                formatted: i.formatted,
                cursorOffset: D + l,
                comments: s
            };
            let F = c.split("");
            F.splice(l, 0, Mn);
            let f = p.split(""), d = Et(F, f), m = D;
            for (let C of d)if (C.removed) {
                if (C.value.includes(Mn)) break;
            } else m += C.count;
            return {
                formatted: i.formatted,
                cursorOffset: m,
                comments: s
            };
        }
        return {
            formatted: i.formatted,
            cursorOffset: -1,
            comments: s
        };
    }
    async function Po(e, t) {
        let { ast: r, text: n } = await De(e, t), { rangeStart: u, rangeEnd: o } = Wn(n, t, r), i = n.slice(u, o), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a = n.slice(s, u).match(/^\s*/u)[0], c = Ee(a, t.tabWidth), D = await Hn(i, {
            ...t,
            rangeStart: 0,
            rangeEnd: Number.POSITIVE_INFINITY,
            cursorOffset: t.cursorOffset > u && t.cursorOffset <= o ? t.cursorOffset - u : -1,
            endOfLine: "lf"
        }, c), p = D.formatted.trimEnd(), { cursorOffset: l } = t;
        l > o ? l += p.length - i.length : D.cursorOffset >= 0 && (l = D.cursorOffset + u);
        let F = n.slice(0, u) + p + n.slice(o);
        if (t.endOfLine !== "lf") {
            let f = xe(t.endOfLine);
            l >= 0 && f === `\r
` && (l += Ct(F.slice(0, l), `
`)), F = te(!1, F, `
`, f);
        }
        return {
            formatted: F,
            cursorOffset: l,
            comments: D.comments
        };
    }
    function Ht(e, t, r) {
        return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
    }
    function Gn(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t;
        return r = Ht(e, r, -1), n = Ht(e, n, 0), u = Ht(e, u, e.length), {
            ...t,
            cursorOffset: r,
            rangeStart: n,
            rangeEnd: u
        };
    }
    function Jn(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o } = Gn(e, t), i = e.charAt(0) === zn;
        if (i && (e = e.slice(1), r--, n--, u--), o === "auto" && (o = nr(e)), e.includes("\r")) {
            let s = (a)=>Ct(e.slice(0, Math.max(a, 0)), `\r
`);
            r -= s(r), n -= s(n), u -= s(u), e = ur(e);
        }
        return {
            hasBOM: i,
            text: e,
            options: Gn(e, {
                ...t,
                cursorOffset: r,
                rangeStart: n,
                rangeEnd: u,
                endOfLine: o
            })
        };
    }
    async function Kn(e, t) {
        let r = await Re(t);
        return !r.hasPragma || r.hasPragma(e);
    }
    async function vo(e, t) {
        var n;
        let r = await Re(t);
        return (n = r.hasIgnorePragma) == null ? void 0 : n.call(r, e);
    }
    async function Jt(e, t) {
        let { hasBOM: r, text: n, options: u } = Jn(e, await ne(t));
        if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await Kn(n, u) || u.checkIgnorePragma && await vo(n, u)) return {
            formatted: e,
            cursorOffset: t.cursorOffset,
            comments: []
        };
        let o;
        return u.rangeStart > 0 || u.rangeEnd < n.length ? o = await Po(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await Kn(n, u) && (n = u.printer.insertPragma(n)), o = await Hn(n, u)), r && (o.formatted = zn + o.formatted, o.cursorOffset >= 0 && o.cursorOffset++), o;
    }
    async function qn(e, t, r) {
        let { text: n, options: u } = Jn(e, await ne(t)), o = await De(n, u);
        return r && (r.preprocessForPrint && (o.ast = await Gt(o.ast, u)), r.massage && (o.ast = Yn(o.ast, u))), o;
    }
    async function Xn(e, t) {
        t = await ne(t);
        let r = await Ye(e, t);
        return me(r, t);
    }
    async function Qn(e, t) {
        let r = wr(e), { formatted: n } = await Jt(r, {
            ...t,
            parser: "__js_expression"
        });
        return n;
    }
    async function Zn(e, t) {
        t = await ne(t);
        let { ast: r } = await De(e, t);
        return t.cursorOffset >= 0 && (t = {
            ...t,
            ...Kt(r, t)
        }), Ye(r, t);
    }
    async function eu(e, t) {
        return me(e, await ne(t));
    }
    var qt = {};
    dt(qt, {
        builders: ()=>Io,
        printer: ()=>Ro,
        utils: ()=>Yo
    });
    var Io = {
        join: ke,
        line: Ge,
        softline: _r,
        hardline: z,
        literalline: Me,
        group: At,
        conditionalGroup: Cr,
        fill: hr,
        lineSuffix: Se,
        lineSuffixBoundary: Ar,
        cursor: X,
        breakParent: pe,
        ifBreak: gr,
        trim: Br,
        indent: ie,
        indentIfBreak: yr,
        align: oe,
        addAlignmentToDoc: Ke,
        markAsRoot: mr,
        dedentToRoot: dr,
        dedent: Er,
        hardlineWithoutBreakParent: Te,
        literallineWithoutBreakParent: Bt,
        label: xr,
        concat: (e)=>e
    }, Ro = {
        printDocToString: me
    }, Yo = {
        willBreak: Dr,
        traverseDoc: le,
        findInDoc: $e,
        mapDoc: be,
        removeLines: fr,
        stripTrailingHardline: We,
        replaceEndOfLine: lr,
        canBreak: Fr
    };
    var tu = "3.6.2";
    var Qt = {};
    dt(Qt, {
        addDanglingComment: ()=>ee,
        addLeadingComment: ()=>se,
        addTrailingComment: ()=>ae,
        getAlignmentSize: ()=>Ee,
        getIndentSize: ()=>ru,
        getMaxContinuousCount: ()=>nu,
        getNextNonSpaceNonCommentCharacter: ()=>uu,
        getNextNonSpaceNonCommentCharacterIndex: ()=>Xo,
        getPreferredQuote: ()=>iu,
        getStringWidth: ()=>Ne,
        hasNewline: ()=>G,
        hasNewlineInRange: ()=>su,
        hasSpaces: ()=>au,
        isNextLineEmpty: ()=>ti,
        isNextLineEmptyAfterIndex: ()=>ft,
        isPreviousLineEmpty: ()=>Zo,
        makeString: ()=>Du,
        skip: ()=>he,
        skipEverythingButNewLine: ()=>qe,
        skipInlineComment: ()=>ye,
        skipNewline: ()=>U,
        skipSpaces: ()=>T,
        skipToLineEnd: ()=>Je,
        skipTrailingComment: ()=>Ae,
        skipWhitespace: ()=>Rr
    });
    function jo(e, t) {
        if (t === !1) return !1;
        if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
            for(let r = t + 2; r < e.length; ++r)if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
        }
        return t;
    }
    var ye = jo;
    function Uo(e, t) {
        return t === !1 ? !1 : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? qe(e, t) : t;
    }
    var Ae = Uo;
    function Vo(e, t) {
        let r = null, n = t;
        for(; n !== r;)r = n, n = T(e, n), n = ye(e, n), n = Ae(e, n), n = U(e, n);
        return n;
    }
    var je = Vo;
    function $o(e, t) {
        let r = null, n = t;
        for(; n !== r;)r = n, n = Je(e, n), n = ye(e, n), n = T(e, n);
        return n = Ae(e, n), n = U(e, n), n !== !1 && G(e, n);
    }
    var ft = $o;
    function Wo(e, t) {
        let r = e.lastIndexOf(`
`);
        return r === -1 ? 0 : Ee(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
    }
    var ru = Wo;
    function Xt(e) {
        if (typeof e != "string") throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    function Mo(e, t) {
        let r = e.match(new RegExp(`(${Xt(t)})+`, "gu"));
        return r === null ? 0 : r.reduce((n, u)=>Math.max(n, u.length / t.length), 0);
    }
    var nu = Mo;
    function Go(e, t) {
        let r = je(e, t);
        return r === !1 ? "" : e.charAt(r);
    }
    var uu = Go;
    var lt = "'", ou = '"';
    function Ko(e, t) {
        let r = t === !0 || t === lt ? lt : ou, n = r === lt ? ou : lt, u = 0, o = 0;
        for (let i of e)i === r ? u++ : i === n && o++;
        return u > o ? n : r;
    }
    var iu = Ko;
    function zo(e, t, r) {
        for(let n = t; n < r; ++n)if (e.charAt(n) === `
`) return !0;
        return !1;
    }
    var su = zo;
    function Ho(e, t, r = {}) {
        return T(e, r.backwards ? t - 1 : t, r) !== t;
    }
    var au = Ho;
    function Jo(e, t, r) {
        let n = t === '"' ? "'" : '"', o = te(!1, e, /\\(.)|(["'])/gsu, (i, s, a)=>s === n ? s : a === t ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
        return t + o + t;
    }
    var Du = Jo;
    function qo(e, t, r) {
        return je(e, r(t));
    }
    function Xo(e, t) {
        return arguments.length === 2 || typeof t == "number" ? je(e, t) : qo(...arguments);
    }
    function Qo(e, t, r) {
        return Pe(e, r(t));
    }
    function Zo(e, t) {
        return arguments.length === 2 || typeof t == "number" ? Pe(e, t) : Qo(...arguments);
    }
    function ei(e, t, r) {
        return ft(e, r(t));
    }
    function ti(e, t) {
        return arguments.length === 2 || typeof t == "number" ? ft(e, t) : ei(...arguments);
    }
    function ce(e, t = 1) {
        return async (...r)=>{
            let n = r[t] ?? {}, u = n.plugins ?? [];
            return r[t] = {
                ...n,
                plugins: Array.isArray(u) ? u : Object.values(u)
            }, e(...r);
        };
    }
    var cu = ce(Jt);
    async function fu(e, t) {
        let { formatted: r } = await cu(e, {
            ...t,
            cursorOffset: -1
        });
        return r;
    }
    async function ri(e, t) {
        return await fu(e, t) === e;
    }
    var ni = ce(Ze, 0), ui = {
        parse: ce(qn),
        formatAST: ce(Xn),
        formatDoc: ce(Qn),
        printToDoc: ce(Zn),
        printDocToString: ce(eu)
    };
    return gu(oi);
});

},{}],"6VKVS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _languagesJs = require("./languages.js");
var _languagesJsDefault = parcelHelpers.interopDefault(_languagesJs);
var _parserJs = require("./parser.js");
var _parserJsDefault = parcelHelpers.interopDefault(_parserJs);
var _printerJs = require("./printer.js");
var _printerJsDefault = parcelHelpers.interopDefault(_printerJs);
const plugin = {
    languages: (0, _languagesJsDefault.default),
    parsers: {
        xml: (0, _parserJsDefault.default)
    },
    printers: {
        xml: (0, _printerJsDefault.default)
    },
    options: {
        xmlSelfClosingSpace: {
            type: "boolean",
            category: "XML",
            default: true,
            description: "Adds a space before self-closing tags.",
            since: "1.1.0"
        },
        xmlWhitespaceSensitivity: {
            type: "choice",
            category: "XML",
            default: "strict",
            description: "How to handle whitespaces in XML.",
            choices: [
                {
                    value: "strict",
                    description: "Whitespaces are considered sensitive in all elements."
                },
                {
                    value: "preserve",
                    description: "Whitespaces within text nodes in XML elements and attributes are considered sensitive."
                },
                {
                    value: "ignore",
                    description: "Whitespaces are considered insensitive in all elements."
                }
            ],
            since: "0.6.0"
        },
        xmlSortAttributesByKey: {
            type: "boolean",
            category: "XML",
            default: false,
            description: "Orders XML attributes by key alphabetically while prioritizing xmlns attributes."
        },
        xmlQuoteAttributes: {
            type: "choice",
            category: "XML",
            default: "preserve",
            description: "How to handle whitespaces in XML.",
            choices: [
                {
                    value: "preserve",
                    description: "Quotes in attribute values will be preserved as written."
                },
                {
                    value: "single",
                    description: "Quotes in attribute values will be converted to consistent single quotes and other quotes in the string will be escaped."
                },
                {
                    value: "double",
                    description: "Quotes in attribute values will be converted to consistent double quotes and other quotes in the string will be escaped."
                }
            ]
        }
    },
    defaultOptions: {
        printWidth: 80,
        tabWidth: 2
    }
};
exports.default = plugin;

},{"./languages.js":"2HPtv","./parser.js":"63dn9","./printer.js":"gcUi0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2HPtv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    {
        name: "Ant Build System",
        tmScope: "text.xml.ant",
        codemirrorMode: "xml",
        codemirrorMimeType: "application/xml",
        filenames: [
            "ant.xml",
            "build.xml"
        ],
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 15,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "COLLADA",
        extensions: [
            ".dae"
        ],
        tmScope: "text.xml",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 49,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "Eagle",
        extensions: [
            ".sch",
            ".brd"
        ],
        tmScope: "text.xml",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 97,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "Genshi",
        extensions: [
            ".kid"
        ],
        tmScope: "text.xml.genshi",
        aliases: [
            "xml+genshi",
            "xml+kid"
        ],
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 126,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "JetBrains MPS",
        extensions: [
            ".mps",
            ".mpl",
            ".msd"
        ],
        tmScope: "none",
        aliases: [
            "mps"
        ],
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 465165328,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "LabVIEW",
        extensions: [
            ".lvproj",
            ".lvclass",
            ".lvlib"
        ],
        tmScope: "text.xml",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 194,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "Maven POM",
        tmScope: "text.xml.pom",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        group: "XML",
        filenames: [
            "pom.xml"
        ],
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 226,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "SVG",
        extensions: [
            ".svg"
        ],
        tmScope: "text.xml.svg",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 337,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "Web Ontology Language",
        extensions: [
            ".owl"
        ],
        tmScope: "text.xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 394,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "XML",
        extensions: [
            ".adml",
            ".admx",
            ".ant",
            ".axaml",
            ".axml",
            ".builds",
            ".ccproj",
            ".ccxml",
            ".clixml",
            ".cproject",
            ".cscfg",
            ".csdef",
            ".csl",
            ".csproj",
            ".ct",
            ".depproj",
            ".dita",
            ".ditamap",
            ".ditaval",
            ".dll.config",
            ".dotsettings",
            ".filters",
            ".fsproj",
            ".fxml",
            ".glade",
            ".gml",
            ".gmx",
            ".gpx",
            ".grxml",
            ".gst",
            ".hzp",
            ".iml",
            ".inx",
            ".ivy",
            ".jelly",
            ".jsproj",
            ".kml",
            ".launch",
            ".mdpolicy",
            ".mjml",
            ".mm",
            ".mod",
            ".mojo",
            ".mxml",
            ".natvis",
            ".ncl",
            ".ndproj",
            ".nproj",
            ".nuspec",
            ".odd",
            ".osm",
            ".pkgproj",
            ".pluginspec",
            ".proj",
            ".props",
            ".ps1xml",
            ".psc1",
            ".pt",
            ".qhelp",
            ".rdf",
            ".res",
            ".resx",
            ".rs",
            ".rss",
            ".runsettings",
            ".sch",
            ".scxml",
            ".sfproj",
            ".shproj",
            ".slnx",
            ".srdf",
            ".storyboard",
            ".sublime-snippet",
            ".sw",
            ".targets",
            ".tml",
            ".typ",
            ".ui",
            ".urdf",
            ".ux",
            ".vbproj",
            ".vcxproj",
            ".vsixmanifest",
            ".vssettings",
            ".vstemplate",
            ".vxml",
            ".wixproj",
            ".workflow",
            ".wsdl",
            ".wsf",
            ".wxi",
            ".wxl",
            ".wxs",
            ".x3d",
            ".xacro",
            ".xaml",
            ".xib",
            ".xlf",
            ".xliff",
            ".xmi",
            ".xml",
            ".xml.dist",
            ".xmp",
            ".xproj",
            ".xsd",
            ".xspec",
            ".xul",
            ".zcml"
        ],
        tmScope: "text.xml",
        aliases: [
            "rss",
            "xsd",
            "wsdl"
        ],
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        filenames: [
            ".classpath",
            ".cproject",
            ".project",
            "App.config",
            "NuGet.config",
            "Settings.StyleCop",
            "Web.Debug.config",
            "Web.Release.config",
            "Web.config",
            "packages.config"
        ],
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 399,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "XML Property List",
        extensions: [
            ".plist",
            ".stTheme",
            ".tmCommand",
            ".tmLanguage",
            ".tmPreferences",
            ".tmSnippet",
            ".tmTheme"
        ],
        tmScope: "text.xml.plist",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        group: "XML",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 75622871,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "XPages",
        extensions: [
            ".xsp-config",
            ".xsp.metadata"
        ],
        tmScope: "text.xml",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 400,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "XProc",
        extensions: [
            ".xpl",
            ".xproc"
        ],
        tmScope: "text.xml",
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 401,
        vscodeLanguageIds: [
            "xml"
        ]
    },
    {
        name: "XSLT",
        extensions: [
            ".xslt",
            ".xsl"
        ],
        tmScope: "text.xml.xsl",
        aliases: [
            "xsl"
        ],
        codemirrorMode: "xml",
        codemirrorMimeType: "text/xml",
        since: "0.1.0",
        parsers: [
            "xml"
        ],
        linguistLanguageId: 404,
        vscodeLanguageIds: [
            "xml"
        ]
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"63dn9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parser = require("@xml-tools/parser");
function createError(message, options) {
    // TODO: Use `Error.prototype.cause` when we drop support for Node.js<18.7.0
    // Construct an error similar to the ones thrown by Prettier.
    const error = new SyntaxError(message + " (" + options.loc.start.line + ":" + options.loc.start.column + ")");
    return Object.assign(error, options);
}
function simplifyCST(node) {
    switch(node.name){
        case "attribute":
            {
                const { Name, EQUALS, STRING } = node.children;
                return {
                    name: "attribute",
                    Name: Name[0].image,
                    EQUALS: EQUALS[0].image,
                    STRING: STRING[0].image,
                    location: node.location
                };
            }
        case "chardata":
            {
                const { SEA_WS, TEXT } = node.children;
                return {
                    name: "chardata",
                    SEA_WS: SEA_WS ? SEA_WS[0].image : null,
                    TEXT: TEXT ? TEXT[0].image : null,
                    location: node.location
                };
            }
        case "content":
            {
                const { CData, Comment, chardata, element, PROCESSING_INSTRUCTION, reference } = node.children;
                return {
                    name: "content",
                    CData: CData || [],
                    Comment: Comment || [],
                    chardata: (chardata || []).map(simplifyCST),
                    element: (element || []).map(simplifyCST),
                    PROCESSING_INSTRUCTION: PROCESSING_INSTRUCTION || [],
                    reference: (reference || []).map(simplifyCST),
                    location: node.location
                };
            }
        case "docTypeDecl":
            {
                const { DocType, Name, externalID, CLOSE } = node.children;
                return {
                    name: "docTypeDecl",
                    DocType: DocType[0].image,
                    Name: Name[0].image,
                    externalID: externalID ? simplifyCST(externalID[0]) : null,
                    CLOSE: CLOSE[0].image,
                    location: node.location
                };
            }
        case "document":
            {
                const { docTypeDecl, element, misc, prolog } = node.children;
                return {
                    name: "document",
                    docTypeDecl: docTypeDecl ? simplifyCST(docTypeDecl[0]) : null,
                    element: element ? simplifyCST(element[0]) : null,
                    misc: (misc || []).filter((child)=>!child.children.SEA_WS).map(simplifyCST),
                    prolog: prolog ? simplifyCST(prolog[0]) : null,
                    location: node.location
                };
            }
        case "element":
            {
                const { OPEN, Name, attribute, START_CLOSE, content, SLASH_OPEN, END_NAME, END, SLASH_CLOSE } = node.children;
                return {
                    name: "element",
                    OPEN: OPEN[0].image,
                    Name: Name[0].image,
                    attribute: (attribute || []).map(simplifyCST),
                    START_CLOSE: START_CLOSE ? START_CLOSE[0].image : null,
                    content: content ? simplifyCST(content[0]) : null,
                    SLASH_OPEN: SLASH_OPEN ? SLASH_OPEN[0].image : null,
                    END_NAME: END_NAME ? END_NAME[0].image : null,
                    END: END ? END[0].image : null,
                    SLASH_CLOSE: SLASH_CLOSE ? SLASH_CLOSE[0].image : null,
                    location: node.location
                };
            }
        case "externalID":
            {
                const { Public, PubIDLiteral, System, SystemLiteral } = node.children;
                return {
                    name: "externalID",
                    Public: Public ? Public[0].image : null,
                    PubIDLiteral: PubIDLiteral ? PubIDLiteral[0].image : null,
                    System: System ? System[0].image : null,
                    SystemLiteral: SystemLiteral ? SystemLiteral[0].image : null,
                    location: node.location
                };
            }
        case "misc":
            {
                const { Comment, PROCESSING_INSTRUCTION, SEA_WS } = node.children;
                return {
                    name: "misc",
                    Comment: Comment ? Comment[0].image : null,
                    PROCESSING_INSTRUCTION: PROCESSING_INSTRUCTION ? PROCESSING_INSTRUCTION[0].image : null,
                    SEA_WS: SEA_WS ? SEA_WS[0].image : null,
                    location: node.location
                };
            }
        case "prolog":
            {
                const { XMLDeclOpen, attribute, SPECIAL_CLOSE } = node.children;
                return {
                    name: "prolog",
                    XMLDeclOpen: XMLDeclOpen[0].image,
                    attribute: (attribute || []).map(simplifyCST),
                    SPECIAL_CLOSE: SPECIAL_CLOSE[0].image,
                    location: node.location
                };
            }
        case "reference":
            {
                const { CharRef, EntityRef } = node.children;
                return {
                    name: "reference",
                    CharRef: CharRef ? CharRef[0].image : null,
                    EntityRef: EntityRef ? EntityRef[0].image : null,
                    location: node.location
                };
            }
        default:
            throw new Error(`Unknown node type: ${node.name}`);
    }
}
const parser = {
    parse (text) {
        const { lexErrors, parseErrors, cst } = (0, _parser.parse)(text);
        // If there are any lexical errors, throw the first of them as an error.
        if (lexErrors.length > 0) {
            const lexError = lexErrors[0];
            throw createError(lexError.message, {
                loc: {
                    start: {
                        line: lexError.line,
                        column: lexError.column
                    },
                    end: {
                        line: lexError.line,
                        column: lexError.column + lexError.length
                    }
                }
            });
        }
        // If there are any parse errors, throw the first of them as an error.
        if (parseErrors.length > 0) {
            const parseError = parseErrors[0];
            throw createError(parseError.message, {
                loc: {
                    start: {
                        line: parseError.token.startLine,
                        column: parseError.token.startColumn
                    },
                    end: {
                        line: parseError.token.endLine,
                        column: parseError.token.endColumn
                    }
                }
            });
        }
        // Otherwise return the CST.
        return simplifyCST(cst);
    },
    astFormat: "xml",
    locStart (node) {
        return node.location.startOffset;
    },
    locEnd (node) {
        return node.location.endOffset;
    }
};
exports.default = parser;

},{"@xml-tools/parser":"gB6FW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gB6FW":[function(require,module,exports,__globalThis) {
const { xmlLexer } = require("ffa10a5e9fd8eb5");
const { xmlParser } = require("584cd7ec09c49f4b");
module.exports = {
    parse: function parse(text) {
        const lexResult = xmlLexer.tokenize(text);
        // setting a new input will RESET the parser instance's state.
        xmlParser.input = lexResult.tokens;
        // any top level rule may be used as an entry point
        const cst = xmlParser.document();
        return {
            cst: cst,
            tokenVector: lexResult.tokens,
            lexErrors: lexResult.errors,
            parseErrors: xmlParser.errors
        };
    },
    BaseXmlCstVisitor: xmlParser.getBaseCstVisitorConstructor()
};

},{"ffa10a5e9fd8eb5":"l7JLH","584cd7ec09c49f4b":"3Cgm9"}],"l7JLH":[function(require,module,exports,__globalThis) {
const { createToken: createTokenOrg, Lexer } = require("90802bfc0edba095");
// A little mini DSL for easier lexer definition.
const fragments = {};
const f = fragments;
function FRAGMENT(name, def) {
    fragments[name] = typeof def === "string" ? def : def.source;
}
function makePattern(strings, ...args) {
    let combined = "";
    for(let i = 0; i < strings.length; i++){
        combined += strings[i];
        if (i < args.length) {
            let pattern = args[i];
            // By wrapping in a RegExp (none) capturing group
            // We enabled the safe usage of qualifiers and assertions.
            combined += `(?:${pattern})`;
        }
    }
    return new RegExp(combined);
}
const tokensArray = [];
const tokensDictionary = {};
function createToken(options) {
    const newTokenType = createTokenOrg(options);
    tokensArray.push(newTokenType);
    tokensDictionary[options.name] = newTokenType;
    return newTokenType;
}
FRAGMENT("NameStartChar", "(:|[a-zA-Z]|_|\\u2070-\\u218F|\\u2C00-\\u2FEF|\\u3001-\\uD7FF|\\uF900-\\uFDCF|\\uFDF0-\\uFFFD)");
FRAGMENT("NameChar", makePattern`${f.NameStartChar}|-|\\.|\\d|\\u00B7||[\\u0300-\\u036F]|[\\u203F-\\u2040]`);
FRAGMENT("Name", makePattern`${f.NameStartChar}(${f.NameChar})*`);
const Comment = createToken({
    name: "Comment",
    pattern: /<!--(.|\r?\n)*?-->/,
    // A Comment may span multiple lines.
    line_breaks: true
});
const CData = createToken({
    name: "CData",
    pattern: /<!\[CDATA\[(.|\r?\n)*?]]>/,
    line_breaks: true
});
const DocType = createToken({
    name: "DocType",
    pattern: /<!DOCTYPE/,
    push_mode: "INSIDE"
});
const IgnoredDTD = createToken({
    name: "DTD",
    pattern: /<!.*?>/,
    group: Lexer.SKIPPED
});
const EntityRef = createToken({
    name: "EntityRef",
    pattern: makePattern`&${f.Name};`
});
const CharRef = createToken({
    name: "CharRef",
    pattern: /&#\d+;|&#x[a-fA-F0-9]/
});
const SEA_WS = createToken({
    name: "SEA_WS",
    pattern: /( |\t|\n|\r\n)+/
});
const XMLDeclOpen = createToken({
    name: "XMLDeclOpen",
    pattern: /<\?xml[ \t\r\n]/,
    push_mode: "INSIDE"
});
const SLASH_OPEN = createToken({
    name: "SLASH_OPEN",
    pattern: /<\//,
    push_mode: "INSIDE"
});
const INVALID_SLASH_OPEN = createToken({
    name: "INVALID_SLASH_OPEN",
    pattern: /<\//,
    categories: [
        SLASH_OPEN
    ]
});
const PROCESSING_INSTRUCTION = createToken({
    name: "PROCESSING_INSTRUCTION",
    pattern: makePattern`<\\?${f.Name}.*\\?>`
});
const OPEN = createToken({
    name: "OPEN",
    pattern: /</,
    push_mode: "INSIDE"
});
// Meant to avoid skipping '<' token in a partial sequence of elements.
// Example of the problem this solves:
// <
// <from>john</from>
//  - The second '<' will be skipped because in the mode "INSIDE" '<' is not recognized.
//  - This means the AST will include only a single element instead of two
const INVALID_OPEN_INSIDE = createToken({
    name: "INVALID_OPEN_INSIDE",
    pattern: /</,
    categories: [
        OPEN
    ]
});
const TEXT = createToken({
    name: "TEXT",
    pattern: /[^<&]+/
});
const CLOSE = createToken({
    name: "CLOSE",
    pattern: />/,
    pop_mode: true
});
const SPECIAL_CLOSE = createToken({
    name: "SPECIAL_CLOSE",
    pattern: /\?>/,
    pop_mode: true
});
const SLASH_CLOSE = createToken({
    name: "SLASH_CLOSE",
    pattern: /\/>/,
    pop_mode: true
});
const SLASH = createToken({
    name: "SLASH",
    pattern: /\//
});
const STRING = createToken({
    name: "STRING",
    pattern: /"[^<"]*"|'[^<']*'/
});
const EQUALS = createToken({
    name: "EQUALS",
    pattern: /=/
});
const Name = createToken({
    name: "Name",
    pattern: makePattern`${f.Name}`
});
const S = createToken({
    name: "S",
    pattern: /[ \t\r\n]/,
    group: Lexer.SKIPPED
});
const xmlLexerDefinition = {
    defaultMode: "OUTSIDE",
    modes: {
        OUTSIDE: [
            Comment,
            CData,
            DocType,
            IgnoredDTD,
            EntityRef,
            CharRef,
            SEA_WS,
            XMLDeclOpen,
            SLASH_OPEN,
            PROCESSING_INSTRUCTION,
            OPEN,
            TEXT
        ],
        INSIDE: [
            // Tokens from `OUTSIDE` to improve error recovery behavior
            Comment,
            INVALID_SLASH_OPEN,
            INVALID_OPEN_INSIDE,
            // "Real" `INSIDE` tokens
            CLOSE,
            SPECIAL_CLOSE,
            SLASH_CLOSE,
            SLASH,
            EQUALS,
            STRING,
            Name,
            S
        ]
    }
};
const xmlLexer = new Lexer(xmlLexerDefinition, {
    // Reducing the amount of position tracking can provide a small performance boost (<10%)
    // Likely best to keep the full info for better error position reporting and
    // to expose "fuller" ITokens from the Lexer.
    positionTracking: "full",
    ensureOptimizations: false,
    // TODO: inspect definitions for XML line terminators
    lineTerminatorCharacters: [
        "\n"
    ],
    lineTerminatorsPattern: /\n|\r\n/g
});
module.exports = {
    xmlLexer,
    tokensDictionary
};

},{"90802bfc0edba095":"wd4P1"}],"wd4P1":[function(require,module,exports,__globalThis) {
/* istanbul ignore file - tricky to import some things from this module during testing */ // semantic version
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>(0, _version.VERSION));
parcelHelpers.export(exports, "CstParser", ()=>(0, _parser.CstParser));
parcelHelpers.export(exports, "EmbeddedActionsParser", ()=>(0, _parser.EmbeddedActionsParser));
parcelHelpers.export(exports, "ParserDefinitionErrorType", ()=>(0, _parser.ParserDefinitionErrorType));
parcelHelpers.export(exports, "EMPTY_ALT", ()=>(0, _parser.EMPTY_ALT));
parcelHelpers.export(exports, "Lexer", ()=>(0, _lexerPublic.Lexer));
parcelHelpers.export(exports, "LexerDefinitionErrorType", ()=>(0, _lexerPublic.LexerDefinitionErrorType));
// Tokens utilities
parcelHelpers.export(exports, "createToken", ()=>(0, _tokensPublic.createToken));
parcelHelpers.export(exports, "createTokenInstance", ()=>(0, _tokensPublic.createTokenInstance));
parcelHelpers.export(exports, "EOF", ()=>(0, _tokensPublic.EOF));
parcelHelpers.export(exports, "tokenLabel", ()=>(0, _tokensPublic.tokenLabel));
parcelHelpers.export(exports, "tokenMatcher", ()=>(0, _tokensPublic.tokenMatcher));
parcelHelpers.export(exports, "tokenName", ()=>(0, _tokensPublic.tokenName));
// Other Utilities
parcelHelpers.export(exports, "defaultGrammarResolverErrorProvider", ()=>(0, _errorsPublic.defaultGrammarResolverErrorProvider));
parcelHelpers.export(exports, "defaultGrammarValidatorErrorProvider", ()=>(0, _errorsPublic.defaultGrammarValidatorErrorProvider));
parcelHelpers.export(exports, "defaultParserErrorProvider", ()=>(0, _errorsPublic.defaultParserErrorProvider));
parcelHelpers.export(exports, "EarlyExitException", ()=>(0, _exceptionsPublic.EarlyExitException));
parcelHelpers.export(exports, "isRecognitionException", ()=>(0, _exceptionsPublic.isRecognitionException));
parcelHelpers.export(exports, "MismatchedTokenException", ()=>(0, _exceptionsPublic.MismatchedTokenException));
parcelHelpers.export(exports, "NotAllInputParsedException", ()=>(0, _exceptionsPublic.NotAllInputParsedException));
parcelHelpers.export(exports, "NoViableAltException", ()=>(0, _exceptionsPublic.NoViableAltException));
parcelHelpers.export(exports, "defaultLexerErrorProvider", ()=>(0, _lexerErrorsPublic.defaultLexerErrorProvider));
// grammar reflection API
parcelHelpers.export(exports, "Alternation", ()=>(0, _gastPublic.Alternation));
parcelHelpers.export(exports, "Alternative", ()=>(0, _gastPublic.Alternative));
parcelHelpers.export(exports, "NonTerminal", ()=>(0, _gastPublic.NonTerminal));
parcelHelpers.export(exports, "Option", ()=>(0, _gastPublic.Option));
parcelHelpers.export(exports, "Repetition", ()=>(0, _gastPublic.Repetition));
parcelHelpers.export(exports, "RepetitionMandatory", ()=>(0, _gastPublic.RepetitionMandatory));
parcelHelpers.export(exports, "RepetitionMandatoryWithSeparator", ()=>(0, _gastPublic.RepetitionMandatoryWithSeparator));
parcelHelpers.export(exports, "RepetitionWithSeparator", ()=>(0, _gastPublic.RepetitionWithSeparator));
parcelHelpers.export(exports, "Rule", ()=>(0, _gastPublic.Rule));
parcelHelpers.export(exports, "Terminal", ()=>(0, _gastPublic.Terminal));
// GAST Utilities
parcelHelpers.export(exports, "serializeGrammar", ()=>(0, _gastPublic.serializeGrammar));
parcelHelpers.export(exports, "serializeProduction", ()=>(0, _gastPublic.serializeProduction));
parcelHelpers.export(exports, "GAstVisitor", ()=>(0, _gastVisitorPublic.GAstVisitor));
parcelHelpers.export(exports, "assignOccurrenceIndices", ()=>(0, _gastResolverPublic.assignOccurrenceIndices));
parcelHelpers.export(exports, "resolveGrammar", ()=>(0, _gastResolverPublic.resolveGrammar));
parcelHelpers.export(exports, "validateGrammar", ()=>(0, _gastResolverPublic.validateGrammar));
parcelHelpers.export(exports, "createSyntaxDiagramsCode", ()=>(0, _renderPublic.createSyntaxDiagramsCode));
parcelHelpers.export(exports, "generateParserFactory", ()=>(0, _generatePublic.generateParserFactory));
parcelHelpers.export(exports, "generateParserModule", ()=>(0, _generatePublic.generateParserModule));
/* istanbul ignore next */ parcelHelpers.export(exports, "clearCache", ()=>clearCache);
parcelHelpers.export(exports, "Parser", ()=>Parser);
var _version = require("./version");
var _parser = require("./parse/parser/parser");
var _lexerPublic = require("./scan/lexer_public");
var _tokensPublic = require("./scan/tokens_public");
var _errorsPublic = require("./parse/errors_public");
var _exceptionsPublic = require("./parse/exceptions_public");
var _lexerErrorsPublic = require("./scan/lexer_errors_public");
var _gastPublic = require("./parse/grammar/gast/gast_public");
var _gastVisitorPublic = require("./parse/grammar/gast/gast_visitor_public");
var _gastResolverPublic = require("./parse/grammar/gast/gast_resolver_public");
var _renderPublic = require("./diagrams/render_public");
var _generatePublic = require("./generate/generate_public");
function clearCache() {
    console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
}
var Parser = /** @class */ function() {
    function Parser() {
        throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_7-0-0");
    }
    return Parser;
}();

},{"./version":"b9fSC","./parse/parser/parser":"ePYOV","./scan/lexer_public":"988dl","./scan/tokens_public":"jSvr0","./parse/errors_public":"af7LB","./parse/exceptions_public":"17qwD","./scan/lexer_errors_public":"2mkr2","./parse/grammar/gast/gast_public":"krg1C","./parse/grammar/gast/gast_visitor_public":"8PTMZ","./parse/grammar/gast/gast_resolver_public":"6kmTG","./diagrams/render_public":"4F2bo","./generate/generate_public":"3Q345","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b9fSC":[function(require,module,exports,__globalThis) {
// needs a separate module as this is required inside chevrotain productive code
// and also in the entry point for webpack(api.ts).
// A separate file avoids cyclic dependencies and webpack errors.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
var VERSION = "7.1.1";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ePYOV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "END_OF_FILE", ()=>END_OF_FILE);
parcelHelpers.export(exports, "DEFAULT_PARSER_CONFIG", ()=>DEFAULT_PARSER_CONFIG);
parcelHelpers.export(exports, "DEFAULT_RULE_CONFIG", ()=>DEFAULT_RULE_CONFIG);
parcelHelpers.export(exports, "ParserDefinitionErrorType", ()=>ParserDefinitionErrorType);
parcelHelpers.export(exports, "EMPTY_ALT", ()=>EMPTY_ALT);
parcelHelpers.export(exports, "Parser", ()=>Parser);
parcelHelpers.export(exports, "CstParser", ()=>CstParser);
parcelHelpers.export(exports, "EmbeddedActionsParser", ()=>EmbeddedActionsParser);
var _utils = require("../../utils/utils");
var _follow = require("../grammar/follow");
var _tokensPublic = require("../../scan/tokens_public");
var _errorsPublic = require("../errors_public");
var _gastResolverPublic = require("../grammar/gast/gast_resolver_public");
var _recoverable = require("./traits/recoverable");
var _looksahead = require("./traits/looksahead");
var _treeBuilder = require("./traits/tree_builder");
var _lexerAdapter = require("./traits/lexer_adapter");
var _recognizerApi = require("./traits/recognizer_api");
var _recognizerEngine = require("./traits/recognizer_engine");
var _errorHandler = require("./traits/error_handler");
var _contextAssist = require("./traits/context_assist");
var _gastRecorder = require("./traits/gast_recorder");
var _perfTracer = require("./traits/perf_tracer");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var END_OF_FILE = (0, _tokensPublic.createTokenInstance)((0, _tokensPublic.EOF), "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(END_OF_FILE);
var DEFAULT_PARSER_CONFIG = Object.freeze({
    recoveryEnabled: false,
    maxLookahead: 3,
    dynamicTokensEnabled: false,
    outputCst: true,
    errorMessageProvider: (0, _errorsPublic.defaultParserErrorProvider),
    nodeLocationTracking: "none",
    traceInitPerf: false,
    skipValidations: false
});
var DEFAULT_RULE_CONFIG = Object.freeze({
    recoveryValueFunc: function() {
        return undefined;
    },
    resyncEnabled: true
});
var ParserDefinitionErrorType;
(function(ParserDefinitionErrorType) {
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
    ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
function EMPTY_ALT(value) {
    if (value === void 0) value = undefined;
    return function() {
        return value;
    };
}
var Parser = /** @class */ function() {
    function Parser(tokenVocabulary, config) {
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        var that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        if ((0, _utils.has)(config, "ignoredIssues")) throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
        this.skipValidations = (0, _utils.has)(config, "skipValidations") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;
    }
    /**
     *  @deprecated use the **instance** method with the same name instead
     */ Parser.performSelfAnalysis = function(parserInstance) {
        throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
    };
    Parser.prototype.performSelfAnalysis = function() {
        var _this = this;
        this.TRACE_INIT("performSelfAnalysis", function() {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function() {
                // Without this voodoo magic the parser would be x3-x4 slower
                // It seems it is better to invoke `toFastProperties` **before**
                // Any manipulations of the `this` object done during the recording phase.
                (0, _utils.toFastProperties)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function() {
                try {
                    _this.enableRecording();
                    // Building the GAST
                    (0, _utils.forEach)(_this.definedRulesNames, function(currRuleName) {
                        var wrappedRule = _this[currRuleName];
                        var originalGrammarAction = wrappedRule["originalGrammarAction"];
                        var recordedRuleGast = undefined;
                        _this.TRACE_INIT(currRuleName + " Rule", function() {
                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                        });
                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                    });
                } finally{
                    _this.disableRecording();
                }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function() {
                resolverErrors = (0, _gastResolverPublic.resolveGrammar)({
                    rules: (0, _utils.values)(_this.gastProductionsCache)
                });
                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors); // mutability for the win?
            });
            _this.TRACE_INIT("Grammar Validations", function() {
                // only perform additional grammar validations IFF no resolving errors have occurred.
                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.
                if ((0, _utils.isEmpty)(resolverErrors) && _this.skipValidations === false) {
                    var validationErrors = (0, _gastResolverPublic.validateGrammar)({
                        rules: (0, _utils.values)(_this.gastProductionsCache),
                        maxLookahead: _this.maxLookahead,
                        tokenTypes: (0, _utils.values)(_this.tokensMap),
                        errMsgProvider: (0, _errorsPublic.defaultGrammarValidatorErrorProvider),
                        grammarName: className
                    });
                    _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors); // mutability for the win?
                }
            });
            // this analysis may fail if the grammar is not perfectly valid
            if ((0, _utils.isEmpty)(_this.definitionErrors)) {
                // The results of these computations are not needed unless error recovery is enabled.
                if (_this.recoveryEnabled) _this.TRACE_INIT("computeAllProdsFollows", function() {
                    var allFollows = (0, _follow.computeAllProdsFollows)((0, _utils.values)(_this.gastProductionsCache));
                    _this.resyncFollows = allFollows;
                });
                _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                    _this.preComputeLookaheadFunctions((0, _utils.values)(_this.gastProductionsCache));
                });
            }
            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !(0, _utils.isEmpty)(_this.definitionErrors)) {
                defErrorsMsgs = (0, _utils.map)(_this.definitionErrors, function(defError) {
                    return defError.message;
                });
                throw new Error("Parser Definition Errors detected:\n " + defErrorsMsgs.join("\n-------------------------------\n"));
            }
        });
    };
    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.
    // (normally during the parser's constructor).
    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,
    // for example: duplicate rule names, referencing an unresolved subrule, ect...
    // This flag should not be enabled during normal usage, it is used in special situations, for example when
    // needing to display the parser definition errors in some GUI(online playground).
    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
    return Parser;
}();
(0, _utils.applyMixins)(Parser, [
    (0, _recoverable.Recoverable),
    (0, _looksahead.LooksAhead),
    (0, _treeBuilder.TreeBuilder),
    (0, _lexerAdapter.LexerAdapter),
    (0, _recognizerEngine.RecognizerEngine),
    (0, _recognizerApi.RecognizerApi),
    (0, _errorHandler.ErrorHandler),
    (0, _contextAssist.ContentAssist),
    (0, _gastRecorder.GastRecorder),
    (0, _perfTracer.PerformanceTracer)
]);
var CstParser = /** @class */ function(_super) {
    __extends(CstParser, _super);
    function CstParser(tokenVocabulary, config) {
        if (config === void 0) config = DEFAULT_PARSER_CONFIG;
        var _this = this;
        var configClone = (0, _utils.cloneObj)(config);
        configClone.outputCst = true;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return CstParser;
}(Parser);
var EmbeddedActionsParser = /** @class */ function(_super) {
    __extends(EmbeddedActionsParser, _super);
    function EmbeddedActionsParser(tokenVocabulary, config) {
        if (config === void 0) config = DEFAULT_PARSER_CONFIG;
        var _this = this;
        var configClone = (0, _utils.cloneObj)(config);
        configClone.outputCst = false;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return EmbeddedActionsParser;
}(Parser);

},{"../../utils/utils":"8K9hy","../grammar/follow":"hCnTc","../../scan/tokens_public":"jSvr0","../errors_public":"af7LB","../grammar/gast/gast_resolver_public":"6kmTG","./traits/recoverable":"gaFM8","./traits/looksahead":"cGikN","./traits/tree_builder":"bgsPX","./traits/lexer_adapter":"emLGG","./traits/recognizer_api":"a6nig","./traits/recognizer_engine":"Olonj","./traits/error_handler":"2W7RW","./traits/context_assist":"4pRzz","./traits/gast_recorder":"6eFnZ","./traits/perf_tracer":"jsW2W","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8K9hy":[function(require,module,exports,__globalThis) {
/*
 Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.
 These utils should replace usage of lodash in the production code base. not because they are any better...
 but for the purpose of being a dependency free library.

 The hotspots in the code are already written in imperative style for performance reasons.
 so writing several dozen utils which may be slower than the original lodash, does not matter as much
 considering they will not be invoked in hotspots...
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "mapValues", ()=>mapValues);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isUndefined", ()=>isUndefined);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "drop", ()=>drop);
parcelHelpers.export(exports, "dropRight", ()=>dropRight);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "reject", ()=>reject);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "contains", ()=>contains);
/**
 * shallow clone
 */ parcelHelpers.export(exports, "cloneArr", ()=>cloneArr);
/**
 * shallow clone
 */ parcelHelpers.export(exports, "cloneObj", ()=>cloneObj);
parcelHelpers.export(exports, "find", ()=>find);
parcelHelpers.export(exports, "findAll", ()=>findAll);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "compact", ()=>compact);
parcelHelpers.export(exports, "uniq", ()=>uniq);
parcelHelpers.export(exports, "partial", ()=>partial);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "indexOf", ()=>indexOf);
parcelHelpers.export(exports, "sortBy", ()=>sortBy);
parcelHelpers.export(exports, "zipObject", ()=>zipObject);
/**
 * mutates! (and returns) target
 */ parcelHelpers.export(exports, "assign", ()=>assign);
/**
 * mutates! (and returns) target
 */ parcelHelpers.export(exports, "assignNoOverwrite", ()=>assignNoOverwrite);
parcelHelpers.export(exports, "defaults", ()=>defaults);
parcelHelpers.export(exports, "groupBy", ()=>groupBy);
/**
 * Merge obj2 into obj1.
 * Will overwrite existing properties with the same name
 */ parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "IDENTITY", ()=>IDENTITY);
/**
 * Will return a new packed array with same values.
 */ parcelHelpers.export(exports, "packArray", ()=>packArray);
parcelHelpers.export(exports, "PRINT_ERROR", ()=>PRINT_ERROR);
parcelHelpers.export(exports, "PRINT_WARNING", ()=>PRINT_WARNING);
parcelHelpers.export(exports, "isES2015MapSupported", ()=>isES2015MapSupported);
parcelHelpers.export(exports, "applyMixins", ()=>applyMixins);
// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216
parcelHelpers.export(exports, "toFastProperties", ()=>toFastProperties);
parcelHelpers.export(exports, "peek", ()=>peek);
/* istanbul ignore next - for performance tracing*/ parcelHelpers.export(exports, "timer", ()=>timer);
function isEmpty(arr) {
    return arr && arr.length === 0;
}
function keys(obj) {
    if (obj === undefined || obj === null) return [];
    return Object.keys(obj);
}
function values(obj) {
    var vals = [];
    var keys = Object.keys(obj);
    for(var i = 0; i < keys.length; i++)vals.push(obj[keys[i]]);
    return vals;
}
function mapValues(obj, callback) {
    var result = [];
    var objKeys = keys(obj);
    for(var idx = 0; idx < objKeys.length; idx++){
        var currKey = objKeys[idx];
        result.push(callback.call(null, obj[currKey], currKey));
    }
    return result;
}
function map(arr, callback) {
    var result = [];
    for(var idx = 0; idx < arr.length; idx++)result.push(callback.call(null, arr[idx], idx));
    return result;
}
function flatten(arr) {
    var result = [];
    for(var idx = 0; idx < arr.length; idx++){
        var currItem = arr[idx];
        if (Array.isArray(currItem)) result = result.concat(flatten(currItem));
        else result.push(currItem);
    }
    return result;
}
function first(arr) {
    return isEmpty(arr) ? undefined : arr[0];
}
function last(arr) {
    var len = arr && arr.length;
    return len ? arr[len - 1] : undefined;
}
function forEach(collection, iteratorCallback) {
    /* istanbul ignore else */ if (Array.isArray(collection)) for(var i = 0; i < collection.length; i++)iteratorCallback.call(null, collection[i], i);
    else if (isObject(collection)) {
        var colKeys = keys(collection);
        for(var i = 0; i < colKeys.length; i++){
            var key = colKeys[i];
            var value = collection[key];
            iteratorCallback.call(null, value, key);
        }
    } else throw Error("non exhaustive match");
}
function isString(item) {
    return typeof item === "string";
}
function isUndefined(item) {
    return item === undefined;
}
function isFunction(item) {
    return item instanceof Function;
}
function drop(arr, howMuch) {
    if (howMuch === void 0) howMuch = 1;
    return arr.slice(howMuch, arr.length);
}
function dropRight(arr, howMuch) {
    if (howMuch === void 0) howMuch = 1;
    return arr.slice(0, arr.length - howMuch);
}
function filter(arr, predicate) {
    var result = [];
    if (Array.isArray(arr)) for(var i = 0; i < arr.length; i++){
        var item = arr[i];
        if (predicate.call(null, item)) result.push(item);
    }
    return result;
}
function reject(arr, predicate) {
    return filter(arr, function(item) {
        return !predicate(item);
    });
}
function pick(obj, predicate) {
    var keys = Object.keys(obj);
    var result = {};
    for(var i = 0; i < keys.length; i++){
        var currKey = keys[i];
        var currItem = obj[currKey];
        if (predicate(currItem)) result[currKey] = currItem;
    }
    return result;
}
function has(obj, prop) {
    if (isObject(obj)) return obj.hasOwnProperty(prop);
    return false;
}
function contains(arr, item) {
    return find(arr, function(currItem) {
        return currItem === item;
    }) !== undefined ? true : false;
}
function cloneArr(arr) {
    var newArr = [];
    for(var i = 0; i < arr.length; i++)newArr.push(arr[i]);
    return newArr;
}
function cloneObj(obj) {
    var clonedObj = {};
    for(var key in obj)/* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(obj, key)) clonedObj[key] = obj[key];
    return clonedObj;
}
function find(arr, predicate) {
    for(var i = 0; i < arr.length; i++){
        var item = arr[i];
        if (predicate.call(null, item)) return item;
    }
    return undefined;
}
function findAll(arr, predicate) {
    var found = [];
    for(var i = 0; i < arr.length; i++){
        var item = arr[i];
        if (predicate.call(null, item)) found.push(item);
    }
    return found;
}
function reduce(arrOrObj, iterator, initial) {
    var isArr = Array.isArray(arrOrObj);
    var vals = isArr ? arrOrObj : values(arrOrObj);
    var objKeys = isArr ? [] : keys(arrOrObj);
    var accumulator = initial;
    for(var i = 0; i < vals.length; i++)accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);
    return accumulator;
}
function compact(arr) {
    return reject(arr, function(item) {
        return item === null || item === undefined;
    });
}
function uniq(arr, identity) {
    if (identity === void 0) identity = function(item) {
        return item;
    };
    var identities = [];
    return reduce(arr, function(result, currItem) {
        var currIdentity = identity(currItem);
        if (contains(identities, currIdentity)) return result;
        else {
            identities.push(currIdentity);
            return result.concat(currItem);
        }
    }, []);
}
function partial(func) {
    var restArgs = [];
    for(var _i = 1; _i < arguments.length; _i++)restArgs[_i - 1] = arguments[_i];
    var firstArg = [
        null
    ];
    var allArgs = firstArg.concat(restArgs);
    return Function.bind.apply(func, allArgs);
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isRegExp(obj) {
    return obj instanceof RegExp;
}
function isObject(obj) {
    return obj instanceof Object;
}
function every(arr, predicate) {
    for(var i = 0; i < arr.length; i++){
        if (!predicate(arr[i], i)) return false;
    }
    return true;
}
function difference(arr, values) {
    return reject(arr, function(item) {
        return contains(values, item);
    });
}
function some(arr, predicate) {
    for(var i = 0; i < arr.length; i++){
        if (predicate(arr[i])) return true;
    }
    return false;
}
function indexOf(arr, value) {
    for(var i = 0; i < arr.length; i++){
        if (arr[i] === value) return i;
    }
    return -1;
}
function sortBy(arr, orderFunc) {
    var result = cloneArr(arr);
    result.sort(function(a, b) {
        return orderFunc(a) - orderFunc(b);
    });
    return result;
}
function zipObject(keys, values) {
    if (keys.length !== values.length) throw Error("can't zipObject with different number of keys and values!");
    var result = {};
    for(var i = 0; i < keys.length; i++)result[keys[i]] = values[i];
    return result;
}
function assign(target) {
    var sources = [];
    for(var _i = 1; _i < arguments.length; _i++)sources[_i - 1] = arguments[_i];
    for(var i = 0; i < sources.length; i++){
        var curSource = sources[i];
        var currSourceKeys = keys(curSource);
        for(var j = 0; j < currSourceKeys.length; j++){
            var currKey = currSourceKeys[j];
            target[currKey] = curSource[currKey];
        }
    }
    return target;
}
function assignNoOverwrite(target) {
    var sources = [];
    for(var _i = 1; _i < arguments.length; _i++)sources[_i - 1] = arguments[_i];
    for(var i = 0; i < sources.length; i++){
        var curSource = sources[i];
        var currSourceKeys = keys(curSource);
        for(var j = 0; j < currSourceKeys.length; j++){
            var currKey = currSourceKeys[j];
            if (!has(target, currKey)) target[currKey] = curSource[currKey];
        }
    }
    return target;
}
function defaults() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    return assignNoOverwrite.apply(null, [
        {}
    ].concat(sources));
}
function groupBy(arr, groupKeyFunc) {
    var result = {};
    forEach(arr, function(item) {
        var currGroupKey = groupKeyFunc(item);
        var currGroupArr = result[currGroupKey];
        if (currGroupArr) currGroupArr.push(item);
        else result[currGroupKey] = [
            item
        ];
    });
    return result;
}
function merge(obj1, obj2) {
    var result = cloneObj(obj1);
    var keys2 = keys(obj2);
    for(var i = 0; i < keys2.length; i++){
        var key = keys2[i];
        var value = obj2[key];
        result[key] = value;
    }
    return result;
}
function NOOP() {}
function IDENTITY(item) {
    return item;
}
function packArray(holeyArr) {
    var result = [];
    for(var i = 0; i < holeyArr.length; i++){
        var orgValue = holeyArr[i];
        result.push(orgValue !== undefined ? orgValue : undefined);
    }
    return result;
}
function PRINT_ERROR(msg) {
    /* istanbul ignore else - can't override global.console in node.js */ if (console && console.error) console.error("Error: " + msg);
}
function PRINT_WARNING(msg) {
    /* istanbul ignore else - can't override global.console in node.js*/ if (console && console.warn) // TODO: modify docs accordingly
    console.warn("Warning: " + msg);
}
function isES2015MapSupported() {
    return typeof Map === "function";
}
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function(baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
            if (propName === "constructor") return;
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            // Handle Accessors
            if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            else derivedCtor.prototype[propName] = baseCtor.prototype[propName];
        });
    });
}
function toFastProperties(toBecomeFast) {
    function FakeConstructor() {}
    // If our object is used as a constructor it would receive
    FakeConstructor.prototype = toBecomeFast;
    var fakeInstance = new FakeConstructor();
    function fakeAccess() {
        return typeof fakeInstance.bar;
    }
    // help V8 understand this is a "real" prototype by actually using
    // the fake instance.
    fakeAccess();
    fakeAccess();
    return toBecomeFast;
}
function peek(arr) {
    return arr[arr.length - 1];
}
function timer(func) {
    var start = new Date().getTime();
    var val = func();
    var end = new Date().getTime();
    var total = end - start;
    return {
        time: total,
        value: val
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hCnTc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ResyncFollowsWalker", ()=>ResyncFollowsWalker);
parcelHelpers.export(exports, "computeAllProdsFollows", ()=>computeAllProdsFollows);
parcelHelpers.export(exports, "buildBetweenProdsFollowPrefix", ()=>buildBetweenProdsFollowPrefix);
parcelHelpers.export(exports, "buildInProdFollowPrefix", ()=>buildInProdFollowPrefix);
var _rest = require("./rest");
var _first = require("./first");
var _utils = require("../../utils/utils");
var _constants = require("../constants");
var _gastPublic = require("./gast/gast_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
// This ResyncFollowsWalker computes all of the follows required for RESYNC
// (skipping reference production).
var ResyncFollowsWalker = /** @class */ function(_super) {
    __extends(ResyncFollowsWalker, _super);
    function ResyncFollowsWalker(topProd) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.follows = {};
        return _this;
    }
    ResyncFollowsWalker.prototype.startWalking = function() {
        this.walk(this.topProd);
        return this.follows;
    };
    ResyncFollowsWalker.prototype.walkTerminal = function(terminal, currRest, prevRest) {
    // do nothing! just like in the public sector after 13:00
    };
    ResyncFollowsWalker.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
        var fullRest = currRest.concat(prevRest);
        var restProd = new (0, _gastPublic.Alternative)({
            definition: fullRest
        });
        var t_in_topProd_follows = (0, _first.first)(restProd);
        this.follows[followName] = t_in_topProd_follows;
    };
    return ResyncFollowsWalker;
}((0, _rest.RestWalker));
function computeAllProdsFollows(topProductions) {
    var reSyncFollows = {};
    (0, _utils.forEach)(topProductions, function(topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0, _utils.assign)(reSyncFollows, currRefsFollow);
    });
    return reSyncFollows;
}
function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
    return inner.name + occurenceInParent + (0, _constants.IN);
}
function buildInProdFollowPrefix(terminal) {
    var terminalName = terminal.terminalType.name;
    return terminalName + terminal.idx + (0, _constants.IN);
}

},{"./rest":"d8Hmj","./first":"l1UOJ","../../utils/utils":"8K9hy","../constants":"a5wbN","./gast/gast_public":"krg1C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d8Hmj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RestWalker", ()=>RestWalker);
var _utils = require("../../utils/utils");
var _gastPublic = require("./gast/gast_public");
/**
 *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.
 */ var RestWalker = /** @class */ function() {
    function RestWalker() {}
    RestWalker.prototype.walk = function(prod, prevRest) {
        var _this = this;
        if (prevRest === void 0) prevRest = [];
        (0, _utils.forEach)(prod.definition, function(subProd, index) {
            var currRest = (0, _utils.drop)(prod.definition, index + 1);
            /* istanbul ignore else */ if (subProd instanceof (0, _gastPublic.NonTerminal)) _this.walkProdRef(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.Terminal)) _this.walkTerminal(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.Alternative)) _this.walkFlat(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.Option)) _this.walkOption(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.RepetitionMandatory)) _this.walkAtLeastOne(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator)) _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.RepetitionWithSeparator)) _this.walkManySep(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.Repetition)) _this.walkMany(subProd, currRest, prevRest);
            else if (subProd instanceof (0, _gastPublic.Alternation)) _this.walkOr(subProd, currRest, prevRest);
            else throw Error("non exhaustive match");
        });
    };
    RestWalker.prototype.walkTerminal = function(terminal, currRest, prevRest) {};
    RestWalker.prototype.walkProdRef = function(refProd, currRest, prevRest) {};
    RestWalker.prototype.walkFlat = function(flatProd, currRest, prevRest) {
        // ABCDEF => after the D the rest is EF
        var fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
    };
    RestWalker.prototype.walkOption = function(optionProd, currRest, prevRest) {
        // ABC(DE)?F => after the (DE)? the rest is F
        var fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
    };
    RestWalker.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F
        var fullAtLeastOneRest = [
            new (0, _gastPublic.Option)({
                definition: atLeastOneProd.definition
            })
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
    };
    RestWalker.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F
        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
    };
    RestWalker.prototype.walkMany = function(manyProd, currRest, prevRest) {
        // ABC(DE)*F => after the (DE)* the rest is (DE)?F
        var fullManyRest = [
            new (0, _gastPublic.Option)({
                definition: manyProd.definition
            })
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
    };
    RestWalker.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F
        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
    };
    RestWalker.prototype.walkOr = function(orProd, currRest, prevRest) {
        var _this = this;
        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G
        var fullOrRest = currRest.concat(prevRest);
        // walk all different alternatives
        (0, _utils.forEach)(orProd.definition, function(alt) {
            // wrapping each alternative in a single definition wrapper
            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows
            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1
            var prodWrapper = new (0, _gastPublic.Alternative)({
                definition: [
                    alt
                ]
            });
            _this.walk(prodWrapper, fullOrRest);
        });
    };
    return RestWalker;
}();
function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
    var repSepRest = [
        new (0, _gastPublic.Option)({
            definition: [
                new (0, _gastPublic.Terminal)({
                    terminalType: repSepProd.separator
                })
            ].concat(repSepProd.definition)
        })
    ];
    var fullRepSepRest = repSepRest.concat(currRest, prevRest);
    return fullRepSepRest;
}

},{"../../utils/utils":"8K9hy","./gast/gast_public":"krg1C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"krg1C":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbstractProduction", ()=>AbstractProduction);
parcelHelpers.export(exports, "NonTerminal", ()=>NonTerminal);
parcelHelpers.export(exports, "Rule", ()=>Rule);
parcelHelpers.export(exports, "Alternative", ()=>Alternative);
parcelHelpers.export(exports, "Option", ()=>Option);
parcelHelpers.export(exports, "RepetitionMandatory", ()=>RepetitionMandatory);
parcelHelpers.export(exports, "RepetitionMandatoryWithSeparator", ()=>RepetitionMandatoryWithSeparator);
parcelHelpers.export(exports, "Repetition", ()=>Repetition);
parcelHelpers.export(exports, "RepetitionWithSeparator", ()=>RepetitionWithSeparator);
parcelHelpers.export(exports, "Alternation", ()=>Alternation);
parcelHelpers.export(exports, "Terminal", ()=>Terminal);
parcelHelpers.export(exports, "serializeGrammar", ()=>serializeGrammar);
parcelHelpers.export(exports, "serializeProduction", ()=>serializeProduction);
var _utils = require("../../../utils/utils");
var _tokensPublic = require("../../../scan/tokens_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var AbstractProduction = /** @class */ function() {
    function AbstractProduction(_definition) {
        this._definition = _definition;
    }
    Object.defineProperty(AbstractProduction.prototype, "definition", {
        get: function() {
            return this._definition;
        },
        set: function(value) {
            this._definition = value;
        },
        enumerable: false,
        configurable: true
    });
    AbstractProduction.prototype.accept = function(visitor) {
        visitor.visit(this);
        (0, _utils.forEach)(this.definition, function(prod) {
            prod.accept(visitor);
        });
    };
    return AbstractProduction;
}();
var NonTerminal = /** @class */ function(_super) {
    __extends(NonTerminal, _super);
    function NonTerminal(options) {
        var _this = _super.call(this, []) || this;
        _this.idx = 1;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    Object.defineProperty(NonTerminal.prototype, "definition", {
        get: function() {
            if (this.referencedRule !== undefined) return this.referencedRule.definition;
            return [];
        },
        set: function(definition) {
        // immutable
        },
        enumerable: false,
        configurable: true
    });
    NonTerminal.prototype.accept = function(visitor) {
        visitor.visit(this);
    // don't visit children of a reference, we will get cyclic infinite loops if we do so
    };
    return NonTerminal;
}(AbstractProduction);
var Rule = /** @class */ function(_super) {
    __extends(Rule, _super);
    function Rule(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.orgText = "";
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return Rule;
}(AbstractProduction);
var Alternative = /** @class */ function(_super) {
    __extends(Alternative, _super);
    function Alternative(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.ignoreAmbiguities = false;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return Alternative;
}(AbstractProduction);
var Option = /** @class */ function(_super) {
    __extends(Option, _super);
    function Option(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return Option;
}(AbstractProduction);
var RepetitionMandatory = /** @class */ function(_super) {
    __extends(RepetitionMandatory, _super);
    function RepetitionMandatory(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return RepetitionMandatory;
}(AbstractProduction);
var RepetitionMandatoryWithSeparator = /** @class */ function(_super) {
    __extends(RepetitionMandatoryWithSeparator, _super);
    function RepetitionMandatoryWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return RepetitionMandatoryWithSeparator;
}(AbstractProduction);
var Repetition = /** @class */ function(_super) {
    __extends(Repetition, _super);
    function Repetition(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return Repetition;
}(AbstractProduction);
var RepetitionWithSeparator = /** @class */ function(_super) {
    __extends(RepetitionWithSeparator, _super);
    function RepetitionWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    return RepetitionWithSeparator;
}(AbstractProduction);
var Alternation = /** @class */ function(_super) {
    __extends(Alternation, _super);
    function Alternation(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        _this.ignoreAmbiguities = false;
        _this.hasPredicates = false;
        (0, _utils.assign)(_this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
        return _this;
    }
    Object.defineProperty(Alternation.prototype, "definition", {
        get: function() {
            return this._definition;
        },
        set: function(value) {
            this._definition = value;
        },
        enumerable: false,
        configurable: true
    });
    return Alternation;
}(AbstractProduction);
var Terminal = /** @class */ function() {
    function Terminal(options) {
        this.idx = 1;
        (0, _utils.assign)(this, (0, _utils.pick)(options, function(v) {
            return v !== undefined;
        }));
    }
    Terminal.prototype.accept = function(visitor) {
        visitor.visit(this);
    };
    return Terminal;
}();
function serializeGrammar(topRules) {
    return (0, _utils.map)(topRules, serializeProduction);
}
function serializeProduction(node) {
    function convertDefinition(definition) {
        return (0, _utils.map)(definition, serializeProduction);
    }
    /* istanbul ignore else */ if (node instanceof NonTerminal) return {
        type: "NonTerminal",
        name: node.nonTerminalName,
        idx: node.idx
    };
    else if (node instanceof Alternative) return {
        type: "Alternative",
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof Option) return {
        type: "Option",
        idx: node.idx,
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof RepetitionMandatory) return {
        type: "RepetitionMandatory",
        idx: node.idx,
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof RepetitionMandatoryWithSeparator) return {
        type: "RepetitionMandatoryWithSeparator",
        idx: node.idx,
        separator: serializeProduction(new Terminal({
            terminalType: node.separator
        })),
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof RepetitionWithSeparator) return {
        type: "RepetitionWithSeparator",
        idx: node.idx,
        separator: serializeProduction(new Terminal({
            terminalType: node.separator
        })),
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof Repetition) return {
        type: "Repetition",
        idx: node.idx,
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof Alternation) return {
        type: "Alternation",
        idx: node.idx,
        definition: convertDefinition(node.definition)
    };
    else if (node instanceof Terminal) {
        var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: (0, _tokensPublic.tokenLabel)(node.terminalType),
            idx: node.idx
        };
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) serializedTerminal.pattern = (0, _utils.isRegExp)(pattern) ? pattern.source : pattern;
        return serializedTerminal;
    } else if (node instanceof Rule) return {
        type: "Rule",
        name: node.name,
        orgText: node.orgText,
        definition: convertDefinition(node.definition)
    };
    else throw Error("non exhaustive match");
}

},{"../../../utils/utils":"8K9hy","../../../scan/tokens_public":"jSvr0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jSvr0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tokenLabel", ()=>tokenLabel);
parcelHelpers.export(exports, "tokenName", ()=>tokenName);
parcelHelpers.export(exports, "hasTokenLabel", ()=>hasTokenLabel);
parcelHelpers.export(exports, "createToken", ()=>createToken);
parcelHelpers.export(exports, "EOF", ()=>EOF);
parcelHelpers.export(exports, "createTokenInstance", ()=>createTokenInstance);
parcelHelpers.export(exports, "tokenMatcher", ()=>tokenMatcher);
var _utils = require("../utils/utils");
var _lexerPublic = require("./lexer_public");
var _tokens = require("./tokens");
function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) return tokType.LABEL;
    else return tokType.name;
}
function tokenName(tokType) {
    return tokType.name;
}
function hasTokenLabel(obj) {
    return (0, _utils.isString)(obj.LABEL) && obj.LABEL !== "";
}
var PARENT = "parent";
var CATEGORIES = "categories";
var LABEL = "label";
var GROUP = "group";
var PUSH_MODE = "push_mode";
var POP_MODE = "pop_mode";
var LONGER_ALT = "longer_alt";
var LINE_BREAKS = "line_breaks";
var START_CHARS_HINT = "start_chars_hint";
function createToken(config) {
    return createTokenInternal(config);
}
function createTokenInternal(config) {
    var pattern = config.pattern;
    var tokenType = {};
    tokenType.name = config.name;
    if (!(0, _utils.isUndefined)(pattern)) tokenType.PATTERN = pattern;
    if ((0, _utils.has)(config, PARENT)) throw "The parent property is no longer supported.\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";
    if ((0, _utils.has)(config, CATEGORIES)) // casting to ANY as this will be fixed inside `augmentTokenTypes``
    tokenType.CATEGORIES = config[CATEGORIES];
    (0, _tokens.augmentTokenTypes)([
        tokenType
    ]);
    if ((0, _utils.has)(config, LABEL)) tokenType.LABEL = config[LABEL];
    if ((0, _utils.has)(config, GROUP)) tokenType.GROUP = config[GROUP];
    if ((0, _utils.has)(config, POP_MODE)) tokenType.POP_MODE = config[POP_MODE];
    if ((0, _utils.has)(config, PUSH_MODE)) tokenType.PUSH_MODE = config[PUSH_MODE];
    if ((0, _utils.has)(config, LONGER_ALT)) tokenType.LONGER_ALT = config[LONGER_ALT];
    if ((0, _utils.has)(config, LINE_BREAKS)) tokenType.LINE_BREAKS = config[LINE_BREAKS];
    if ((0, _utils.has)(config, START_CHARS_HINT)) tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
    return tokenType;
}
var EOF = createToken({
    name: "EOF",
    pattern: (0, _lexerPublic.Lexer).NA
});
(0, _tokens.augmentTokenTypes)([
    EOF
]);
function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
    return {
        image: image,
        startOffset: startOffset,
        endOffset: endOffset,
        startLine: startLine,
        endLine: endLine,
        startColumn: startColumn,
        endColumn: endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
    };
}
function tokenMatcher(token, tokType) {
    return (0, _tokens.tokenStructuredMatcher)(token, tokType);
}

},{"../utils/utils":"8K9hy","./lexer_public":"988dl","./tokens":"535mp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"988dl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LexerDefinitionErrorType", ()=>LexerDefinitionErrorType);
parcelHelpers.export(exports, "Lexer", ()=>Lexer);
var _lexer = require("./lexer");
var _utils = require("../utils/utils");
var _tokens = require("./tokens");
var _lexerErrorsPublic = require("../scan/lexer_errors_public");
var _regExpParser = require("./reg_exp_parser");
var LexerDefinitionErrorType;
(function(LexerDefinitionErrorType) {
    LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
    LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
    LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
var DEFAULT_LEXER_CONFIG = {
    deferDefinitionErrorsHandling: false,
    positionTracking: "full",
    lineTerminatorsPattern: /\n|\r\n?/g,
    lineTerminatorCharacters: [
        "\n",
        "\r"
    ],
    ensureOptimizations: false,
    safeMode: false,
    errorMessageProvider: (0, _lexerErrorsPublic.defaultLexerErrorProvider),
    traceInitPerf: false,
    skipValidations: false
};
Object.freeze(DEFAULT_LEXER_CONFIG);
var Lexer = /** @class */ function() {
    function Lexer(lexerDefinition, config) {
        var _this = this;
        if (config === void 0) config = DEFAULT_LEXER_CONFIG;
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.config = undefined;
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        if (typeof config === "boolean") throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
        // todo: defaults func?
        this.config = (0, _utils.merge)(DEFAULT_LEXER_CONFIG, config);
        var traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
        } else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", function() {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function() {
                if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) // optimized built-in implementation for the defaults definition of lineTerminators
                _this.config.lineTerminatorsPattern = (0, _lexer.LineTerminatorOptimizedTester);
                else {
                    if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                }
                if (config.safeMode && config.ensureOptimizations) throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.
                if ((0, _utils.isArray)(lexerDefinition)) {
                    actualDefinition = {
                        modes: {}
                    };
                    actualDefinition.modes[0, _lexer.DEFAULT_MODE] = (0, _utils.cloneArr)(lexerDefinition);
                    actualDefinition[0, _lexer.DEFAULT_MODE] = (0, _lexer.DEFAULT_MODE);
                } else {
                    // no conversion needed, input should already be a IMultiModeLexerDefinition
                    hasOnlySingleMode = false;
                    actualDefinition = (0, _utils.cloneObj)(lexerDefinition);
                }
            });
            if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function() {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, _lexer.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, _lexer.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
            }
            // for extra robustness to avoid throwing an none informative error message
            actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
            // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.
            // this transformation is to increase robustness in the case of partially invalid lexer definition.
            (0, _utils.forEach)(actualDefinition.modes, function(currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = (0, _utils.reject)(currModeValue, function(currTokType) {
                    return (0, _utils.isUndefined)(currTokType);
                });
            });
            var allModeNames = (0, _utils.keys)(actualDefinition.modes);
            (0, _utils.forEach)(actualDefinition.modes, function(currModDef, currModName) {
                _this.TRACE_INIT("Mode: <" + currModName + "> processing", function() {
                    _this.modes.push(currModName);
                    if (_this.config.skipValidations === false) _this.TRACE_INIT("validatePatterns", function() {
                        _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, _lexer.validatePatterns)(currModDef, allModeNames));
                    });
                    // If definition errors were encountered, the analysis phase may fail unexpectedly/
                    // Considering a lexer with definition errors may never be used, there is no point
                    // to performing the analysis anyhow...
                    if ((0, _utils.isEmpty)(_this.lexerDefinitionErrors)) {
                        (0, _tokens.augmentTokenTypes)(currModDef);
                        var currAnalyzeResult_1;
                        _this.TRACE_INIT("analyzeTokenTypes", function() {
                            currAnalyzeResult_1 = (0, _lexer.analyzeTokenTypes)(currModDef, {
                                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                                positionTracking: config.positionTracking,
                                ensureOptimizations: config.ensureOptimizations,
                                safeMode: config.safeMode,
                                tracer: _this.TRACE_INIT.bind(_this)
                            });
                        });
                        _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                        _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                        _this.emptyGroups = (0, _utils.merge)(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                        _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                        _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                    }
                });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0, _utils.isEmpty)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = (0, _utils.map)(_this.lexerDefinitionErrors, function(error) {
                    return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            // Only print warning if there are no errors, This will avoid pl
            (0, _utils.forEach)(_this.lexerDefinitionWarning, function(warningDescriptor) {
                (0, _utils.PRINT_WARNING)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function() {
                // Choose the relevant internal implementations for this specific parser.
                // These implementations should be in-lined by the JavaScript engine
                // to provide optimal performance in each scenario.
                if (0, _lexer.SUPPORT_STICKY) {
                    _this.chopInput = (0, _utils.IDENTITY);
                    _this.match = _this.matchWithTest;
                } else {
                    _this.updateLastIndex = (0, _utils.NOOP);
                    _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) _this.handleModes = (0, _utils.NOOP);
                if (_this.trackStartLines === false) _this.computeNewColumn = (0, _utils.IDENTITY);
                if (_this.trackEndLines === false) _this.updateTokenEndLineColumnLocation = (0, _utils.NOOP);
                if (/full/i.test(_this.config.positionTracking)) _this.createTokenInstance = _this.createFullToken;
                else if (/onlyStart/i.test(_this.config.positionTracking)) _this.createTokenInstance = _this.createStartOnlyToken;
                else if (/onlyOffset/i.test(_this.config.positionTracking)) _this.createTokenInstance = _this.createOffsetOnlyToken;
                else throw Error("Invalid <positionTracking> config option: \"" + _this.config.positionTracking + "\"");
                if (_this.hasCustom) {
                    _this.addToken = _this.addTokenUsingPush;
                    _this.handlePayload = _this.handlePayloadWithCustom;
                } else {
                    _this.addToken = _this.addTokenUsingMemberAccess;
                    _this.handlePayload = _this.handlePayloadNoCustom;
                }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function() {
                var unOptimizedModes = (0, _utils.reduce)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                    if (canBeOptimized === false) cannotBeOptimized.push(modeName);
                    return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !(0, _utils.isEmpty)(unOptimizedModes)) throw Error("Lexer Modes: < " + unOptimizedModes.join(", ") + " > cannot be optimized.\n" + '\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n' + "\t Or inspect the console log for details on how to resolve these issues.");
            });
            _this.TRACE_INIT("clearRegExpParserCache", function() {
                (0, _regExpParser.clearRegExpParserCache)();
            });
            _this.TRACE_INIT("toFastProperties", function() {
                (0, _utils.toFastProperties)(_this);
            });
        });
    }
    Lexer.prototype.tokenize = function(text, initialMode) {
        if (initialMode === void 0) initialMode = this.defaultMode;
        if (!(0, _utils.isEmpty)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0, _utils.map)(this.lexerDefinitionErrors, function(error) {
                return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
        }
        var lexResult = this.tokenizeInternal(text, initialMode);
        return lexResult;
    };
    // There is quite a bit of duplication between this and "tokenizeInternalLazy"
    // This is intentional due to performance considerations.
    Lexer.prototype.tokenizeInternal = function(text, initialMode) {
        var _this = this;
        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        var orgText = text;
        var orgLength = orgText.length;
        var offset = 0;
        var matchedTokensIndex = 0;
        // initializing the tokensArray to the "guessed" size.
        // guessing too little will still reduce the number of array re-sizes on pushes.
        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory
        // but would still have a faster runtime by avoiding (All but one) array resizing.
        var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.
         : Math.floor(text.length / 10);
        var matchedTokens = new Array(guessedNumberOfTokens);
        var errors = [];
        var line = this.trackStartLines ? 1 : undefined;
        var column = this.trackStartLines ? 1 : undefined;
        var groups = (0, _lexer.cloneEmptyGroups)(this.emptyGroups);
        var trackLines = this.trackStartLines;
        var lineTerminatorPattern = this.config.lineTerminatorsPattern;
        var currModePatternsLength = 0;
        var patternIdxToConfig = [];
        var currCharCodeToPatternIdxToConfig = [];
        var modeStack = [];
        var emptyArray = [];
        Object.freeze(emptyArray);
        var getPossiblePatterns = undefined;
        function getPossiblePatternsSlow() {
            return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = (0, _lexer.charCodeToOptimizedIndex)(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === undefined) return emptyArray;
            else return possiblePatterns;
        }
        var pop_mode = function(popToken) {
            // TODO: perhaps avoid this error in the edge case there is no more input?
            if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
            // So no error should occur.
            popToken.tokenType.PUSH_MODE === undefined) {
                // if we try to pop the last mode there lexer will no longer have ANY mode.
                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                    offset: popToken.startOffset,
                    line: popToken.startLine !== undefined ? popToken.startLine : undefined,
                    column: popToken.startColumn !== undefined ? popToken.startColumn : undefined,
                    length: popToken.image.length,
                    message: msg_1
                });
            } else {
                modeStack.pop();
                var newMode = (0, _utils.last)(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) getPossiblePatterns = getPossiblePatternsOptimized;
                else getPossiblePatterns = getPossiblePatternsSlow;
            }
        };
        function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) getPossiblePatterns = getPossiblePatternsOptimized;
            else getPossiblePatterns = getPossiblePatternsSlow;
        }
        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not
        // seem to matter performance wise.
        push_mode.call(this, initialMode);
        var currConfig;
        while(offset < orgLength){
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for(i = 0; i < chosenPatternsLength; i++){
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                // manually in-lined because > 600 chars won't be in-lined in V8
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                    if (nextCharCode === singleCharCode) // single character string
                    matchedImage = currPattern;
                } else if (currConfig.isCustom === true) {
                    match = currPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                        matchedImage = match[0];
                        if (match.payload !== undefined) payload = match.payload;
                    } else matchedImage = null;
                } else {
                    this.updateLastIndex(currPattern, offset);
                    matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                    // even though this pattern matched we must try a another longer alternative.
                    // this can be used to prioritize keywords over identifiers
                    longerAltIdx = currConfig.longerAlt;
                    if (longerAltIdx !== undefined) {
                        // TODO: micro optimize, avoid extra prop access
                        // by saving/linking longerAlt on the original config?
                        var longerAltConfig = patternIdxToConfig[longerAltIdx];
                        var longerAltPattern = longerAltConfig.pattern;
                        altPayload = null;
                        // single Char can never be a longer alt so no need to test it.
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        if (longerAltConfig.isCustom === true) {
                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                            if (match !== null) {
                                matchAltImage = match[0];
                                if (match.payload !== undefined) altPayload = match.payload;
                            } else matchAltImage = null;
                        } else {
                            this.updateLastIndex(longerAltPattern, offset);
                            matchAltImage = this.match(longerAltPattern, text, offset);
                        }
                        if (matchAltImage && matchAltImage.length > matchedImage.length) {
                            matchedImage = matchAltImage;
                            payload = altPayload;
                            currConfig = longerAltConfig;
                        }
                    }
                    break;
                }
            }
            // successful match
            if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== undefined) {
                    tokType = currConfig.tokenTypeIdx;
                    // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside
                    // createFullToken method
                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                    this.handlePayload(newToken, payload);
                    // TODO: optimize NOOP in case there are no special groups?
                    if (group === false) matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                    else groups[group].push(newToken);
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                // TODO: with newlines the column may be assigned twice
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true && currConfig.canLineTerminator === true) {
                    var numOfLTsInMatch = 0;
                    var foundTerminator = void 0;
                    var lastLTEndOffset = void 0;
                    lineTerminatorPattern.lastIndex = 0;
                    do {
                        foundTerminator = lineTerminatorPattern.test(matchedImage);
                        if (foundTerminator === true) {
                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                            numOfLTsInMatch++;
                        }
                    }while (foundTerminator === true);
                    if (numOfLTsInMatch !== 0) {
                        line = line + numOfLTsInMatch;
                        column = imageLength - lastLTEndOffset;
                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                    }
                }
                // will be NOOP if no modes present
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
            } else {
                // error recovery, drop characters until we identify a valid token's start point
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = false;
                while(!foundResyncPoint && offset < orgLength){
                    // drop chars until we succeed in matching something
                    droppedChar = orgText.charCodeAt(offset);
                    // Identity Func (when sticky flag is enabled)
                    text = this.chopInput(text, 1);
                    offset++;
                    for(j = 0; j < currModePatternsLength; j++){
                        var currConfig_1 = patternIdxToConfig[j];
                        var currPattern = currConfig_1.pattern;
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        var singleCharCode = currConfig_1.short;
                        if (singleCharCode !== false) {
                            if (orgText.charCodeAt(offset) === singleCharCode) // single character string
                            foundResyncPoint = true;
                        } else if (currConfig_1.isCustom === true) foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                        else {
                            this.updateLastIndex(currPattern, offset);
                            foundResyncPoint = currPattern.exec(text) !== null;
                        }
                        if (foundResyncPoint === true) break;
                    }
                }
                errLength = offset - errorStartOffset;
                // at this point we either re-synced or reached the end of the input text
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                    offset: errorStartOffset,
                    line: errorLine,
                    column: errorColumn,
                    length: errLength,
                    message: msg
                });
            }
        }
        // if we do have custom patterns which push directly into the
        // TODO: custom tokens should not push directly??
        if (!this.hasCustom) // if we guessed a too large size for the tokens array this will shrink it to the right size.
        matchedTokens.length = matchedTokensIndex;
        return {
            tokens: matchedTokens,
            groups: groups,
            errors: errors
        };
    };
    Lexer.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
            // need to save the PUSH_MODE property as if the mode is popped
            // patternIdxToPopMode is updated to reflect the new mode after popping the stack
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== undefined) push_mode.call(this, pushMode);
        } else if (config.push !== undefined) push_mode.call(this, config.push);
    };
    Lexer.prototype.chopInput = function(text, length) {
        return text.substring(length);
    };
    Lexer.prototype.updateLastIndex = function(regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
    };
    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
    Lexer.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
        var lastCharIsLT, fixForEndingInLT;
        if (group !== undefined) {
            // a none skipped multi line Token, need to update endLine/endColumn
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                // if a token ends in a LT that last LT only affects the line numbering of following Tokens
                newToken.endLine = line + fixForEndingInLT;
                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)
                // inclusive to exclusive range.
                newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
        // else single LT in the last character of a token, no need to modify the endLine/EndColumn
        }
    };
    Lexer.prototype.computeNewColumn = function(oldColumn, imageLength) {
        return oldColumn + imageLength;
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */ Lexer.prototype.createTokenInstance = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return null;
    };
    Lexer.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
        return {
            image: image,
            startOffset: startOffset,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
            image: image,
            startOffset: startOffset,
            startLine: startLine,
            startColumn: startColumn,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
            image: image,
            startOffset: startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine: startLine,
            endLine: startLine,
            startColumn: startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */ Lexer.prototype.addToken = function(tokenVector, index, tokenToAdd) {
        return 666;
    };
    Lexer.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
    };
    Lexer.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
    };
    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.
    /* istanbul ignore next - place holder */ Lexer.prototype.handlePayload = function(token, payload) {};
    Lexer.prototype.handlePayloadNoCustom = function(token, payload) {};
    Lexer.prototype.handlePayloadWithCustom = function(token, payload) {
        if (payload !== null) token.payload = payload;
    };
    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */ Lexer.prototype.match = function(pattern, text, offset) {
        return null;
    };
    Lexer.prototype.matchWithTest = function(pattern, text, offset) {
        var found = pattern.test(text);
        if (found === true) return text.substring(offset, pattern.lastIndex);
        return null;
    };
    Lexer.prototype.matchWithExec = function(pattern, text) {
        var regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : regExpArray;
    };
    // Duplicated from the parser's perf trace trait to allow future extraction
    // of the lexer to a separate package.
    Lexer.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) console.log(indent + "--> <" + phaseDesc + ">");
            var _a = (0, _utils.timer)(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */ var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            this.traceInitIndent--;
            return value;
        } else return phaseImpl();
    };
    Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
    Lexer.NA = /NOT_APPLICABLE/;
    return Lexer;
}();

},{"./lexer":"lRth9","../utils/utils":"8K9hy","./tokens":"535mp","../scan/lexer_errors_public":"2mkr2","./reg_exp_parser":"aj68x","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lRth9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_MODE", ()=>DEFAULT_MODE);
parcelHelpers.export(exports, "MODES", ()=>MODES);
parcelHelpers.export(exports, "SUPPORT_STICKY", ()=>SUPPORT_STICKY);
parcelHelpers.export(exports, "disableSticky", ()=>disableSticky);
parcelHelpers.export(exports, "enableSticky", ()=>enableSticky);
parcelHelpers.export(exports, "analyzeTokenTypes", ()=>analyzeTokenTypes);
parcelHelpers.export(exports, "validatePatterns", ()=>validatePatterns);
parcelHelpers.export(exports, "findMissingPatterns", ()=>findMissingPatterns);
parcelHelpers.export(exports, "findInvalidPatterns", ()=>findInvalidPatterns);
parcelHelpers.export(exports, "findEndOfInputAnchor", ()=>findEndOfInputAnchor);
parcelHelpers.export(exports, "findEmptyMatchRegExps", ()=>findEmptyMatchRegExps);
parcelHelpers.export(exports, "findStartOfInputAnchor", ()=>findStartOfInputAnchor);
parcelHelpers.export(exports, "findUnsupportedFlags", ()=>findUnsupportedFlags);
// This can only test for identical duplicate RegExps, not semantically equivalent ones.
parcelHelpers.export(exports, "findDuplicatePatterns", ()=>findDuplicatePatterns);
parcelHelpers.export(exports, "findInvalidGroupType", ()=>findInvalidGroupType);
parcelHelpers.export(exports, "findModesThatDoNotExist", ()=>findModesThatDoNotExist);
parcelHelpers.export(exports, "findUnreachablePatterns", ()=>findUnreachablePatterns);
parcelHelpers.export(exports, "addStartOfInput", ()=>addStartOfInput);
parcelHelpers.export(exports, "addStickyFlag", ()=>addStickyFlag);
parcelHelpers.export(exports, "performRuntimeChecks", ()=>performRuntimeChecks);
parcelHelpers.export(exports, "performWarningRuntimeChecks", ()=>performWarningRuntimeChecks);
parcelHelpers.export(exports, "cloneEmptyGroups", ()=>cloneEmptyGroups);
// TODO: refactor to avoid duplication
parcelHelpers.export(exports, "isCustomPattern", ()=>isCustomPattern);
parcelHelpers.export(exports, "isShortPattern", ()=>isShortPattern);
parcelHelpers.export(exports, "LineTerminatorOptimizedTester", ()=>LineTerminatorOptimizedTester);
parcelHelpers.export(exports, "buildLineBreakIssueMessage", ()=>buildLineBreakIssueMessage);
parcelHelpers.export(exports, "minOptimizationVal", ()=>minOptimizationVal);
/**
 * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.
 * This is because ASCI are the most common start chars so each one of those will get its own
 * possible token configs vector.
 *
 * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"
 * to place these into buckets of possible token configs, What we gain from
 * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'
 * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).
 * Our 'charCodeToPatternIdxToConfig' max size will now be:
 * 256 + (2^16 / 2^8) - 1 === 511
 *
 * note the hack for fast division integer part extraction
 * See: https://stackoverflow.com/a/4228528
 */ parcelHelpers.export(exports, "charCodeToOptimizedIndex", ()=>charCodeToOptimizedIndex);
var _regexpToAst = require("regexp-to-ast");
var _lexerPublic = require("./lexer_public");
var _utils = require("../utils/utils");
var _regExp = require("./reg_exp");
var _regExpParser = require("./reg_exp_parser");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var PATTERN = "PATTERN";
var DEFAULT_MODE = "defaultMode";
var MODES = "modes";
var SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
function disableSticky() {
    SUPPORT_STICKY = false;
}
function enableSticky() {
    SUPPORT_STICKY = true;
}
function analyzeTokenTypes(tokenTypes, options) {
    options = (0, _utils.defaults)(options, {
        useSticky: SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: [
            "\r",
            "\n"
        ],
        tracer: function(msg, action) {
            return action();
        }
    });
    var tracer = options.tracer;
    tracer("initCharCodeToOptimizedIndexMap", function() {
        initCharCodeToOptimizedIndexMap();
    });
    var onlyRelevantTypes;
    tracer("Reject Lexer.NA", function() {
        onlyRelevantTypes = (0, _utils.reject)(tokenTypes, function(currType) {
            return currType[PATTERN] === (0, _lexerPublic.Lexer).NA;
        });
    });
    var hasCustom = false;
    var allTransformedPatterns;
    tracer("Transform Patterns", function() {
        hasCustom = false;
        allTransformedPatterns = (0, _utils.map)(onlyRelevantTypes, function(currType) {
            var currPattern = currType[PATTERN];
            /* istanbul ignore else */ if ((0, _utils.isRegExp)(currPattern)) {
                var regExpSource = currPattern.source;
                if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
                regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) return regExpSource;
                else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
                !(0, _utils.contains)([
                    "d",
                    "D",
                    "s",
                    "S",
                    "t",
                    "r",
                    "n",
                    "t",
                    "0",
                    "c",
                    "b",
                    "B",
                    "f",
                    "v",
                    "w",
                    "W"
                ], regExpSource[1])) // escaped meta Characters: /\+/ /\[/
                // or redundant escaping: /\a/
                // without the escaping "\"
                return regExpSource[1];
                else return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
            } else if ((0, _utils.isFunction)(currPattern)) {
                hasCustom = true;
                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
                return {
                    exec: currPattern
                };
            } else if ((0, _utils.has)(currPattern, "exec")) {
                hasCustom = true;
                // ICustomPattern
                return currPattern;
            } else if (typeof currPattern === "string") {
                if (currPattern.length === 1) return currPattern;
                else {
                    var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                    var wrappedRegExp = new RegExp(escapedRegExpString);
                    return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
                }
            } else throw Error("non exhaustive match");
        });
    });
    var patternIdxToType;
    var patternIdxToGroup;
    var patternIdxToLongerAltIdx;
    var patternIdxToPushMode;
    var patternIdxToPopMode;
    tracer("misc mapping", function() {
        patternIdxToType = (0, _utils.map)(onlyRelevantTypes, function(currType) {
            return currType.tokenTypeIdx;
        });
        patternIdxToGroup = (0, _utils.map)(onlyRelevantTypes, function(clazz) {
            var groupName = clazz.GROUP;
            /* istanbul ignore next */ if (groupName === (0, _lexerPublic.Lexer).SKIPPED) return undefined;
            else if ((0, _utils.isString)(groupName)) return groupName;
            else if ((0, _utils.isUndefined)(groupName)) return false;
            else throw Error("non exhaustive match");
        });
        patternIdxToLongerAltIdx = (0, _utils.map)(onlyRelevantTypes, function(clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
                var longerAltIdx = (0, _utils.indexOf)(onlyRelevantTypes, longerAltType);
                return longerAltIdx;
            }
        });
        patternIdxToPushMode = (0, _utils.map)(onlyRelevantTypes, function(clazz) {
            return clazz.PUSH_MODE;
        });
        patternIdxToPopMode = (0, _utils.map)(onlyRelevantTypes, function(clazz) {
            return (0, _utils.has)(clazz, "POP_MODE");
        });
    });
    var patternIdxToCanLineTerminator;
    tracer("Line Terminator Handling", function() {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0, _utils.map)(onlyRelevantTypes, function(tokType) {
            return false;
        });
        if (options.positionTracking !== "onlyOffset") patternIdxToCanLineTerminator = (0, _utils.map)(onlyRelevantTypes, function(tokType) {
            if ((0, _utils.has)(tokType, "LINE_BREAKS")) return tokType.LINE_BREAKS;
            else {
                if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) return (0, _regExp.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
        });
    });
    var patternIdxToIsCustom;
    var patternIdxToShort;
    var emptyGroups;
    var patternIdxToConfig;
    tracer("Misc Mapping #2", function() {
        patternIdxToIsCustom = (0, _utils.map)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0, _utils.map)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0, _utils.reduce)(onlyRelevantTypes, function(acc, clazz) {
            var groupName = clazz.GROUP;
            if ((0, _utils.isString)(groupName) && !(groupName === (0, _lexerPublic.Lexer).SKIPPED)) acc[groupName] = [];
            return acc;
        }, {});
        patternIdxToConfig = (0, _utils.map)(allTransformedPatterns, function(x, idx) {
            return {
                pattern: allTransformedPatterns[idx],
                longerAlt: patternIdxToLongerAltIdx[idx],
                canLineTerminator: patternIdxToCanLineTerminator[idx],
                isCustom: patternIdxToIsCustom[idx],
                short: patternIdxToShort[idx],
                group: patternIdxToGroup[idx],
                push: patternIdxToPushMode[idx],
                pop: patternIdxToPopMode[idx],
                tokenTypeIdx: patternIdxToType[idx],
                tokenType: onlyRelevantTypes[idx]
            };
        });
    });
    var canBeOptimized = true;
    var charCodeToPatternIdxToConfig = [];
    if (!options.safeMode) tracer("First Char Optimization", function() {
        charCodeToPatternIdxToConfig = (0, _utils.reduce)(onlyRelevantTypes, function(result, currTokType, idx) {
            if (typeof currTokType.PATTERN === "string") {
                var charCode = currTokType.PATTERN.charCodeAt(0);
                var optimizedIdx = charCodeToOptimizedIndex(charCode);
                addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
            } else if ((0, _utils.isArray)(currTokType.START_CHARS_HINT)) {
                var lastOptimizedIdx_1;
                (0, _utils.forEach)(currTokType.START_CHARS_HINT, function(charOrInt) {
                    var charCode = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                    var currOptimizedIdx = charCodeToOptimizedIndex(charCode);
                    // Avoid adding the config multiple times
                    /* istanbul ignore else */ // - Difficult to check this scenario effects as it is only a performance
                    //   optimization that does not change correctness
                    if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                        lastOptimizedIdx_1 = currOptimizedIdx;
                        addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                    }
                });
            } else if ((0, _utils.isRegExp)(currTokType.PATTERN)) {
                if (currTokType.PATTERN.unicode) {
                    canBeOptimized = false;
                    if (options.ensureOptimizations) (0, _utils.PRINT_ERROR)("" + (0, _regExp.failedOptimizationPrefixMsg) + ("\tUnable to analyze < " + currTokType.PATTERN.toString() + " > pattern.\n") + "\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n" + "\tThis will disable the lexer's first char optimizations.\n" + "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                } else {
                    var optimizedCodes = (0, _regExp.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                    /* istanbul ignore if */ // start code will only be empty given an empty regExp or failure of regexp-to-ast library
                    // the first should be a different validation and the second cannot be tested.
                    if ((0, _utils.isEmpty)(optimizedCodes)) // we cannot understand what codes may start possible matches
                    // The optimization correctness requires knowing start codes for ALL patterns.
                    // Not actually sure this is an error, no debug message
                    canBeOptimized = false;
                    (0, _utils.forEach)(optimizedCodes, function(code) {
                        addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                    });
                }
            } else {
                if (options.ensureOptimizations) (0, _utils.PRINT_ERROR)("" + (0, _regExp.failedOptimizationPrefixMsg) + ("\tTokenType: <" + currTokType.name + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "\tThis will disable the lexer's first char optimizations.\n" + "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                canBeOptimized = false;
            }
            return result;
        }, []);
    });
    tracer("ArrayPacking", function() {
        charCodeToPatternIdxToConfig = (0, _utils.packArray)(charCodeToPatternIdxToConfig);
    });
    return {
        emptyGroups: emptyGroups,
        patternIdxToConfig: patternIdxToConfig,
        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,
        hasCustom: hasCustom,
        canBeOptimized: canBeOptimized
    };
}
function validatePatterns(tokenTypes, validModesNames) {
    var errors = [];
    var missingResult = findMissingPatterns(tokenTypes);
    errors = errors.concat(missingResult.errors);
    var invalidResult = findInvalidPatterns(missingResult.valid);
    var validTokenTypes = invalidResult.valid;
    errors = errors.concat(invalidResult.errors);
    errors = errors.concat(validateRegExpPattern(validTokenTypes));
    errors = errors.concat(findInvalidGroupType(validTokenTypes));
    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
    errors = errors.concat(findUnreachablePatterns(validTokenTypes));
    return errors;
}
function validateRegExpPattern(tokenTypes) {
    var errors = [];
    var withRegExpPatterns = (0, _utils.filter)(tokenTypes, function(currTokType) {
        return (0, _utils.isRegExp)(currTokType[PATTERN]);
    });
    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
    return errors;
}
function findMissingPatterns(tokenTypes) {
    var tokenTypesWithMissingPattern = (0, _utils.filter)(tokenTypes, function(currType) {
        return !(0, _utils.has)(currType, PATTERN);
    });
    var errors = (0, _utils.map)(tokenTypesWithMissingPattern, function(currType) {
        return {
            message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
            type: (0, _lexerPublic.LexerDefinitionErrorType).MISSING_PATTERN,
            tokenTypes: [
                currType
            ]
        };
    });
    var valid = (0, _utils.difference)(tokenTypes, tokenTypesWithMissingPattern);
    return {
        errors: errors,
        valid: valid
    };
}
function findInvalidPatterns(tokenTypes) {
    var tokenTypesWithInvalidPattern = (0, _utils.filter)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return !(0, _utils.isRegExp)(pattern) && !(0, _utils.isFunction)(pattern) && !(0, _utils.has)(pattern, "exec") && !(0, _utils.isString)(pattern);
    });
    var errors = (0, _utils.map)(tokenTypesWithInvalidPattern, function(currType) {
        return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a" + " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: (0, _lexerPublic.LexerDefinitionErrorType).INVALID_PATTERN,
            tokenTypes: [
                currType
            ]
        };
    });
    var valid = (0, _utils.difference)(tokenTypes, tokenTypesWithInvalidPattern);
    return {
        errors: errors,
        valid: valid
    };
}
var end_of_input = /[^\\][\$]/;
function findEndOfInputAnchor(tokenTypes) {
    var EndAnchorFinder = /** @class */ function(_super) {
        __extends(EndAnchorFinder, _super);
        function EndAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        EndAnchorFinder.prototype.visitEndAnchor = function(node) {
            this.found = true;
        };
        return EndAnchorFinder;
    }((0, _regexpToAst.BaseRegExpVisitor));
    var invalidRegex = (0, _utils.filter)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = (0, _regExpParser.getRegExpAst)(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
        } catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/ return end_of_input.test(pattern.source);
        }
    });
    var errors = (0, _utils.map)(invalidRegex, function(currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n" + "\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" + "\tfor details.",
            type: (0, _lexerPublic.LexerDefinitionErrorType).EOI_ANCHOR_FOUND,
            tokenTypes: [
                currType
            ]
        };
    });
    return errors;
}
function findEmptyMatchRegExps(tokenTypes) {
    var matchesEmptyString = (0, _utils.filter)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern.test("");
    });
    var errors = (0, _utils.map)(matchesEmptyString, function(currType) {
        return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
            type: (0, _lexerPublic.LexerDefinitionErrorType).EMPTY_MATCH_PATTERN,
            tokenTypes: [
                currType
            ]
        };
    });
    return errors;
}
var start_of_input = /[^\\[][\^]|^\^/;
function findStartOfInputAnchor(tokenTypes) {
    var StartAnchorFinder = /** @class */ function(_super) {
        __extends(StartAnchorFinder, _super);
        function StartAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        StartAnchorFinder.prototype.visitStartAnchor = function(node) {
            this.found = true;
        };
        return StartAnchorFinder;
    }((0, _regexpToAst.BaseRegExpVisitor));
    var invalidRegex = (0, _utils.filter)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = (0, _regExpParser.getRegExpAst)(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
        } catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/ return start_of_input.test(pattern.source);
        }
    });
    var errors = (0, _utils.map)(invalidRegex, function(currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n" + "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" + "\tfor details.",
            type: (0, _lexerPublic.LexerDefinitionErrorType).SOI_ANCHOR_FOUND,
            tokenTypes: [
                currType
            ]
        };
    });
    return errors;
}
function findUnsupportedFlags(tokenTypes) {
    var invalidFlags = (0, _utils.filter)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
    });
    var errors = (0, _utils.map)(invalidFlags, function(currType) {
        return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: (0, _lexerPublic.LexerDefinitionErrorType).UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [
                currType
            ]
        };
    });
    return errors;
}
function findDuplicatePatterns(tokenTypes) {
    var found = [];
    var identicalPatterns = (0, _utils.map)(tokenTypes, function(outerType) {
        return (0, _utils.reduce)(tokenTypes, function(result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, _utils.contains)(found, innerType) && innerType.PATTERN !== (0, _lexerPublic.Lexer).NA) {
                // this avoids duplicates in the result, each Token Type may only appear in one "set"
                // in essence we are creating Equivalence classes on equality relation.
                found.push(innerType);
                result.push(innerType);
                return result;
            }
            return result;
        }, []);
    });
    identicalPatterns = (0, _utils.compact)(identicalPatterns);
    var duplicatePatterns = (0, _utils.filter)(identicalPatterns, function(currIdenticalSet) {
        return currIdenticalSet.length > 1;
    });
    var errors = (0, _utils.map)(duplicatePatterns, function(setOfIdentical) {
        var tokenTypeNames = (0, _utils.map)(setOfIdentical, function(currType) {
            return currType.name;
        });
        var dupPatternSrc = (0, _utils.first)(setOfIdentical).PATTERN;
        return {
            message: "The same RegExp pattern ->" + dupPatternSrc + "<-" + ("has been used in all of the following Token Types: " + tokenTypeNames.join(", ") + " <-"),
            type: (0, _lexerPublic.LexerDefinitionErrorType).DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
        };
    });
    return errors;
}
function findInvalidGroupType(tokenTypes) {
    var invalidTypes = (0, _utils.filter)(tokenTypes, function(clazz) {
        if (!(0, _utils.has)(clazz, "GROUP")) return false;
        var group = clazz.GROUP;
        return group !== (0, _lexerPublic.Lexer).SKIPPED && group !== (0, _lexerPublic.Lexer).NA && !(0, _utils.isString)(group);
    });
    var errors = (0, _utils.map)(invalidTypes, function(currType) {
        return {
            message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: (0, _lexerPublic.LexerDefinitionErrorType).INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [
                currType
            ]
        };
    });
    return errors;
}
function findModesThatDoNotExist(tokenTypes, validModes) {
    var invalidModes = (0, _utils.filter)(tokenTypes, function(clazz) {
        return clazz.PUSH_MODE !== undefined && !(0, _utils.contains)(validModes, clazz.PUSH_MODE);
    });
    var errors = (0, _utils.map)(invalidModes, function(tokType) {
        var msg = "Token Type: ->" + tokType.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + tokType.PUSH_MODE + "<-" + "which does not exist";
        return {
            message: msg,
            type: (0, _lexerPublic.LexerDefinitionErrorType).PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [
                tokType
            ]
        };
    });
    return errors;
}
function findUnreachablePatterns(tokenTypes) {
    var errors = [];
    var canBeTested = (0, _utils.reduce)(tokenTypes, function(result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === (0, _lexerPublic.Lexer).NA) return result;
        // a more comprehensive validation for all forms of regExps would require
        // deeper regExp analysis capabilities
        if ((0, _utils.isString)(pattern)) result.push({
            str: pattern,
            idx: idx,
            tokenType: tokType
        });
        else if ((0, _utils.isRegExp)(pattern) && noMetaChar(pattern)) result.push({
            str: pattern.source,
            idx: idx,
            tokenType: tokType
        });
        return result;
    }, []);
    (0, _utils.forEach)(tokenTypes, function(tokType, testIdx) {
        (0, _utils.forEach)(canBeTested, function(_a) {
            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
                var msg = "Token: ->" + tokenType.name + "<- can never be matched.\n" + ("Because it appears AFTER the Token Type ->" + tokType.name + "<-") + "in the lexer's definition.\n" + "See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
                errors.push({
                    message: msg,
                    type: (0, _lexerPublic.LexerDefinitionErrorType).UNREACHABLE_PATTERN,
                    tokenTypes: [
                        tokType,
                        tokenType
                    ]
                });
            }
        });
    });
    return errors;
}
function testTokenType(str, pattern) {
    /* istanbul ignore else */ if ((0, _utils.isRegExp)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
    } else if ((0, _utils.isFunction)(pattern)) // maintain the API of custom patterns
    return pattern(str, 0, [], {});
    else if ((0, _utils.has)(pattern, "exec")) // maintain the API of custom patterns
    return pattern.exec(str, 0, [], {});
    else if (typeof pattern === "string") return pattern === str;
    else throw Error("non exhaustive match");
}
function noMetaChar(regExp) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
    ];
    return (0, _utils.find)(metaChars, function(char) {
        return regExp.source.indexOf(char) !== -1;
    }) === undefined;
}
function addStartOfInput(pattern) {
    var flags = pattern.ignoreCase ? "i" : "";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("^(?:" + pattern.source + ")", flags);
}
function addStickyFlag(pattern) {
    var flags = pattern.ignoreCase ? "iy" : "y";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("" + pattern.source, flags);
}
function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var errors = [];
    // some run time checks to help the end users.
    if (!(0, _utils.has)(lexerDefinition, DEFAULT_MODE)) errors.push({
        message: "A MultiMode Lexer cannot be initialized without a <" + DEFAULT_MODE + "> property in its definition\n",
        type: (0, _lexerPublic.LexerDefinitionErrorType).MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
    });
    if (!(0, _utils.has)(lexerDefinition, MODES)) errors.push({
        message: "A MultiMode Lexer cannot be initialized without a <" + MODES + "> property in its definition\n",
        type: (0, _lexerPublic.LexerDefinitionErrorType).MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
    });
    if ((0, _utils.has)(lexerDefinition, MODES) && (0, _utils.has)(lexerDefinition, DEFAULT_MODE) && !(0, _utils.has)(lexerDefinition.modes, lexerDefinition.defaultMode)) errors.push({
        message: "A MultiMode Lexer cannot be initialized with a " + DEFAULT_MODE + ": <" + lexerDefinition.defaultMode + ">" + "which does not exist\n",
        type: (0, _lexerPublic.LexerDefinitionErrorType).MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
    });
    if ((0, _utils.has)(lexerDefinition, MODES)) (0, _utils.forEach)(lexerDefinition.modes, function(currModeValue, currModeName) {
        (0, _utils.forEach)(currModeValue, function(currTokType, currIdx) {
            if ((0, _utils.isUndefined)(currTokType)) errors.push({
                message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + ("<" + currModeName + "> at index: <" + currIdx + ">\n"),
                type: (0, _lexerPublic.LexerDefinitionErrorType).LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
            });
        });
    });
    return errors;
}
function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var warnings = [];
    var hasAnyLineBreak = false;
    var allTokenTypes = (0, _utils.compact)((0, _utils.flatten)((0, _utils.mapValues)(lexerDefinition.modes, function(tokTypes) {
        return tokTypes;
    })));
    var concreteTokenTypes = (0, _utils.reject)(allTokenTypes, function(currType) {
        return currType[PATTERN] === (0, _lexerPublic.Lexer).NA;
    });
    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
    if (trackLines) (0, _utils.forEach)(concreteTokenTypes, function(tokType) {
        var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
        if (currIssue !== false) {
            var message = buildLineBreakIssueMessage(tokType, currIssue);
            var warningDescriptor = {
                message: message,
                type: currIssue.issue,
                tokenType: tokType
            };
            warnings.push(warningDescriptor);
        } else {
            // we don't want to attempt to scan if the user explicitly specified the line_breaks option.
            if ((0, _utils.has)(tokType, "LINE_BREAKS")) {
                if (tokType.LINE_BREAKS === true) hasAnyLineBreak = true;
            } else if ((0, _regExp.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) hasAnyLineBreak = true;
        }
    });
    if (trackLines && !hasAnyLineBreak) warnings.push({
        message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
        type: (0, _lexerPublic.LexerDefinitionErrorType).NO_LINE_BREAKS_FLAGS
    });
    return warnings;
}
function cloneEmptyGroups(emptyGroups) {
    var clonedResult = {};
    var groupKeys = (0, _utils.keys)(emptyGroups);
    (0, _utils.forEach)(groupKeys, function(currKey) {
        var currGroupValue = emptyGroups[currKey];
        /* istanbul ignore else */ if ((0, _utils.isArray)(currGroupValue)) clonedResult[currKey] = [];
        else throw Error("non exhaustive match");
    });
    return clonedResult;
}
function isCustomPattern(tokenType) {
    var pattern = tokenType.PATTERN;
    /* istanbul ignore else */ if ((0, _utils.isRegExp)(pattern)) return false;
    else if ((0, _utils.isFunction)(pattern)) // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
    return true;
    else if ((0, _utils.has)(pattern, "exec")) // ICustomPattern
    return true;
    else if ((0, _utils.isString)(pattern)) return false;
    else throw Error("non exhaustive match");
}
function isShortPattern(pattern) {
    if ((0, _utils.isString)(pattern) && pattern.length === 1) return pattern.charCodeAt(0);
    else return false;
}
var LineTerminatorOptimizedTester = {
    // implements /\n|\r\n?/g.test
    test: function(text) {
        var len = text.length;
        for(var i = this.lastIndex; i < len; i++){
            var c = text.charCodeAt(i);
            if (c === 10) {
                this.lastIndex = i + 1;
                return true;
            } else if (c === 13) {
                if (text.charCodeAt(i + 1) === 10) this.lastIndex = i + 2;
                else this.lastIndex = i + 1;
                return true;
            }
        }
        return false;
    },
    lastIndex: 0
};
function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
    if ((0, _utils.has)(tokType, "LINE_BREAKS")) // if the user explicitly declared the line_breaks option we will respect their choice
    // and assume it is correct.
    return false;
    else {
        /* istanbul ignore else */ if ((0, _utils.isRegExp)(tokType.PATTERN)) {
            try {
                (0, _regExp.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            } catch (e) {
                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */ return {
                    issue: (0, _lexerPublic.LexerDefinitionErrorType).IDENTIFY_TERMINATOR,
                    errMsg: e.message
                };
            }
            return false;
        } else if ((0, _utils.isString)(tokType.PATTERN)) // string literal patterns can always be analyzed to detect line terminator usage
        return false;
        else if (isCustomPattern(tokType)) // custom token types
        return {
            issue: (0, _lexerPublic.LexerDefinitionErrorType).CUSTOM_LINE_BREAK
        };
        else throw Error("non exhaustive match");
    }
}
function buildLineBreakIssueMessage(tokType, details) {
    /* istanbul ignore else */ if (details.issue === (0, _lexerPublic.LexerDefinitionErrorType).IDENTIFY_TERMINATOR) return "Warning: unable to identify line terminator usage in pattern.\n" + ("\tThe problem is in the <" + tokType.name + "> Token Type\n") + ("\t Root cause: " + details.errMsg + ".\n") + "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
    else if (details.issue === (0, _lexerPublic.LexerDefinitionErrorType).CUSTOM_LINE_BREAK) return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + ("\tThe problem is in the <" + tokType.name + "> Token Type\n") + "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
    else throw Error("non exhaustive match");
}
function getCharCodes(charsOrCodes) {
    var charCodes = (0, _utils.map)(charsOrCodes, function(numOrString) {
        if ((0, _utils.isString)(numOrString) && numOrString.length > 0) return numOrString.charCodeAt(0);
        else return numOrString;
    });
    return charCodes;
}
function addToMapOfArrays(map, key, value) {
    if (map[key] === undefined) map[key] = [
        value
    ];
    else map[key].push(value);
}
var minOptimizationVal = 256;
function charCodeToOptimizedIndex(charCode) {
    return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
}
/**
 * This is a compromise between cold start / hot running performance
 * Creating this array takes ~3ms on a modern machine,
 * But if we perform the computation at runtime as needed the CSS Lexer benchmark
 * performance degrades by ~10%
 *
 * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.
 */ var charCodeToOptimizedIdxMap = [];
function initCharCodeToOptimizedIndexMap() {
    if ((0, _utils.isEmpty)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for(var i = 0; i < 65536; i++)/* tslint:disable */ charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
    }
}

},{"regexp-to-ast":"kIwiv","./lexer_public":"988dl","../utils/utils":"8K9hy","./reg_exp":"cyjIz","./reg_exp_parser":"aj68x","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kIwiv":[function(require,module,exports,__globalThis) {
(function(root, factory) {
    // istanbul ignore next
    if (typeof define === "function" && define.amd) // istanbul ignore next
    define([], factory);
    else if (module.exports) module.exports = factory();
    else // istanbul ignore next
    root.regexpToAst = factory();
})(typeof self !== "undefined" ? self : this, function() {
    // references
    // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983
    // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern
    function RegExpParser() {}
    RegExpParser.prototype.saveState = function() {
        return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
        };
    };
    RegExpParser.prototype.restoreState = function(newState) {
        this.idx = newState.idx;
        this.input = newState.input;
        this.groupIdx = newState.groupIdx;
    };
    RegExpParser.prototype.pattern = function(input) {
        // parser state
        this.idx = 0;
        this.input = input;
        this.groupIdx = 0;
        this.consumeChar("/");
        var value = this.disjunction();
        this.consumeChar("/");
        var flags = {
            type: "Flags",
            loc: {
                begin: this.idx,
                end: input.length
            },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
        };
        while(this.isRegExpFlag())switch(this.popChar()){
            case "g":
                addFlag(flags, "global");
                break;
            case "i":
                addFlag(flags, "ignoreCase");
                break;
            case "m":
                addFlag(flags, "multiLine");
                break;
            case "u":
                addFlag(flags, "unicode");
                break;
            case "y":
                addFlag(flags, "sticky");
                break;
        }
        if (this.idx !== this.input.length) throw Error("Redundant input: " + this.input.substring(this.idx));
        return {
            type: "Pattern",
            flags: flags,
            value: value,
            loc: this.loc(0)
        };
    };
    RegExpParser.prototype.disjunction = function() {
        var alts = [];
        var begin = this.idx;
        alts.push(this.alternative());
        while(this.peekChar() === "|"){
            this.consumeChar("|");
            alts.push(this.alternative());
        }
        return {
            type: "Disjunction",
            value: alts,
            loc: this.loc(begin)
        };
    };
    RegExpParser.prototype.alternative = function() {
        var terms = [];
        var begin = this.idx;
        while(this.isTerm())terms.push(this.term());
        return {
            type: "Alternative",
            value: terms,
            loc: this.loc(begin)
        };
    };
    RegExpParser.prototype.term = function() {
        if (this.isAssertion()) return this.assertion();
        else return this.atom();
    };
    RegExpParser.prototype.assertion = function() {
        var begin = this.idx;
        switch(this.popChar()){
            case "^":
                return {
                    type: "StartAnchor",
                    loc: this.loc(begin)
                };
            case "$":
                return {
                    type: "EndAnchor",
                    loc: this.loc(begin)
                };
            // '\b' or '\B'
            case "\\":
                switch(this.popChar()){
                    case "b":
                        return {
                            type: "WordBoundary",
                            loc: this.loc(begin)
                        };
                    case "B":
                        return {
                            type: "NonWordBoundary",
                            loc: this.loc(begin)
                        };
                }
                // istanbul ignore next
                throw Error("Invalid Assertion Escape");
            // '(?=' or '(?!'
            case "(":
                this.consumeChar("?");
                var type;
                switch(this.popChar()){
                    case "=":
                        type = "Lookahead";
                        break;
                    case "!":
                        type = "NegativeLookahead";
                        break;
                }
                ASSERT_EXISTS(type);
                var disjunction = this.disjunction();
                this.consumeChar(")");
                return {
                    type: type,
                    value: disjunction,
                    loc: this.loc(begin)
                };
        }
        // istanbul ignore next
        ASSERT_NEVER_REACH_HERE();
    };
    RegExpParser.prototype.quantifier = function(isBacktracking) {
        var range;
        var begin = this.idx;
        switch(this.popChar()){
            case "*":
                range = {
                    atLeast: 0,
                    atMost: Infinity
                };
                break;
            case "+":
                range = {
                    atLeast: 1,
                    atMost: Infinity
                };
                break;
            case "?":
                range = {
                    atLeast: 0,
                    atMost: 1
                };
                break;
            case "{":
                var atLeast = this.integerIncludingZero();
                switch(this.popChar()){
                    case "}":
                        range = {
                            atLeast: atLeast,
                            atMost: atLeast
                        };
                        break;
                    case ",":
                        var atMost;
                        if (this.isDigit()) {
                            atMost = this.integerIncludingZero();
                            range = {
                                atLeast: atLeast,
                                atMost: atMost
                            };
                        } else range = {
                            atLeast: atLeast,
                            atMost: Infinity
                        };
                        this.consumeChar("}");
                        break;
                }
                // throwing exceptions from "ASSERT_EXISTS" during backtracking
                // causes severe performance degradations
                if (isBacktracking === true && range === undefined) return undefined;
                ASSERT_EXISTS(range);
                break;
        }
        // throwing exceptions from "ASSERT_EXISTS" during backtracking
        // causes severe performance degradations
        if (isBacktracking === true && range === undefined) return undefined;
        ASSERT_EXISTS(range);
        if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range.greedy = false;
        } else range.greedy = true;
        range.type = "Quantifier";
        range.loc = this.loc(begin);
        return range;
    };
    RegExpParser.prototype.atom = function() {
        var atom;
        var begin = this.idx;
        switch(this.peekChar()){
            case ".":
                atom = this.dotAll();
                break;
            case "\\":
                atom = this.atomEscape();
                break;
            case "[":
                atom = this.characterClass();
                break;
            case "(":
                atom = this.group();
                break;
        }
        if (atom === undefined && this.isPatternCharacter()) atom = this.patternCharacter();
        ASSERT_EXISTS(atom);
        atom.loc = this.loc(begin);
        if (this.isQuantifier()) atom.quantifier = this.quantifier();
        return atom;
    };
    RegExpParser.prototype.dotAll = function() {
        this.consumeChar(".");
        return {
            type: "Set",
            complement: true,
            value: [
                cc("\n"),
                cc("\r"),
                cc("\u2028"),
                cc("\u2029")
            ]
        };
    };
    RegExpParser.prototype.atomEscape = function() {
        this.consumeChar("\\");
        switch(this.peekChar()){
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
                return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
                return this.controlEscapeAtom();
            case "c":
                return this.controlLetterEscapeAtom();
            case "0":
                return this.nulCharacterAtom();
            case "x":
                return this.hexEscapeSequenceAtom();
            case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
            default:
                return this.identityEscapeAtom();
        }
    };
    RegExpParser.prototype.decimalEscapeAtom = function() {
        var value = this.positiveInteger();
        return {
            type: "GroupBackReference",
            value: value
        };
    };
    RegExpParser.prototype.characterClassEscape = function() {
        var set;
        var complement = false;
        switch(this.popChar()){
            case "d":
                set = digitsCharCodes;
                break;
            case "D":
                set = digitsCharCodes;
                complement = true;
                break;
            case "s":
                set = whitespaceCodes;
                break;
            case "S":
                set = whitespaceCodes;
                complement = true;
                break;
            case "w":
                set = wordCharCodes;
                break;
            case "W":
                set = wordCharCodes;
                complement = true;
                break;
        }
        ASSERT_EXISTS(set);
        return {
            type: "Set",
            value: set,
            complement: complement
        };
    };
    RegExpParser.prototype.controlEscapeAtom = function() {
        var escapeCode;
        switch(this.popChar()){
            case "f":
                escapeCode = cc("\f");
                break;
            case "n":
                escapeCode = cc("\n");
                break;
            case "r":
                escapeCode = cc("\r");
                break;
            case "t":
                escapeCode = cc("\t");
                break;
            case "v":
                escapeCode = cc("\v");
                break;
        }
        ASSERT_EXISTS(escapeCode);
        return {
            type: "Character",
            value: escapeCode
        };
    };
    RegExpParser.prototype.controlLetterEscapeAtom = function() {
        this.consumeChar("c");
        var letter = this.popChar();
        if (/[a-zA-Z]/.test(letter) === false) throw Error("Invalid ");
        var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
        return {
            type: "Character",
            value: letterCode
        };
    };
    RegExpParser.prototype.nulCharacterAtom = function() {
        // TODO implement '[lookahead  DecimalDigit]'
        // TODO: for the deprecated octal escape sequence
        this.consumeChar("0");
        return {
            type: "Character",
            value: cc("\0")
        };
    };
    RegExpParser.prototype.hexEscapeSequenceAtom = function() {
        this.consumeChar("x");
        return this.parseHexDigits(2);
    };
    RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
        this.consumeChar("u");
        return this.parseHexDigits(4);
    };
    RegExpParser.prototype.identityEscapeAtom = function() {
        // TODO: implement "SourceCharacter but not UnicodeIDContinue"
        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
        var escapedChar = this.popChar();
        return {
            type: "Character",
            value: cc(escapedChar)
        };
    };
    RegExpParser.prototype.classPatternCharacterAtom = function() {
        switch(this.peekChar()){
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case "]":
                throw Error("TBD");
            default:
                var nextChar = this.popChar();
                return {
                    type: "Character",
                    value: cc(nextChar)
                };
        }
    };
    RegExpParser.prototype.characterClass = function() {
        var set = [];
        var complement = false;
        this.consumeChar("[");
        if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
        }
        while(this.isClassAtom()){
            var from = this.classAtom();
            var isFromSingleChar = from.type === "Character";
            if (isFromSingleChar && this.isRangeDash()) {
                this.consumeChar("-");
                var to = this.classAtom();
                var isToSingleChar = to.type === "Character";
                // a range can only be used when both sides are single characters
                if (isToSingleChar) {
                    if (to.value < from.value) throw Error("Range out of order in character class");
                    set.push({
                        from: from.value,
                        to: to.value
                    });
                } else {
                    // literal dash
                    insertToSet(from.value, set);
                    set.push(cc("-"));
                    insertToSet(to.value, set);
                }
            } else insertToSet(from.value, set);
        }
        this.consumeChar("]");
        return {
            type: "Set",
            complement: complement,
            value: set
        };
    };
    RegExpParser.prototype.classAtom = function() {
        switch(this.peekChar()){
            // istanbul ignore next
            case "]":
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
                throw Error("TBD");
            case "\\":
                return this.classEscape();
            default:
                return this.classPatternCharacterAtom();
        }
    };
    RegExpParser.prototype.classEscape = function() {
        this.consumeChar("\\");
        switch(this.peekChar()){
            // Matches a backspace.
            // (Not to be confused with \b word boundary outside characterClass)
            case "b":
                this.consumeChar("b");
                return {
                    type: "Character",
                    value: cc("\u0008")
                };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
                return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
                return this.controlEscapeAtom();
            case "c":
                return this.controlLetterEscapeAtom();
            case "0":
                return this.nulCharacterAtom();
            case "x":
                return this.hexEscapeSequenceAtom();
            case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
            default:
                return this.identityEscapeAtom();
        }
    };
    RegExpParser.prototype.group = function() {
        var capturing = true;
        this.consumeChar("(");
        switch(this.peekChar(0)){
            case "?":
                this.consumeChar("?");
                this.consumeChar(":");
                capturing = false;
                break;
            default:
                this.groupIdx++;
                break;
        }
        var value = this.disjunction();
        this.consumeChar(")");
        var groupAst = {
            type: "Group",
            capturing: capturing,
            value: value
        };
        if (capturing) groupAst.idx = this.groupIdx;
        return groupAst;
    };
    RegExpParser.prototype.positiveInteger = function() {
        var number = this.popChar();
        // istanbul ignore next - can't ever get here due to previous lookahead checks
        // still implementing this error checking in case this ever changes.
        if (decimalPatternNoZero.test(number) === false) throw Error("Expecting a positive integer");
        while(decimalPattern.test(this.peekChar(0)))number += this.popChar();
        return parseInt(number, 10);
    };
    RegExpParser.prototype.integerIncludingZero = function() {
        var number = this.popChar();
        if (decimalPattern.test(number) === false) throw Error("Expecting an integer");
        while(decimalPattern.test(this.peekChar(0)))number += this.popChar();
        return parseInt(number, 10);
    };
    RegExpParser.prototype.patternCharacter = function() {
        var nextChar = this.popChar();
        switch(nextChar){
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "^":
            // istanbul ignore next
            case "$":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case ".":
            // istanbul ignore next
            case "*":
            // istanbul ignore next
            case "+":
            // istanbul ignore next
            case "?":
            // istanbul ignore next
            case "(":
            // istanbul ignore next
            case ")":
            // istanbul ignore next
            case "[":
            // istanbul ignore next
            case "|":
                // istanbul ignore next
                throw Error("TBD");
            default:
                return {
                    type: "Character",
                    value: cc(nextChar)
                };
        }
    };
    RegExpParser.prototype.isRegExpFlag = function() {
        switch(this.peekChar(0)){
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
                return true;
            default:
                return false;
        }
    };
    RegExpParser.prototype.isRangeDash = function() {
        return this.peekChar() === "-" && this.isClassAtom(1);
    };
    RegExpParser.prototype.isDigit = function() {
        return decimalPattern.test(this.peekChar(0));
    };
    RegExpParser.prototype.isClassAtom = function(howMuch) {
        if (howMuch === undefined) howMuch = 0;
        switch(this.peekChar(howMuch)){
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
                return false;
            default:
                return true;
        }
    };
    RegExpParser.prototype.isTerm = function() {
        return this.isAtom() || this.isAssertion();
    };
    RegExpParser.prototype.isAtom = function() {
        if (this.isPatternCharacter()) return true;
        switch(this.peekChar(0)){
            case ".":
            case "\\":
            case "[":
            // TODO: isAtom must be called before isAssertion - disambiguate
            case "(":
                return true;
            default:
                return false;
        }
    };
    RegExpParser.prototype.isAssertion = function() {
        switch(this.peekChar(0)){
            case "^":
            case "$":
                return true;
            // '\b' or '\B'
            case "\\":
                switch(this.peekChar(1)){
                    case "b":
                    case "B":
                        return true;
                    default:
                        return false;
                }
            // '(?=' or '(?!'
            case "(":
                return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
                return false;
        }
    };
    RegExpParser.prototype.isQuantifier = function() {
        var prevState = this.saveState();
        try {
            return this.quantifier(true) !== undefined;
        } catch (e) {
            return false;
        } finally{
            this.restoreState(prevState);
        }
    };
    RegExpParser.prototype.isPatternCharacter = function() {
        switch(this.peekChar()){
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
                return false;
            default:
                return true;
        }
    };
    RegExpParser.prototype.parseHexDigits = function(howMany) {
        var hexString = "";
        for(var i = 0; i < howMany; i++){
            var hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) throw Error("Expecting a HexDecimal digits");
            hexString += hexChar;
        }
        var charCode = parseInt(hexString, 16);
        return {
            type: "Character",
            value: charCode
        };
    };
    RegExpParser.prototype.peekChar = function(howMuch) {
        if (howMuch === undefined) howMuch = 0;
        return this.input[this.idx + howMuch];
    };
    RegExpParser.prototype.popChar = function() {
        var nextChar = this.peekChar(0);
        this.consumeChar();
        return nextChar;
    };
    RegExpParser.prototype.consumeChar = function(char) {
        if (char !== undefined && this.input[this.idx] !== char) throw Error("Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
        if (this.idx >= this.input.length) throw Error("Unexpected end of input");
        this.idx++;
    };
    RegExpParser.prototype.loc = function(begin) {
        return {
            begin: begin,
            end: this.idx
        };
    };
    // consts and utilities
    var hexDigitPattern = /[0-9a-fA-F]/;
    var decimalPattern = /[0-9]/;
    var decimalPatternNoZero = /[1-9]/;
    function cc(char) {
        return char.charCodeAt(0);
    }
    function insertToSet(item, set) {
        if (item.length !== undefined) item.forEach(function(subItem) {
            set.push(subItem);
        });
        else set.push(item);
    }
    function addFlag(flagObj, flagKey) {
        if (flagObj[flagKey] === true) throw "duplicate flag " + flagKey;
        flagObj[flagKey] = true;
    }
    function ASSERT_EXISTS(obj) {
        // istanbul ignore next
        if (obj === undefined) throw Error("Internal Error - Should never get here!");
    }
    // istanbul ignore next
    function ASSERT_NEVER_REACH_HERE() {
        throw Error("Internal Error - Should never get here!");
    }
    var i;
    var digitsCharCodes = [];
    for(i = cc("0"); i <= cc("9"); i++)digitsCharCodes.push(i);
    var wordCharCodes = [
        cc("_")
    ].concat(digitsCharCodes);
    for(i = cc("a"); i <= cc("z"); i++)wordCharCodes.push(i);
    for(i = cc("A"); i <= cc("Z"); i++)wordCharCodes.push(i);
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes
    var whitespaceCodes = [
        cc(" "),
        cc("\f"),
        cc("\n"),
        cc("\r"),
        cc("\t"),
        cc("\v"),
        cc("\t"),
        cc("\u00a0"),
        cc("\u1680"),
        cc("\u2000"),
        cc("\u2001"),
        cc("\u2002"),
        cc("\u2003"),
        cc("\u2004"),
        cc("\u2005"),
        cc("\u2006"),
        cc("\u2007"),
        cc("\u2008"),
        cc("\u2009"),
        cc("\u200a"),
        cc("\u2028"),
        cc("\u2029"),
        cc("\u202f"),
        cc("\u205f"),
        cc("\u3000"),
        cc("\ufeff")
    ];
    function BaseRegExpVisitor() {}
    BaseRegExpVisitor.prototype.visitChildren = function(node) {
        for(var key in node){
            var child = node[key];
            /* istanbul ignore else */ if (node.hasOwnProperty(key)) {
                if (child.type !== undefined) this.visit(child);
                else if (Array.isArray(child)) child.forEach(function(subChild) {
                    this.visit(subChild);
                }, this);
            }
        }
    };
    BaseRegExpVisitor.prototype.visit = function(node) {
        switch(node.type){
            case "Pattern":
                this.visitPattern(node);
                break;
            case "Flags":
                this.visitFlags(node);
                break;
            case "Disjunction":
                this.visitDisjunction(node);
                break;
            case "Alternative":
                this.visitAlternative(node);
                break;
            case "StartAnchor":
                this.visitStartAnchor(node);
                break;
            case "EndAnchor":
                this.visitEndAnchor(node);
                break;
            case "WordBoundary":
                this.visitWordBoundary(node);
                break;
            case "NonWordBoundary":
                this.visitNonWordBoundary(node);
                break;
            case "Lookahead":
                this.visitLookahead(node);
                break;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                break;
            case "Character":
                this.visitCharacter(node);
                break;
            case "Set":
                this.visitSet(node);
                break;
            case "Group":
                this.visitGroup(node);
                break;
            case "GroupBackReference":
                this.visitGroupBackReference(node);
                break;
            case "Quantifier":
                this.visitQuantifier(node);
                break;
        }
        this.visitChildren(node);
    };
    BaseRegExpVisitor.prototype.visitPattern = function(node) {};
    BaseRegExpVisitor.prototype.visitFlags = function(node) {};
    BaseRegExpVisitor.prototype.visitDisjunction = function(node) {};
    BaseRegExpVisitor.prototype.visitAlternative = function(node) {};
    // Assertion
    BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {};
    BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {};
    BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {};
    BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {};
    BaseRegExpVisitor.prototype.visitLookahead = function(node) {};
    BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {};
    // atoms
    BaseRegExpVisitor.prototype.visitCharacter = function(node) {};
    BaseRegExpVisitor.prototype.visitSet = function(node) {};
    BaseRegExpVisitor.prototype.visitGroup = function(node) {};
    BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {};
    BaseRegExpVisitor.prototype.visitQuantifier = function(node) {};
    return {
        RegExpParser: RegExpParser,
        BaseRegExpVisitor: BaseRegExpVisitor,
        VERSION: "0.5.0"
    };
});

},{}],"cyjIz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "failedOptimizationPrefixMsg", ()=>failedOptimizationPrefixMsg);
parcelHelpers.export(exports, "getOptimizedStartCodesIndices", ()=>getOptimizedStartCodesIndices);
parcelHelpers.export(exports, "firstCharOptimizedIndices", ()=>firstCharOptimizedIndices);
parcelHelpers.export(exports, "canMatchCharCode", ()=>canMatchCharCode);
var _regexpToAst = require("regexp-to-ast");
var _utils = require("../utils/utils");
var _regExpParser = require("./reg_exp_parser");
var _lexer = require("./lexer");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var complementErrorMessage = "Complement Sets are not supported for first char optimization";
var failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
    if (ensureOptimizations === void 0) ensureOptimizations = false;
    try {
        var ast = (0, _regExpParser.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
    } catch (e) {
        /* istanbul ignore next */ // Testing this relies on the regexp-to-ast library having a bug... */
        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc
        if (e.message === complementErrorMessage) {
            if (ensureOptimizations) (0, _utils.PRINT_WARNING)("" + failedOptimizationPrefixMsg + ("\tUnable to optimize: < " + regExp.toString() + " >\n") + "\tComplement Sets cannot be automatically optimized.\n" + "\tThis will disable the lexer's first char optimizations.\n" + "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
        } else {
            var msgSuffix = "";
            if (ensureOptimizations) msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            (0, _utils.PRINT_ERROR)(failedOptimizationPrefixMsg + "\n" + ("\tFailed parsing: < " + regExp.toString() + " >\n") + ("\tUsing the regexp-to-ast library version: " + (0, _regexpToAst.VERSION) + "\n") + "\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
        }
    }
    return [];
}
function firstCharOptimizedIndices(ast, result, ignoreCase) {
    switch(ast.type){
        case "Disjunction":
            for(var i = 0; i < ast.value.length; i++)firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            break;
        case "Alternative":
            var terms = ast.value;
            for(var i = 0; i < terms.length; i++){
                var term = terms[i];
                // skip terms that cannot effect the first char results
                switch(term.type){
                    case "EndAnchor":
                    // A group back reference cannot affect potential starting char.
                    // because if a back reference is the first production than automatically
                    // the group being referenced has had to come BEFORE so its codes have already been added
                    case "GroupBackReference":
                    // assertions do not affect potential starting codes
                    case "Lookahead":
                    case "NegativeLookahead":
                    case "StartAnchor":
                    case "WordBoundary":
                    case "NonWordBoundary":
                        continue;
                }
                var atom = term;
                switch(atom.type){
                    case "Character":
                        addOptimizedIdxToResult(atom.value, result, ignoreCase);
                        break;
                    case "Set":
                        if (atom.complement === true) throw Error(complementErrorMessage);
                        (0, _utils.forEach)(atom.value, function(code) {
                            if (typeof code === "number") addOptimizedIdxToResult(code, result, ignoreCase);
                            else {
                                // range
                                var range = code;
                                // cannot optimize when ignoreCase is
                                if (ignoreCase === true) for(var rangeCode = range.from; rangeCode <= range.to; rangeCode++)addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                else {
                                    // handle unoptimized values
                                    for(var rangeCode = range.from; rangeCode <= range.to && rangeCode < (0, _lexer.minOptimizationVal); rangeCode++)addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    // Less common charCode where we optimize for faster init time, by using larger "buckets"
                                    if (range.to >= (0, _lexer.minOptimizationVal)) {
                                        var minUnOptVal = range.from >= (0, _lexer.minOptimizationVal) ? range.from : (0, _lexer.minOptimizationVal);
                                        var maxUnOptVal = range.to;
                                        var minOptIdx = (0, _lexer.charCodeToOptimizedIndex)(minUnOptVal);
                                        var maxOptIdx = (0, _lexer.charCodeToOptimizedIndex)(maxUnOptVal);
                                        for(var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++)result[currOptIdx] = currOptIdx;
                                    }
                                }
                            }
                        });
                        break;
                    case "Group":
                        firstCharOptimizedIndices(atom.value, result, ignoreCase);
                        break;
                    /* istanbul ignore next */ default:
                        throw Error("Non Exhaustive Match");
                }
                // reached a mandatory production, no more **start** codes can be found on this alternative
                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;
                if (// A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
                atom.type !== "Group" && isOptionalQuantifier === false) break;
            }
            break;
        /* istanbul ignore next */ default:
            throw Error("non exhaustive match!");
    }
    // console.log(Object.keys(result).length)
    return (0, _utils.values)(result);
}
function addOptimizedIdxToResult(code, result, ignoreCase) {
    var optimizedCharIdx = (0, _lexer.charCodeToOptimizedIndex)(code);
    result[optimizedCharIdx] = optimizedCharIdx;
    if (ignoreCase === true) handleIgnoreCase(code, result);
}
function handleIgnoreCase(code, result) {
    var char = String.fromCharCode(code);
    var upperChar = char.toUpperCase();
    /* istanbul ignore else */ if (upperChar !== char) {
        var optimizedCharIdx = (0, _lexer.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
    } else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
            var optimizedCharIdx = (0, _lexer.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
        }
    }
}
function findCode(setNode, targetCharCodes) {
    return (0, _utils.find)(setNode.value, function(codeOrRange) {
        if (typeof codeOrRange === "number") return (0, _utils.contains)(targetCharCodes, codeOrRange);
        else {
            // range
            var range_1 = codeOrRange;
            return (0, _utils.find)(targetCharCodes, function(targetCode) {
                return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== undefined;
        }
    });
}
function isWholeOptional(ast) {
    if (ast.quantifier && ast.quantifier.atLeast === 0) return true;
    if (!ast.value) return false;
    return (0, _utils.isArray)(ast.value) ? (0, _utils.every)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
}
var CharCodeFinder = /** @class */ function(_super) {
    __extends(CharCodeFinder, _super);
    function CharCodeFinder(targetCharCodes) {
        var _this = _super.call(this) || this;
        _this.targetCharCodes = targetCharCodes;
        _this.found = false;
        return _this;
    }
    CharCodeFinder.prototype.visitChildren = function(node) {
        // No need to keep looking...
        if (this.found === true) return;
        // switch lookaheads as they do not actually consume any characters thus
        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.
        switch(node.type){
            case "Lookahead":
                this.visitLookahead(node);
                return;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
        }
        _super.prototype.visitChildren.call(this, node);
    };
    CharCodeFinder.prototype.visitCharacter = function(node) {
        if ((0, _utils.contains)(this.targetCharCodes, node.value)) this.found = true;
    };
    CharCodeFinder.prototype.visitSet = function(node) {
        if (node.complement) {
            if (findCode(node, this.targetCharCodes) === undefined) this.found = true;
        } else if (findCode(node, this.targetCharCodes) !== undefined) this.found = true;
    };
    return CharCodeFinder;
}((0, _regexpToAst.BaseRegExpVisitor));
function canMatchCharCode(charCodes, pattern) {
    if (pattern instanceof RegExp) {
        var ast = (0, _regExpParser.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
    } else return (0, _utils.find)(pattern, function(char) {
        return (0, _utils.contains)(charCodes, char.charCodeAt(0));
    }) !== undefined;
}

},{"regexp-to-ast":"kIwiv","../utils/utils":"8K9hy","./reg_exp_parser":"aj68x","./lexer":"lRth9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aj68x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRegExpAst", ()=>getRegExpAst);
parcelHelpers.export(exports, "clearRegExpParserCache", ()=>clearRegExpParserCache);
var _regexpToAst = require("regexp-to-ast");
var regExpAstCache = {};
var regExpParser = new (0, _regexpToAst.RegExpParser)();
function getRegExpAst(regExp) {
    var regExpStr = regExp.toString();
    if (regExpAstCache.hasOwnProperty(regExpStr)) return regExpAstCache[regExpStr];
    else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
    }
}
function clearRegExpParserCache() {
    regExpAstCache = {};
}

},{"regexp-to-ast":"kIwiv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"535mp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tokenStructuredMatcher", ()=>tokenStructuredMatcher);
// Optimized tokenMatcher in case our grammar does not use token categories
// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead
parcelHelpers.export(exports, "tokenStructuredMatcherNoCategories", ()=>tokenStructuredMatcherNoCategories);
parcelHelpers.export(exports, "tokenShortNameIdx", ()=>tokenShortNameIdx);
parcelHelpers.export(exports, "tokenIdxToClass", ()=>tokenIdxToClass);
parcelHelpers.export(exports, "augmentTokenTypes", ()=>augmentTokenTypes);
parcelHelpers.export(exports, "expandCategories", ()=>expandCategories);
parcelHelpers.export(exports, "assignTokenDefaultProps", ()=>assignTokenDefaultProps);
parcelHelpers.export(exports, "assignCategoriesTokensProp", ()=>assignCategoriesTokensProp);
parcelHelpers.export(exports, "assignCategoriesMapProp", ()=>assignCategoriesMapProp);
parcelHelpers.export(exports, "singleAssignCategoriesToksMap", ()=>singleAssignCategoriesToksMap);
parcelHelpers.export(exports, "hasShortKeyProperty", ()=>hasShortKeyProperty);
parcelHelpers.export(exports, "hasCategoriesProperty", ()=>hasCategoriesProperty);
parcelHelpers.export(exports, "hasExtendingTokensTypesProperty", ()=>hasExtendingTokensTypesProperty);
parcelHelpers.export(exports, "hasExtendingTokensTypesMapProperty", ()=>hasExtendingTokensTypesMapProperty);
parcelHelpers.export(exports, "isTokenType", ()=>isTokenType);
var _utils = require("../utils/utils");
function tokenStructuredMatcher(tokInstance, tokConstructor) {
    var instanceType = tokInstance.tokenTypeIdx;
    if (instanceType === tokConstructor.tokenTypeIdx) return true;
    else return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
}
function tokenStructuredMatcherNoCategories(token, tokType) {
    return token.tokenTypeIdx === tokType.tokenTypeIdx;
}
var tokenShortNameIdx = 1;
var tokenIdxToClass = {};
function augmentTokenTypes(tokenTypes) {
    // collect the parent Token Types as well.
    var tokenTypesAndParents = expandCategories(tokenTypes);
    // add required tokenType and categoryMatches properties
    assignTokenDefaultProps(tokenTypesAndParents);
    // fill up the categoryMatches
    assignCategoriesMapProp(tokenTypesAndParents);
    assignCategoriesTokensProp(tokenTypesAndParents);
    (0, _utils.forEach)(tokenTypesAndParents, function(tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
    });
}
function expandCategories(tokenTypes) {
    var result = (0, _utils.cloneArr)(tokenTypes);
    var categories = tokenTypes;
    var searching = true;
    while(searching){
        categories = (0, _utils.compact)((0, _utils.flatten)((0, _utils.map)(categories, function(currTokType) {
            return currTokType.CATEGORIES;
        })));
        var newCategories = (0, _utils.difference)(categories, result);
        result = result.concat(newCategories);
        if ((0, _utils.isEmpty)(newCategories)) searching = false;
        else categories = newCategories;
    }
    return result;
}
function assignTokenDefaultProps(tokenTypes) {
    (0, _utils.forEach)(tokenTypes, function(currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
            tokenIdxToClass[tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = tokenShortNameIdx++;
        }
        // CATEGORIES? : TokenType | TokenType[]
        if (hasCategoriesProperty(currTokType) && !(0, _utils.isArray)(currTokType.CATEGORIES)) currTokType.CATEGORIES = [
            currTokType.CATEGORIES
        ];
        if (!hasCategoriesProperty(currTokType)) currTokType.CATEGORIES = [];
        if (!hasExtendingTokensTypesProperty(currTokType)) currTokType.categoryMatches = [];
        if (!hasExtendingTokensTypesMapProperty(currTokType)) currTokType.categoryMatchesMap = {};
    });
}
function assignCategoriesTokensProp(tokenTypes) {
    (0, _utils.forEach)(tokenTypes, function(currTokType) {
        // avoid duplications
        currTokType.categoryMatches = [];
        (0, _utils.forEach)(currTokType.categoryMatchesMap, function(val, key) {
            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
        });
    });
}
function assignCategoriesMapProp(tokenTypes) {
    (0, _utils.forEach)(tokenTypes, function(currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
    });
}
function singleAssignCategoriesToksMap(path, nextNode) {
    (0, _utils.forEach)(path, function(pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
    });
    (0, _utils.forEach)(nextNode.CATEGORIES, function(nextCategory) {
        var newPath = path.concat(nextNode);
        // avoids infinite loops due to cyclic categories.
        if (!(0, _utils.contains)(newPath, nextCategory)) singleAssignCategoriesToksMap(newPath, nextCategory);
    });
}
function hasShortKeyProperty(tokType) {
    return (0, _utils.has)(tokType, "tokenTypeIdx");
}
function hasCategoriesProperty(tokType) {
    return (0, _utils.has)(tokType, "CATEGORIES");
}
function hasExtendingTokensTypesProperty(tokType) {
    return (0, _utils.has)(tokType, "categoryMatches");
}
function hasExtendingTokensTypesMapProperty(tokType) {
    return (0, _utils.has)(tokType, "categoryMatchesMap");
}
function isTokenType(tokType) {
    return (0, _utils.has)(tokType, "tokenTypeIdx");
}

},{"../utils/utils":"8K9hy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2mkr2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultLexerErrorProvider", ()=>defaultLexerErrorProvider);
var defaultLexerErrorProvider = {
    buildUnableToPopLexerModeMessage: function(token) {
        return "Unable to pop Lexer Mode after encountering Token ->" + token.image + "<- The Mode Stack is empty";
    },
    buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
        return "unexpected character: ->" + fullText.charAt(startOffset) + "<- at offset: " + startOffset + "," + (" skipped " + length + " characters.");
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l1UOJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "firstForSequence", ()=>firstForSequence);
parcelHelpers.export(exports, "firstForBranching", ()=>firstForBranching);
parcelHelpers.export(exports, "firstForTerminal", ()=>firstForTerminal);
var _utils = require("../../utils/utils");
var _gastPublic = require("./gast/gast_public");
var _gast = require("./gast/gast");
function first(prod) {
    /* istanbul ignore else */ if (prod instanceof (0, _gastPublic.NonTerminal)) // this could in theory cause infinite loops if
    // (1) prod A refs prod B.
    // (2) prod B refs prod A
    // (3) AB can match the empty set
    // in other words a cycle where everything is optional so the first will keep
    // looking ahead for the next optional part and will never exit
    // currently there is no safeguard for this unique edge case because
    // (1) not sure a grammar in which this can happen is useful for anything (productive)
    return first(prod.referencedRule);
    else if (prod instanceof (0, _gastPublic.Terminal)) return firstForTerminal(prod);
    else if ((0, _gast.isSequenceProd)(prod)) return firstForSequence(prod);
    else if ((0, _gast.isBranchingProd)(prod)) return firstForBranching(prod);
    else throw Error("non exhaustive match");
}
function firstForSequence(prod) {
    var firstSet = [];
    var seq = prod.definition;
    var nextSubProdIdx = 0;
    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    var currSubProd;
    // so we enter the loop at least once (if the definition is not empty
    var isLastInnerProdOptional = true;
    // scan a sequence until it's end or until we have found a NONE optional production in it
    while(hasInnerProdsRemaining && isLastInnerProdOptional){
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0, _gast.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    }
    return (0, _utils.uniq)(firstSet);
}
function firstForBranching(prod) {
    var allAlternativesFirsts = (0, _utils.map)(prod.definition, function(innerProd) {
        return first(innerProd);
    });
    return (0, _utils.uniq)((0, _utils.flatten)(allAlternativesFirsts));
}
function firstForTerminal(terminal) {
    return [
        terminal.terminalType
    ];
}

},{"../../utils/utils":"8K9hy","./gast/gast_public":"krg1C","./gast/gast":"k45eR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k45eR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isSequenceProd", ()=>isSequenceProd);
parcelHelpers.export(exports, "isOptionalProd", ()=>isOptionalProd);
parcelHelpers.export(exports, "isBranchingProd", ()=>isBranchingProd);
parcelHelpers.export(exports, "getProductionDslName", ()=>getProductionDslName);
parcelHelpers.export(exports, "DslMethodsCollectorVisitor", ()=>DslMethodsCollectorVisitor);
parcelHelpers.export(exports, "collectMethods", ()=>collectMethods);
var _utils = require("../../../utils/utils");
var _gastPublic = require("./gast_public");
var _gastVisitorPublic = require("./gast_visitor_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
function isSequenceProd(prod) {
    return prod instanceof (0, _gastPublic.Alternative) || prod instanceof (0, _gastPublic.Option) || prod instanceof (0, _gastPublic.Repetition) || prod instanceof (0, _gastPublic.RepetitionMandatory) || prod instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator) || prod instanceof (0, _gastPublic.RepetitionWithSeparator) || prod instanceof (0, _gastPublic.Terminal) || prod instanceof (0, _gastPublic.Rule);
}
function isOptionalProd(prod, alreadyVisited) {
    if (alreadyVisited === void 0) alreadyVisited = [];
    var isDirectlyOptional = prod instanceof (0, _gastPublic.Option) || prod instanceof (0, _gastPublic.Repetition) || prod instanceof (0, _gastPublic.RepetitionWithSeparator);
    if (isDirectlyOptional) return true;
    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
    // empty optional top rule
    // may be indirectly optional ((A?B?C?) | (D?E?F?))
    if (prod instanceof (0, _gastPublic.Alternation)) // for OR its enough for just one of the alternatives to be optional
    return (0, _utils.some)(prod.definition, function(subProd) {
        return isOptionalProd(subProd, alreadyVisited);
    });
    else if (prod instanceof (0, _gastPublic.NonTerminal) && (0, _utils.contains)(alreadyVisited, prod)) // avoiding stack overflow due to infinite recursion
    return false;
    else if (prod instanceof (0, _gastPublic.AbstractProduction)) {
        if (prod instanceof (0, _gastPublic.NonTerminal)) alreadyVisited.push(prod);
        return (0, _utils.every)(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    } else return false;
}
function isBranchingProd(prod) {
    return prod instanceof (0, _gastPublic.Alternation);
}
function getProductionDslName(prod) {
    /* istanbul ignore else */ if (prod instanceof (0, _gastPublic.NonTerminal)) return "SUBRULE";
    else if (prod instanceof (0, _gastPublic.Option)) return "OPTION";
    else if (prod instanceof (0, _gastPublic.Alternation)) return "OR";
    else if (prod instanceof (0, _gastPublic.RepetitionMandatory)) return "AT_LEAST_ONE";
    else if (prod instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator)) return "AT_LEAST_ONE_SEP";
    else if (prod instanceof (0, _gastPublic.RepetitionWithSeparator)) return "MANY_SEP";
    else if (prod instanceof (0, _gastPublic.Repetition)) return "MANY";
    else if (prod instanceof (0, _gastPublic.Terminal)) return "CONSUME";
    else throw Error("non exhaustive match");
}
var DslMethodsCollectorVisitor = /** @class */ function(_super) {
    __extends(DslMethodsCollectorVisitor, _super);
    function DslMethodsCollectorVisitor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // A minus is never valid in an identifier name
        _this.separator = "-";
        _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
        return _this;
    }
    DslMethodsCollectorVisitor.prototype.reset = function() {
        this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
    };
    DslMethodsCollectorVisitor.prototype.visitTerminal = function(terminal) {
        var key = terminal.terminalType.name + this.separator + "Terminal";
        if (!(0, _utils.has)(this.dslMethods, key)) this.dslMethods[key] = [];
        this.dslMethods[key].push(terminal);
    };
    DslMethodsCollectorVisitor.prototype.visitNonTerminal = function(subrule) {
        var key = subrule.nonTerminalName + this.separator + "Terminal";
        if (!(0, _utils.has)(this.dslMethods, key)) this.dslMethods[key] = [];
        this.dslMethods[key].push(subrule);
    };
    DslMethodsCollectorVisitor.prototype.visitOption = function(option) {
        this.dslMethods.option.push(option);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function(manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function(atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetition = function(many) {
        this.dslMethods.repetition.push(many);
    };
    DslMethodsCollectorVisitor.prototype.visitAlternation = function(or) {
        this.dslMethods.alternation.push(or);
    };
    return DslMethodsCollectorVisitor;
}((0, _gastVisitorPublic.GAstVisitor));
var collectorVisitor = new DslMethodsCollectorVisitor();
function collectMethods(rule) {
    collectorVisitor.reset();
    rule.accept(collectorVisitor);
    var dslMethods = collectorVisitor.dslMethods;
    // avoid uncleaned references
    collectorVisitor.reset();
    return dslMethods;
}

},{"../../../utils/utils":"8K9hy","./gast_public":"krg1C","./gast_visitor_public":"8PTMZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8PTMZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GAstVisitor", ()=>GAstVisitor);
var _gastPublic = require("./gast_public");
var GAstVisitor = /** @class */ function() {
    function GAstVisitor() {}
    GAstVisitor.prototype.visit = function(node) {
        var nodeAny = node;
        switch(nodeAny.constructor){
            case 0, _gastPublic.NonTerminal:
                return this.visitNonTerminal(nodeAny);
            case 0, _gastPublic.Alternative:
                return this.visitAlternative(nodeAny);
            case 0, _gastPublic.Option:
                return this.visitOption(nodeAny);
            case 0, _gastPublic.RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
            case 0, _gastPublic.RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case 0, _gastPublic.RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
            case 0, _gastPublic.Repetition:
                return this.visitRepetition(nodeAny);
            case 0, _gastPublic.Alternation:
                return this.visitAlternation(nodeAny);
            case 0, _gastPublic.Terminal:
                return this.visitTerminal(nodeAny);
            case 0, _gastPublic.Rule:
                return this.visitRule(nodeAny);
            /* istanbul ignore next */ default:
                throw Error("non exhaustive match");
        }
    };
    GAstVisitor.prototype.visitNonTerminal = function(node) {};
    GAstVisitor.prototype.visitAlternative = function(node) {};
    GAstVisitor.prototype.visitOption = function(node) {};
    GAstVisitor.prototype.visitRepetition = function(node) {};
    GAstVisitor.prototype.visitRepetitionMandatory = function(node) {};
    GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function(node) {};
    GAstVisitor.prototype.visitRepetitionWithSeparator = function(node) {};
    GAstVisitor.prototype.visitAlternation = function(node) {};
    GAstVisitor.prototype.visitTerminal = function(node) {};
    GAstVisitor.prototype.visitRule = function(node) {};
    return GAstVisitor;
}();

},{"./gast_public":"krg1C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a5wbN":[function(require,module,exports,__globalThis) {
// TODO: can this be removed? where is it used?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IN", ()=>IN);
var IN = "_~IN~_";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"af7LB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultParserErrorProvider", ()=>defaultParserErrorProvider);
parcelHelpers.export(exports, "defaultGrammarResolverErrorProvider", ()=>defaultGrammarResolverErrorProvider);
parcelHelpers.export(exports, "defaultGrammarValidatorErrorProvider", ()=>defaultGrammarValidatorErrorProvider);
var _tokensPublic = require("../scan/tokens_public");
var _utils = require("../utils/utils");
var _gastPublic = require("./grammar/gast/gast_public");
var _gast = require("./grammar/gast/gast");
var defaultParserErrorProvider = {
    buildMismatchTokenMessage: function(_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = (0, _tokensPublic.hasTokenLabel)(expected);
        var expectedMsg = hasLabel ? "--> " + (0, _tokensPublic.tokenLabel)(expected) + " <--" : "token of type --> " + expected.name + " <--";
        var msg = "Expecting " + expectedMsg + " but found --> '" + actual.image + "' <--";
        return msg;
    },
    buildNotAllInputParsedMessage: function(_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
    },
    buildNoViableAltMessage: function(_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = (0, _utils.first)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) return errPrefix + customUserDescription + errSuffix;
        else {
            var allLookAheadPaths = (0, _utils.reduce)(expectedPathsPerAlt, function(result, currAltPaths) {
                return result.concat(currAltPaths);
            }, []);
            var nextValidTokenSequences = (0, _utils.map)(allLookAheadPaths, function(currPath) {
                return "[" + (0, _utils.map)(currPath, function(currTokenType) {
                    return (0, _tokensPublic.tokenLabel)(currTokenType);
                }).join(", ") + "]";
            });
            var nextValidSequenceItems = (0, _utils.map)(nextValidTokenSequences, function(itemMsg, idx) {
                return "  " + (idx + 1) + ". " + itemMsg;
            });
            var calculatedDescription = "one of these possible Token sequences:\n" + nextValidSequenceItems.join("\n");
            return errPrefix + calculatedDescription + errSuffix;
        }
    },
    buildEarlyExitMessage: function(_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = (0, _utils.first)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) return errPrefix + customUserDescription + errSuffix;
        else {
            var nextValidTokenSequences = (0, _utils.map)(expectedIterationPaths, function(currPath) {
                return "[" + (0, _utils.map)(currPath, function(currTokenType) {
                    return (0, _tokensPublic.tokenLabel)(currTokenType);
                }).join(",") + "]";
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + ("<" + nextValidTokenSequences.join(" ,") + ">");
            return errPrefix + calculatedDescription + errSuffix;
        }
    }
};
Object.freeze(defaultParserErrorProvider);
var defaultGrammarResolverErrorProvider = {
    buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\n" + "inside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
    }
};
var defaultGrammarValidatorErrorProvider = {
    buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
            if (prod instanceof (0, _gastPublic.Terminal)) return prod.terminalType.name;
            else if (prod instanceof (0, _gastPublic.NonTerminal)) return prod.nonTerminalName;
            else return "";
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0, _utils.first)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0, _gast.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->" + dslName + (hasExplicitIndex ? index : "") + "<- " + (extraArgument ? "with argument: ->" + extraArgument + "<-" : "") + "\n                  appears more than once (" + duplicateProds.length + " times) in the top level rule: ->" + topLevelName + "<-.                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";
        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
    },
    buildNamespaceConflictError: function(rule) {
        var errMsg = "Namespace conflict found in grammar.\n" + ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + rule.name + ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\n" + "This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\n" + "and Non-Terminal names start with a lower case letter.";
        return errMsg;
    },
    buildAlternationPrefixAmbiguityError: function(options) {
        var pathMsg = (0, _utils.map)(options.prefixPath, function(currTok) {
            return (0, _tokensPublic.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <" + options.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\n" + ("in <OR" + occurrence + "> inside <" + options.topLevelRule.name + "> Rule,\n") + ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n") + "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\n" + "For Further details.";
        return errMsg;
    },
    buildAlternationAmbiguityError: function(options) {
        var pathMsg = (0, _utils.map)(options.prefixPath, function(currtok) {
            return (0, _tokensPublic.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <" + options.ambiguityIndices.join(" ,") + "> in <OR" + occurrence + ">" + (" inside <" + options.topLevelRule.name + "> Rule,\n") + ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n");
        currMessage = currMessage + "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n" + "For Further details.";
        return currMessage;
    },
    buildEmptyRepetitionError: function(options) {
        var dslName = (0, _gast.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) dslName += options.repetition.idx;
        var errMsg = "The repetition <" + dslName + "> within Rule <" + options.topLevelRule.name + "> can never consume any tokens.\n" + "This could lead to an infinite loop.";
        return errMsg;
    },
    // TODO: remove - `errors_public` from nyc.config.js exclude
    //       once this method is fully removed from this file
    buildTokenNameError: function(options) {
        /* istanbul ignore next */ return "deprecated";
    },
    buildEmptyAlternationError: function(options) {
        var errMsg = "Ambiguous empty alternative: <" + (options.emptyChoiceIdx + 1) + ">" + (" in <OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n") + "Only the last alternative may be an empty alternative.";
        return errMsg;
    },
    buildTooManyAlternativesError: function(options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + ("<OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n has " + (options.alternation.definition.length + 1) + " alternatives.");
        return errMsg;
    },
    buildLeftRecursionError: function(options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = _utils.map(options.leftRecursionPath, function(currRule) {
            return currRule.name;
        });
        var leftRecursivePath = ruleName + " --> " + pathNames.concat([
            ruleName
        ]).join(" --> ");
        var errMsg = "Left Recursion found in grammar.\n" + ("rule: <" + ruleName + "> can be invoked from itself (directly or indirectly)\n") + ("without consuming any Tokens. The grammar path that causes this is: \n " + leftRecursivePath + "\n") + " To fix this refactor your grammar to remove the left recursion.\n" + "see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
        return errMsg;
    },
    // TODO: remove - `errors_public` from nyc.config.js exclude
    //       once this method is fully removed from this file
    buildInvalidRuleNameError: function(options) {
        /* istanbul ignore next */ return "deprecated";
    },
    buildDuplicateRuleNameError: function(options) {
        var ruleName;
        if (options.topLevelRule instanceof (0, _gastPublic.Rule)) ruleName = options.topLevelRule.name;
        else ruleName = options.topLevelRule;
        var errMsg = "Duplicate definition, rule: ->" + ruleName + "<- is already defined in the grammar: ->" + options.grammarName + "<-";
        return errMsg;
    }
};

},{"../scan/tokens_public":"jSvr0","../utils/utils":"8K9hy","./grammar/gast/gast_public":"krg1C","./grammar/gast/gast":"k45eR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6kmTG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveGrammar", ()=>resolveGrammar);
parcelHelpers.export(exports, "validateGrammar", ()=>validateGrammar);
parcelHelpers.export(exports, "assignOccurrenceIndices", ()=>assignOccurrenceIndices);
var _utils = require("../../../utils/utils");
var _resolver = require("../resolver");
var _checks = require("../checks");
var _errorsPublic = require("../../errors_public");
var _gast = require("./gast");
function resolveGrammar(options) {
    options = (0, _utils.defaults)(options, {
        errMsgProvider: (0, _errorsPublic.defaultGrammarResolverErrorProvider)
    });
    var topRulesTable = {};
    (0, _utils.forEach)(options.rules, function(rule) {
        topRulesTable[rule.name] = rule;
    });
    return (0, _resolver.resolveGrammar)(topRulesTable, options.errMsgProvider);
}
function validateGrammar(options) {
    options = (0, _utils.defaults)(options, {
        errMsgProvider: (0, _errorsPublic.defaultGrammarValidatorErrorProvider)
    });
    return (0, _checks.validateGrammar)(options.rules, options.maxLookahead, options.tokenTypes, options.errMsgProvider, options.grammarName);
}
function assignOccurrenceIndices(options) {
    (0, _utils.forEach)(options.rules, function(currRule) {
        var methodsCollector = new (0, _gast.DslMethodsCollectorVisitor)();
        currRule.accept(methodsCollector);
        (0, _utils.forEach)(methodsCollector.dslMethods, function(methods) {
            (0, _utils.forEach)(methods, function(currMethod, arrIdx) {
                currMethod.idx = arrIdx + 1;
            });
        });
    });
}

},{"../../../utils/utils":"8K9hy","../resolver":"dfn3q","../checks":"6Imh4","../../errors_public":"af7LB","./gast":"k45eR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dfn3q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveGrammar", ()=>resolveGrammar);
parcelHelpers.export(exports, "GastRefResolverVisitor", ()=>GastRefResolverVisitor);
var _parser = require("../parser/parser");
var _utils = require("../../utils/utils");
var _gastVisitorPublic = require("./gast/gast_visitor_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
function resolveGrammar(topLevels, errMsgProvider) {
    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
    refResolver.resolveRefs();
    return refResolver.errors;
}
var GastRefResolverVisitor = /** @class */ function(_super) {
    __extends(GastRefResolverVisitor, _super);
    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {
        var _this = _super.call(this) || this;
        _this.nameToTopRule = nameToTopRule;
        _this.errMsgProvider = errMsgProvider;
        _this.errors = [];
        return _this;
    }
    GastRefResolverVisitor.prototype.resolveRefs = function() {
        var _this = this;
        (0, _utils.forEach)((0, _utils.values)(this.nameToTopRule), function(prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
        });
    };
    GastRefResolverVisitor.prototype.visitNonTerminal = function(node) {
        var ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
                message: msg,
                type: (0, _parser.ParserDefinitionErrorType).UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
            });
        } else node.referencedRule = ref;
    };
    return GastRefResolverVisitor;
}((0, _gastVisitorPublic.GAstVisitor));

},{"../parser/parser":"ePYOV","../../utils/utils":"8K9hy","./gast/gast_visitor_public":"8PTMZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Imh4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateGrammar", ()=>validateGrammar);
parcelHelpers.export(exports, "identifyProductionForDuplicates", ()=>identifyProductionForDuplicates);
parcelHelpers.export(exports, "OccurrenceValidationCollector", ()=>OccurrenceValidationCollector);
parcelHelpers.export(exports, "validateRuleDoesNotAlreadyExist", ()=>validateRuleDoesNotAlreadyExist);
// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?
// This is not part of the IGrammarErrorProvider because the validation cannot be performed on
// The grammar structure, only at runtime.
parcelHelpers.export(exports, "validateRuleIsOverridden", ()=>validateRuleIsOverridden);
parcelHelpers.export(exports, "validateNoLeftRecursion", ()=>validateNoLeftRecursion);
parcelHelpers.export(exports, "getFirstNoneTerminal", ()=>getFirstNoneTerminal);
parcelHelpers.export(exports, "validateEmptyOrAlternative", ()=>validateEmptyOrAlternative);
parcelHelpers.export(exports, "validateAmbiguousAlternationAlternatives", ()=>validateAmbiguousAlternationAlternatives);
parcelHelpers.export(exports, "RepetionCollector", ()=>RepetionCollector);
parcelHelpers.export(exports, "validateTooManyAlts", ()=>validateTooManyAlts);
parcelHelpers.export(exports, "validateSomeNonEmptyLookaheadPath", ()=>validateSomeNonEmptyLookaheadPath);
parcelHelpers.export(exports, "checkPrefixAlternativesAmbiguities", ()=>checkPrefixAlternativesAmbiguities);
var _utils = require("../../utils/utils");
var _parser = require("../parser/parser");
var _gast = require("./gast/gast");
var _lookahead = require("./lookahead");
var _interpreter = require("./interpreter");
var _gastPublic = require("./gast/gast_public");
var _gastVisitorPublic = require("./gast/gast_visitor_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {
    var duplicateErrors = _utils.map(topLevels, function(currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
    });
    var leftRecursionErrors = _utils.map(topLevels, function(currTopRule) {
        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
    });
    var emptyAltErrors = [];
    var ambiguousAltsErrors = [];
    var emptyRepetitionErrors = [];
    // left recursion could cause infinite loops in the following validations.
    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.
    if ((0, _utils.every)(leftRecursionErrors, (0, _utils.isEmpty))) {
        emptyAltErrors = (0, _utils.map)(topLevels, function(currTopRule) {
            return validateEmptyOrAlternative(currTopRule, errMsgProvider);
        });
        ambiguousAltsErrors = (0, _utils.map)(topLevels, function(currTopRule) {
            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);
        });
        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
    }
    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
    var tooManyAltsErrors = (0, _utils.map)(topLevels, function(curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
    });
    var duplicateRulesError = (0, _utils.map)(topLevels, function(curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
    });
    return _utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));
}
function validateDuplicateProductions(topLevelRule, errMsgProvider) {
    var collectorVisitor = new OccurrenceValidationCollector();
    topLevelRule.accept(collectorVisitor);
    var allRuleProductions = collectorVisitor.allProductions;
    var productionGroups = _utils.groupBy(allRuleProductions, identifyProductionForDuplicates);
    var duplicates = _utils.pick(productionGroups, function(currGroup) {
        return currGroup.length > 1;
    });
    var errors = _utils.map(_utils.values(duplicates), function(currDuplicates) {
        var firstProd = _utils.first(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0, _gast.getProductionDslName)(firstProd);
        var defError = {
            message: msg,
            type: (0, _parser.ParserDefinitionErrorType).DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName: dslName,
            occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) defError.parameter = param;
        return defError;
    });
    return errors;
}
function identifyProductionForDuplicates(prod) {
    return (0, _gast.getProductionDslName)(prod) + "_#_" + prod.idx + "_#_" + getExtraProductionArgument(prod);
}
function getExtraProductionArgument(prod) {
    if (prod instanceof (0, _gastPublic.Terminal)) return prod.terminalType.name;
    else if (prod instanceof (0, _gastPublic.NonTerminal)) return prod.nonTerminalName;
    else return "";
}
var OccurrenceValidationCollector = /** @class */ function(_super) {
    __extends(OccurrenceValidationCollector, _super);
    function OccurrenceValidationCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    OccurrenceValidationCollector.prototype.visitNonTerminal = function(subrule) {
        this.allProductions.push(subrule);
    };
    OccurrenceValidationCollector.prototype.visitOption = function(option) {
        this.allProductions.push(option);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function(manySep) {
        this.allProductions.push(manySep);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function(atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    OccurrenceValidationCollector.prototype.visitRepetition = function(many) {
        this.allProductions.push(many);
    };
    OccurrenceValidationCollector.prototype.visitAlternation = function(or) {
        this.allProductions.push(or);
    };
    OccurrenceValidationCollector.prototype.visitTerminal = function(terminal) {
        this.allProductions.push(terminal);
    };
    return OccurrenceValidationCollector;
}((0, _gastVisitorPublic.GAstVisitor));
function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
    var errors = [];
    var occurrences = (0, _utils.reduce)(allRules, function(result, curRule) {
        if (curRule.name === rule.name) return result + 1;
        return result;
    }, 0);
    if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
        });
        errors.push({
            message: errMsg,
            type: (0, _parser.ParserDefinitionErrorType).DUPLICATE_RULE_NAME,
            ruleName: rule.name
        });
    }
    return errors;
}
function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
    var errors = [];
    var errMsg;
    if (!_utils.contains(definedRulesNames, ruleName)) {
        errMsg = "Invalid rule override, rule: ->" + ruleName + "<- cannot be overridden in the grammar: ->" + className + "<-" + "as it is not defined in any of the super grammars ";
        errors.push({
            message: errMsg,
            type: (0, _parser.ParserDefinitionErrorType).INVALID_RULE_OVERRIDE,
            ruleName: ruleName
        });
    }
    return errors;
}
function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
    if (path === void 0) path = [];
    var errors = [];
    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
    if (_utils.isEmpty(nextNonTerminals)) return [];
    else {
        var ruleName = topRule.name;
        var foundLeftRecursion = _utils.contains(nextNonTerminals, topRule);
        if (foundLeftRecursion) errors.push({
            message: errMsgProvider.buildLeftRecursionError({
                topLevelRule: topRule,
                leftRecursionPath: path
            }),
            type: (0, _parser.ParserDefinitionErrorType).LEFT_RECURSION,
            ruleName: ruleName
        });
        // we are only looking for cyclic paths leading back to the specific topRule
        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...
        var validNextSteps = _utils.difference(nextNonTerminals, path.concat([
            topRule
        ]));
        var errorsFromNextSteps = _utils.map(validNextSteps, function(currRefRule) {
            var newPath = _utils.cloneArr(path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(_utils.flatten(errorsFromNextSteps));
    }
}
function getFirstNoneTerminal(definition) {
    var result = [];
    if (_utils.isEmpty(definition)) return result;
    var firstProd = _utils.first(definition);
    /* istanbul ignore else */ if (firstProd instanceof (0, _gastPublic.NonTerminal)) result.push(firstProd.referencedRule);
    else if (firstProd instanceof (0, _gastPublic.Alternative) || firstProd instanceof (0, _gastPublic.Option) || firstProd instanceof (0, _gastPublic.RepetitionMandatory) || firstProd instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator) || firstProd instanceof (0, _gastPublic.RepetitionWithSeparator) || firstProd instanceof (0, _gastPublic.Repetition)) result = result.concat(getFirstNoneTerminal(firstProd.definition));
    else if (firstProd instanceof (0, _gastPublic.Alternation)) // each sub definition in alternation is a FLAT
    result = _utils.flatten(_utils.map(firstProd.definition, function(currSubDef) {
        return getFirstNoneTerminal(currSubDef.definition);
    }));
    else if (firstProd instanceof (0, _gastPublic.Terminal)) ;
    else throw Error("non exhaustive match");
    var isFirstOptional = (0, _gast.isOptionalProd)(firstProd);
    var hasMore = definition.length > 1;
    if (isFirstOptional && hasMore) {
        var rest = _utils.drop(definition);
        return result.concat(getFirstNoneTerminal(rest));
    } else return result;
}
var OrCollector = /** @class */ function(_super) {
    __extends(OrCollector, _super);
    function OrCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.alternations = [];
        return _this;
    }
    OrCollector.prototype.visitAlternation = function(node) {
        this.alternations.push(node);
    };
    return OrCollector;
}((0, _gastVisitorPublic.GAstVisitor));
function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = _utils.reduce(ors, function(errors, currOr) {
        var exceptLast = _utils.dropRight(currOr.definition);
        var currErrors = _utils.map(exceptLast, function(currAlternative, currAltIdx) {
            var possibleFirstInAlt = (0, _interpreter.nextPossibleTokensAfter)([
                currAlternative
            ], [], null, 1);
            if (_utils.isEmpty(possibleFirstInAlt)) return {
                message: errMsgProvider.buildEmptyAlternationError({
                    topLevelRule: topLevelRule,
                    alternation: currOr,
                    emptyChoiceIdx: currAltIdx
                }),
                type: (0, _parser.ParserDefinitionErrorType).NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
            };
            else return null;
        });
        return errors.concat(_utils.compact(currErrors));
    }, []);
    return errors;
}
function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    // New Handling of ignoring ambiguities
    // - https://github.com/SAP/chevrotain/issues/869
    ors = (0, _utils.reject)(ors, function(currOr) {
        return currOr.ignoreAmbiguities === true;
    });
    var errors = _utils.reduce(ors, function(result, currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0, _lookahead.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);
    }, []);
    return errors;
}
var RepetionCollector = /** @class */ function(_super) {
    __extends(RepetionCollector, _super);
    function RepetionCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    RepetionCollector.prototype.visitRepetitionWithSeparator = function(manySep) {
        this.allProductions.push(manySep);
    };
    RepetionCollector.prototype.visitRepetitionMandatory = function(atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    RepetionCollector.prototype.visitRepetition = function(many) {
        this.allProductions.push(many);
    };
    return RepetionCollector;
}((0, _gastVisitorPublic.GAstVisitor));
function validateTooManyAlts(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = _utils.reduce(ors, function(errors, currOr) {
        if (currOr.definition.length > 255) errors.push({
            message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule: topLevelRule,
                alternation: currOr
            }),
            type: (0, _parser.ParserDefinitionErrorType).TOO_MANY_ALTS,
            ruleName: topLevelRule.name,
            occurrence: currOr.idx
        });
        return errors;
    }, []);
    return errors;
}
function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
    var errors = [];
    (0, _utils.forEach)(topLevelRules, function(currTopRule) {
        var collectorVisitor = new RepetionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0, _utils.forEach)(allRuleProductions, function(currProd) {
            var prodType = (0, _lookahead.getProdType)(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = (0, _lookahead.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if ((0, _utils.isEmpty)((0, _utils.flatten)(pathsInsideProduction))) {
                var errMsg = errMsgProvider.buildEmptyRepetitionError({
                    topLevelRule: currTopRule,
                    repetition: currProd
                });
                errors.push({
                    message: errMsg,
                    type: (0, _parser.ParserDefinitionErrorType).NO_NON_EMPTY_LOOKAHEAD,
                    ruleName: currTopRule.name
                });
            }
        });
    });
    return errors;
}
function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var foundAmbiguousPaths = [];
    var identicalAmbiguities = (0, _utils.reduce)(alternatives, function(result, currAlt, currAltIdx) {
        // ignore (skip) ambiguities with this alternative
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) return result;
        (0, _utils.forEach)(currAlt, function(currPath) {
            var altsCurrPathAppearsIn = [
                currAltIdx
            ];
            (0, _utils.forEach)(alternatives, function(currOtherAlt, currOtherAltIdx) {
                if (currAltIdx !== currOtherAltIdx && (0, _lookahead.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
                alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) altsCurrPathAppearsIn.push(currOtherAltIdx);
            });
            if (altsCurrPathAppearsIn.length > 1 && !(0, _lookahead.containsPath)(foundAmbiguousPaths, currPath)) {
                foundAmbiguousPaths.push(currPath);
                result.push({
                    alts: altsCurrPathAppearsIn,
                    path: currPath
                });
            }
        });
        return result;
    }, []);
    var currErrors = _utils.map(identicalAmbiguities, function(currAmbDescriptor) {
        var ambgIndices = (0, _utils.map)(currAmbDescriptor.alts, function(currAltIdx) {
            return currAltIdx + 1;
        });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation: alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
        });
        return {
            message: currMessage,
            type: (0, _parser.ParserDefinitionErrorType).AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: [
                currAmbDescriptor.alts
            ]
        };
    });
    return currErrors;
}
function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var errors = [];
    // flatten
    var pathsAndIndices = (0, _utils.reduce)(alternatives, function(result, currAlt, idx) {
        var currPathsAndIdx = (0, _utils.map)(currAlt, function(currPath) {
            return {
                idx: idx,
                path: currPath
            };
        });
        return result.concat(currPathsAndIdx);
    }, []);
    (0, _utils.forEach)(pathsAndIndices, function(currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        // ignore (skip) ambiguities with this alternative
        if (alternativeGast.ignoreAmbiguities === true) return;
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0, _utils.findAll)(pathsAndIndices, function(searchPathAndIdx) {
            // prefix ambiguity can only be created from lower idx (higher priority) path
            return(// ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
            // will be be detected using a different validation.
            (0, _lookahead.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath));
        });
        var currPathPrefixErrors = (0, _utils.map)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
            var ambgIndices = [
                currAmbPathAndIdx.idx + 1,
                targetIdx + 1
            ];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
                topLevelRule: rule,
                alternation: alternation,
                ambiguityIndices: ambgIndices,
                prefixPath: currAmbPathAndIdx.path
            });
            return {
                message: message,
                type: (0, _parser.ParserDefinitionErrorType).AMBIGUOUS_PREFIX_ALTS,
                ruleName: rule.name,
                occurrence: occurrence,
                alternatives: ambgIndices
            };
        });
        errors = errors.concat(currPathPrefixErrors);
    });
    return errors;
}
function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
    var errors = [];
    var tokenNames = (0, _utils.map)(tokenTypes, function(currToken) {
        return currToken.name;
    });
    (0, _utils.forEach)(topLevels, function(currRule) {
        var currRuleName = currRule.name;
        if ((0, _utils.contains)(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
                message: errMsg,
                type: (0, _parser.ParserDefinitionErrorType).CONFLICT_TOKENS_RULES_NAMESPACE,
                ruleName: currRuleName
            });
        }
    });
    return errors;
}

},{"../../utils/utils":"8K9hy","../parser/parser":"ePYOV","./gast/gast":"k45eR","./lookahead":"c24Uo","./interpreter":"2XcSV","./gast/gast_public":"krg1C","./gast/gast_visitor_public":"8PTMZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c24Uo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PROD_TYPE", ()=>PROD_TYPE);
parcelHelpers.export(exports, "getProdType", ()=>getProdType);
parcelHelpers.export(exports, "buildLookaheadFuncForOr", ()=>buildLookaheadFuncForOr);
/**
 *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare
 *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).
 *
 *  Example: given a production:
 *  ABC(DE)?DF
 *
 *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two
 *  alternatives.
 *
 *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.
 */ parcelHelpers.export(exports, "buildLookaheadFuncForOptionalProd", ()=>buildLookaheadFuncForOptionalProd);
parcelHelpers.export(exports, "buildAlternativesLookAheadFunc", ()=>buildAlternativesLookAheadFunc);
parcelHelpers.export(exports, "buildSingleAlternativeLookaheadFunction", ()=>buildSingleAlternativeLookaheadFunction);
parcelHelpers.export(exports, "lookAheadSequenceFromAlternatives", ()=>lookAheadSequenceFromAlternatives);
parcelHelpers.export(exports, "getLookaheadPathsForOr", ()=>getLookaheadPathsForOr);
parcelHelpers.export(exports, "getLookaheadPathsForOptionalProd", ()=>getLookaheadPathsForOptionalProd);
parcelHelpers.export(exports, "containsPath", ()=>containsPath);
parcelHelpers.export(exports, "isStrictPrefixOfPath", ()=>isStrictPrefixOfPath);
parcelHelpers.export(exports, "areTokenCategoriesNotUsed", ()=>areTokenCategoriesNotUsed);
var _utils = require("../../utils/utils");
var _interpreter = require("./interpreter");
var _rest = require("./rest");
var _tokens = require("../../scan/tokens");
var _gastPublic = require("./gast/gast_public");
var _gastVisitorPublic = require("./gast/gast_visitor_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var PROD_TYPE;
(function(PROD_TYPE) {
    PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";
    PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";
})(PROD_TYPE || (PROD_TYPE = {}));
function getProdType(prod) {
    /* istanbul ignore else */ if (prod instanceof (0, _gastPublic.Option)) return PROD_TYPE.OPTION;
    else if (prod instanceof (0, _gastPublic.Repetition)) return PROD_TYPE.REPETITION;
    else if (prod instanceof (0, _gastPublic.RepetitionMandatory)) return PROD_TYPE.REPETITION_MANDATORY;
    else if (prod instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator)) return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
    else if (prod instanceof (0, _gastPublic.RepetitionWithSeparator)) return PROD_TYPE.REPETITION_WITH_SEPARATOR;
    else if (prod instanceof (0, _gastPublic.Alternation)) return PROD_TYPE.ALTERNATION;
    else throw Error("non exhaustive match");
}
function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? (0, _tokens.tokenStructuredMatcherNoCategories) : (0, _tokens.tokenStructuredMatcher);
    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
}
function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? (0, _tokens.tokenStructuredMatcherNoCategories) : (0, _tokens.tokenStructuredMatcher);
    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
}
function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
    var numOfAlts = alts.length;
    var areAllOneTokenLookahead = (0, _utils.every)(alts, function(currAlt) {
        return (0, _utils.every)(currAlt, function(currPath) {
            return currPath.length === 1;
        });
    });
    // This version takes into account the predicates as well.
    if (hasPredicates) /**
         * @returns {number} - The chosen alternative index
         */ return function(orAlts) {
        // unfortunately the predicates must be extracted every single time
        // as they cannot be cached due to references to parameters(vars) which are no longer valid.
        // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)
        var predicates = (0, _utils.map)(orAlts, function(currAlt) {
            return currAlt.GATE;
        });
        for(var t = 0; t < numOfAlts; t++){
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            var currPredicate = predicates[t];
            if (currPredicate !== undefined && currPredicate.call(this) === false) continue;
            nextPath: for(var j = 0; j < currNumOfPaths; j++){
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for(var i = 0; i < currPathLength; i++){
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) continue nextPath;
                }
                // found a full path that matches.
                // this will also work for an empty ALT as the loop will be skipped
                return t;
            }
        // none of the paths for the current alternative matched
        // try the next alternative
        }
        // none of the alternatives could be matched
        return undefined;
    };
    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        // optimized (common) case of all the lookaheads paths requiring only
        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.
        var singleTokenAlts = (0, _utils.map)(alts, function(currAlt) {
            return (0, _utils.flatten)(currAlt);
        });
        var choiceToAlt_1 = (0, _utils.reduce)(singleTokenAlts, function(result, currAlt, idx) {
            (0, _utils.forEach)(currAlt, function(currTokType) {
                if (!(0, _utils.has)(result, currTokType.tokenTypeIdx)) result[currTokType.tokenTypeIdx] = idx;
                (0, _utils.forEach)(currTokType.categoryMatches, function(currExtendingType) {
                    if (!(0, _utils.has)(result, currExtendingType)) result[currExtendingType] = idx;
                });
            });
            return result;
        }, []);
        /**
         * @returns {number} - The chosen alternative index
         */ return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
    } else // optimized lookahead without needing to check the predicates at all.
    // this causes code duplication which is intentional to improve performance.
    /**
         * @returns {number} - The chosen alternative index
         */ return function() {
        for(var t = 0; t < numOfAlts; t++){
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            nextPath: for(var j = 0; j < currNumOfPaths; j++){
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for(var i = 0; i < currPathLength; i++){
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) continue nextPath;
                }
                // found a full path that matches.
                // this will also work for an empty ALT as the loop will be skipped
                return t;
            }
        // none of the paths for the current alternative matched
        // try the next alternative
        }
        // none of the alternatives could be matched
        return undefined;
    };
}
function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
    var areAllOneTokenLookahead = (0, _utils.every)(alt, function(currPath) {
        return currPath.length === 1;
    });
    var numOfPaths = alt.length;
    // optimized (common) case of all the lookaheads paths requiring only
    // a single token lookahead.
    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0, _utils.flatten)(alt);
        if (singleTokensTypes.length === 1 && (0, _utils.isEmpty)(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function() {
                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
        } else {
            var choiceToAlt_2 = (0, _utils.reduce)(singleTokensTypes, function(result, currTokType, idx) {
                result[currTokType.tokenTypeIdx] = true;
                (0, _utils.forEach)(currTokType.categoryMatches, function(currExtendingType) {
                    result[currExtendingType] = true;
                });
                return result;
            }, []);
            return function() {
                var nextToken = this.LA(1);
                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
        }
    } else return function() {
        nextPath: for(var j = 0; j < numOfPaths; j++){
            var currPath = alt[j];
            var currPathLength = currPath.length;
            for(var i = 0; i < currPathLength; i++){
                var nextToken = this.LA(i + 1);
                if (tokenMatcher(nextToken, currPath[i]) === false) continue nextPath;
            }
            // found a full path that matches.
            return true;
        }
        // none of the paths matched
        return false;
    };
}
var RestDefinitionFinderWalker = /** @class */ function(_super) {
    __extends(RestDefinitionFinderWalker, _super);
    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        return _this;
    }
    RestDefinitionFinderWalker.prototype.startWalking = function() {
        this.walk(this.topProd);
        return this.restDef;
    };
    RestDefinitionFinderWalker.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
        }
        // performance optimization, do not iterate over the entire Grammar ast after we have found the target
        return false;
    };
    RestDefinitionFinderWalker.prototype.walkOption = function(optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
    };
    RestDefinitionFinderWalker.prototype.walkMany = function(manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
    };
    RestDefinitionFinderWalker.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
    };
    return RestDefinitionFinderWalker;
}((0, _rest.RestWalker));
/**
 * Returns the definition of a target production in a top level level rule.
 */ var InsideDefinitionFinderVisitor = /** @class */ function(_super) {
    __extends(InsideDefinitionFinderVisitor, _super);
    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {
        var _this = _super.call(this) || this;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        _this.targetRef = targetRef;
        _this.result = [];
        return _this;
    }
    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function(node, expectedProdName) {
        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) this.result = node.definition;
    };
    InsideDefinitionFinderVisitor.prototype.visitOption = function(node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetition = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitAlternation = function(node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
    };
    return InsideDefinitionFinderVisitor;
}((0, _gastVisitorPublic.GAstVisitor));
function initializeArrayOfArrays(size) {
    var result = new Array(size);
    for(var i = 0; i < size; i++)result[i] = [];
    return result;
}
/**
 * A sort of hash function between a Path in the grammar and a string.
 * Note that this returns multiple "hashes" to support the scenario of token categories.
 * -  A single path with categories may match multiple **actual** paths.
 */ function pathToHashKeys(path) {
    var keys = [
        ""
    ];
    for(var i = 0; i < path.length; i++){
        var tokType = path[i];
        var longerKeys = [];
        for(var j = 0; j < keys.length; j++){
            var currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for(var t = 0; t < tokType.categoryMatches.length; t++){
                var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
                longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
        }
        keys = longerKeys;
    }
    return keys;
}
/**
 * Imperative style due to being called from a hot spot
 */ function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
    for(var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++){
        // We only want to test vs the other alternatives
        if (currAltIdx === idx) continue;
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for(var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++){
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) return false;
        }
    }
    // None of the SearchPathKeys were found in any of the other alternatives
    return true;
}
function lookAheadSequenceFromAlternatives(altsDefs, k) {
    var partialAlts = (0, _utils.map)(altsDefs, function(currAlt) {
        return (0, _interpreter.possiblePathsFrom)([
            currAlt
        ], 1);
    });
    var finalResult = initializeArrayOfArrays(partialAlts.length);
    var altsHashes = (0, _utils.map)(partialAlts, function(currAltPaths) {
        var dict = {};
        (0, _utils.forEach)(currAltPaths, function(item) {
            var keys = pathToHashKeys(item.partialPath);
            (0, _utils.forEach)(keys, function(currKey) {
                dict[currKey] = true;
            });
        });
        return dict;
    });
    var newData = partialAlts;
    // maxLookahead loop
    for(var pathLength = 1; pathLength <= k; pathLength++){
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function(altIdx) {
            var currAltPathsAndSuffixes = currDataset[altIdx];
            // paths in current alternative loop
            for(var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++){
                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
                var prefixKeys = pathToHashKeys(currPathPrefix);
                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
                // End of the line for this path.
                if (isUnique || (0, _utils.isEmpty)(suffixDef) || currPathPrefix.length === k) {
                    var currAltResult = finalResult[altIdx];
                    // TODO: Can we implement a containsPath using Maps/Dictionaries?
                    if (containsPath(currAltResult, currPathPrefix) === false) {
                        currAltResult.push(currPathPrefix);
                        // Update all new  keys for the current path.
                        for(var j = 0; j < prefixKeys.length; j++){
                            var currKey = prefixKeys[j];
                            altsHashes[altIdx][currKey] = true;
                        }
                    }
                } else {
                    var newPartialPathsAndSuffixes = (0, _interpreter.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
                    // Update keys for new known paths
                    (0, _utils.forEach)(newPartialPathsAndSuffixes, function(item) {
                        var prefixKeys = pathToHashKeys(item.partialPath);
                        (0, _utils.forEach)(prefixKeys, function(key) {
                            altsHashes[altIdx][key] = true;
                        });
                    });
                }
            }
        };
        // alternatives loop
        for(var altIdx = 0; altIdx < currDataset.length; altIdx++)_loop_1(altIdx);
    }
    return finalResult;
}
function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
    ruleGrammar.accept(visitor);
    return lookAheadSequenceFromAlternatives(visitor.result, k);
}
function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
    ruleGrammar.accept(insideDefVisitor);
    var insideDef = insideDefVisitor.result;
    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
    var afterDef = afterDefWalker.startWalking();
    var insideFlat = new (0, _gastPublic.Alternative)({
        definition: insideDef
    });
    var afterFlat = new (0, _gastPublic.Alternative)({
        definition: afterDef
    });
    return lookAheadSequenceFromAlternatives([
        insideFlat,
        afterFlat
    ], k);
}
function containsPath(alternative, searchPath) {
    compareOtherPath: for(var i = 0; i < alternative.length; i++){
        var otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) continue;
        for(var j = 0; j < otherPath.length; j++){
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;
            if (matchingTokens === false) continue compareOtherPath;
        }
        return true;
    }
    return false;
}
function isStrictPrefixOfPath(prefix, other) {
    return prefix.length < other.length && (0, _utils.every)(prefix, function(tokType, idx) {
        var otherTokType = other[idx];
        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
    });
}
function areTokenCategoriesNotUsed(lookAheadPaths) {
    return (0, _utils.every)(lookAheadPaths, function(singleAltPaths) {
        return (0, _utils.every)(singleAltPaths, function(singlePath) {
            return (0, _utils.every)(singlePath, function(token) {
                return (0, _utils.isEmpty)(token.categoryMatches);
            });
        });
    });
}

},{"../../utils/utils":"8K9hy","./interpreter":"2XcSV","./rest":"d8Hmj","../../scan/tokens":"535mp","./gast/gast_public":"krg1C","./gast/gast_visitor_public":"8PTMZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2XcSV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbstractNextPossibleTokensWalker", ()=>AbstractNextPossibleTokensWalker);
parcelHelpers.export(exports, "NextAfterTokenWalker", ()=>NextAfterTokenWalker);
parcelHelpers.export(exports, "AbstractNextTerminalAfterProductionWalker", ()=>AbstractNextTerminalAfterProductionWalker);
parcelHelpers.export(exports, "NextTerminalAfterManyWalker", ()=>NextTerminalAfterManyWalker);
parcelHelpers.export(exports, "NextTerminalAfterManySepWalker", ()=>NextTerminalAfterManySepWalker);
parcelHelpers.export(exports, "NextTerminalAfterAtLeastOneWalker", ()=>NextTerminalAfterAtLeastOneWalker);
parcelHelpers.export(exports, "NextTerminalAfterAtLeastOneSepWalker", ()=>NextTerminalAfterAtLeastOneSepWalker);
parcelHelpers.export(exports, "possiblePathsFrom", ()=>possiblePathsFrom);
parcelHelpers.export(exports, "nextPossibleTokensAfter", ()=>nextPossibleTokensAfter);
var _rest = require("./rest");
var _utils = require("../../utils/utils");
var _first = require("./first");
var _gastPublic = require("./gast/gast_public");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var AbstractNextPossibleTokensWalker = /** @class */ function(_super) {
    __extends(AbstractNextPossibleTokensWalker, _super);
    function AbstractNextPossibleTokensWalker(topProd, path) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.path = path;
        _this.possibleTokTypes = [];
        _this.nextProductionName = "";
        _this.nextProductionOccurrence = 0;
        _this.found = false;
        _this.isAtEndOfPath = false;
        return _this;
    }
    AbstractNextPossibleTokensWalker.prototype.startWalking = function() {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) throw Error("The path does not start with the walker's top Rule!");
        // immutable for the win
        this.ruleStack = (0, _utils.cloneArr)(this.path.ruleStack).reverse(); // intelij bug requires assertion
        this.occurrenceStack = (0, _utils.cloneArr)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion
        // already verified that the first production is valid, we now seek the 2nd production
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
    };
    AbstractNextPossibleTokensWalker.prototype.walk = function(prod, prevRest) {
        if (prevRest === void 0) prevRest = [];
        // stop scanning once we found the path
        if (!this.found) _super.prototype.walk.call(this, prod, prevRest);
    };
    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        // found the next production, need to keep walking in it
        if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function() {
        // need to consume the Terminal
        if ((0, _utils.isEmpty)(this.ruleStack)) {
            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are
            // really seeking is the last Terminal...
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
        } else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
    };
    return AbstractNextPossibleTokensWalker;
}((0, _rest.RestWalker));
var NextAfterTokenWalker = /** @class */ function(_super) {
    __extends(NextAfterTokenWalker, _super);
    function NextAfterTokenWalker(topProd, path) {
        var _this = _super.call(this, topProd, path) || this;
        _this.path = path;
        _this.nextTerminalName = "";
        _this.nextTerminalOccurrence = 0;
        _this.nextTerminalName = _this.path.lastTok.name;
        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
        return _this;
    }
    NextAfterTokenWalker.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new (0, _gastPublic.Alternative)({
                definition: fullRest
            });
            this.possibleTokTypes = (0, _first.first)(restProd);
            this.found = true;
        }
    };
    return NextAfterTokenWalker;
}(AbstractNextPossibleTokensWalker);
/**
 * This walker only "walks" a single "TOP" level in the Grammar Ast, this means
 * it never "follows" production refs
 */ var AbstractNextTerminalAfterProductionWalker = /** @class */ function(_super) {
    __extends(AbstractNextTerminalAfterProductionWalker, _super);
    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {
        var _this = _super.call(this) || this;
        _this.topRule = topRule;
        _this.occurrence = occurrence;
        _this.result = {
            token: undefined,
            occurrence: undefined,
            isEndOfRule: undefined
        };
        return _this;
    }
    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function() {
        this.walk(this.topRule);
        return this.result;
    };
    return AbstractNextTerminalAfterProductionWalker;
}((0, _rest.RestWalker));
var NextTerminalAfterManyWalker = /** @class */ function(_super) {
    __extends(NextTerminalAfterManyWalker, _super);
    function NextTerminalAfterManyWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManyWalker.prototype.walkMany = function(manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0, _utils.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === undefined;
            if (firstAfterMany instanceof (0, _gastPublic.Terminal)) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
            }
        } else _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
    };
    return NextTerminalAfterManyWalker;
}(AbstractNextTerminalAfterProductionWalker);
var NextTerminalAfterManySepWalker = /** @class */ function(_super) {
    __extends(NextTerminalAfterManySepWalker, _super);
    function NextTerminalAfterManySepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManySepWalker.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0, _utils.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === undefined;
            if (firstAfterManySep instanceof (0, _gastPublic.Terminal)) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
            }
        } else _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
    };
    return NextTerminalAfterManySepWalker;
}(AbstractNextTerminalAfterProductionWalker);
var NextTerminalAfterAtLeastOneWalker = /** @class */ function(_super) {
    __extends(NextTerminalAfterAtLeastOneWalker, _super);
    function NextTerminalAfterAtLeastOneWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0, _utils.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;
            if (firstAfterAtLeastOne instanceof (0, _gastPublic.Terminal)) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
            }
        } else _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
    };
    return NextTerminalAfterAtLeastOneWalker;
}(AbstractNextTerminalAfterProductionWalker);
// TODO: reduce code duplication in the AfterWalkers
var NextTerminalAfterAtLeastOneSepWalker = /** @class */ function(_super) {
    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);
    function NextTerminalAfterAtLeastOneSepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0, _utils.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;
            if (firstAfterfirstAfterAtLeastOneSep instanceof (0, _gastPublic.Terminal)) {
                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
        } else _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
    };
    return NextTerminalAfterAtLeastOneSepWalker;
}(AbstractNextTerminalAfterProductionWalker);
function possiblePathsFrom(targetDef, maxLength, currPath) {
    if (currPath === void 0) currPath = [];
    // avoid side effects
    currPath = (0, _utils.cloneArr)(currPath);
    var result = [];
    var i = 0;
    // TODO: avoid inner funcs
    function remainingPathWith(nextDef) {
        return nextDef.concat((0, _utils.drop)(targetDef, i + 1));
    }
    // TODO: avoid inner funcs
    function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
    }
    /**
     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the
     * following (rest) of the targetDef.
     *
     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the
     * the optional production.
     */ while(currPath.length < maxLength && i < targetDef.length){
        var prod = targetDef[i];
        /* istanbul ignore else */ if (prod instanceof (0, _gastPublic.Alternative)) return getAlternativesForProd(prod.definition);
        else if (prod instanceof (0, _gastPublic.NonTerminal)) return getAlternativesForProd(prod.definition);
        else if (prod instanceof (0, _gastPublic.Option)) result = getAlternativesForProd(prod.definition);
        else if (prod instanceof (0, _gastPublic.RepetitionMandatory)) {
            var newDef = prod.definition.concat([
                new (0, _gastPublic.Repetition)({
                    definition: prod.definition
                })
            ]);
            return getAlternativesForProd(newDef);
        } else if (prod instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator)) {
            var newDef = [
                new (0, _gastPublic.Alternative)({
                    definition: prod.definition
                }),
                new (0, _gastPublic.Repetition)({
                    definition: [
                        new (0, _gastPublic.Terminal)({
                            terminalType: prod.separator
                        })
                    ].concat(prod.definition)
                })
            ];
            return getAlternativesForProd(newDef);
        } else if (prod instanceof (0, _gastPublic.RepetitionWithSeparator)) {
            var newDef = prod.definition.concat([
                new (0, _gastPublic.Repetition)({
                    definition: [
                        new (0, _gastPublic.Terminal)({
                            terminalType: prod.separator
                        })
                    ].concat(prod.definition)
                })
            ]);
            result = getAlternativesForProd(newDef);
        } else if (prod instanceof (0, _gastPublic.Repetition)) {
            var newDef = prod.definition.concat([
                new (0, _gastPublic.Repetition)({
                    definition: prod.definition
                })
            ]);
            result = getAlternativesForProd(newDef);
        } else if (prod instanceof (0, _gastPublic.Alternation)) {
            (0, _utils.forEach)(prod.definition, function(currAlt) {
                // TODO: this is a limited check for empty alternatives
                //   It would prevent a common case of infinite loops during parser initialization.
                //   However **in-directly** empty alternatives may still cause issues.
                if ((0, _utils.isEmpty)(currAlt.definition) === false) result = getAlternativesForProd(currAlt.definition);
            });
            return result;
        } else if (prod instanceof (0, _gastPublic.Terminal)) currPath.push(prod.terminalType);
        else throw Error("non exhaustive match");
        i++;
    }
    result.push({
        partialPath: currPath,
        suffixDef: (0, _utils.drop)(targetDef, i)
    });
    return result;
}
function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
    var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
    // to avoid creating a new Array each time.
    var EXIT_NON_TERMINAL_ARR = [
        EXIT_NON_TERMINAL
    ];
    var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
    var foundCompletePath = false;
    var tokenVectorLength = tokenVector.length;
    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
    var result = [];
    var possiblePaths = [];
    possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
    });
    while(!(0, _utils.isEmpty)(possiblePaths)){
        var currPath = possiblePaths.pop();
        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)
        if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath && (0, _utils.last)(possiblePaths).idx <= minimalAlternativesIndex) // remove irrelevant alternative
            possiblePaths.pop();
            continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT
        if ((0, _utils.isEmpty)(currDef)) continue;
        var prod = currDef[0];
        /* istanbul ignore else */ if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
                idx: currIdx,
                def: (0, _utils.drop)(currDef),
                ruleStack: (0, _utils.dropRight)(currRuleStack),
                occurrenceStack: (0, _utils.dropRight)(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
        } else if (prod instanceof (0, _gastPublic.Terminal)) {
            /* istanbul ignore else */ if (currIdx < tokenVectorLength - 1) {
                var nextIdx = currIdx + 1;
                var actualToken = tokenVector[nextIdx];
                if (tokMatcher(actualToken, prod.terminalType)) {
                    var nextPath = {
                        idx: nextIdx,
                        def: (0, _utils.drop)(currDef),
                        ruleStack: currRuleStack,
                        occurrenceStack: currOccurrenceStack
                    };
                    possiblePaths.push(nextPath);
                }
            // end of the line
            } else if (currIdx === tokenVectorLength - 1) {
                // IGNORE ABOVE ELSE
                result.push({
                    nextTokenType: prod.terminalType,
                    nextTokenOccurrence: prod.idx,
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                });
                foundCompletePath = true;
            } else throw Error("non exhaustive match");
        } else if (prod instanceof (0, _gastPublic.NonTerminal)) {
            var newRuleStack = (0, _utils.cloneArr)(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = (0, _utils.cloneArr)(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
                idx: currIdx,
                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, _utils.drop)(currDef)),
                ruleStack: newRuleStack,
                occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
        } else if (prod instanceof (0, _gastPublic.Option)) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0, _utils.drop)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
                idx: currIdx,
                def: prod.definition.concat((0, _utils.drop)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        } else if (prod instanceof (0, _gastPublic.RepetitionMandatory)) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var secondIteration = new (0, _gastPublic.Repetition)({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([
                secondIteration
            ], (0, _utils.drop)(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        } else if (prod instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator)) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var separatorGast = new (0, _gastPublic.Terminal)({
                terminalType: prod.separator
            });
            var secondIteration = new (0, _gastPublic.Repetition)({
                definition: [
                    separatorGast
                ].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([
                secondIteration
            ], (0, _utils.drop)(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        } else if (prod instanceof (0, _gastPublic.RepetitionWithSeparator)) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0, _utils.drop)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new (0, _gastPublic.Terminal)({
                terminalType: prod.separator
            });
            var nthRepetition = new (0, _gastPublic.Repetition)({
                definition: [
                    separatorGast
                ].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([
                nthRepetition
            ], (0, _utils.drop)(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        } else if (prod instanceof (0, _gastPublic.Repetition)) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0, _utils.drop)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?
            var nthRepetition = new (0, _gastPublic.Repetition)({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([
                nthRepetition
            ], (0, _utils.drop)(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        } else if (prod instanceof (0, _gastPublic.Alternation)) // the order of alternatives is meaningful, FILO (Last path will be traversed first).
        for(var i = prod.definition.length - 1; i >= 0; i--){
            var currAlt = prod.definition[i];
            var currAltPath = {
                idx: currIdx,
                def: currAlt.definition.concat((0, _utils.drop)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(currAltPath);
            possiblePaths.push(EXIT_ALTERNATIVE);
        }
        else if (prod instanceof (0, _gastPublic.Alternative)) possiblePaths.push({
            idx: currIdx,
            def: prod.definition.concat((0, _utils.drop)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
        });
        else if (prod instanceof (0, _gastPublic.Rule)) // last because we should only encounter at most a single one of these per invocation.
        possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        else throw Error("non exhaustive match");
    }
    return result;
}
function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
    var newRuleStack = (0, _utils.cloneArr)(currRuleStack);
    newRuleStack.push(topRule.name);
    var newCurrOccurrenceStack = (0, _utils.cloneArr)(currOccurrenceStack);
    // top rule is always assumed to have been called with occurrence index 1
    newCurrOccurrenceStack.push(1);
    return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
    };
}

},{"./rest":"d8Hmj","../../utils/utils":"8K9hy","./first":"l1UOJ","./gast/gast_public":"krg1C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gaFM8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EOF_FOLLOW_KEY", ()=>EOF_FOLLOW_KEY);
parcelHelpers.export(exports, "IN_RULE_RECOVERY_EXCEPTION", ()=>IN_RULE_RECOVERY_EXCEPTION);
parcelHelpers.export(exports, "InRuleRecoveryException", ()=>InRuleRecoveryException);
parcelHelpers.export(exports, "Recoverable", ()=>Recoverable);
parcelHelpers.export(exports, "attemptInRepetitionRecovery", ()=>attemptInRepetitionRecovery);
var _tokensPublic = require("../../../scan/tokens_public");
var _utils = require("../../../utils/utils");
var _exceptionsPublic = require("../../exceptions_public");
var _constants = require("../../constants");
var _parser = require("../parser");
var EOF_FOLLOW_KEY = {};
var IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
function InRuleRecoveryException(message) {
    this.name = IN_RULE_RECOVERY_EXCEPTION;
    this.message = message;
}
InRuleRecoveryException.prototype = Error.prototype;
/**
 * This trait is responsible for the error recovery and fault tolerant logic
 */ var Recoverable = /** @class */ function() {
    function Recoverable() {}
    Recoverable.prototype.initRecoverable = function(config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = (0, _utils.has)(config, "recoveryEnabled") ? config.recoveryEnabled : (0, _parser.DEFAULT_PARSER_CONFIG).recoveryEnabled;
        // performance optimization, NOOP will be inlined which
        // effectively means that this optional feature does not exist
        // when not used.
        if (this.recoveryEnabled) this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
    };
    Recoverable.prototype.getTokenToInsert = function(tokType) {
        var tokToInsert = (0, _tokensPublic.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
    };
    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
        return true;
    };
    Recoverable.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        var _this = this;
        // TODO: can the resyncTokenType be cached?
        var reSyncTokType = this.findReSyncTokenType();
        var savedLexerState = this.exportLexerState();
        var resyncedTokens = [];
        var passedResyncPoint = false;
        var nextTokenWithoutResync = this.LA(1);
        var currToken = this.LA(1);
        var generateErrorMessage = function() {
            var previousToken = _this.LA(0);
            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce
            // the error that would have been thrown
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
            });
            var error = new (0, _exceptionsPublic.MismatchedTokenException)(msg, nextTokenWithoutResync, _this.LA(0));
            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.
            error.resyncedTokens = (0, _utils.dropRight)(resyncedTokens);
            _this.SAVE_ERROR(error);
        };
        while(!passedResyncPoint){
            // re-synced to a point where we can safely exit the repetition/
            if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return; // must return here to avoid reverting the inputIdx
            } else if (lookAheadFunc.call(this)) {
                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule
                generateErrorMessage();
                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule
                grammarRule.apply(this, grammarRuleArgs);
                return; // must return here to avoid reverting the inputIdx
            } else if (this.tokenMatcher(currToken, reSyncTokType)) passedResyncPoint = true;
            else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
            }
        }
        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.
        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by
        // "between rules" resync recovery later in the flow.
        this.importLexerState(savedLexerState);
    };
    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
        // Edge case of arriving from a MANY repetition which is stuck
        // Attempting recovery in this case could cause an infinite loop
        if (notStuck === false) return false;
        // arguments to try and perform resync into the next iteration of the many are missing
        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) return false;
        // no need to recover, next token is what we expect...
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) return false;
        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path
        // and prefer some backtracking path that includes recovered errors.
        if (this.isBackTracking()) return false;
        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm
        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)
        //noinspection RedundantIfStatementJS
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) return false;
        return true;
    };
    // Error Recovery functionality
    Recoverable.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        var follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
    };
    Recoverable.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
    };
    Recoverable.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
        return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
    };
    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
        var _this = this;
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) return false;
        // must know the possible following tokens to perform single token insertion
        if ((0, _utils.isEmpty)(follows)) return false;
        var mismatchedTok = this.LA(1);
        var isMisMatchedTokInFollows = (0, _utils.find)(follows, function(possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== undefined;
        return isMisMatchedTokInFollows;
    };
    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
    };
    Recoverable.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
        var followKey = this.getCurrFollowKey();
        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return (0, _utils.contains)(currentRuleReSyncSet, tokenTypeIdx);
    };
    Recoverable.prototype.findReSyncTokenType = function() {
        var allPossibleReSyncTokTypes = this.flattenFollowSet();
        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input
        var nextToken = this.LA(1);
        var k = 2;
        while(true){
            var nextTokenType = nextToken.tokenType;
            if ((0, _utils.contains)(allPossibleReSyncTokTypes, nextTokenType)) return nextTokenType;
            nextToken = this.LA(k);
            k++;
        }
    };
    Recoverable.prototype.getCurrFollowKey = function() {
        // the length is at least one as we always add the ruleName to the stack before invoking the rule.
        if (this.RULE_STACK.length === 1) return EOF_FOLLOW_KEY;
        var currRuleShortName = this.getLastExplicitRuleShortName();
        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        var prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
        };
    };
    Recoverable.prototype.buildFullFollowKeyStack = function() {
        var _this = this;
        var explicitRuleStack = this.RULE_STACK;
        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        return (0, _utils.map)(explicitRuleStack, function(ruleName, idx) {
            if (idx === 0) return EOF_FOLLOW_KEY;
            return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
        });
    };
    Recoverable.prototype.flattenFollowSet = function() {
        var _this = this;
        var followStack = (0, _utils.map)(this.buildFullFollowKeyStack(), function(currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
        });
        return (0, _utils.flatten)(followStack);
    };
    Recoverable.prototype.getFollowSetFromFollowKey = function(followKey) {
        if (followKey === EOF_FOLLOW_KEY) return [
            (0, _tokensPublic.EOF)
        ];
        var followName = followKey.ruleName + followKey.idxInCallingRule + (0, _constants.IN) + followKey.inRule;
        return this.resyncFollows[followName];
    };
    // It does not make any sense to include a virtual EOF token in the list of resynced tokens
    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
    Recoverable.prototype.addToResyncTokens = function(token, resyncTokens) {
        if (!this.tokenMatcher(token, (0, _tokensPublic.EOF))) resyncTokens.push(token);
        return resyncTokens;
    };
    Recoverable.prototype.reSyncTo = function(tokType) {
        var resyncedTokens = [];
        var nextTok = this.LA(1);
        while(this.tokenMatcher(nextTok, tokType) === false){
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
        }
        // the last token is not part of the error.
        return (0, _utils.dropRight)(resyncedTokens);
    };
    Recoverable.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    // by default this is a NO-OP
    // The actual implementation is with the function(not method) below
    };
    Recoverable.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
        var pathRuleStack = this.getHumanReadableRuleStack();
        var pathOccurrenceStack = (0, _utils.cloneArr)(this.RULE_OCCURRENCE_STACK);
        var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
        };
        return grammarPath;
    };
    Recoverable.prototype.getHumanReadableRuleStack = function() {
        var _this = this;
        return (0, _utils.map)(this.RULE_STACK, function(currShortName) {
            return _this.shortRuleNameToFullName(currShortName);
        });
    };
    return Recoverable;
}();
function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
    var firstAfterRepInfo = this.firstAfterRepMap[key];
    if (firstAfterRepInfo === undefined) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
    }
    var expectTokAfterLastMatch = firstAfterRepInfo.token;
    var nextTokIdx = firstAfterRepInfo.occurrence;
    var isEndOfRule = firstAfterRepInfo.isEndOfRule;
    // special edge case of a TOP most repetition after which the input should END.
    // this will force an attempt for inRule recovery in that scenario.
    if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {
        expectTokAfterLastMatch = (0, _tokensPublic.EOF);
        nextTokIdx = 1;
    }
    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) // TODO: performance optimization: instead of passing the original args here, we modify
    // the args param (or create a new one) and make sure the lookahead func is explicitly provided
    // to avoid searching the cache for it once more.
    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
}

},{"../../../scan/tokens_public":"jSvr0","../../../utils/utils":"8K9hy","../../exceptions_public":"17qwD","../../constants":"a5wbN","../parser":"ePYOV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"17qwD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// hacks to bypass no support for custom Errors in javascript/typescript
parcelHelpers.export(exports, "isRecognitionException", ()=>isRecognitionException);
parcelHelpers.export(exports, "MismatchedTokenException", ()=>MismatchedTokenException);
parcelHelpers.export(exports, "NoViableAltException", ()=>NoViableAltException);
parcelHelpers.export(exports, "NotAllInputParsedException", ()=>NotAllInputParsedException);
parcelHelpers.export(exports, "EarlyExitException", ()=>EarlyExitException);
var _utils = require("../utils/utils");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
var EARLY_EXIT_EXCEPTION = "EarlyExitException";
var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
var RECOGNITION_EXCEPTION_NAMES = [
    MISMATCHED_TOKEN_EXCEPTION,
    NO_VIABLE_ALT_EXCEPTION,
    EARLY_EXIT_EXCEPTION,
    NOT_ALL_INPUT_PARSED_EXCEPTION
];
Object.freeze(RECOGNITION_EXCEPTION_NAMES);
function isRecognitionException(error) {
    // can't do instanceof on hacked custom js exceptions
    return (0, _utils.contains)(RECOGNITION_EXCEPTION_NAMES, error.name);
}
var RecognitionException = /** @class */ function(_super) {
    __extends(RecognitionException, _super);
    function RecognitionException(message, token) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.token = token;
        _this.resyncedTokens = [];
        // fix prototype chain when typescript target is ES5
        Object.setPrototypeOf(_this, _newTarget.prototype);
        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */ if (Error.captureStackTrace) Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    return RecognitionException;
}(Error);
var MismatchedTokenException = /** @class */ function(_super) {
    __extends(MismatchedTokenException, _super);
    function MismatchedTokenException(message, token, previousToken) {
        var _this = _super.call(this, message, token) || this;
        _this.previousToken = previousToken;
        _this.name = MISMATCHED_TOKEN_EXCEPTION;
        return _this;
    }
    return MismatchedTokenException;
}(RecognitionException);
var NoViableAltException = /** @class */ function(_super) {
    __extends(NoViableAltException, _super);
    function NoViableAltException(message, token, previousToken) {
        var _this = _super.call(this, message, token) || this;
        _this.previousToken = previousToken;
        _this.name = NO_VIABLE_ALT_EXCEPTION;
        return _this;
    }
    return NoViableAltException;
}(RecognitionException);
var NotAllInputParsedException = /** @class */ function(_super) {
    __extends(NotAllInputParsedException, _super);
    function NotAllInputParsedException(message, token) {
        var _this = _super.call(this, message, token) || this;
        _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
        return _this;
    }
    return NotAllInputParsedException;
}(RecognitionException);
var EarlyExitException = /** @class */ function(_super) {
    __extends(EarlyExitException, _super);
    function EarlyExitException(message, token, previousToken) {
        var _this = _super.call(this, message, token) || this;
        _this.previousToken = previousToken;
        _this.name = EARLY_EXIT_EXCEPTION;
        return _this;
    }
    return EarlyExitException;
}(RecognitionException);

},{"../utils/utils":"8K9hy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cGikN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LooksAhead", ()=>LooksAhead);
var _lookahead = require("../../grammar/lookahead");
var _utils = require("../../../utils/utils");
var _parser = require("../parser");
var _keys = require("../../grammar/keys");
var _gast = require("../../grammar/gast/gast");
/**
 * Trait responsible for the lookahead related utilities and optimizations.
 */ var LooksAhead = /** @class */ function() {
    function LooksAhead() {}
    LooksAhead.prototype.initLooksAhead = function(config) {
        this.dynamicTokensEnabled = (0, _utils.has)(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : (0, _parser.DEFAULT_PARSER_CONFIG).dynamicTokensEnabled;
        this.maxLookahead = (0, _utils.has)(config, "maxLookahead") ? config.maxLookahead : (0, _parser.DEFAULT_PARSER_CONFIG).maxLookahead;
        /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */ this.lookAheadFuncsCache = (0, _utils.isES2015MapSupported)() ? new Map() : [];
        // Performance optimization on newer engines that support ES6 Map
        // For larger Maps this is slightly faster than using a plain object (array in our case).
        /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */ if ((0, _utils.isES2015MapSupported)()) {
            this.getLaFuncFromCache = this.getLaFuncFromMap;
            this.setLaFuncCache = this.setLaFuncCacheUsingMap;
        } else {
            this.getLaFuncFromCache = this.getLaFuncFromObj;
            this.setLaFuncCache = this.setLaFuncUsingObj;
        }
    };
    LooksAhead.prototype.preComputeLookaheadFunctions = function(rules) {
        var _this = this;
        (0, _utils.forEach)(rules, function(currRule) {
            _this.TRACE_INIT(currRule.name + " Rule Lookahead", function() {
                var _a = (0, _gast.collectMethods)(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
                (0, _utils.forEach)(alternation, function(currProd) {
                    var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                    _this.TRACE_INIT("" + (0, _gast.getProductionDslName)(currProd) + prodIdx, function() {
                        var laFunc = (0, _lookahead.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
                        var key = (0, _keys.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], (0, _keys.OR_IDX), currProd.idx);
                        _this.setLaFuncCache(key, laFunc);
                    });
                });
                (0, _utils.forEach)(repetition, function(currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, (0, _keys.MANY_IDX), (0, _lookahead.PROD_TYPE).REPETITION, currProd.maxLookahead, (0, _gast.getProductionDslName)(currProd));
                });
                (0, _utils.forEach)(option, function(currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, (0, _keys.OPTION_IDX), (0, _lookahead.PROD_TYPE).OPTION, currProd.maxLookahead, (0, _gast.getProductionDslName)(currProd));
                });
                (0, _utils.forEach)(repetitionMandatory, function(currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, (0, _keys.AT_LEAST_ONE_IDX), (0, _lookahead.PROD_TYPE).REPETITION_MANDATORY, currProd.maxLookahead, (0, _gast.getProductionDslName)(currProd));
                });
                (0, _utils.forEach)(repetitionMandatoryWithSeparator, function(currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, (0, _keys.AT_LEAST_ONE_SEP_IDX), (0, _lookahead.PROD_TYPE).REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, _gast.getProductionDslName)(currProd));
                });
                (0, _utils.forEach)(repetitionWithSeparator, function(currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, (0, _keys.MANY_SEP_IDX), (0, _lookahead.PROD_TYPE).REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, _gast.getProductionDslName)(currProd));
                });
            });
        });
    };
    LooksAhead.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        var _this = this;
        this.TRACE_INIT("" + dslMethodName + (prodOccurrence === 0 ? "" : prodOccurrence), function() {
            var laFunc = (0, _lookahead.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
            var key = (0, _keys.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
        });
    };
    LooksAhead.prototype.lookAheadBuilderForOptional = function(alt, tokenMatcher, dynamicTokensEnabled) {
        return (0, _lookahead.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);
    };
    LooksAhead.prototype.lookAheadBuilderForAlternatives = function(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        return (0, _lookahead.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);
    };
    // this actually returns a number, but it is always used as a string (object prop key)
    LooksAhead.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
        var currRuleShortName = this.getLastExplicitRuleShortName();
        return (0, _keys.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
    };
    /* istanbul ignore next */ LooksAhead.prototype.getLaFuncFromCache = function(key) {
        return undefined;
    };
    LooksAhead.prototype.getLaFuncFromMap = function(key) {
        return this.lookAheadFuncsCache.get(key);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */ LooksAhead.prototype.getLaFuncFromObj = function(key) {
        return this.lookAheadFuncsCache[key];
    };
    /* istanbul ignore next */ LooksAhead.prototype.setLaFuncCache = function(key, value) {};
    LooksAhead.prototype.setLaFuncCacheUsingMap = function(key, value) {
        this.lookAheadFuncsCache.set(key, value);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */ LooksAhead.prototype.setLaFuncUsingObj = function(key, value) {
        this.lookAheadFuncsCache[key] = value;
    };
    return LooksAhead;
}();

},{"../../grammar/lookahead":"c24Uo","../../../utils/utils":"8K9hy","../parser":"ePYOV","../../grammar/keys":"7M4hz","../../grammar/gast/gast":"k45eR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7M4hz":[function(require,module,exports,__globalThis) {
// Lookahead keys are 32Bit integers in the form
// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX
// XXXX -> Occurrence Index bitmap.
// YYYY -> DSL Method Type bitmap.
// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.
// TTTTTTTTT -> alternation alternative index bitmap
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BITS_FOR_METHOD_TYPE", ()=>BITS_FOR_METHOD_TYPE);
parcelHelpers.export(exports, "BITS_FOR_OCCURRENCE_IDX", ()=>BITS_FOR_OCCURRENCE_IDX);
parcelHelpers.export(exports, "BITS_FOR_RULE_IDX", ()=>BITS_FOR_RULE_IDX);
parcelHelpers.export(exports, "BITS_FOR_ALT_IDX", ()=>BITS_FOR_ALT_IDX);
parcelHelpers.export(exports, "OR_IDX", ()=>OR_IDX);
parcelHelpers.export(exports, "OPTION_IDX", ()=>OPTION_IDX);
parcelHelpers.export(exports, "MANY_IDX", ()=>MANY_IDX);
parcelHelpers.export(exports, "AT_LEAST_ONE_IDX", ()=>AT_LEAST_ONE_IDX);
parcelHelpers.export(exports, "MANY_SEP_IDX", ()=>MANY_SEP_IDX);
parcelHelpers.export(exports, "AT_LEAST_ONE_SEP_IDX", ()=>AT_LEAST_ONE_SEP_IDX);
/* tslint:enable */ // this actually returns a number, but it is always used as a string (object prop key)
parcelHelpers.export(exports, "getKeyForAutomaticLookahead", ()=>getKeyForAutomaticLookahead);
var BITS_FOR_METHOD_TYPE = 4;
var BITS_FOR_OCCURRENCE_IDX = 8;
var BITS_FOR_RULE_IDX = 12;
var BITS_FOR_ALT_IDX = 8;
var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
    /* tslint:disable */ return occurrence | dslMethodIdx | ruleIdx;
/* tslint:enable */ }
var BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bgsPX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TreeBuilder", ()=>TreeBuilder);
var _cst = require("../../cst/cst");
var _utils = require("../../../utils/utils");
var _cstVisitor = require("../../cst/cst_visitor");
var _parser = require("../parser");
/**
 * This trait is responsible for the CST building logic.
 */ var TreeBuilder = /** @class */ function() {
    function TreeBuilder() {}
    TreeBuilder.prototype.initTreeBuilder = function(config) {
        this.CST_STACK = [];
        // outputCst is no longer exposed/defined in the pubic API
        this.outputCst = config.outputCst;
        this.nodeLocationTracking = (0, _utils.has)(config, "nodeLocationTracking") ? config.nodeLocationTracking : (0, _parser.DEFAULT_PARSER_CONFIG).nodeLocationTracking;
        if (!this.outputCst) {
            this.cstInvocationStateUpdate = (0, _utils.NOOP);
            this.cstFinallyStateUpdate = (0, _utils.NOOP);
            this.cstPostTerminal = (0, _utils.NOOP);
            this.cstPostNonTerminal = (0, _utils.NOOP);
            this.cstPostRule = (0, _utils.NOOP);
        } else {
            if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = (0, _cst.setNodeLocationFull);
                    this.setNodeLocationFromNode = (0, _cst.setNodeLocationFull);
                    this.cstPostRule = (0, _utils.NOOP);
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                } else {
                    this.setNodeLocationFromToken = (0, _utils.NOOP);
                    this.setNodeLocationFromNode = (0, _utils.NOOP);
                    this.cstPostRule = this.cstPostRuleFull;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = (0, _cst.setNodeLocationOnlyOffset);
                    this.setNodeLocationFromNode = (0, _cst.setNodeLocationOnlyOffset);
                    this.cstPostRule = (0, _utils.NOOP);
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                } else {
                    this.setNodeLocationFromToken = (0, _utils.NOOP);
                    this.setNodeLocationFromNode = (0, _utils.NOOP);
                    this.cstPostRule = this.cstPostRuleOnlyOffset;
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
            } else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = (0, _utils.NOOP);
                this.setNodeLocationFromNode = (0, _utils.NOOP);
                this.cstPostRule = (0, _utils.NOOP);
                this.setInitialNodeLocation = (0, _utils.NOOP);
            } else throw Error("Invalid <nodeLocationTracking> config option: \"" + config.nodeLocationTracking + "\"");
        }
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
        cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
        cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
        cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    /**
       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
  
       * @param cstNode
       */ TreeBuilder.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
        var nextToken = this.LA(1);
        cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    TreeBuilder.prototype.cstInvocationStateUpdate = function(fullRuleName, shortName) {
        var cstNode = {
            name: fullRuleName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstFinallyStateUpdate = function() {
        this.CST_STACK.pop();
    };
    TreeBuilder.prototype.cstPostRuleFull = function(ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
        } else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
        }
    };
    TreeBuilder.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode.
        if (loc.startOffset <= prevToken.startOffset === true) loc.endOffset = prevToken.endOffset;
        else loc.startOffset = NaN;
    };
    TreeBuilder.prototype.cstPostTerminal = function(key, consumedToken) {
        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        (0, _cst.addTerminalToCst)(rootCst, consumedToken, key);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
    };
    TreeBuilder.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
        (0, _cst.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructor = function() {
        if ((0, _utils.isUndefined)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = (0, _cstVisitor.createBaseSemanticVisitorConstructor)(this.className, (0, _utils.keys)(this.gastProductionsCache));
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
        if ((0, _utils.isUndefined)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = (0, _cstVisitor.createBaseVisitorConstructorWithDefaults)(this.className, (0, _utils.keys)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
    };
    TreeBuilder.prototype.getLastExplicitRuleShortName = function() {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function() {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function() {
        var occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
    };
    return TreeBuilder;
}();

},{"../../cst/cst":"gP77y","../../../utils/utils":"8K9hy","../../cst/cst_visitor":"cINP9","../parser":"ePYOV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gP77y":[function(require,module,exports,__globalThis) {
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setNodeLocationOnlyOffset", ()=>setNodeLocationOnlyOffset);
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */ parcelHelpers.export(exports, "setNodeLocationFull", ()=>setNodeLocationFull);
parcelHelpers.export(exports, "addTerminalToCst", ()=>addTerminalToCst);
parcelHelpers.export(exports, "addNoneTerminalToCst", ()=>addNoneTerminalToCst);
function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (both start/end offsets exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) currNodeLocation.endOffset = newLocationInfo.endOffset;
}
function setNodeLocationFull(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (all start/end props exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
}
function addTerminalToCst(node, token, tokenTypeName) {
    if (node.children[tokenTypeName] === undefined) node.children[tokenTypeName] = [
        token
    ];
    else node.children[tokenTypeName].push(token);
}
function addNoneTerminalToCst(node, ruleName, ruleResult) {
    if (node.children[ruleName] === undefined) node.children[ruleName] = [
        ruleResult
    ];
    else node.children[ruleName].push(ruleResult);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cINP9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultVisit", ()=>defaultVisit);
parcelHelpers.export(exports, "createBaseSemanticVisitorConstructor", ()=>createBaseSemanticVisitorConstructor);
parcelHelpers.export(exports, "createBaseVisitorConstructorWithDefaults", ()=>createBaseVisitorConstructorWithDefaults);
parcelHelpers.export(exports, "CstVisitorDefinitionError", ()=>CstVisitorDefinitionError);
parcelHelpers.export(exports, "validateVisitor", ()=>validateVisitor);
parcelHelpers.export(exports, "validateMissingCstMethods", ()=>validateMissingCstMethods);
parcelHelpers.export(exports, "validateRedundantMethods", ()=>validateRedundantMethods);
var _utils = require("../../utils/utils");
var _langExtensions = require("../../lang/lang_extensions");
function defaultVisit(ctx, param) {
    var childrenNames = (0, _utils.keys)(ctx);
    var childrenNamesLength = childrenNames.length;
    for(var i = 0; i < childrenNamesLength; i++){
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for(var j = 0; j < currChildArrayLength; j++){
            var currChild = currChildArray[j];
            // distinction between Tokens Children and CstNode children
            if (currChild.tokenTypeIdx === undefined) this[currChild.name](currChild.children, param);
        }
    }
    // defaultVisit does not support generic out param
    return undefined;
}
function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
    var derivedConstructor = function() {};
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    (0, _langExtensions.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
    var semanticProto = {
        visit: function(cstNode, param) {
            // enables writing more concise visitor methods when CstNode has only a single child
            if ((0, _utils.isArray)(cstNode)) // A CST Node's children dictionary can never have empty arrays as values
            // If a key is defined there will be at least one element in the corresponding value array.
            cstNode = cstNode[0];
            // enables passing optional CstNodes concisely.
            if ((0, _utils.isUndefined)(cstNode)) return undefined;
            return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function() {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!(0, _utils.isEmpty)(semanticDefinitionErrors)) {
                var errorMessages = (0, _utils.map)(semanticDefinitionErrors, function(currDefError) {
                    return currDefError.msg;
                });
                throw Error("Errors Detected in CST Visitor <" + (0, _langExtensions.functionName)(this.constructor) + ">:\n\t" + ("" + errorMessages.join("\n\n").replace(/\n/g, "\n\t")));
            }
        }
    };
    derivedConstructor.prototype = semanticProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    derivedConstructor._RULE_NAMES = ruleNames;
    return derivedConstructor;
}
function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
    var derivedConstructor = function() {};
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    (0, _langExtensions.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
    var withDefaultsProto = Object.create(baseConstructor.prototype);
    (0, _utils.forEach)(ruleNames, function(ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
    });
    derivedConstructor.prototype = withDefaultsProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    return derivedConstructor;
}
var CstVisitorDefinitionError;
(function(CstVisitorDefinitionError) {
    CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
    CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";
})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
function validateVisitor(visitorInstance, ruleNames) {
    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);
    return missingErrors.concat(redundantErrors);
}
function validateMissingCstMethods(visitorInstance, ruleNames) {
    var errors = (0, _utils.map)(ruleNames, function(currRuleName) {
        if (!(0, _utils.isFunction)(visitorInstance[currRuleName])) return {
            msg: "Missing visitor method: <" + currRuleName + "> on " + (0, _langExtensions.functionName)(visitorInstance.constructor) + " CST Visitor.",
            type: CstVisitorDefinitionError.MISSING_METHOD,
            methodName: currRuleName
        };
    });
    return (0, _utils.compact)(errors);
}
var VALID_PROP_NAMES = [
    "constructor",
    "visit",
    "validateVisitor"
];
function validateRedundantMethods(visitorInstance, ruleNames) {
    var errors = [];
    for(var prop in visitorInstance)if ((0, _utils.isFunction)(visitorInstance[prop]) && !(0, _utils.contains)(VALID_PROP_NAMES, prop) && !(0, _utils.contains)(ruleNames, prop)) errors.push({
        msg: "Redundant visitor method: <" + prop + "> on " + (0, _langExtensions.functionName)(visitorInstance.constructor) + " CST Visitor\n" + "There is no Grammar Rule corresponding to this method's name.\n",
        type: CstVisitorDefinitionError.REDUNDANT_METHOD,
        methodName: prop
    });
    return errors;
}

},{"../../utils/utils":"8K9hy","../../lang/lang_extensions":"3WdiW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3WdiW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "classNameFromInstance", ()=>classNameFromInstance);
/**
 * Utility to obtain Function names.
 * Note that there should not be an assumptions on the result of this function.
 * E.g: When running from minified source code the result may be auto generated.
 */ parcelHelpers.export(exports, "functionName", ()=>functionName);
/**
 * @returns {boolean} - has the property been successfully defined
 */ parcelHelpers.export(exports, "defineNameProp", ()=>defineNameProp);
var _utils = require("../utils/utils");
function classNameFromInstance(instance) {
    return functionName(instance.constructor);
}
var NAME = "name";
function functionName(func) {
    // Engines that support Function.prototype.name OR the nth (n>1) time after
    // the name has been computed in the following else block.
    var existingNameProp = func.name;
    /* istanbul ignore else - too many hacks for IE/old versions of node.js here*/ if (existingNameProp) return existingNameProp;
    else return "anonymous";
}
function defineNameProp(obj, nameValue) {
    var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);
    /* istanbul ignore else -> will only run in old versions of node.js */ if ((0, _utils.isUndefined)(namePropDescriptor) || namePropDescriptor.configurable) {
        Object.defineProperty(obj, NAME, {
            enumerable: false,
            configurable: true,
            writable: false,
            value: nameValue
        });
        return true;
    }
    /* istanbul ignore next -> will only run in old versions of node.js */ return false;
}

},{"../utils/utils":"8K9hy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"emLGG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LexerAdapter", ()=>LexerAdapter);
var _parser = require("../parser");
/**
 * Trait responsible abstracting over the interaction with Lexer output (Token vector).
 *
 * This could be generalized to support other kinds of lexers, e.g.
 * - Just in Time Lexing / Lexer-Less parsing.
 * - Streaming Lexer.
 */ var LexerAdapter = /** @class */ function() {
    function LexerAdapter() {}
    LexerAdapter.prototype.initLexerAdapter = function() {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
    };
    Object.defineProperty(LexerAdapter.prototype, "input", {
        get: function() {
            return this.tokVector;
        },
        set: function(newInput) {
            // @ts-ignore - `this parameter` not supported in setters/getters
            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters
            if (this.selfAnalysisDone !== true) throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            // @ts-ignore - `this parameter` not supported in setters/getters
            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
        },
        enumerable: false,
        configurable: true
    });
    // skips a token and returns the next token
    LexerAdapter.prototype.SKIP_TOKEN = function() {
        if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
        } else return 0, _parser.END_OF_FILE;
    };
    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
    // or lexers dependent on parser context.
    LexerAdapter.prototype.LA = function(howMuch) {
        var soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) return 0, _parser.END_OF_FILE;
        else return this.tokVector[soughtIdx];
    };
    LexerAdapter.prototype.consumeToken = function() {
        this.currIdx++;
    };
    LexerAdapter.prototype.exportLexerState = function() {
        return this.currIdx;
    };
    LexerAdapter.prototype.importLexerState = function(newState) {
        this.currIdx = newState;
    };
    LexerAdapter.prototype.resetLexerState = function() {
        this.currIdx = -1;
    };
    LexerAdapter.prototype.moveToTerminatedState = function() {
        this.currIdx = this.tokVector.length - 1;
    };
    LexerAdapter.prototype.getLexerPosition = function() {
        return this.exportLexerState();
    };
    return LexerAdapter;
}();

},{"../parser":"ePYOV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a6nig":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RecognizerApi", ()=>RecognizerApi);
var _utils = require("../../../utils/utils");
var _exceptionsPublic = require("../../exceptions_public");
var _parser = require("../parser");
var _errorsPublic = require("../../errors_public");
var _checks = require("../../grammar/checks");
var _gastPublic = require("../../grammar/gast/gast_public");
/**
 * This trait is responsible for implementing the public API
 * for defining Chevrotain parsers, i.e:
 * - CONSUME
 * - RULE
 * - OPTION
 * - ...
 */ var RecognizerApi = /** @class */ function() {
    function RecognizerApi() {}
    RecognizerApi.prototype.ACTION = function(impl) {
        return impl.call(this);
    };
    RecognizerApi.prototype.consume = function(idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
    };
    RecognizerApi.prototype.subrule = function(idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
    };
    RecognizerApi.prototype.option = function(idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
    };
    RecognizerApi.prototype.or = function(idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
    };
    RecognizerApi.prototype.many = function(idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.atLeastOne = function(idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.CONSUME = function(tokType, options) {
        return this.consumeInternal(tokType, 0, options);
    };
    RecognizerApi.prototype.CONSUME1 = function(tokType, options) {
        return this.consumeInternal(tokType, 1, options);
    };
    RecognizerApi.prototype.CONSUME2 = function(tokType, options) {
        return this.consumeInternal(tokType, 2, options);
    };
    RecognizerApi.prototype.CONSUME3 = function(tokType, options) {
        return this.consumeInternal(tokType, 3, options);
    };
    RecognizerApi.prototype.CONSUME4 = function(tokType, options) {
        return this.consumeInternal(tokType, 4, options);
    };
    RecognizerApi.prototype.CONSUME5 = function(tokType, options) {
        return this.consumeInternal(tokType, 5, options);
    };
    RecognizerApi.prototype.CONSUME6 = function(tokType, options) {
        return this.consumeInternal(tokType, 6, options);
    };
    RecognizerApi.prototype.CONSUME7 = function(tokType, options) {
        return this.consumeInternal(tokType, 7, options);
    };
    RecognizerApi.prototype.CONSUME8 = function(tokType, options) {
        return this.consumeInternal(tokType, 8, options);
    };
    RecognizerApi.prototype.CONSUME9 = function(tokType, options) {
        return this.consumeInternal(tokType, 9, options);
    };
    RecognizerApi.prototype.SUBRULE = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
    };
    RecognizerApi.prototype.SUBRULE1 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
    };
    RecognizerApi.prototype.SUBRULE2 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
    };
    RecognizerApi.prototype.SUBRULE3 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
    };
    RecognizerApi.prototype.SUBRULE4 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
    };
    RecognizerApi.prototype.SUBRULE5 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
    };
    RecognizerApi.prototype.SUBRULE6 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
    };
    RecognizerApi.prototype.SUBRULE7 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
    };
    RecognizerApi.prototype.SUBRULE8 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
    };
    RecognizerApi.prototype.SUBRULE9 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
    };
    RecognizerApi.prototype.OPTION = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
    };
    RecognizerApi.prototype.OPTION1 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
    };
    RecognizerApi.prototype.OPTION2 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
    };
    RecognizerApi.prototype.OPTION3 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
    };
    RecognizerApi.prototype.OPTION4 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
    };
    RecognizerApi.prototype.OPTION5 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
    };
    RecognizerApi.prototype.OPTION6 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
    };
    RecognizerApi.prototype.OPTION7 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
    };
    RecognizerApi.prototype.OPTION8 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
    };
    RecognizerApi.prototype.OPTION9 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
    };
    RecognizerApi.prototype.OR = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
    };
    RecognizerApi.prototype.OR1 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
    };
    RecognizerApi.prototype.OR2 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
    };
    RecognizerApi.prototype.OR3 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
    };
    RecognizerApi.prototype.OR4 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
    };
    RecognizerApi.prototype.OR5 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
    };
    RecognizerApi.prototype.OR6 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
    };
    RecognizerApi.prototype.OR7 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
    };
    RecognizerApi.prototype.OR8 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
    };
    RecognizerApi.prototype.OR9 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
    };
    RecognizerApi.prototype.MANY = function(actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY1 = function(actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY2 = function(actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY3 = function(actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY4 = function(actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY5 = function(actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY6 = function(actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY7 = function(actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY8 = function(actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY9 = function(actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY_SEP = function(options) {
        this.manySepFirstInternal(0, options);
    };
    RecognizerApi.prototype.MANY_SEP1 = function(options) {
        this.manySepFirstInternal(1, options);
    };
    RecognizerApi.prototype.MANY_SEP2 = function(options) {
        this.manySepFirstInternal(2, options);
    };
    RecognizerApi.prototype.MANY_SEP3 = function(options) {
        this.manySepFirstInternal(3, options);
    };
    RecognizerApi.prototype.MANY_SEP4 = function(options) {
        this.manySepFirstInternal(4, options);
    };
    RecognizerApi.prototype.MANY_SEP5 = function(options) {
        this.manySepFirstInternal(5, options);
    };
    RecognizerApi.prototype.MANY_SEP6 = function(options) {
        this.manySepFirstInternal(6, options);
    };
    RecognizerApi.prototype.MANY_SEP7 = function(options) {
        this.manySepFirstInternal(7, options);
    };
    RecognizerApi.prototype.MANY_SEP8 = function(options) {
        this.manySepFirstInternal(8, options);
    };
    RecognizerApi.prototype.MANY_SEP9 = function(options) {
        this.manySepFirstInternal(9, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function(options) {
        this.atLeastOneSepFirstInternal(0, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function(options) {
        this.atLeastOneSepFirstInternal(1, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function(options) {
        this.atLeastOneSepFirstInternal(2, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function(options) {
        this.atLeastOneSepFirstInternal(3, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function(options) {
        this.atLeastOneSepFirstInternal(4, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function(options) {
        this.atLeastOneSepFirstInternal(5, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function(options) {
        this.atLeastOneSepFirstInternal(6, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function(options) {
        this.atLeastOneSepFirstInternal(7, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function(options) {
        this.atLeastOneSepFirstInternal(8, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function(options) {
        this.atLeastOneSepFirstInternal(9, options);
    };
    RecognizerApi.prototype.RULE = function(name, implementation, config) {
        if (config === void 0) config = (0, _parser.DEFAULT_RULE_CONFIG);
        if ((0, _utils.contains)(this.definedRulesNames, name)) {
            var errMsg = (0, _errorsPublic.defaultGrammarValidatorErrorProvider).buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
            });
            var error = {
                message: errMsg,
                type: (0, _parser.ParserDefinitionErrorType).DUPLICATE_RULE_NAME,
                ruleName: name
            };
            this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        var ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.OVERRIDE_RULE = function(name, impl, config) {
        if (config === void 0) config = (0, _parser.DEFAULT_RULE_CONFIG);
        var ruleErrors = [];
        ruleErrors = ruleErrors.concat((0, _checks.validateRuleIsOverridden)(name, this.definedRulesNames, this.className));
        this.definitionErrors.push.apply(this.definitionErrors, ruleErrors); // mutability for the win
        var ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.BACKTRACK = function(grammarRule, args) {
        return function() {
            // save org state
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
                grammarRule.apply(this, args);
                // if no exception was thrown we have succeed parsing the rule.
                return true;
            } catch (e) {
                if ((0, _exceptionsPublic.isRecognitionException)(e)) return false;
                else throw e;
            } finally{
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
            }
        };
    };
    // GAST export APIs
    RecognizerApi.prototype.getGAstProductions = function() {
        return this.gastProductionsCache;
    };
    RecognizerApi.prototype.getSerializedGastProductions = function() {
        return (0, _gastPublic.serializeGrammar)((0, _utils.values)(this.gastProductionsCache));
    };
    return RecognizerApi;
}();

},{"../../../utils/utils":"8K9hy","../../exceptions_public":"17qwD","../parser":"ePYOV","../../errors_public":"af7LB","../../grammar/checks":"6Imh4","../../grammar/gast/gast_public":"krg1C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"Olonj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RecognizerEngine", ()=>RecognizerEngine);
var _utils = require("../../../utils/utils");
var _keys = require("../../grammar/keys");
var _exceptionsPublic = require("../../exceptions_public");
var _lookahead = require("../../grammar/lookahead");
var _interpreter = require("../../grammar/interpreter");
var _parser = require("../parser");
var _recoverable = require("./recoverable");
var _tokensPublic = require("../../../scan/tokens_public");
var _tokens = require("../../../scan/tokens");
var _langExtensions = require("../../../lang/lang_extensions");
/**
 * This trait is responsible for the runtime parsing engine
 * Used by the official API (recognizer_api.ts)
 */ var RecognizerEngine = /** @class */ function() {
    function RecognizerEngine() {}
    RecognizerEngine.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
        this.className = (0, _langExtensions.classNameFromInstance)(this);
        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = (0, _tokens.tokenStructuredMatcherNoCategories);
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if ((0, _utils.has)(config, "serializedGrammar")) throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
        if ((0, _utils.isArray)(tokenVocabulary)) {
            // This only checks for Token vocabularies provided as arrays.
            // That is good enough because the main objective is to detect users of pre-V4.0 APIs
            // rather than all edge cases of empty Token vocabularies.
            if ((0, _utils.isEmpty)(tokenVocabulary)) throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
            if (typeof tokenVocabulary[0].startOffset === "number") throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
        }
        if ((0, _utils.isArray)(tokenVocabulary)) this.tokensMap = (0, _utils.reduce)(tokenVocabulary, function(acc, tokType) {
            acc[tokType.name] = tokType;
            return acc;
        }, {});
        else if ((0, _utils.has)(tokenVocabulary, "modes") && (0, _utils.every)((0, _utils.flatten)((0, _utils.values)(tokenVocabulary.modes)), (0, _tokens.isTokenType))) {
            var allTokenTypes = (0, _utils.flatten)((0, _utils.values)(tokenVocabulary.modes));
            var uniqueTokens = (0, _utils.uniq)(allTokenTypes);
            this.tokensMap = (0, _utils.reduce)(uniqueTokens, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        } else if ((0, _utils.isObject)(tokenVocabulary)) this.tokensMap = (0, _utils.cloneObj)(tokenVocabulary);
        else throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been
        // parsed with a clear error message ("expecting EOF but found ...")
        /* tslint:disable */ this.tokensMap["EOF"] = (0, _tokensPublic.EOF);
        // TODO: This check may not be accurate for multi mode lexers
        var noTokenCategoriesUsed = (0, _utils.every)((0, _utils.values)(tokenVocabulary), function(tokenConstructor) {
            return (0, _utils.isEmpty)(tokenConstructor.categoryMatches);
        });
        this.tokenMatcher = noTokenCategoriesUsed ? (0, _tokens.tokenStructuredMatcherNoCategories) : (0, _tokens.tokenStructuredMatcher);
        // Because ES2015+ syntax should be supported for creating Token classes
        // We cannot assume that the Token classes were created using the "extendToken" utilities
        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization
        (0, _tokens.augmentTokenTypes)((0, _utils.values)(this.tokensMap));
    };
    RecognizerEngine.prototype.defineRule = function(ruleName, impl, config) {
        if (this.selfAnalysisDone) throw Error("Grammar rule <" + ruleName + "> may not be defined after the 'performSelfAnalysis' method has been called'\n" + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
        var resyncEnabled = (0, _utils.has)(config, "resyncEnabled") ? config.resyncEnabled : (0, _parser.DEFAULT_RULE_CONFIG).resyncEnabled;
        var recoveryValueFunc = (0, _utils.has)(config, "recoveryValueFunc") ? config.recoveryValueFunc : (0, _parser.DEFAULT_RULE_CONFIG).recoveryValueFunc;
        // performance optimization: Use small integers as keys for the longer human readable "full" rule names.
        // this greatly improves Map access time (as much as 8% for some performance benchmarks).
        /* tslint:disable */ var shortName = this.ruleShortNameIdx << (0, _keys.BITS_FOR_METHOD_TYPE) + (0, _keys.BITS_FOR_OCCURRENCE_IDX);
        /* tslint:enable */ this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        function invokeRuleWithTry(args) {
            try {
                if (this.outputCst === true) {
                    impl.apply(this, args);
                    var cst = this.CST_STACK[this.CST_STACK.length - 1];
                    this.cstPostRule(cst);
                    return cst;
                } else return impl.apply(this, args);
            } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            } finally{
                this.ruleFinallyStateUpdate();
            }
        }
        var wrappedGrammarRule;
        wrappedGrammarRule = function(idxInCallingRule, args) {
            if (idxInCallingRule === void 0) idxInCallingRule = 0;
            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);
            return invokeRuleWithTry.call(this, args);
        };
        var ruleNamePropName = "ruleName";
        wrappedGrammarRule[ruleNamePropName] = ruleName;
        wrappedGrammarRule["originalGrammarAction"] = impl;
        return wrappedGrammarRule;
    };
    RecognizerEngine.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
        var isFirstInvokedRule = this.RULE_STACK.length === 1;
        // note the reSync is always enabled for the first rule invocation, because we must always be able to
        // reSync with EOF and just output some INVALID ParseTree
        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking
        // path is really the most valid one
        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
        if ((0, _exceptionsPublic.isRecognitionException)(e)) {
            var recogError = e;
            if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        return partialCstResult;
                    } else return recoveryValueFunc();
                } else {
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        recogError.partialCstResult = partialCstResult;
                    }
                    // to be handled Further up the call stack
                    throw recogError;
                }
            } else if (isFirstInvokedRule) {
                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case
                this.moveToTerminatedState();
                // the parser should never throw one of its own errors outside its flow.
                // even if error recovery is disabled
                return recoveryValueFunc();
            } else // to be recovered Further up the call stack
            throw recogError;
        } else // some other Error type which we don't know how to handle (for example a built in JavaScript Error)
        throw e;
    };
    // Implementation of parsing DSL
    RecognizerEngine.prototype.optionInternal = function(actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead((0, _keys.OPTION_IDX), occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
    };
    RecognizerEngine.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function() {
                    return predicate.call(_this) && orgLookaheadFunction_1.call(_this);
                };
            }
        } else action = actionORMethodDef;
        if (lookAheadFunc.call(this) === true) return action.call(this);
        return undefined;
    };
    RecognizerEngine.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead((0, _keys.AT_LEAST_ONE_IDX), prodOccurrence);
        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    };
    RecognizerEngine.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function() {
                    return predicate.call(_this) && orgLookaheadFunction_2.call(_this);
                };
            }
        } else action = actionORMethodDef;
        if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while(lookAheadFunc.call(this) === true && notStuck === true)notStuck = this.doSingleRepetition(action);
        } else throw this.raiseEarlyExitException(prodOccurrence, (0, _lookahead.PROD_TYPE).REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        // note that while it may seem that this can cause an error because by using a recursive call to
        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call
        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [
            prodOccurrence,
            actionORMethodDef
        ], lookAheadFunc, (0, _keys.AT_LEAST_ONE_IDX), prodOccurrence, (0, _interpreter.NextTerminalAfterAtLeastOneWalker));
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead((0, _keys.AT_LEAST_ONE_SEP_IDX), prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLookaheadFunc.call(this) === true) {
            action.call(this);
            //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"
            //  because it is only needed in error recovery scenarios.
            var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while(this.tokenMatcher(this.LA(1), separator) === true){
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                (0, _interpreter.NextTerminalAfterAtLeastOneSepWalker)
            ], separatorLookAheadFunc, (0, _keys.AT_LEAST_ONE_SEP_IDX), prodOccurrence, (0, _interpreter.NextTerminalAfterAtLeastOneSepWalker));
        } else throw this.raiseEarlyExitException(prodOccurrence, (0, _lookahead.PROD_TYPE).REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
    };
    RecognizerEngine.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead((0, _keys.MANY_IDX), prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    };
    RecognizerEngine.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookaheadFunction = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function() {
                    return predicate.call(_this) && orgLookaheadFunction_3.call(_this);
                };
            }
        } else action = actionORMethodDef;
        var notStuck = true;
        while(lookaheadFunction.call(this) === true && notStuck === true)notStuck = this.doSingleRepetition(action);
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.manyInternal, [
            prodOccurrence,
            actionORMethodDef
        ], lookaheadFunction, (0, _keys.MANY_IDX), prodOccurrence, (0, _interpreter.NextTerminalAfterManyWalker), // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
        // An infinite loop cannot occur as:
        // - Either the lookahead is guaranteed to consume something (Single Token Separator)
        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
        notStuck);
    };
    RecognizerEngine.prototype.manySepFirstInternal = function(prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead((0, _keys.MANY_SEP_IDX), prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLaFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while(this.tokenMatcher(this.LA(1), separator) === true){
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                // No need for checking infinite loop here due to consuming the separator.
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                (0, _interpreter.NextTerminalAfterManySepWalker)
            ], separatorLookAheadFunc, (0, _keys.MANY_SEP_IDX), prodOccurrence, (0, _interpreter.NextTerminalAfterManySepWalker));
        }
    };
    RecognizerEngine.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while(separatorLookAheadFunc()){
            // note that this CONSUME will never enter recovery because
            // the separatorLookAheadFunc checks that the separator really does exist.
            this.CONSUME(separator);
            action.call(this);
        }
        // we can only arrive to this function after an error
        // has occurred (hence the name 'second') so the following
        // IF will always be entered, its possible to remove it...
        // however it is kept to avoid confusion and be consistent.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        /* istanbul ignore else */ this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
        ], separatorLookAheadFunc, (0, _keys.AT_LEAST_ONE_SEP_IDX), prodOccurrence, nextTerminalAfterWalker);
    };
    RecognizerEngine.prototype.doSingleRepetition = function(action) {
        var beforeIteration = this.getLexerPosition();
        action.call(this);
        var afterIteration = this.getLexerPosition();
        // This boolean will indicate if this repetition progressed
        // or if we are "stuck" (potential infinite loop in the repetition).
        return afterIteration > beforeIteration;
    };
    RecognizerEngine.prototype.orInternal = function(altsOrOpts, occurrence) {
        var laKey = this.getKeyForAutomaticLookahead((0, _keys.OR_IDX), occurrence);
        var alts = (0, _utils.isArray)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
        var laFunc = this.getLaFuncFromCache(laKey);
        var altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== undefined) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
    };
    RecognizerEngine.prototype.ruleFinallyStateUpdate = function() {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new (0, _exceptionsPublic.NotAllInputParsedException)(errMsg, firstRedundantTok));
        }
    };
    RecognizerEngine.prototype.subruleInternal = function(ruleToCall, idx, options) {
        var ruleResult;
        try {
            var args = options !== undefined ? options.ARGS : undefined;
            ruleResult = ruleToCall.call(this, idx, args);
            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);
            return ruleResult;
        } catch (e) {
            this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
    };
    RecognizerEngine.prototype.subruleInternalError = function(e, options, ruleName) {
        if ((0, _exceptionsPublic.isRecognitionException)(e) && e.partialCstResult !== undefined) {
            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);
            delete e.partialCstResult;
        }
        throw e;
    };
    RecognizerEngine.prototype.consumeInternal = function(tokType, idx, options) {
        var consumedToken;
        try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
            } else this.consumeInternalError(tokType, nextToken, options);
        } catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);
        return consumedToken;
    };
    RecognizerEngine.prototype.consumeInternalError = function(tokType, nextToken, options) {
        var msg;
        var previousToken = this.LA(0);
        if (options !== undefined && options.ERR_MSG) msg = options.ERR_MSG;
        else msg = this.errorMessageProvider.buildMismatchTokenMessage({
            expected: tokType,
            actual: nextToken,
            previous: previousToken,
            ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new (0, _exceptionsPublic.MismatchedTokenException)(msg, nextToken, previousToken));
    };
    RecognizerEngine.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it
        // but the original syntax could have been parsed successfully without any backtracking + recovery
        if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
        eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
                return this.tryInRuleRecovery(tokType, follows);
            } catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === (0, _recoverable.IN_RULE_RECOVERY_EXCEPTION)) // failed in RuleRecovery.
                // throw the original error in order to trigger reSync error recovery
                throw eFromConsumption;
                else throw eFromInRuleRecovery;
            }
        } else throw eFromConsumption;
    };
    RecognizerEngine.prototype.saveRecogState = function() {
        // errors is a getter which will clone the errors array
        var savedErrors = this.errors;
        var savedRuleStack = (0, _utils.cloneArr)(this.RULE_STACK);
        return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK
        };
    };
    RecognizerEngine.prototype.reloadRecogState = function(newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
    };
    RecognizerEngine.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        // NOOP when cst is disabled
        this.cstInvocationStateUpdate(fullName, shortName);
    };
    RecognizerEngine.prototype.isBackTracking = function() {
        return this.isBackTrackingStack.length !== 0;
    };
    RecognizerEngine.prototype.getCurrRuleFullName = function() {
        var shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.shortRuleNameToFullName = function(shortName) {
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.isAtEndOfInput = function() {
        return this.tokenMatcher(this.LA(1), (0, _tokensPublic.EOF));
    };
    RecognizerEngine.prototype.reset = function() {
        this.resetLexerState();
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        // TODO: extract a specific reset for TreeBuilder trait
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
    };
    return RecognizerEngine;
}();

},{"../../../utils/utils":"8K9hy","../../grammar/keys":"7M4hz","../../exceptions_public":"17qwD","../../grammar/lookahead":"c24Uo","../../grammar/interpreter":"2XcSV","../parser":"ePYOV","./recoverable":"gaFM8","../../../scan/tokens_public":"jSvr0","../../../scan/tokens":"535mp","../../../lang/lang_extensions":"3WdiW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2W7RW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ErrorHandler", ()=>ErrorHandler);
var _exceptionsPublic = require("../../exceptions_public");
var _utils = require("../../../utils/utils");
var _lookahead = require("../../grammar/lookahead");
var _parser = require("../parser");
/**
 * Trait responsible for runtime parsing errors.
 */ var ErrorHandler = /** @class */ function() {
    function ErrorHandler() {}
    ErrorHandler.prototype.initErrorHandler = function(config) {
        this._errors = [];
        this.errorMessageProvider = (0, _utils.has)(config, "errorMessageProvider") ? config.errorMessageProvider : (0, _parser.DEFAULT_PARSER_CONFIG).errorMessageProvider;
    };
    ErrorHandler.prototype.SAVE_ERROR = function(error) {
        if ((0, _exceptionsPublic.isRecognitionException)(error)) {
            error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: (0, _utils.cloneArr)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
        } else throw Error("Trying to save an Error which is not a RecognitionException");
    };
    Object.defineProperty(ErrorHandler.prototype, "errors", {
        get: function() {
            return (0, _utils.cloneArr)(this._errors);
        },
        set: function(newErrors) {
            this._errors = newErrors;
        },
        enumerable: false,
        configurable: true
    });
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        var lookAheadPathsPerAlternative = (0, _lookahead.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
        var insideProdPaths = lookAheadPathsPerAlternative[0];
        var actualTokens = [];
        for(var i = 1; i <= this.maxLookahead; i++)actualTokens.push(this.LA(i));
        var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName: ruleName
        });
        throw this.SAVE_ERROR(new (0, _exceptionsPublic.EarlyExitException)(msg, this.LA(1), this.LA(0)));
    };
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?
        var lookAheadPathsPerAlternative = (0, _lookahead.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
        var actualTokens = [];
        for(var i = 1; i <= this.maxLookahead; i++)actualTokens.push(this.LA(i));
        var previousToken = this.LA(0);
        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new (0, _exceptionsPublic.NoViableAltException)(errMsg, this.LA(1), previousToken));
    };
    return ErrorHandler;
}();

},{"../../exceptions_public":"17qwD","../../../utils/utils":"8K9hy","../../grammar/lookahead":"c24Uo","../parser":"ePYOV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4pRzz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContentAssist", ()=>ContentAssist);
var _interpreter = require("../../grammar/interpreter");
var _utils = require("../../../utils/utils");
var ContentAssist = /** @class */ function() {
    function ContentAssist() {}
    ContentAssist.prototype.initContentAssist = function() {};
    ContentAssist.prototype.computeContentAssist = function(startRuleName, precedingInput) {
        var startRuleGast = this.gastProductionsCache[startRuleName];
        if ((0, _utils.isUndefined)(startRuleGast)) throw Error("Rule ->" + startRuleName + "<- does not exist in this grammar.");
        return (0, _interpreter.nextPossibleTokensAfter)([
            startRuleGast
        ], precedingInput, this.tokenMatcher, this.maxLookahead);
    };
    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
    // TODO: should this be more explicitly part of the public API?
    ContentAssist.prototype.getNextPossibleTokenTypes = function(grammarPath) {
        var topRuleName = (0, _utils.first)(grammarPath.ruleStack);
        var gastProductions = this.getGAstProductions();
        var topProduction = gastProductions[topRuleName];
        var nextPossibleTokenTypes = new (0, _interpreter.NextAfterTokenWalker)(topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
    };
    return ContentAssist;
}();

},{"../../grammar/interpreter":"2XcSV","../../../utils/utils":"8K9hy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6eFnZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GastRecorder", ()=>GastRecorder);
var _utils = require("../../../utils/utils");
var _gastPublic = require("../../grammar/gast/gast_public");
var _lexerPublic = require("../../../scan/lexer_public");
var _tokens = require("../../../scan/tokens");
var _tokensPublic = require("../../../scan/tokens_public");
var _parser = require("../parser");
var _keys = require("../../grammar/keys");
var RECORDING_NULL_OBJECT = {
    description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(RECORDING_NULL_OBJECT);
var HANDLE_SEPARATOR = true;
var MAX_METHOD_IDX = Math.pow(2, (0, _keys.BITS_FOR_OCCURRENCE_IDX)) - 1;
var RFT = (0, _tokensPublic.createToken)({
    name: "RECORDING_PHASE_TOKEN",
    pattern: (0, _lexerPublic.Lexer).NA
});
(0, _tokens.augmentTokenTypes)([
    RFT
]);
var RECORDING_PHASE_TOKEN = (0, _tokensPublic.createTokenInstance)(RFT, "This IToken indicates the Parser is in Recording Phase\n	See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details", // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
-1, -1, -1, -1, -1, -1);
Object.freeze(RECORDING_PHASE_TOKEN);
var RECORDING_PHASE_CSTNODE = {
    name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details",
    children: {}
};
/**
 * This trait handles the creation of the GAST structure for Chevrotain Grammars
 */ var GastRecorder = /** @class */ function() {
    function GastRecorder() {}
    GastRecorder.prototype.initGastRecorder = function(config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
    };
    GastRecorder.prototype.enableRecording = function() {
        var _this = this;
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", function() {
            var _loop_1 = function(i) {
                var idx = i > 0 ? i : "";
                _this["CONSUME" + idx] = function(arg1, arg2) {
                    return this.consumeInternalRecord(arg1, i, arg2);
                };
                _this["SUBRULE" + idx] = function(arg1, arg2) {
                    return this.subruleInternalRecord(arg1, i, arg2);
                };
                _this["OPTION" + idx] = function(arg1) {
                    return this.optionInternalRecord(arg1, i);
                };
                _this["OR" + idx] = function(arg1) {
                    return this.orInternalRecord(arg1, i);
                };
                _this["MANY" + idx] = function(arg1) {
                    this.manyInternalRecord(i, arg1);
                };
                _this["MANY_SEP" + idx] = function(arg1) {
                    this.manySepFirstInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE" + idx] = function(arg1) {
                    this.atLeastOneInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE_SEP" + idx] = function(arg1) {
                    this.atLeastOneSepFirstInternalRecord(i, arg1);
                };
            };
            /**
             * Warning Dark Voodoo Magic upcoming!
             * We are "replacing" the public parsing DSL methods API
             * With **new** alternative implementations on the Parser **instance**
             *
             * So far this is the only way I've found to avoid performance regressions during parsing time.
             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"
             *   implementations directly instead.
             */ for(var i = 0; i < 10; i++)_loop_1(i);
            // DSL methods with the idx(suffix) as an argument
            _this["consume"] = function(idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function(idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function(idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function(idx, arg1) {
                return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function(idx, arg1) {
                this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function(idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
        });
    };
    GastRecorder.prototype.disableRecording = function() {
        var _this = this;
        this.RECORDING_PHASE = false;
        // By deleting these **instance** properties, any future invocation
        // will be deferred to the original methods on the **prototype** object
        // This seems to get rid of any incorrect optimizations that V8 may
        // do during the recording phase.
        this.TRACE_INIT("Deleting Recording methods", function() {
            for(var i = 0; i < 10; i++){
                var idx = i > 0 ? i : "";
                delete _this["CONSUME" + idx];
                delete _this["SUBRULE" + idx];
                delete _this["OPTION" + idx];
                delete _this["OR" + idx];
                delete _this["MANY" + idx];
                delete _this["MANY_SEP" + idx];
                delete _this["AT_LEAST_ONE" + idx];
                delete _this["AT_LEAST_ONE_SEP" + idx];
            }
            delete _this["consume"];
            delete _this["subrule"];
            delete _this["option"];
            delete _this["or"];
            delete _this["many"];
            delete _this["atLeastOne"];
            delete _this.ACTION;
            delete _this.BACKTRACK;
            delete _this.LA;
        });
    };
    // TODO: is there any way to use this method to check no
    //   Parser methods are called inside an ACTION?
    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
    GastRecorder.prototype.ACTION_RECORD = function(impl) {
        // NO-OP during recording
        return;
    };
    // Executing backtracking logic will break our recording logic assumptions
    GastRecorder.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
        return function() {
            return true;
        };
    };
    // LA is part of the official API and may be used for custom lookahead logic
    // by end users who may forget to wrap it in ACTION or inside a GATE
    GastRecorder.prototype.LA_RECORD = function(howMuch) {
        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend
        // On LA return EOF at the end of the input so an infinite loop may occur.
        return 0, _parser.END_OF_FILE;
    };
    GastRecorder.prototype.topLevelRuleRecord = function(name, def) {
        try {
            var newTopLevelRule = new (0, _gastPublic.Rule)({
                definition: [],
                name: name
            });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
        } catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) try {
                originalError.message = originalError.message + '\n\t This error was thrown during the "grammar recording phase" For more info see:\n\t' + "https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording";
            } catch (mutabilityError) {
                // We may not be able to modify the original error object
                throw originalError;
            }
            throw originalError;
        }
    };
    // Implementation of parsing DSL
    GastRecorder.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
        return recordProd.call(this, (0, _gastPublic.Option), actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
        recordProd.call(this, (0, _gastPublic.RepetitionMandatory), actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
        recordProd.call(this, (0, _gastPublic.RepetitionMandatoryWithSeparator), options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
        recordProd.call(this, (0, _gastPublic.Repetition), actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.manySepFirstInternalRecord = function(occurrence, options) {
        recordProd.call(this, (0, _gastPublic.RepetitionWithSeparator), options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
    };
    GastRecorder.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || (0, _utils.has)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE" + getIdxSuffix(occurrence) + "> argument is invalid" + (" expecting a Parser method reference but got: <" + JSON.stringify(ruleToCall) + ">") + ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = (0, _utils.peek)(this.recordingProdStack);
        var ruleName = ruleToCall["ruleName"];
        var newNoneTerminal = new (0, _gastPublic.NonTerminal)({
            idx: occurrence,
            nonTerminalName: ruleName,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: undefined
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
    };
    GastRecorder.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!(0, _tokens.hasShortKeyProperty)(tokType)) {
            var error = new Error("<CONSUME" + getIdxSuffix(occurrence) + "> argument is invalid" + (" expecting a TokenType reference but got: <" + JSON.stringify(tokType) + ">") + ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = (0, _utils.peek)(this.recordingProdStack);
        var newNoneTerminal = new (0, _gastPublic.Terminal)({
            idx: occurrence,
            terminalType: tokType
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
    };
    return GastRecorder;
}();
function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
    if (handleSep === void 0) handleSep = false;
    assertMethodIdxIsValid(occurrence);
    var prevProd = (0, _utils.peek)(this.recordingProdStack);
    var grammarAction = (0, _utils.isFunction)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
    var newProd = new prodConstructor({
        definition: [],
        idx: occurrence
    });
    if (handleSep) newProd.separator = mainProdArg.SEP;
    if ((0, _utils.has)(mainProdArg, "MAX_LOOKAHEAD")) newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    this.recordingProdStack.push(newProd);
    grammarAction.call(this);
    prevProd.definition.push(newProd);
    this.recordingProdStack.pop();
    return RECORDING_NULL_OBJECT;
}
function recordOrProd(mainProdArg, occurrence) {
    var _this = this;
    assertMethodIdxIsValid(occurrence);
    var prevProd = (0, _utils.peek)(this.recordingProdStack);
    // Only an array of alternatives
    var hasOptions = (0, _utils.isArray)(mainProdArg) === false;
    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
    var newOrProd = new (0, _gastPublic.Alternation)({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
    });
    if ((0, _utils.has)(mainProdArg, "MAX_LOOKAHEAD")) newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    var hasPredicates = (0, _utils.some)(alts, function(currAlt) {
        return (0, _utils.isFunction)(currAlt.GATE);
    });
    newOrProd.hasPredicates = hasPredicates;
    prevProd.definition.push(newOrProd);
    (0, _utils.forEach)(alts, function(currAlt) {
        var currAltFlat = new (0, _gastPublic.Alternative)({
            definition: []
        });
        newOrProd.definition.push(currAltFlat);
        if ((0, _utils.has)(currAlt, "IGNORE_AMBIGUITIES")) currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        else if ((0, _utils.has)(currAlt, "GATE")) currAltFlat.ignoreAmbiguities = true;
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
    });
    return RECORDING_NULL_OBJECT;
}
function getIdxSuffix(idx) {
    return idx === 0 ? "" : "" + idx;
}
function assertMethodIdxIsValid(idx) {
    if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(// The stack trace will contain all the needed details
        "Invalid DSL Method idx value: <" + idx + ">\n\t" + ("Idx value must be a none negative value smaller than " + (MAX_METHOD_IDX + 1)));
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
    }
}

},{"../../../utils/utils":"8K9hy","../../grammar/gast/gast_public":"krg1C","../../../scan/lexer_public":"988dl","../../../scan/tokens":"535mp","../../../scan/tokens_public":"jSvr0","../parser":"ePYOV","../../grammar/keys":"7M4hz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jsW2W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PerformanceTracer", ()=>PerformanceTracer);
var _utils = require("../../../utils/utils");
var _parser = require("../parser");
/**
 * Trait responsible for runtime parsing errors.
 */ var PerformanceTracer = /** @class */ function() {
    function PerformanceTracer() {}
    PerformanceTracer.prototype.initPerformanceTracer = function(config) {
        if ((0, _utils.has)(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
        } else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = (0, _parser.DEFAULT_PARSER_CONFIG).traceInitPerf;
        }
        this.traceInitIndent = -1;
    };
    PerformanceTracer.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) console.log(indent + "--> <" + phaseDesc + ">");
            var _a = (0, _utils.timer)(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */ var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            this.traceInitIndent--;
            return value;
        } else return phaseImpl();
    };
    return PerformanceTracer;
}();

},{"../../../utils/utils":"8K9hy","../parser":"ePYOV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4F2bo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSyntaxDiagramsCode", ()=>createSyntaxDiagramsCode);
var _version = require("../version");
function createSyntaxDiagramsCode(grammar, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@" + (0, _version.VERSION) + "/diagrams/" : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@" + (0, _version.VERSION) + "/diagrams/diagrams.css" : _d;
    var header = "\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n";
    var cssHtml = "\n<link rel='stylesheet' href='" + css + "'>\n";
    var scripts = "\n<script src='" + resourceBase + "vendor/railroad-diagrams.js'></script>\n<script src='" + resourceBase + "src/diagrams_builder.js'></script>\n<script src='" + resourceBase + "src/diagrams_behavior.js'></script>\n<script src='" + resourceBase + "src/main.js'></script>\n";
    var diagramsDiv = "\n<div id=\"diagrams\" align=\"center\"></div>    \n";
    var serializedGrammar = "\n<script>\n    window.serializedGrammar = " + JSON.stringify(grammar, null, "  ") + ";\n</script>\n";
    var initLogic = "\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n";
    return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
}

},{"../version":"b9fSC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Q345":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateParserFactory", ()=>generateParserFactory);
parcelHelpers.export(exports, "generateParserModule", ()=>generateParserModule);
var _generate = require("./generate");
function generateParserFactory(options) {
    var wrapperText = (0, _generate.genWrapperFunction)({
        name: options.name,
        rules: options.rules
    });
    var constructorWrapper = new Function("tokenVocabulary", "config", "chevrotain", wrapperText);
    return function(config) {
        return constructorWrapper(options.tokenVocabulary, config, // TODO: check how the require is transpiled/webpacked
        require("134a0d060465ae89"));
    };
}
function generateParserModule(options) {
    return (0, _generate.genUmdModule)({
        name: options.name,
        rules: options.rules
    });
}

},{"./generate":"7iMEt","134a0d060465ae89":"wd4P1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7iMEt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "genUmdModule", ()=>genUmdModule);
parcelHelpers.export(exports, "genWrapperFunction", ()=>genWrapperFunction);
parcelHelpers.export(exports, "genClass", ()=>genClass);
parcelHelpers.export(exports, "genAllRules", ()=>genAllRules);
parcelHelpers.export(exports, "genRule", ()=>genRule);
parcelHelpers.export(exports, "genTerminal", ()=>genTerminal);
parcelHelpers.export(exports, "genNonTerminal", ()=>genNonTerminal);
parcelHelpers.export(exports, "genAlternation", ()=>genAlternation);
parcelHelpers.export(exports, "genSingleAlt", ()=>genSingleAlt);
var _utils = require("../utils/utils");
var _gastPublic = require("../parse/grammar/gast/gast_public");
/**
 * Missing features
 * 1. Rule arguments
 * 2. Gates
 * 3. embedded actions
 */ var NL = "\n";
function genUmdModule(options) {
    return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + genClass(options) + "\n    \nreturn {\n    " + options.name + ": " + options.name + " \n}\n}));\n";
}
function genWrapperFunction(options) {
    return "    \n" + genClass(options) + "\nreturn new " + options.name + "(tokenVocabulary, config)    \n";
}
function genClass(options) {
    // TODO: how to pass the token vocabulary? Constructor? other?
    var result = "\nfunction " + options.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + genAllRules(options.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + options.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + options.name + ".prototype.constructor = " + options.name + "    \n    ";
    return result;
}
function genAllRules(rules) {
    var rulesText = (0, _utils.map)(rules, function(currRule) {
        return genRule(currRule, 1);
    });
    return rulesText.join("\n");
}
function genRule(prod, n) {
    var result = indent(n, "$.RULE(\"" + prod.name + "\", function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "})") + NL;
    return result;
}
function genTerminal(prod, n) {
    var name = prod.terminalType.name;
    // TODO: potential performance optimization, avoid tokenMap Dictionary access
    return indent(n, "$.CONSUME" + prod.idx + "(this.tokensMap." + name + ")" + NL);
}
function genNonTerminal(prod, n) {
    return indent(n, "$.SUBRULE" + prod.idx + "($." + prod.nonTerminalName + ")" + NL);
}
function genAlternation(prod, n) {
    var result = indent(n, "$.OR" + prod.idx + "([") + NL;
    var alts = (0, _utils.map)(prod.definition, function(altDef) {
        return genSingleAlt(altDef, n + 1);
    });
    result += alts.join("," + NL);
    result += NL + indent(n, "])" + NL);
    return result;
}
function genSingleAlt(prod, n) {
    var result = indent(n, "{") + NL;
    result += indent(n + 1, "ALT: function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "}") + NL;
    result += indent(n, "}");
    return result;
}
function genProd(prod, n) {
    /* istanbul ignore else */ if (prod instanceof (0, _gastPublic.NonTerminal)) return genNonTerminal(prod, n);
    else if (prod instanceof (0, _gastPublic.Option)) return genDSLRule("OPTION", prod, n);
    else if (prod instanceof (0, _gastPublic.RepetitionMandatory)) return genDSLRule("AT_LEAST_ONE", prod, n);
    else if (prod instanceof (0, _gastPublic.RepetitionMandatoryWithSeparator)) return genDSLRule("AT_LEAST_ONE_SEP", prod, n);
    else if (prod instanceof (0, _gastPublic.RepetitionWithSeparator)) return genDSLRule("MANY_SEP", prod, n);
    else if (prod instanceof (0, _gastPublic.Repetition)) return genDSLRule("MANY", prod, n);
    else if (prod instanceof (0, _gastPublic.Alternation)) return genAlternation(prod, n);
    else if (prod instanceof (0, _gastPublic.Terminal)) return genTerminal(prod, n);
    else if (prod instanceof (0, _gastPublic.Alternative)) return genDefinition(prod.definition, n);
    else throw Error("non exhaustive match");
}
function genDSLRule(dslName, prod, n) {
    var result = indent(n, "$." + (dslName + prod.idx) + "(");
    if (prod.separator) {
        result += "{" + NL;
        result += indent(n + 1, "SEP: this.tokensMap." + prod.separator.name) + "," + NL;
        result += "DEF: " + genDefFunction(prod.definition, n + 2) + NL;
        result += indent(n, "}") + NL;
    } else result += genDefFunction(prod.definition, n + 1);
    result += indent(n, ")") + NL;
    return result;
}
function genDefFunction(definition, n) {
    var def = "function() {" + NL;
    def += genDefinition(definition, n);
    def += indent(n, "}") + NL;
    return def;
}
function genDefinition(def, n) {
    var result = "";
    (0, _utils.forEach)(def, function(prod) {
        result += genProd(prod, n + 1);
    });
    return result;
}
function indent(howMuch, text) {
    var spaces = Array(howMuch * 4 + 1).join(" ");
    return spaces + text;
}

},{"../utils/utils":"8K9hy","../parse/grammar/gast/gast_public":"krg1C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Cgm9":[function(require,module,exports,__globalThis) {
const { CstParser, tokenMatcher } = require("904c7161c8f3122f");
const { tokensDictionary: t } = require("3a8ab981bb9d4a68");
class Parser extends CstParser {
    constructor(){
        super(t, {
            maxLookahead: 1,
            recoveryEnabled: true,
            nodeLocationTracking: "full"
        });
        this.deletionRecoveryEnabled = true;
        const $ = this;
        $.RULE("document", ()=>{
            $.OPTION(()=>{
                $.SUBRULE($.prolog);
            });
            $.MANY(()=>{
                $.SUBRULE($.misc);
            });
            $.OPTION2(()=>{
                $.SUBRULE($.docTypeDecl);
            });
            $.MANY2(()=>{
                $.SUBRULE2($.misc);
            });
            $.SUBRULE($.element);
            $.MANY3(()=>{
                $.SUBRULE3($.misc);
            });
        });
        $.RULE("prolog", ()=>{
            $.CONSUME(t.XMLDeclOpen);
            $.MANY(()=>{
                $.SUBRULE($.attribute);
            });
            $.CONSUME(t.SPECIAL_CLOSE);
        });
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        $.RULE("docTypeDecl", ()=>{
            $.CONSUME(t.DocType);
            $.CONSUME(t.Name);
            $.OPTION(()=>{
                $.SUBRULE($.externalID);
            });
            // The internal subSet part is intentionally not implemented because we do not at this
            // time wish to implement a full DTD Parser as part of this project...
            // https://www.w3.org/TR/xml/#NT-intSubset
            $.CONSUME(t.CLOSE);
        });
        $.RULE("externalID", ()=>{
            // Using gates to assert the value of the "Name" Identifiers.
            // We could use Categories to model un-reserved keywords, however I am not sure
            // The added complexity is needed at this time...
            $.OR([
                {
                    GATE: ()=>$.LA(1).image === "SYSTEM",
                    ALT: ()=>{
                        $.CONSUME2(t.Name, {
                            LABEL: "System"
                        });
                        $.CONSUME(t.STRING, {
                            LABEL: "SystemLiteral"
                        });
                    }
                },
                {
                    GATE: ()=>$.LA(1).image === "PUBLIC",
                    ALT: ()=>{
                        $.CONSUME3(t.Name, {
                            LABEL: "Public"
                        });
                        $.CONSUME2(t.STRING, {
                            LABEL: "PubIDLiteral"
                        });
                        $.CONSUME3(t.STRING, {
                            LABEL: "SystemLiteral"
                        });
                    }
                }
            ]);
        });
        $.RULE("content", ()=>{
            $.MANY(()=>{
                $.OR([
                    {
                        ALT: ()=>$.SUBRULE($.element)
                    },
                    {
                        ALT: ()=>$.SUBRULE($.chardata)
                    },
                    {
                        ALT: ()=>$.SUBRULE($.reference)
                    },
                    {
                        ALT: ()=>$.CONSUME(t.CData)
                    },
                    {
                        ALT: ()=>$.CONSUME(t.PROCESSING_INSTRUCTION)
                    },
                    {
                        ALT: ()=>$.CONSUME(t.Comment)
                    }
                ]);
            });
        });
        $.RULE("element", ()=>{
            $.CONSUME(t.OPEN);
            try {
                this.deletionRecoveryEnabled = false;
                // disabling single token deletion here
                // because `<
                //            </note>`
                // will be parsed as: `<note>`
                // and the next element will be lost
                $.CONSUME(t.Name);
            } finally{
                this.deletionRecoveryEnabled = true;
            }
            $.MANY(()=>{
                $.SUBRULE($.attribute);
            });
            $.OR([
                {
                    ALT: ()=>{
                        $.CONSUME(t.CLOSE, {
                            LABEL: "START_CLOSE"
                        });
                        $.SUBRULE($.content);
                        $.CONSUME(t.SLASH_OPEN);
                        $.CONSUME2(t.Name, {
                            LABEL: "END_NAME"
                        });
                        $.CONSUME2(t.CLOSE, {
                            LABEL: "END"
                        });
                    }
                },
                {
                    ALT: ()=>{
                        $.CONSUME(t.SLASH_CLOSE);
                    }
                }
            ]);
        });
        $.RULE("reference", ()=>{
            $.OR([
                {
                    ALT: ()=>$.CONSUME(t.EntityRef)
                },
                {
                    ALT: ()=>$.CONSUME(t.CharRef)
                }
            ]);
        });
        $.RULE("attribute", ()=>{
            $.CONSUME(t.Name);
            try {
                this.deletionRecoveryEnabled = false;
                // disabling single token deletion here
                // because `attrib1 attrib2="666`
                // will be parsed as: `attrib1="666`
                $.CONSUME(t.EQUALS);
                // disabling single token deletion here
                // to avoid new elementName being
                $.CONSUME(t.STRING);
            } finally{
                this.deletionRecoveryEnabled = true;
            }
        });
        $.RULE("chardata", ()=>{
            $.OR([
                {
                    ALT: ()=>$.CONSUME(t.TEXT)
                },
                {
                    ALT: ()=>$.CONSUME(t.SEA_WS)
                }
            ]);
        });
        $.RULE("misc", ()=>{
            $.OR([
                {
                    ALT: ()=>$.CONSUME(t.Comment)
                },
                {
                    ALT: ()=>$.CONSUME(t.PROCESSING_INSTRUCTION)
                },
                {
                    ALT: ()=>$.CONSUME(t.SEA_WS)
                }
            ]);
        });
        this.performSelfAnalysis();
    }
    canRecoverWithSingleTokenDeletion(expectedTokType) {
        if (this.deletionRecoveryEnabled === false) return false;
        return super.canRecoverWithSingleTokenDeletion(expectedTokType);
    }
    // TODO: provide this fix upstream to chevrotain
    // https://github.com/SAP/chevrotain/issues/1055
    /* istanbul ignore next - should be tested as part of Chevrotain */ findReSyncTokenType() {
        const allPossibleReSyncTokTypes = this.flattenFollowSet();
        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input
        let nextToken = this.LA(1);
        let k = 2;
        /* eslint-disable-next-line no-constant-condition -- see above comment */ while(true){
            const foundMatch = allPossibleReSyncTokTypes.find((resyncTokType)=>{
                const canMatch = tokenMatcher(nextToken, resyncTokType);
                return canMatch;
            });
            if (foundMatch !== undefined) return foundMatch;
            nextToken = this.LA(k);
            k++;
        }
    }
}
// Re-use the same parser instance
const xmlParser = new Parser();
module.exports = {
    xmlParser
};

},{"904c7161c8f3122f":"wd4P1","3a8ab981bb9d4a68":"l7JLH"}],"gcUi0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doc = require("prettier/doc");
var _embedJs = require("./embed.js");
var _embedJsDefault = parcelHelpers.interopDefault(_embedJs);
const { fill, group, hardline, indent, join, line, literalline, softline } = _doc.builders;
const ignoreStartComment = "<!-- prettier-ignore-start -->";
const ignoreEndComment = "<!-- prettier-ignore-end -->";
function hasIgnoreRanges(comments) {
    if (comments.length === 0) return false;
    comments.sort((left, right)=>left.startOffset - right.startOffset);
    let startFound = false;
    for(let idx = 0; idx < comments.length; idx += 1){
        if (comments[idx].image === ignoreStartComment) startFound = true;
        else if (startFound && comments[idx].image === ignoreEndComment) return true;
    }
    return false;
}
function isWhitespaceIgnorable(opts, name, attributes, content) {
    // If the whitespace sensitivity setting is "strict", then we can't ignore the
    // whitespace.
    if (opts.xmlWhitespaceSensitivity === "strict") return false;
    // If we have an xsl:text element, then we cannot ignore the whitespace.
    if (name === "xsl:text") return false;
    // If there is an xml:space attribute set to "preserve", then we can't ignore
    // the whitespace.
    if (attributes.some((attribute)=>attribute && attribute.Name === "xml:space" && attribute.STRING.slice(1, -1) === "preserve")) return false;
    // If there are character data nodes in the content, then we can't ignore the
    // whitespace.
    if (content.CData.length > 0) return false;
    // If there are comments in the content and the comments are ignore ranges,
    // then we can't ignore the whitespace.
    if (hasIgnoreRanges(content.Comment)) return false;
    // Otherwise we can.
    return true;
}
function printIToken(path) {
    const node = path.getValue();
    return {
        offset: node.startOffset,
        startLine: node.startLine,
        endLine: node.endLine,
        printed: node.image
    };
}
function printAttribute(path, opts, print) {
    const { Name, EQUALS, STRING } = path.getValue();
    let attributeValue;
    if (opts.xmlQuoteAttributes === "double") {
        const content = STRING.slice(1, -1).replaceAll('"', "&quot;");
        attributeValue = `"${content}"`;
    } else if (opts.xmlQuoteAttributes === "single") {
        const content = STRING.slice(1, -1).replaceAll("'", "&apos;");
        attributeValue = `'${content}'`;
    } else // preserve
    attributeValue = STRING;
    return [
        Name,
        EQUALS,
        attributeValue
    ];
}
function printCharData(path, opts, print) {
    const { SEA_WS, TEXT } = path.getValue();
    const image = SEA_WS || TEXT;
    return image.split(/(\n)/g).map((value, index)=>index % 2 === 0 ? value : literalline);
}
function printContentFragments(path, print) {
    return [
        ...path.map(printIToken, "CData"),
        ...path.map(printIToken, "Comment"),
        ...path.map((charDataPath)=>({
                offset: charDataPath.getValue().location.startOffset,
                printed: print(charDataPath)
            }), "chardata"),
        ...path.map((elementPath)=>({
                offset: elementPath.getValue().location.startOffset,
                printed: print(elementPath)
            }), "element"),
        ...path.map(printIToken, "PROCESSING_INSTRUCTION"),
        ...path.map((referencePath)=>{
            const referenceNode = referencePath.getValue();
            return {
                offset: referenceNode.location.startOffset,
                printed: print(referencePath)
            };
        }, "reference")
    ];
}
function printContent(path, opts, print) {
    let fragments = printContentFragments(path, print);
    const { Comment } = path.getValue();
    if (hasIgnoreRanges(Comment)) {
        Comment.sort((left, right)=>left.startOffset - right.startOffset);
        const ignoreRanges = [];
        let ignoreStart = null;
        // Build up a list of ignored ranges from the original text based on
        // the special prettier-ignore-* comments
        Comment.forEach((comment)=>{
            if (comment.image === ignoreStartComment) ignoreStart = comment;
            else if (ignoreStart && comment.image === ignoreEndComment) {
                ignoreRanges.push({
                    start: ignoreStart.startOffset,
                    end: comment.endOffset
                });
                ignoreStart = null;
            }
        });
        // Filter the printed children to only include the ones that are
        // outside of each of the ignored ranges
        fragments = fragments.filter((fragment)=>ignoreRanges.every(({ start, end })=>fragment.offset < start || fragment.offset > end));
        // Push each of the ignored ranges into the child list as its own
        // element so that the original content is still included
        ignoreRanges.forEach(({ start, end })=>{
            const content = opts.originalText.slice(start, end + 1);
            fragments.push({
                offset: start,
                printed: _doc.utils.replaceEndOfLine(content)
            });
        });
    }
    fragments.sort((left, right)=>left.offset - right.offset);
    return group(fragments.map(({ printed })=>printed));
}
function printDocTypeDecl(path, opts, print) {
    const { DocType, Name, externalID, CLOSE } = path.getValue();
    const parts = [
        DocType,
        " ",
        Name
    ];
    if (externalID) parts.push(" ", path.call(print, "externalID"));
    return group([
        ...parts,
        CLOSE
    ]);
}
function printDocument(path, opts, print) {
    const { docTypeDecl, element, misc, prolog } = path.getValue();
    const fragments = [];
    if (docTypeDecl) fragments.push({
        offset: docTypeDecl.location.startOffset,
        printed: path.call(print, "docTypeDecl")
    });
    if (prolog) fragments.push({
        offset: prolog.location.startOffset,
        printed: path.call(print, "prolog")
    });
    path.each((miscPath)=>{
        const misc = miscPath.getValue();
        fragments.push({
            offset: misc.location.startOffset,
            printed: print(miscPath)
        });
    }, "misc");
    if (element) fragments.push({
        offset: element.location.startOffset,
        printed: path.call(print, "element")
    });
    fragments.sort((left, right)=>left.offset - right.offset);
    return [
        join(hardline, fragments.map(({ printed })=>printed)),
        hardline
    ];
}
function printCharDataPreserve(path, print) {
    let prevLocation;
    const response = [];
    path.each((charDataPath)=>{
        const chardata = charDataPath.getValue();
        const location = chardata.location;
        const content = print(charDataPath);
        if (prevLocation && location.startColumn && prevLocation.endColumn && location.startLine === prevLocation.endLine && location.startColumn === prevLocation.endColumn + 1) {
            // continuation of previous fragment
            const prevFragment = response[response.length - 1];
            prevFragment.endLine = location.endLine;
            prevFragment.printed = group([
                prevFragment.printed,
                content
            ]);
        } else response.push({
            offset: location.startOffset,
            startLine: location.startLine,
            endLine: location.endLine,
            printed: content,
            whitespace: true
        });
        prevLocation = location;
    }, "chardata");
    return response;
}
function printCharDataIgnore(path) {
    const response = [];
    path.each((charDataPath)=>{
        const chardata = charDataPath.getValue();
        if (!chardata.TEXT) return;
        const content = chardata.TEXT.replaceAll(/^[\t\n\r\s]+|[\t\n\r\s]+$/g, "");
        const printed = group(content.split(/(\n)/g).map((value)=>{
            if (value === "\n") return literalline;
            return fill(value.split(/\b( +)\b/g).map((segment, index)=>index % 2 === 0 ? segment : line));
        }));
        const location = chardata.location;
        response.push({
            offset: location.startOffset,
            startLine: location.startLine,
            endLine: location.endLine,
            printed
        });
    }, "chardata");
    return response;
}
function printElementFragments(path, opts, print) {
    const children = path.getValue();
    let response = [];
    response = response.concat(path.map(printIToken, "Comment"));
    if (children.chardata.length > 0) {
        if (children.chardata.some((chardata)=>!!chardata.TEXT) && opts.xmlWhitespaceSensitivity === "preserve") response = response.concat(printCharDataPreserve(path, print));
        else response = response.concat(printCharDataIgnore(path, print));
    }
    response = response.concat(path.map((elementPath)=>{
        const location = elementPath.getValue().location;
        return {
            offset: location.startOffset,
            startLine: location.startLine,
            endLine: location.endLine,
            printed: print(elementPath)
        };
    }, "element"));
    response = response.concat(path.map(printIToken, "PROCESSING_INSTRUCTION"));
    response = response.concat(path.map((referencePath)=>{
        const referenceNode = referencePath.getValue();
        return {
            type: "reference",
            offset: referenceNode.location.startOffset,
            startLine: referenceNode.location.startLine,
            endLine: referenceNode.location.endLine,
            printed: print(referencePath)
        };
    }, "reference"));
    return response;
}
function printElement(path, opts, print) {
    const { OPEN, Name, attribute, START_CLOSE, content, SLASH_OPEN, END_NAME, END, SLASH_CLOSE } = path.getValue();
    const parts = [
        OPEN,
        Name
    ];
    if (attribute.length > 0) {
        const attributes = path.map((attributePath)=>({
                node: attributePath.getValue(),
                printed: print(attributePath)
            }), "attribute");
        if (opts.xmlSortAttributesByKey) attributes.sort((left, right)=>{
            const leftAttr = left.node.Name;
            const rightAttr = right.node.Name;
            // Check if the attributes are xmlns.
            if (leftAttr === "xmlns") return -1;
            if (rightAttr === "xmlns") return 1;
            // Check if they are both in namespaces.
            if (leftAttr.includes(":") && rightAttr.includes(":")) {
                const [leftNS, leftKey] = leftAttr.split(":");
                const [rightNS, rightKey] = rightAttr.split(":");
                // If namespaces are equal, compare keys
                if (leftNS === rightNS) return leftKey.localeCompare(rightKey);
                // Handle the 1 but not both being an xmlns
                if (leftNS === "xmlns") return -1;
                if (rightNS === "xmlns") return 1;
                return leftNS.localeCompare(rightNS);
            }
            // Check if the attributes have namespaces.
            if (leftAttr.includes(":")) return -1;
            if (rightAttr.includes(":")) return 1;
            return leftAttr.localeCompare(rightAttr);
        });
        const separator = opts.singleAttributePerLine ? hardline : line;
        parts.push(indent([
            line,
            join(separator, attributes.map(({ printed })=>printed))
        ]));
    }
    // Determine the value that will go between the <, name, and attributes
    // of an element and the /> of an element.
    let space;
    if (opts.bracketSameLine) space = opts.xmlSelfClosingSpace ? " " : "";
    else space = opts.xmlSelfClosingSpace ? line : softline;
    if (SLASH_CLOSE) return group([
        ...parts,
        space,
        SLASH_CLOSE
    ]);
    if (content.chardata.length === 0 && content.CData.length === 0 && content.Comment.length === 0 && content.element.length === 0 && content.PROCESSING_INSTRUCTION.length === 0 && content.reference.length === 0) return group([
        ...parts,
        space,
        "/>"
    ]);
    const openTag = group([
        ...parts,
        opts.bracketSameLine ? "" : softline,
        START_CLOSE
    ]);
    const closeTag = group([
        SLASH_OPEN,
        END_NAME,
        END
    ]);
    if (isWhitespaceIgnorable(opts, Name, attribute, content)) {
        const fragments = path.call((childrenPath)=>printElementFragments(childrenPath, opts, print), "content");
        fragments.sort((left, right)=>left.offset - right.offset);
        if (opts.xmlWhitespaceSensitivity === "preserve" && fragments.some(({ whitespace })=>whitespace)) return group([
            openTag,
            fragments.map(({ printed })=>printed),
            closeTag
        ]);
        if (fragments.length === 0) return group([
            ...parts,
            space,
            "/>"
        ]);
        // If the only content of this tag is chardata, then use a softline so
        // that we won't necessarily break (to allow <foo>bar</foo>).
        if (fragments.length === 1 && content.chardata.filter((chardata)=>chardata.TEXT).length === 1) return group([
            openTag,
            indent([
                softline,
                fragments[0].printed
            ]),
            softline,
            closeTag
        ]);
        let delimiter = hardline;
        // If the only content is both chardata and references, then use a softline
        // so that we won't necessarily break.
        if (fragments.length === content.chardata.filter((chardata)=>chardata.TEXT).length + content.reference.length) delimiter = " ";
        const docs = [
            hardline
        ];
        let lastLine = fragments[0].startLine;
        fragments.forEach((node, index)=>{
            if (index !== 0) {
                if (node.startLine - lastLine >= 2) docs.push(hardline, hardline);
                else docs.push(delimiter);
            }
            docs.push(node.printed);
            lastLine = node.endLine;
        });
        return group([
            openTag,
            indent(docs),
            hardline,
            closeTag
        ]);
    }
    return group([
        openTag,
        indent(path.call(print, "content")),
        closeTag
    ]);
}
function printExternalID(path, opts, print) {
    const { Public, PubIDLiteral, System, SystemLiteral } = path.getValue();
    if (System) return group([
        System,
        indent([
            line,
            SystemLiteral
        ])
    ]);
    return group([
        group([
            Public,
            indent([
                line,
                PubIDLiteral
            ])
        ]),
        indent([
            line,
            SystemLiteral
        ])
    ]);
}
function printMisc(path, opts, print) {
    const { Comment, PROCESSING_INSTRUCTION, SEA_WS } = path.getValue();
    return Comment || PROCESSING_INSTRUCTION || SEA_WS;
}
function printProlog(path, opts, print) {
    const { XMLDeclOpen, attribute, SPECIAL_CLOSE } = path.getValue();
    const parts = [
        XMLDeclOpen
    ];
    if (attribute) parts.push(indent([
        softline,
        join(line, path.map(print, "attribute"))
    ]));
    return group([
        ...parts,
        opts.xmlSelfClosingSpace ? line : softline,
        SPECIAL_CLOSE
    ]);
}
function printReference(path, opts, print) {
    const { CharRef, EntityRef } = path.getValue();
    return CharRef || EntityRef;
}
const printer = {
    getVisitorKeys (node, nonTraversableKeys) {
        return Object.keys(node).filter((key)=>key !== "location" && key !== "tokenType");
    },
    embed: (0, _embedJsDefault.default),
    print (path, opts, print) {
        const node = path.getValue();
        switch(node.name){
            case "attribute":
                return printAttribute(path, opts, print);
            case "chardata":
                return printCharData(path, opts, print);
            case "content":
                return printContent(path, opts, print);
            case "docTypeDecl":
                return printDocTypeDecl(path, opts, print);
            case "document":
                return printDocument(path, opts, print);
            case "element":
                return printElement(path, opts, print);
            case "externalID":
                return printExternalID(path, opts, print);
            case "misc":
                return printMisc(path, opts, print);
            case "prolog":
                return printProlog(path, opts, print);
            case "reference":
                return printReference(path, opts, print);
            default:
                throw new Error(`Unknown node type: ${node.name}`);
        }
    }
};
exports.default = printer;

},{"prettier/doc":"gXMRv","./embed.js":"9bOKq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gXMRv":[function(require,module,exports,__globalThis) {
(function(factory) {
    function interopModuleDefault() {
        var module1 = factory();
        return module1.default || module1;
    }
    var root;
    module.exports = interopModuleDefault();
})(function() {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all)=>{
        for(var name in all)__defProp(target, name, {
            get: all[name],
            enumerable: true
        });
    };
    var __copyProps = (to, from, except, desc)=>{
        if (from && typeof from === "object" || typeof from === "function") {
            for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                get: ()=>from[key],
                enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
            });
        }
        return to;
    };
    var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
            value: true
        }), mod);
    // src/document/public.js
    var public_exports = {};
    __export(public_exports, {
        builders: ()=>builders,
        printer: ()=>printer,
        utils: ()=>utils
    });
    // src/document/constants.js
    var DOC_TYPE_STRING = "string";
    var DOC_TYPE_ARRAY = "array";
    var DOC_TYPE_CURSOR = "cursor";
    var DOC_TYPE_INDENT = "indent";
    var DOC_TYPE_ALIGN = "align";
    var DOC_TYPE_TRIM = "trim";
    var DOC_TYPE_GROUP = "group";
    var DOC_TYPE_FILL = "fill";
    var DOC_TYPE_IF_BREAK = "if-break";
    var DOC_TYPE_INDENT_IF_BREAK = "indent-if-break";
    var DOC_TYPE_LINE_SUFFIX = "line-suffix";
    var DOC_TYPE_LINE_SUFFIX_BOUNDARY = "line-suffix-boundary";
    var DOC_TYPE_LINE = "line";
    var DOC_TYPE_LABEL = "label";
    var DOC_TYPE_BREAK_PARENT = "break-parent";
    var VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([
        DOC_TYPE_CURSOR,
        DOC_TYPE_INDENT,
        DOC_TYPE_ALIGN,
        DOC_TYPE_TRIM,
        DOC_TYPE_GROUP,
        DOC_TYPE_FILL,
        DOC_TYPE_IF_BREAK,
        DOC_TYPE_INDENT_IF_BREAK,
        DOC_TYPE_LINE_SUFFIX,
        DOC_TYPE_LINE_SUFFIX_BOUNDARY,
        DOC_TYPE_LINE,
        DOC_TYPE_LABEL,
        DOC_TYPE_BREAK_PARENT
    ]);
    // scripts/build/shims/at.js
    var at = (isOptionalObject, object, index)=>{
        if (isOptionalObject && (object === void 0 || object === null)) return;
        if (Array.isArray(object) || typeof object === "string") return object[index < 0 ? object.length + index : index];
        return object.at(index);
    };
    var at_default = at;
    // node_modules/trim-newlines/index.js
    function trimNewlinesEnd(string) {
        let end = string.length;
        while(end > 0 && (string[end - 1] === "\r" || string[end - 1] === "\n"))end--;
        return end < string.length ? string.slice(0, end) : string;
    }
    // src/document/utils/get-doc-type.js
    function getDocType(doc) {
        if (typeof doc === "string") return DOC_TYPE_STRING;
        if (Array.isArray(doc)) return DOC_TYPE_ARRAY;
        if (!doc) return;
        const { type } = doc;
        if (VALID_OBJECT_DOC_TYPES.has(type)) return type;
    }
    var get_doc_type_default = getDocType;
    // src/document/invalid-doc-error.js
    var disjunctionListFormat = (list)=>new Intl.ListFormat("en-US", {
            type: "disjunction"
        }).format(list);
    function getDocErrorMessage(doc) {
        const type = doc === null ? "null" : typeof doc;
        if (type !== "string" && type !== "object") return `Unexpected doc '${type}', 
Expected it to be 'string' or 'object'.`;
        if (get_doc_type_default(doc)) throw new Error("doc is valid.");
        const objectType = Object.prototype.toString.call(doc);
        if (objectType !== "[object Object]") return `Unexpected doc '${objectType}'.`;
        const EXPECTED_TYPE_VALUES = disjunctionListFormat([
            ...VALID_OBJECT_DOC_TYPES
        ].map((type2)=>`'${type2}'`));
        return `Unexpected doc.type '${doc.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
    }
    var InvalidDocError = class extends Error {
        name = "InvalidDocError";
        constructor(doc){
            super(getDocErrorMessage(doc));
            this.doc = doc;
        }
    };
    var invalid_doc_error_default = InvalidDocError;
    // src/document/utils/traverse-doc.js
    var traverseDocOnExitStackMarker = {};
    function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
        const docsStack = [
            doc
        ];
        while(docsStack.length > 0){
            const doc2 = docsStack.pop();
            if (doc2 === traverseDocOnExitStackMarker) {
                onExit(docsStack.pop());
                continue;
            }
            if (onExit) docsStack.push(doc2, traverseDocOnExitStackMarker);
            const docType = get_doc_type_default(doc2);
            if (!docType) throw new invalid_doc_error_default(doc2);
            if ((onEnter == null ? void 0 : onEnter(doc2)) === false) continue;
            switch(docType){
                case DOC_TYPE_ARRAY:
                case DOC_TYPE_FILL:
                    {
                        const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;
                        for(let ic = parts.length, i = ic - 1; i >= 0; --i)docsStack.push(parts[i]);
                        break;
                    }
                case DOC_TYPE_IF_BREAK:
                    docsStack.push(doc2.flatContents, doc2.breakContents);
                    break;
                case DOC_TYPE_GROUP:
                    if (shouldTraverseConditionalGroups && doc2.expandedStates) for(let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i)docsStack.push(doc2.expandedStates[i]);
                    else docsStack.push(doc2.contents);
                    break;
                case DOC_TYPE_ALIGN:
                case DOC_TYPE_INDENT:
                case DOC_TYPE_INDENT_IF_BREAK:
                case DOC_TYPE_LABEL:
                case DOC_TYPE_LINE_SUFFIX:
                    docsStack.push(doc2.contents);
                    break;
                case DOC_TYPE_STRING:
                case DOC_TYPE_CURSOR:
                case DOC_TYPE_TRIM:
                case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
                case DOC_TYPE_LINE:
                case DOC_TYPE_BREAK_PARENT:
                    break;
                default:
                    throw new invalid_doc_error_default(doc2);
            }
        }
    }
    var traverse_doc_default = traverseDoc;
    // src/document/utils.js
    function mapDoc(doc, cb) {
        if (typeof doc === "string") return cb(doc);
        const mapped = /* @__PURE__ */ new Map();
        return rec(doc);
        function rec(doc2) {
            if (mapped.has(doc2)) return mapped.get(doc2);
            const result = process2(doc2);
            mapped.set(doc2, result);
            return result;
        }
        function process2(doc2) {
            switch(get_doc_type_default(doc2)){
                case DOC_TYPE_ARRAY:
                    return cb(doc2.map(rec));
                case DOC_TYPE_FILL:
                    return cb({
                        ...doc2,
                        parts: doc2.parts.map(rec)
                    });
                case DOC_TYPE_IF_BREAK:
                    return cb({
                        ...doc2,
                        breakContents: rec(doc2.breakContents),
                        flatContents: rec(doc2.flatContents)
                    });
                case DOC_TYPE_GROUP:
                    {
                        let { expandedStates, contents } = doc2;
                        if (expandedStates) {
                            expandedStates = expandedStates.map(rec);
                            contents = expandedStates[0];
                        } else contents = rec(contents);
                        return cb({
                            ...doc2,
                            contents,
                            expandedStates
                        });
                    }
                case DOC_TYPE_ALIGN:
                case DOC_TYPE_INDENT:
                case DOC_TYPE_INDENT_IF_BREAK:
                case DOC_TYPE_LABEL:
                case DOC_TYPE_LINE_SUFFIX:
                    return cb({
                        ...doc2,
                        contents: rec(doc2.contents)
                    });
                case DOC_TYPE_STRING:
                case DOC_TYPE_CURSOR:
                case DOC_TYPE_TRIM:
                case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
                case DOC_TYPE_LINE:
                case DOC_TYPE_BREAK_PARENT:
                    return cb(doc2);
                default:
                    throw new invalid_doc_error_default(doc2);
            }
        }
    }
    function findInDoc(doc, fn, defaultValue) {
        let result = defaultValue;
        let shouldSkipFurtherProcessing = false;
        function findInDocOnEnterFn(doc2) {
            if (shouldSkipFurtherProcessing) return false;
            const maybeResult = fn(doc2);
            if (maybeResult !== void 0) {
                shouldSkipFurtherProcessing = true;
                result = maybeResult;
            }
        }
        traverse_doc_default(doc, findInDocOnEnterFn);
        return result;
    }
    function willBreakFn(doc) {
        if (doc.type === DOC_TYPE_GROUP && doc.break) return true;
        if (doc.type === DOC_TYPE_LINE && doc.hard) return true;
        if (doc.type === DOC_TYPE_BREAK_PARENT) return true;
    }
    function willBreak(doc) {
        return findInDoc(doc, willBreakFn, false);
    }
    function breakParentGroup(groupStack) {
        if (groupStack.length > 0) {
            const parentGroup = at_default(/* isOptionalObject */ false, groupStack, -1);
            if (!parentGroup.expandedStates && !parentGroup.break) parentGroup.break = "propagated";
        }
        return null;
    }
    function propagateBreaks(doc) {
        const alreadyVisitedSet = /* @__PURE__ */ new Set();
        const groupStack = [];
        function propagateBreaksOnEnterFn(doc2) {
            if (doc2.type === DOC_TYPE_BREAK_PARENT) breakParentGroup(groupStack);
            if (doc2.type === DOC_TYPE_GROUP) {
                groupStack.push(doc2);
                if (alreadyVisitedSet.has(doc2)) return false;
                alreadyVisitedSet.add(doc2);
            }
        }
        function propagateBreaksOnExitFn(doc2) {
            if (doc2.type === DOC_TYPE_GROUP) {
                const group2 = groupStack.pop();
                if (group2.break) breakParentGroup(groupStack);
            }
        }
        traverse_doc_default(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, /* shouldTraverseConditionalGroups */ true);
    }
    function removeLinesFn(doc) {
        if (doc.type === DOC_TYPE_LINE && !doc.hard) return doc.soft ? "" : " ";
        if (doc.type === DOC_TYPE_IF_BREAK) return doc.flatContents;
        return doc;
    }
    function removeLines(doc) {
        return mapDoc(doc, removeLinesFn);
    }
    function stripTrailingHardlineFromParts(parts) {
        parts = [
            ...parts
        ];
        while(parts.length >= 2 && at_default(/* isOptionalObject */ false, parts, -2).type === DOC_TYPE_LINE && at_default(/* isOptionalObject */ false, parts, -1).type === DOC_TYPE_BREAK_PARENT)parts.length -= 2;
        if (parts.length > 0) {
            const lastPart = stripTrailingHardlineFromDoc(at_default(/* isOptionalObject */ false, parts, -1));
            parts[parts.length - 1] = lastPart;
        }
        return parts;
    }
    function stripTrailingHardlineFromDoc(doc) {
        switch(get_doc_type_default(doc)){
            case DOC_TYPE_INDENT:
            case DOC_TYPE_INDENT_IF_BREAK:
            case DOC_TYPE_GROUP:
            case DOC_TYPE_LINE_SUFFIX:
            case DOC_TYPE_LABEL:
                {
                    const contents = stripTrailingHardlineFromDoc(doc.contents);
                    return {
                        ...doc,
                        contents
                    };
                }
            case DOC_TYPE_IF_BREAK:
                return {
                    ...doc,
                    breakContents: stripTrailingHardlineFromDoc(doc.breakContents),
                    flatContents: stripTrailingHardlineFromDoc(doc.flatContents)
                };
            case DOC_TYPE_FILL:
                return {
                    ...doc,
                    parts: stripTrailingHardlineFromParts(doc.parts)
                };
            case DOC_TYPE_ARRAY:
                return stripTrailingHardlineFromParts(doc);
            case DOC_TYPE_STRING:
                return trimNewlinesEnd(doc);
            case DOC_TYPE_ALIGN:
            case DOC_TYPE_CURSOR:
            case DOC_TYPE_TRIM:
            case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
            case DOC_TYPE_LINE:
            case DOC_TYPE_BREAK_PARENT:
                break;
            default:
                throw new invalid_doc_error_default(doc);
        }
        return doc;
    }
    function stripTrailingHardline(doc) {
        return stripTrailingHardlineFromDoc(cleanDoc(doc));
    }
    function cleanDocFn(doc) {
        switch(get_doc_type_default(doc)){
            case DOC_TYPE_FILL:
                if (doc.parts.every((part)=>part === "")) return "";
                break;
            case DOC_TYPE_GROUP:
                if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) return "";
                if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) return doc.contents;
                break;
            case DOC_TYPE_ALIGN:
            case DOC_TYPE_INDENT:
            case DOC_TYPE_INDENT_IF_BREAK:
            case DOC_TYPE_LINE_SUFFIX:
                if (!doc.contents) return "";
                break;
            case DOC_TYPE_IF_BREAK:
                if (!doc.flatContents && !doc.breakContents) return "";
                break;
            case DOC_TYPE_ARRAY:
                {
                    const parts = [];
                    for (const part of doc){
                        if (!part) continue;
                        const [currentPart, ...restParts] = Array.isArray(part) ? part : [
                            part
                        ];
                        if (typeof currentPart === "string" && typeof at_default(/* isOptionalObject */ false, parts, -1) === "string") parts[parts.length - 1] += currentPart;
                        else parts.push(currentPart);
                        parts.push(...restParts);
                    }
                    if (parts.length === 0) return "";
                    if (parts.length === 1) return parts[0];
                    return parts;
                }
            case DOC_TYPE_STRING:
            case DOC_TYPE_CURSOR:
            case DOC_TYPE_TRIM:
            case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
            case DOC_TYPE_LINE:
            case DOC_TYPE_LABEL:
            case DOC_TYPE_BREAK_PARENT:
                break;
            default:
                throw new invalid_doc_error_default(doc);
        }
        return doc;
    }
    function cleanDoc(doc) {
        return mapDoc(doc, (currentDoc)=>cleanDocFn(currentDoc));
    }
    function replaceEndOfLine(doc, replacement = literalline) {
        return mapDoc(doc, (currentDoc)=>typeof currentDoc === "string" ? join(replacement, currentDoc.split("\n")) : currentDoc);
    }
    function canBreakFn(doc) {
        if (doc.type === DOC_TYPE_LINE) return true;
    }
    function canBreak(doc) {
        return findInDoc(doc, canBreakFn, false);
    }
    // src/document/utils/assert-doc.js
    var noop = ()=>{};
    var assertDoc = noop;
    var assertDocArray = noop;
    var assertDocFillParts = noop;
    // src/document/builders.js
    function indent(contents) {
        assertDoc(contents);
        return {
            type: DOC_TYPE_INDENT,
            contents
        };
    }
    function align(widthOrString, contents) {
        assertDoc(contents);
        return {
            type: DOC_TYPE_ALIGN,
            contents,
            n: widthOrString
        };
    }
    function group(contents, opts = {}) {
        assertDoc(contents);
        assertDocArray(opts.expandedStates, /* optional */ true);
        return {
            type: DOC_TYPE_GROUP,
            id: opts.id,
            contents,
            break: Boolean(opts.shouldBreak),
            expandedStates: opts.expandedStates
        };
    }
    function dedentToRoot(contents) {
        return align(Number.NEGATIVE_INFINITY, contents);
    }
    function markAsRoot(contents) {
        return align({
            type: "root"
        }, contents);
    }
    function dedent(contents) {
        return align(-1, contents);
    }
    function conditionalGroup(states, opts) {
        return group(states[0], {
            ...opts,
            expandedStates: states
        });
    }
    function fill(parts) {
        assertDocFillParts(parts);
        return {
            type: DOC_TYPE_FILL,
            parts
        };
    }
    function ifBreak(breakContents, flatContents = "", opts = {}) {
        assertDoc(breakContents);
        if (flatContents !== "") assertDoc(flatContents);
        return {
            type: DOC_TYPE_IF_BREAK,
            breakContents,
            flatContents,
            groupId: opts.groupId
        };
    }
    function indentIfBreak(contents, opts) {
        assertDoc(contents);
        return {
            type: DOC_TYPE_INDENT_IF_BREAK,
            contents,
            groupId: opts.groupId,
            negate: opts.negate
        };
    }
    function lineSuffix(contents) {
        assertDoc(contents);
        return {
            type: DOC_TYPE_LINE_SUFFIX,
            contents
        };
    }
    var lineSuffixBoundary = {
        type: DOC_TYPE_LINE_SUFFIX_BOUNDARY
    };
    var breakParent = {
        type: DOC_TYPE_BREAK_PARENT
    };
    var trim = {
        type: DOC_TYPE_TRIM
    };
    var hardlineWithoutBreakParent = {
        type: DOC_TYPE_LINE,
        hard: true
    };
    var literallineWithoutBreakParent = {
        type: DOC_TYPE_LINE,
        hard: true,
        literal: true
    };
    var line = {
        type: DOC_TYPE_LINE
    };
    var softline = {
        type: DOC_TYPE_LINE,
        soft: true
    };
    var hardline = [
        hardlineWithoutBreakParent,
        breakParent
    ];
    var literalline = [
        literallineWithoutBreakParent,
        breakParent
    ];
    var cursor = {
        type: DOC_TYPE_CURSOR
    };
    function join(separator, docs) {
        assertDoc(separator);
        assertDocArray(docs);
        const parts = [];
        for(let i = 0; i < docs.length; i++){
            if (i !== 0) parts.push(separator);
            parts.push(docs[i]);
        }
        return parts;
    }
    function addAlignmentToDoc(doc, size, tabWidth) {
        assertDoc(doc);
        let aligned = doc;
        if (size > 0) {
            for(let i = 0; i < Math.floor(size / tabWidth); ++i)aligned = indent(aligned);
            aligned = align(size % tabWidth, aligned);
            aligned = align(Number.NEGATIVE_INFINITY, aligned);
        }
        return aligned;
    }
    function label(label2, contents) {
        assertDoc(contents);
        return label2 ? {
            type: DOC_TYPE_LABEL,
            label: label2,
            contents
        } : contents;
    }
    // scripts/build/shims/string-replace-all.js
    var stringReplaceAll = (isOptionalObject, original, pattern, replacement)=>{
        if (isOptionalObject && (original === void 0 || original === null)) return;
        if (original.replaceAll) return original.replaceAll(pattern, replacement);
        if (pattern.global) return original.replace(pattern, replacement);
        return original.split(pattern).join(replacement);
    };
    var string_replace_all_default = stringReplaceAll;
    // src/common/end-of-line.js
    function convertEndOfLineToChars(value) {
        switch(value){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    }
    // node_modules/emoji-regex/index.mjs
    var emoji_regex_default = ()=>{
        return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    // node_modules/get-east-asian-width/lookup.js
    function isFullWidth(x) {
        return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
    }
    function isWide(x) {
        return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101631 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129673 || x >= 129679 && x <= 129734 || x >= 129742 && x <= 129756 || x >= 129759 && x <= 129769 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
    }
    // node_modules/get-east-asian-width/index.js
    var _isNarrowWidth = (codePoint)=>!(isFullWidth(codePoint) || isWide(codePoint));
    // src/utils/get-string-width.js
    var notAsciiRegex = /[^\x20-\x7F]/u;
    function getStringWidth(text) {
        if (!text) return 0;
        if (!notAsciiRegex.test(text)) return text.length;
        text = text.replace(emoji_regex_default(), "  ");
        let width = 0;
        for (const character of text){
            const codePoint = character.codePointAt(0);
            if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) continue;
            if (codePoint >= 768 && codePoint <= 879) continue;
            width += _isNarrowWidth(codePoint) ? 1 : 2;
        }
        return width;
    }
    var get_string_width_default = getStringWidth;
    // src/document/printer.js
    var MODE_BREAK = Symbol("MODE_BREAK");
    var MODE_FLAT = Symbol("MODE_FLAT");
    var CURSOR_PLACEHOLDER = Symbol("cursor");
    var DOC_FILL_PRINTED_LENGTH = Symbol("DOC_FILL_PRINTED_LENGTH");
    function rootIndent() {
        return {
            value: "",
            length: 0,
            queue: []
        };
    }
    function makeIndent(ind, options) {
        return generateInd(ind, {
            type: "indent"
        }, options);
    }
    function makeAlign(indent2, widthOrDoc, options) {
        if (widthOrDoc === Number.NEGATIVE_INFINITY) return indent2.root || rootIndent();
        if (widthOrDoc < 0) return generateInd(indent2, {
            type: "dedent"
        }, options);
        if (!widthOrDoc) return indent2;
        if (widthOrDoc.type === "root") return {
            ...indent2,
            root: indent2
        };
        const alignType = typeof widthOrDoc === "string" ? "stringAlign" : "numberAlign";
        return generateInd(indent2, {
            type: alignType,
            n: widthOrDoc
        }, options);
    }
    function generateInd(ind, newPart, options) {
        const queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : [
            ...ind.queue,
            newPart
        ];
        let value = "";
        let length = 0;
        let lastTabs = 0;
        let lastSpaces = 0;
        for (const part of queue)switch(part.type){
            case "indent":
                flush();
                if (options.useTabs) addTabs(1);
                else addSpaces(options.tabWidth);
                break;
            case "stringAlign":
                flush();
                value += part.n;
                length += part.n.length;
                break;
            case "numberAlign":
                lastTabs += 1;
                lastSpaces += part.n;
                break;
            default:
                throw new Error(`Unexpected type '${part.type}'`);
        }
        flushSpaces();
        return {
            ...ind,
            value,
            length,
            queue
        };
        function addTabs(count) {
            value += "	".repeat(count);
            length += options.tabWidth * count;
        }
        function addSpaces(count) {
            value += " ".repeat(count);
            length += count;
        }
        function flush() {
            if (options.useTabs) flushTabs();
            else flushSpaces();
        }
        function flushTabs() {
            if (lastTabs > 0) addTabs(lastTabs);
            resetLast();
        }
        function flushSpaces() {
            if (lastSpaces > 0) addSpaces(lastSpaces);
            resetLast();
        }
        function resetLast() {
            lastTabs = 0;
            lastSpaces = 0;
        }
    }
    function trim2(out) {
        let trimCount = 0;
        let cursorCount = 0;
        let outIndex = out.length;
        outer: while(outIndex--){
            const last = out[outIndex];
            if (last === CURSOR_PLACEHOLDER) {
                cursorCount++;
                continue;
            }
            for(let charIndex = last.length - 1; charIndex >= 0; charIndex--){
                const char = last[charIndex];
                if (char === " " || char === "	") trimCount++;
                else {
                    out[outIndex] = last.slice(0, charIndex + 1);
                    break outer;
                }
            }
        }
        if (trimCount > 0 || cursorCount > 0) {
            out.length = outIndex + 1;
            while(cursorCount-- > 0)out.push(CURSOR_PLACEHOLDER);
        }
        return trimCount;
    }
    function fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {
        if (width === Number.POSITIVE_INFINITY) return true;
        let restIdx = restCommands.length;
        const cmds = [
            next
        ];
        const out = [];
        while(width >= 0){
            if (cmds.length === 0) {
                if (restIdx === 0) return true;
                cmds.push(restCommands[--restIdx]);
                continue;
            }
            const { mode, doc } = cmds.pop();
            const docType = get_doc_type_default(doc);
            switch(docType){
                case DOC_TYPE_STRING:
                    out.push(doc);
                    width -= get_string_width_default(doc);
                    break;
                case DOC_TYPE_ARRAY:
                case DOC_TYPE_FILL:
                    {
                        const parts = docType === DOC_TYPE_ARRAY ? doc : doc.parts;
                        const end = doc[DOC_FILL_PRINTED_LENGTH] ?? 0;
                        for(let i = parts.length - 1; i >= end; i--)cmds.push({
                            mode,
                            doc: parts[i]
                        });
                        break;
                    }
                case DOC_TYPE_INDENT:
                case DOC_TYPE_ALIGN:
                case DOC_TYPE_INDENT_IF_BREAK:
                case DOC_TYPE_LABEL:
                    cmds.push({
                        mode,
                        doc: doc.contents
                    });
                    break;
                case DOC_TYPE_TRIM:
                    width += trim2(out);
                    break;
                case DOC_TYPE_GROUP:
                    {
                        if (mustBeFlat && doc.break) return false;
                        const groupMode = doc.break ? MODE_BREAK : mode;
                        const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(/* isOptionalObject */ false, doc.expandedStates, -1) : doc.contents;
                        cmds.push({
                            mode: groupMode,
                            doc: contents
                        });
                        break;
                    }
                case DOC_TYPE_IF_BREAK:
                    {
                        const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;
                        const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;
                        if (contents) cmds.push({
                            mode,
                            doc: contents
                        });
                        break;
                    }
                case DOC_TYPE_LINE:
                    if (mode === MODE_BREAK || doc.hard) return true;
                    if (!doc.soft) {
                        out.push(" ");
                        width--;
                    }
                    break;
                case DOC_TYPE_LINE_SUFFIX:
                    hasLineSuffix = true;
                    break;
                case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
                    if (hasLineSuffix) return false;
                    break;
            }
        }
        return false;
    }
    function printDocToString(doc, options) {
        const groupModeMap = {};
        const width = options.printWidth;
        const newLine = convertEndOfLineToChars(options.endOfLine);
        let pos = 0;
        const cmds = [
            {
                ind: rootIndent(),
                mode: MODE_BREAK,
                doc
            }
        ];
        const out = [];
        let shouldRemeasure = false;
        const lineSuffix2 = [];
        let printedCursorCount = 0;
        propagateBreaks(doc);
        while(cmds.length > 0){
            const { ind, mode, doc: doc2 } = cmds.pop();
            switch(get_doc_type_default(doc2)){
                case DOC_TYPE_STRING:
                    {
                        const formatted = newLine !== "\n" ? string_replace_all_default(/* isOptionalObject */ false, doc2, "\n", newLine) : doc2;
                        out.push(formatted);
                        if (cmds.length > 0) pos += get_string_width_default(formatted);
                        break;
                    }
                case DOC_TYPE_ARRAY:
                    for(let i = doc2.length - 1; i >= 0; i--)cmds.push({
                        ind,
                        mode,
                        doc: doc2[i]
                    });
                    break;
                case DOC_TYPE_CURSOR:
                    if (printedCursorCount >= 2) throw new Error("There are too many 'cursor' in doc.");
                    out.push(CURSOR_PLACEHOLDER);
                    printedCursorCount++;
                    break;
                case DOC_TYPE_INDENT:
                    cmds.push({
                        ind: makeIndent(ind, options),
                        mode,
                        doc: doc2.contents
                    });
                    break;
                case DOC_TYPE_ALIGN:
                    cmds.push({
                        ind: makeAlign(ind, doc2.n, options),
                        mode,
                        doc: doc2.contents
                    });
                    break;
                case DOC_TYPE_TRIM:
                    pos -= trim2(out);
                    break;
                case DOC_TYPE_GROUP:
                    switch(mode){
                        case MODE_FLAT:
                            if (!shouldRemeasure) {
                                cmds.push({
                                    ind,
                                    mode: doc2.break ? MODE_BREAK : MODE_FLAT,
                                    doc: doc2.contents
                                });
                                break;
                            }
                        // fallthrough
                        case MODE_BREAK:
                            {
                                shouldRemeasure = false;
                                const next = {
                                    ind,
                                    mode: MODE_FLAT,
                                    doc: doc2.contents
                                };
                                const rem = width - pos;
                                const hasLineSuffix = lineSuffix2.length > 0;
                                if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) cmds.push(next);
                                else if (doc2.expandedStates) {
                                    const mostExpanded = at_default(/* isOptionalObject */ false, doc2.expandedStates, -1);
                                    if (doc2.break) {
                                        cmds.push({
                                            ind,
                                            mode: MODE_BREAK,
                                            doc: mostExpanded
                                        });
                                        break;
                                    } else {
                                        for(let i = 1; i < doc2.expandedStates.length + 1; i++)if (i >= doc2.expandedStates.length) {
                                            cmds.push({
                                                ind,
                                                mode: MODE_BREAK,
                                                doc: mostExpanded
                                            });
                                            break;
                                        } else {
                                            const state = doc2.expandedStates[i];
                                            const cmd = {
                                                ind,
                                                mode: MODE_FLAT,
                                                doc: state
                                            };
                                            if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {
                                                cmds.push(cmd);
                                                break;
                                            }
                                        }
                                    }
                                } else cmds.push({
                                    ind,
                                    mode: MODE_BREAK,
                                    doc: doc2.contents
                                });
                                break;
                            }
                    }
                    if (doc2.id) groupModeMap[doc2.id] = at_default(/* isOptionalObject */ false, cmds, -1).mode;
                    break;
                // Fills each line with as much code as possible before moving to a new
                // line with the same indentation.
                //
                // Expects doc.parts to be an array of alternating content and
                // whitespace. The whitespace contains the linebreaks.
                //
                // For example:
                //   ["I", line, "love", line, "monkeys"]
                // or
                //   [{ type: group, ... }, softline, { type: group, ... }]
                //
                // It uses this parts structure to handle three main layout cases:
                // * The first two content items fit on the same line without
                //   breaking
                //   -> output the first content item and the whitespace "flat".
                // * Only the first content item fits on the line without breaking
                //   -> output the first content item "flat" and the whitespace with
                //   "break".
                // * Neither content item fits on the line without breaking
                //   -> output the first content item and the whitespace with "break".
                case DOC_TYPE_FILL:
                    {
                        const rem = width - pos;
                        const offset = doc2[DOC_FILL_PRINTED_LENGTH] ?? 0;
                        const { parts } = doc2;
                        const length = parts.length - offset;
                        if (length === 0) break;
                        const content = parts[offset + 0];
                        const whitespace = parts[offset + 1];
                        const contentFlatCmd = {
                            ind,
                            mode: MODE_FLAT,
                            doc: content
                        };
                        const contentBreakCmd = {
                            ind,
                            mode: MODE_BREAK,
                            doc: content
                        };
                        const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);
                        if (length === 1) {
                            if (contentFits) cmds.push(contentFlatCmd);
                            else cmds.push(contentBreakCmd);
                            break;
                        }
                        const whitespaceFlatCmd = {
                            ind,
                            mode: MODE_FLAT,
                            doc: whitespace
                        };
                        const whitespaceBreakCmd = {
                            ind,
                            mode: MODE_BREAK,
                            doc: whitespace
                        };
                        if (length === 2) {
                            if (contentFits) cmds.push(whitespaceFlatCmd, contentFlatCmd);
                            else cmds.push(whitespaceBreakCmd, contentBreakCmd);
                            break;
                        }
                        const secondContent = parts[offset + 2];
                        const remainingCmd = {
                            ind,
                            mode,
                            doc: {
                                ...doc2,
                                [DOC_FILL_PRINTED_LENGTH]: offset + 2
                            }
                        };
                        const firstAndSecondContentFlatCmd = {
                            ind,
                            mode: MODE_FLAT,
                            doc: [
                                content,
                                whitespace,
                                secondContent
                            ]
                        };
                        const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);
                        if (firstAndSecondContentFits) cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);
                        else if (contentFits) cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);
                        else cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);
                        break;
                    }
                case DOC_TYPE_IF_BREAK:
                case DOC_TYPE_INDENT_IF_BREAK:
                    {
                        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;
                        if (groupMode === MODE_BREAK) {
                            const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);
                            if (breakContents) cmds.push({
                                ind,
                                mode,
                                doc: breakContents
                            });
                        }
                        if (groupMode === MODE_FLAT) {
                            const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;
                            if (flatContents) cmds.push({
                                ind,
                                mode,
                                doc: flatContents
                            });
                        }
                        break;
                    }
                case DOC_TYPE_LINE_SUFFIX:
                    lineSuffix2.push({
                        ind,
                        mode,
                        doc: doc2.contents
                    });
                    break;
                case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
                    if (lineSuffix2.length > 0) cmds.push({
                        ind,
                        mode,
                        doc: hardlineWithoutBreakParent
                    });
                    break;
                case DOC_TYPE_LINE:
                    switch(mode){
                        case MODE_FLAT:
                            if (!doc2.hard) {
                                if (!doc2.soft) {
                                    out.push(" ");
                                    pos += 1;
                                }
                                break;
                            } else shouldRemeasure = true;
                        // fallthrough
                        case MODE_BREAK:
                            if (lineSuffix2.length > 0) {
                                cmds.push({
                                    ind,
                                    mode,
                                    doc: doc2
                                }, ...lineSuffix2.reverse());
                                lineSuffix2.length = 0;
                                break;
                            }
                            if (doc2.literal) {
                                if (ind.root) {
                                    out.push(newLine, ind.root.value);
                                    pos = ind.root.length;
                                } else {
                                    out.push(newLine);
                                    pos = 0;
                                }
                            } else {
                                pos -= trim2(out);
                                out.push(newLine + ind.value);
                                pos = ind.length;
                            }
                            break;
                    }
                    break;
                case DOC_TYPE_LABEL:
                    cmds.push({
                        ind,
                        mode,
                        doc: doc2.contents
                    });
                    break;
                case DOC_TYPE_BREAK_PARENT:
                    break;
                default:
                    throw new invalid_doc_error_default(doc2);
            }
            if (cmds.length === 0 && lineSuffix2.length > 0) {
                cmds.push(...lineSuffix2.reverse());
                lineSuffix2.length = 0;
            }
        }
        const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);
        if (cursorPlaceholderIndex !== -1) {
            const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);
            if (otherCursorPlaceholderIndex === -1) return {
                formatted: out.filter((char)=>char !== CURSOR_PLACEHOLDER).join("")
            };
            const beforeCursor = out.slice(0, cursorPlaceholderIndex).join("");
            const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join("");
            const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
            return {
                formatted: beforeCursor + aroundCursor + afterCursor,
                cursorNodeStart: beforeCursor.length,
                cursorNodeText: aroundCursor
            };
        }
        return {
            formatted: out.join("")
        };
    }
    // src/document/public.js
    var builders = {
        join,
        line,
        softline,
        hardline,
        literalline,
        group,
        conditionalGroup,
        fill,
        lineSuffix,
        lineSuffixBoundary,
        cursor,
        breakParent,
        ifBreak,
        trim,
        indent,
        indentIfBreak,
        align,
        addAlignmentToDoc,
        markAsRoot,
        dedentToRoot,
        dedent,
        hardlineWithoutBreakParent,
        literallineWithoutBreakParent,
        label,
        // TODO: Remove this in v4
        concat: (parts)=>parts
    };
    var printer = {
        printDocToString
    };
    var utils = {
        willBreak,
        traverseDoc: traverse_doc_default,
        findInDoc,
        mapDoc,
        removeLines,
        stripTrailingHardline,
        replaceEndOfLine,
        canBreak
    };
    return __toCommonJS(public_exports);
});

},{}],"9bOKq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doc = require("prettier/doc");
const { dedentToRoot, group, hardline, indent, join, line, literalline, softline } = _doc.builders;
// Get the start and end element tags from the current node on the tree
function getElementTags(path, opts, print) {
    const node = path.getValue();
    const { OPEN, Name, attribute, START_CLOSE, SLASH_OPEN, END_NAME, END } = node;
    const parts = [
        OPEN,
        Name
    ];
    if (attribute.length > 0) parts.push(indent([
        line,
        join(line, path.map(print, "attribute"))
    ]));
    if (!opts.bracketSameLine) parts.push(softline);
    return {
        openTag: group([
            ...parts,
            START_CLOSE
        ]),
        closeTag: group([
            SLASH_OPEN,
            END_NAME,
            END
        ])
    };
}
// Returns the value of the type tag if there is one, otherwise returns null.
function getTagType(attributes) {
    for (const attribute of attributes)if (attribute.Name === "type") {
        const value = attribute.STRING;
        if (value.startsWith('"text/') && value.endsWith('"')) return value.slice(6, -1);
    }
    return null;
}
// Get the name of the parser that is represented by the given element node,
// return null if a matching parser cannot be found
function getParser(node, opts) {
    const { Name, attribute } = node;
    let parser = Name.toLowerCase();
    // We don't want to deal with some weird recursive parser situation, so we
    // need to explicitly call out the XML parser here and just return null
    if (parser === "xml") return null;
    // If this is a style tag or a script tag with a text/xxx type then we will
    // use xxx as the name of the parser
    if ((parser === "style" || parser === "script") && attribute.length > 0) parser = getTagType(attribute);
    // If the name of the parser is "javascript", then we're going to switch over
    // to the babel parser.
    if (parser === "javascript") parser = "babel";
    // If there is a plugin that has a parser that matches the name of this
    // element, then we're going to assume that's correct for embedding and go
    // ahead and switch to that parser
    if (opts.plugins.some((plugin)=>typeof plugin !== "string" && plugin.parsers && Object.prototype.hasOwnProperty.call(plugin.parsers, parser))) return parser;
    return null;
}
// Get the source string that will be passed into the embedded parser from the
// content of the inside of the element node
function getSource(content) {
    return content.chardata.map((node)=>{
        const { SEA_WS, TEXT } = node;
        const image = SEA_WS || TEXT;
        return {
            offset: node.location.startOffset,
            printed: image
        };
    }).sort(({ offset })=>offset).map(({ printed })=>printed).join("");
}
function embed(path, opts) {
    const node = path.getValue();
    // If the node isn't an element node, then skip
    if (node.name !== "element") return;
    // If the name of the node does not correspond to the name of a parser that
    // prettier knows about, then skip
    const parser = getParser(node, opts);
    if (!parser) return;
    // If the node is self-closing, then skip
    if (!node.content) return;
    // If the node does not actually contain content, or it contains any content
    // that is not just plain text, then skip.
    const content = node.content;
    if (content.chardata.length === 0 || content.CData.length > 0 || content.Comment.length > 0 || content.element.length > 0 || content.PROCESSING_INSTRUCTION.length > 0 || content.reference.length > 0) return;
    return async function(textToDoc, print) {
        // Get the open and close tags of this element, then return the properly
        // formatted content enclosed within them
        const { openTag, closeTag } = getElementTags(path, opts, print);
        const docNode = await textToDoc(getSource(content), {
            parser
        });
        return group([
            openTag,
            literalline,
            dedentToRoot(_doc.utils.replaceEndOfLine(docNode)),
            hardline,
            closeTag
        ]);
    };
}
exports.default = embed;

},{"prettier/doc":"gXMRv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i9Wnp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "currentSaveVersion", ()=>currentSaveVersion);
parcelHelpers.export(exports, "emtpySaveState", ()=>emtpySaveState);
/**
 * Controller for saving and loading the progress in json format
 */ parcelHelpers.export(exports, "SaveController", ()=>SaveController);
var _bootstrap = require("bootstrap");
var _internal = require("../internal");
var _packageJson = require("../../../package.json");
let currentSaveVersion = "0.1";
let emtpySaveState = {
    version: currentSaveVersion,
    components: []
};
class SaveController {
    static _instance;
    static get instance() {
        if (!SaveController._instance) SaveController._instance = new SaveController();
        return SaveController._instance;
    }
    loadModal;
    modalElement;
    loadInput;
    loadMessage;
    loadButton;
    loadArea;
    loadAreaBackground;
    currentlyLoadedSaveVersion = currentSaveVersion;
    constructor(){
        this.modalElement = document.getElementById("loadModal");
        this.loadModal = new (0, _bootstrap.Modal)(this.modalElement);
        this.loadInput = document.getElementById("file-input");
        this.loadMessage = document.getElementById("load-message");
        this.loadButton = document.getElementById("loadJSONButton");
        this.loadArea = document.getElementById("dragdroparea");
        this.loadAreaBackground = document.getElementById("dragdropbackground");
        const opacity0 = ()=>{
            this.loadAreaBackground.style.opacity = "0";
        };
        this.loadArea.addEventListener("dragenter", (ev)=>{
            this.loadAreaBackground.style.opacity = "0.3";
        });
        this.loadArea.addEventListener("dragleave", opacity0);
        this.loadArea.addEventListener("drop", opacity0);
    }
    save() {
        let componentArray = [];
        for (const component of (0, _internal.MainController).instance.circuitComponents)componentArray.push(component.toJson());
        let data = {
            version: currentSaveVersion,
            components: componentArray
        };
        (0, _internal.ExportController).instance.exportJSON(JSON.stringify(data, null, 4));
    }
    load() {
        //open modal for file selection
        this.loadModal.show();
        const changeText = (()=>{
            let file = this.loadInput.files[0];
            if (file) this.loadMessage.textContent = this.loadInput.value.split("\\").pop();
            else this.loadMessage.textContent = "No file selected";
        }).bind(this);
        const loadFile = (()=>{
            let file = this.loadInput.files[0];
            if (file) {
                var reader = new FileReader();
                reader.readAsText(file, "UTF-8");
                reader.onload = (evt)=>{
                    let inputstring = evt.target.result instanceof ArrayBuffer ? "" : evt.target.result;
                    const input = JSON.parse(inputstring);
                    if (!("version" in input)) alert("You are using an old version of the json save file format. Please override all files exported from Circuitikz Designer version 0.6 and older by reexporting your circuit to json to update them to the newest json save file format version (currently: " + currentSaveVersion + " for Circuitikz Designer version " + (0, _packageJson.version) + "). Old versions might be deprecated at any time and therefore might not properly load.");
                    this.loadFromJSON(input, true);
                    this.loadModal.hide();
                };
                reader.onerror = (evt)=>{
                    this.loadMessage.textContent = "error reading file";
                };
            }
        }).bind(this);
        this.loadInput.addEventListener("change", changeText);
        this.loadButton.addEventListener("click", loadFile);
        const hideListener = (()=>{
            this.loadInput.removeEventListener("change", changeText);
            this.loadButton.removeEventListener("click", loadFile);
            // "once" is not always supported:
            this.modalElement.removeEventListener("hidden.bs.modal", hideListener);
        }).bind(this);
        this.modalElement.addEventListener("hidden.bs.modal", hideListener, {
            passive: true,
            once: true
        });
    }
    loadFromJSON(saveFile, selectComponents = false) {
        //delete current state if necessary
        if (document.getElementById("loadCheckRemove").checked) {
            (0, _internal.SelectionController).instance.selectAll();
            (0, _internal.SelectionController).instance.removeSelection();
        }
        let components = [];
        if (!("version" in saveFile)) {
            // old file format
            this.currentlyLoadedSaveVersion = "";
            //@ts-ignore
            for (const component of saveFile){
                let c = SaveController.fromJson(component);
                if (c) components.push(c);
            }
        } else {
            this.currentlyLoadedSaveVersion = saveFile.version;
            for (const component of saveFile.components){
                let c = SaveController.fromJson(component);
                if (c) components.push(c);
            }
        }
        if (selectComponents) {
            (0, _internal.SelectionController).instance.deactivateSelection();
            (0, _internal.SelectionController).instance.activateSelection();
            (0, _internal.SelectionController).instance.selectComponents(components, (0, _internal.SelectionMode).RESET);
        }
        (0, _internal.Undo).addState();
        this.currentlyLoadedSaveVersion = currentSaveVersion;
    }
    static fromJson(saveJson) {
        return (0, _internal.CircuitComponent).fromJson(saveJson);
    }
}

},{"bootstrap":"hjCRY","../internal":"f6vBb","../../../package.json":"c3hj5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eSfs2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SelectionMode", ()=>SelectionMode);
parcelHelpers.export(exports, "AlignmentMode", ()=>AlignmentMode);
parcelHelpers.export(exports, "DistributionMode", ()=>DistributionMode);
/**
 * Controller holding selection information and handling selecting/deselecting
 * @class
 */ parcelHelpers.export(exports, "SelectionController", ()=>SelectionController);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var SelectionMode;
(function(SelectionMode) {
    SelectionMode[SelectionMode["RESET"] = 0] = "RESET";
    SelectionMode[SelectionMode["ADD"] = 1] = "ADD";
    SelectionMode[SelectionMode["SUB"] = 2] = "SUB";
})(SelectionMode || (SelectionMode = {}));
var AlignmentMode;
(function(AlignmentMode) {
    AlignmentMode[AlignmentMode["START"] = -1] = "START";
    AlignmentMode[AlignmentMode["CENTER"] = 0] = "CENTER";
    AlignmentMode[AlignmentMode["END"] = 1] = "END";
})(AlignmentMode || (AlignmentMode = {}));
var DistributionMode;
(function(DistributionMode) {
    DistributionMode[DistributionMode["CENTER"] = 0] = "CENTER";
    DistributionMode[DistributionMode["SPACE"] = 1] = "SPACE";
})(DistributionMode || (DistributionMode = {}));
class SelectionController {
    static _instance;
    selectionMode;
    selectionStartPosition;
    selectionRectangle;
    currentlyDragging;
    currentlySelectedComponents = [];
    selectionEnabled;
    referenceComponent;
    constructor(){
        this.selectionStartPosition = new _svgJs.Point();
        this.selectionRectangle = (0, _internal.CanvasController).instance.canvas.rect(0, 0).move(0, 0);
        this.selectionRectangle.stroke({
            width: 0.5,
            color: (0, _internal.defaultStroke)
        }).fill("none").id("selectionRectangle");
        this.selectionRectangle.addClass("pointerNone");
        this.selectionEnabled = true;
        this.currentlyDragging = false;
        this.selectionMode = SelectionMode.RESET;
        this.selectionStart = this.selectionStart.bind(this);
        this.selectionMove = this.selectionMove.bind(this);
        this.selectionEnd = this.selectionEnd.bind(this);
        (0, _internal.CanvasController).instance.canvas.on("mousedown", this.selectionStart);
        (0, _internal.CanvasController).instance.canvas.on("touchstart", this.selectionStart);
        (0, _internal.CanvasController).instance.canvas.on("mousemove", this.selectionMove);
        (0, _internal.CanvasController).instance.canvas.on("touchmove", this.selectionMove);
        (0, _internal.CanvasController).instance.canvas.on("mouseup", this.selectionEnd);
        (0, _internal.CanvasController).instance.canvas.on("touchend", this.selectionEnd);
    }
    selectionStart(evt) {
        if (!this.selectionEnabled || this.currentlyDragging) return;
        if (evt instanceof MouseEvent && evt.button !== 0) return;
        evt.preventDefault();
        let shift = evt.shiftKey; //||evt.detail.shiftKey
        let ctrl = evt.ctrlKey || (0, _internal.MainController).instance.isMac && evt.metaKey || (0, _internal.MainController).instance.isMac && evt.metaKey;
        if (shift) {
            if (ctrl) this.selectionMode = SelectionMode.RESET;
            else this.selectionMode = SelectionMode.ADD;
        } else if (ctrl) this.selectionMode = SelectionMode.SUB;
        else this.selectionMode = SelectionMode.RESET;
        this.currentlyDragging = true;
        this.selectionStartPosition = (0, _internal.CanvasController).eventToPoint(evt, false);
        (0, _internal.CanvasController).instance.canvas.put(this.selectionRectangle); // bring to front
        this.selectionRectangle.move(this.selectionStartPosition.x, this.selectionStartPosition.y);
    }
    selectionMove(evt) {
        if (!this.selectionEnabled || !this.currentlyDragging) return;
        if (evt instanceof MouseEvent && evt.button !== 0) return;
        if (window.TouchEvent && evt instanceof TouchEvent && evt.touches.length > 1) {
            this.currentlyDragging = false;
            this.selectionRectangle.size(0, 0).move(0, 0);
            this.viewSelection(true);
            return;
        }
        let pt = (0, _internal.CanvasController).eventToPoint(evt, false);
        let dx = pt.x - this.selectionStartPosition.x;
        let dy = pt.y - this.selectionStartPosition.y;
        let moveX = this.selectionStartPosition.x;
        let moveY = this.selectionStartPosition.y;
        if (dx < 0) {
            moveX += dx;
            dx = -dx;
        }
        if (dy < 0) {
            moveY += dy;
            dy = -dy;
        }
        this.selectionRectangle.move(moveX, moveY);
        this.selectionRectangle.attr("width", dx);
        this.selectionRectangle.attr("height", dy);
        this.previewSelection();
    }
    selectionEnd(evt) {
        if ((0, _internal.CanvasController).instance.draggingFromInput) {
            evt.preventDefault();
            (0, _internal.CanvasController).instance.draggingFromInput.focus();
            return;
        }
        if (!this.selectionEnabled) return;
        if (evt instanceof MouseEvent && evt.button !== 0) return;
        if (window.TouchEvent && evt instanceof TouchEvent && evt.touches.length > 0) return;
        if (this.currentlyDragging) {
            this.updateSelectionWithRectangle();
            this.currentlyDragging = false;
            this.selectionRectangle.size(0, 0);
        }
        let pt = (0, _internal.CanvasController).eventToPoint(evt, false);
        if (pt.x == this.selectionStartPosition.x && pt.y == this.selectionStartPosition.y) {
            // clicked on canvas
            this.selectionRectangle.move(pt.x, pt.y).size(0, 0);
            this.updateSelectionWithRectangle();
        }
        (0, _internal.PropertyController).instance.update();
    }
    static get instance() {
        if (!SelectionController._instance) SelectionController._instance = new SelectionController();
        return SelectionController._instance;
    }
    updateSelectionWithRectangle() {
        let selectionBox = this.selectionRectangle.bbox();
        let components = (0, _internal.MainController).instance.circuitComponents.filter((comp)=>comp.isInsideSelectionRectangle(selectionBox));
        this.selectComponents(components, this.selectionMode);
    }
    previewSelection() {
        let selectionBox = this.selectionRectangle.bbox();
        if (this.selectionMode == SelectionMode.RESET) for (const component of (0, _internal.MainController).instance.circuitComponents)component.viewSelected(component.isInsideSelectionRectangle(selectionBox));
        else if (this.selectionMode == SelectionMode.ADD) for (const component of (0, _internal.MainController).instance.circuitComponents)component.viewSelected(component.isSelected || component.isInsideSelectionRectangle(selectionBox));
        else if (this.selectionMode == SelectionMode.SUB) for (const component of (0, _internal.MainController).instance.circuitComponents)component.viewSelected(component.isSelected && !component.isInsideSelectionRectangle(selectionBox));
    }
    activateSelection() {
        this.selectionEnabled = true;
        for (const component of (0, _internal.MainController).instance.circuitComponents)component.draggable(true);
    }
    deactivateSelection() {
        this.selectionEnabled = false;
        this.selectionRectangle.attr("width", 0);
        this.selectionRectangle.attr("height", 0);
        this.selectionMode = SelectionMode.RESET;
        for (const component of (0, _internal.MainController).instance.circuitComponents){
            component.isSelected = false;
            component.isHovered = false;
            component.viewSelected(false);
            component.draggable(false);
        }
    }
    viewSelection(show = true) {
        for (const component of (0, _internal.MainController).instance.circuitComponents)component.viewSelected(show && component.isSelected);
    }
    selectComponents(components, mode) {
        if (mode == SelectionMode.RESET) {
            for (const component of (0, _internal.MainController).instance.circuitComponents)component.isSelected = false;
            for (const component of components)component.isSelected = true;
        } else if (mode == SelectionMode.ADD) for (const component of components)component.isSelected = true;
        else if (mode == SelectionMode.SUB) for (const component of components)component.isSelected = false;
        this.currentlySelectedComponents.splice(0);
        this.currentlySelectedComponents.push(...(0, _internal.MainController).instance.circuitComponents.filter((comp)=>comp.isSelected));
        this.viewSelection();
        (0, _internal.PropertyController).instance.update();
    }
    selectAll() {
        this.currentlySelectedComponents.splice(0);
        this.currentlySelectedComponents.push(...(0, _internal.MainController).instance.circuitComponents);
        for (const component of (0, _internal.MainController).instance.circuitComponents)component.isSelected = true;
        this.viewSelection();
        (0, _internal.PropertyController).instance.update();
    }
    getOverallBoundingBox() {
        let bbox = null;
        for (const component of this.currentlySelectedComponents)if (component.isSelected) {
            if (bbox == null) bbox = component.bbox;
            else bbox = bbox.merge(component.bbox);
        }
        return bbox;
    }
    /**
     *
     * @param {Number} angleDeg rotation in degrees (only 90 degree multiples, also negative)
     */ rotateSelection(angleDeg) {
        //get overall center
        if (!this.hasSelection()) return;
        let overallBBox = this.getOverallBoundingBox();
        let overallCenter = new _svgJs.Point(overallBBox.cx, overallBBox.cy);
        //rotate all components/lines individually around their center
        //get individual center and rotate that around overall center
        //move individual components/lines to new rotated center
        for (const component of this.currentlySelectedComponents){
            component.rotate(angleDeg);
            let move = component.position.rotate(angleDeg, overallCenter, false);
            component.moveTo(move);
            component.recalculateSnappingPoints();
        }
    }
    /**
     *
     * @param {boolean} horizontal if flipping horizontally or vertically
     */ flipSelection(horizontal) {
        //get overall center
        if (!this.hasSelection()) return;
        let overallBBox = this.getOverallBoundingBox();
        let overallCenter = new _svgJs.Point(overallBBox.cx, overallBBox.cy);
        let flipX = horizontal ? 0 : -2;
        let flipY = horizontal ? -2 : 0;
        //flip all components/lines individually at their center
        //get individual center and flip that at overall center
        //move individual components/lines to new flipped center
        for (const component of this.currentlySelectedComponents){
            let diffToCenter = component.position.sub(overallCenter);
            component.flip(horizontal);
            component.moveRel(new _svgJs.Point(diffToCenter.x * flipX, diffToCenter.y * flipY));
        }
    }
    /**
     * move the selection by delta
     * @param {SVG.Point} delta the amount to move the selection by
     */ moveSelectionRel(delta) {
        for (const element of this.currentlySelectedComponents)element.moveRel(delta);
    }
    /**
     * move the center of the selection to the new position
     * @param position the new position
     */ moveSelectionTo(position) {
        let overallBBox = this.getOverallBoundingBox();
        let overallCenter = new _svgJs.Point(overallBBox.cx, overallBBox.cy);
        this.moveSelectionRel(position.sub(overallCenter));
    }
    removeSelection() {
        for (const component of this.currentlySelectedComponents)(0, _internal.MainController).instance.removeComponent(component);
        this.currentlySelectedComponents = [];
        (0, _internal.PropertyController).instance.update();
    }
    /**
     * checks if anything is selected
     */ hasSelection() {
        return this.currentlySelectedComponents.length > 0;
    }
    setReference(component) {
        if (component == this.referenceComponent) {
            component.isSelected = false;
            component.isSelected = true;
            component.viewSelected(true);
        } else {
            component.setAsSelectionReference();
            this.referenceComponent = component;
        }
    }
    alignSelection(mode, horizontal) {
        let selectionBBox = this.getOverallBoundingBox();
        let selectionCenter = new _svgJs.Point(selectionBBox.cx, selectionBBox.cy);
        let halfSelectionSize = new _svgJs.Point(selectionBBox.w / 2, selectionBBox.h / 2);
        let direction = horizontal ? new _svgJs.Point(1, 0) : new _svgJs.Point(0, 1);
        let referencePosition;
        if (this.referenceComponent) {
            let elementBBox = this.referenceComponent.bbox;
            let elementHalfSize = new _svgJs.Point(elementBBox.w / 2, elementBBox.h / 2);
            referencePosition = new _svgJs.Point(elementBBox.cx, elementBBox.cy).add(elementHalfSize.mul(direction).mul(mode));
        } else referencePosition = selectionCenter.add(halfSelectionSize.mul(direction).mul(mode));
        for (const element of this.currentlySelectedComponents){
            let elementBBox = element.bbox;
            let elementHalfSize = new _svgJs.Point(elementBBox.w / 2, elementBBox.h / 2);
            let elementReferencePoint = new _svgJs.Point(elementBBox.cx, elementBBox.cy).add(elementHalfSize.mul(direction).mul(mode));
            let delta = referencePosition.sub(elementReferencePoint).mul(direction);
            element.moveRel(delta);
        }
        (0, _internal.Undo).addState();
    }
    distributeSelection(mode, horizontal) {
        if (this.currentlySelectedComponents.length < 2) return;
        let direction = horizontal ? new _svgJs.Point(1, 0) : new _svgJs.Point(0, 1);
        let refPos;
        let bboxes = this.currentlySelectedComponents.map((c)=>{
            let bbox = c.bbox;
            if (c == this.referenceComponent) refPos = c.position;
            return {
                box: bbox,
                component: c
            };
        });
        bboxes.sort((a, b)=>{
            let diff = new _svgJs.Point(a.box.cx - b.box.cx, a.box.cy - b.box.cy);
            return horizontal ? diff.x : diff.y;
        });
        let shouldUndo = false;
        let zeroVector = new _svgJs.Point();
        if (mode == DistributionMode.CENTER) {
            let totalSpace = new _svgJs.Point(bboxes.at(-1).box.cx - bboxes[0].box.cx, bboxes.at(-1).box.cy - bboxes[0].box.cy);
            const start = new _svgJs.Point(bboxes[0].box.cx, bboxes[0].box.cy);
            const increment = totalSpace.div(this.currentlySelectedComponents.length - 1);
            for(let index = 1; index < bboxes.length - 1; index++){
                const bbox = bboxes[index];
                const newPosDiff = start.add(increment.mul(index)).sub(new _svgJs.Point(bbox.box.cx, bbox.box.cy)).mul(direction);
                if (!shouldUndo && !newPosDiff.eq(zeroVector)) shouldUndo = true;
                bbox.component.moveRel(newPosDiff);
            }
        } else {
            let selectionBBox = this.getOverallBoundingBox();
            let availableSpacing = new _svgJs.Point(selectionBBox.w, selectionBBox.h);
            bboxes.forEach((value)=>{
                availableSpacing.x -= value.box.w;
                availableSpacing.y -= value.box.h;
            });
            availableSpacing.x = availableSpacing.x < 0 ? 0 : availableSpacing.x;
            availableSpacing.y = availableSpacing.y < 0 ? 0 : availableSpacing.y;
            availableSpacing = availableSpacing.div(this.currentlySelectedComponents.length - 1);
            let lastPos = new _svgJs.Point(bboxes[0].box.x2, bboxes[0].box.y2);
            for(let index = 1; index < bboxes.length; index++){
                const bbox = bboxes[index];
                lastPos = lastPos.add(availableSpacing).add(new _svgJs.Point(bbox.box.w, bbox.box.h));
                const newPosDiff = lastPos.sub(new _svgJs.Point(bbox.box.x2, bbox.box.y2)).mul(direction);
                if (!shouldUndo && !newPosDiff.eq(zeroVector)) shouldUndo = true;
                bbox.component.moveRel(newPosDiff);
            }
        }
        if (refPos) {
            let refResetDiff = refPos.sub(this.referenceComponent.position);
            for (const element of this.currentlySelectedComponents)element.moveRel(refResetDiff);
            if (!shouldUndo && !refResetDiff.eq(zeroVector)) shouldUndo = true;
        }
        if (shouldUndo) (0, _internal.Undo).addState();
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"az8F5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Class handling undo and redo via save states
 * @class
 */ parcelHelpers.export(exports, "Undo", ()=>Undo);
var _internal = require("../internal");
class Undo {
    static states = [];
    static currentIndex = -1;
    //TODO discuss if selections should be remembered or not???
    static addState() {
        // get json object
        let currentState = [];
        for (const component of (0, _internal.MainController).instance.circuitComponents){
            let componentObject = component.toJson();
            componentObject.selected = component.isSelected;
            currentState.push(componentObject);
        }
        let shouldAddState = true;
        if (Undo.states.length > 0) {
            let compareState = Undo.states.at(Undo.currentIndex);
            if (JSON.stringify(compareState) == JSON.stringify(currentState)) // This and the last state are identical -> no new state
            // sometimes needed for more complicated scenarios
            shouldAddState = false;
        }
        // push state on stack
        if (shouldAddState) {
            Undo.states = Undo.states.slice(0, Undo.currentIndex + 1);
            Undo.states.push(currentState);
            Undo.currentIndex = Undo.states.length - 1;
        }
    }
    static getCurrentState() {
        return Undo.states[Undo.currentIndex];
    }
    static undo() {
        Undo.currentIndex -= 1;
        if (Undo.currentIndex < 0) {
            Undo.currentIndex = 0;
            return;
        }
        Undo.loadState();
    }
    static redo() {
        Undo.currentIndex += 1;
        if (Undo.currentIndex >= Undo.states.length) {
            Undo.currentIndex = Undo.states.length - 1;
            return;
        }
        Undo.loadState();
    }
    static loadState() {
        // remove all components
        while((0, _internal.MainController).instance.circuitComponents.length > 0)(0, _internal.MainController).instance.removeComponent((0, _internal.MainController).instance.circuitComponents[0]);
        // load state
        let state = Undo.states[Undo.currentIndex];
        let components = [];
        for (const component of state){
            let initalializedComponenent = (0, _internal.SaveController).fromJson(component);
            if (component.selected && initalializedComponenent) components.push(initalializedComponenent);
        }
        if (components.length > 0) (0, _internal.SelectionController).instance.selectComponents(components, (0, _internal.SelectionMode).RESET);
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jV7zX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Class handling copy, paste and cut
 * @class
 */ parcelHelpers.export(exports, "CopyPaste", ()=>CopyPaste);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
class CopyPaste {
    static clipboard = null;
    static copy() {
        if ((0, _internal.SelectionController).instance.hasSelection()) {
            let components = [];
            for (const component of (0, _internal.SelectionController).instance.currentlySelectedComponents){
                let componentObject = component.toJson();
                if ("name" in componentObject) componentObject.name = "";
                components.push(componentObject);
            }
            let bbox = (0, _internal.SelectionController).instance.getOverallBoundingBox();
            CopyPaste.clipboard = {
                components: components,
                selectionPos: new (0, _svgJs.Point)(bbox.cx, bbox.cy)
            };
            (0, _internal.MainController).instance.sendBroadcastMessage("clipboard", CopyPaste.clipboard);
        }
    }
    static setClipboard(clipboard) {
        this.clipboard = clipboard;
    }
    static paste() {
        if (CopyPaste.clipboard && Object.keys(CopyPaste.clipboard).length === 0) return;
        if (!CopyPaste.clipboard) return;
        (0, _internal.SelectionController).instance.deactivateSelection();
        (0, _internal.SelectionController).instance.activateSelection();
        let allComponents = [];
        for (const component of CopyPaste.clipboard.components)allComponents.push((0, _internal.SaveController).fromJson(component));
        if (allComponents.length > 0) (0, _internal.SelectionController).instance.selectComponents(allComponents, (0, _internal.SelectionMode).RESET);
        (0, _internal.SelectionController).instance.moveSelectionTo(new (0, _svgJs.Point)(CopyPaste.clipboard.selectionPos).add(new (0, _svgJs.Point)(20, 20)));
        (0, _internal.Undo).addState();
    }
    static cut() {
        if ((0, _internal.SelectionController).instance.hasSelection()) {
            CopyPaste.copy();
            for (const component of (0, _internal.SelectionController).instance.currentlySelectedComponents)(0, _internal.MainController).instance.removeComponent(component);
            (0, _internal.Undo).addState();
        }
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6pbkP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertyCategories", ()=>PropertyCategories);
parcelHelpers.export(exports, "PropertiesCollection", ()=>PropertiesCollection);
parcelHelpers.export(exports, "PropertyController", ()=>PropertyController);
var _internal = require("../internal");
var PropertyCategories;
(function(PropertyCategories) {
    PropertyCategories[PropertyCategories["manipulation"] = 0] = "manipulation";
    PropertyCategories[PropertyCategories["ordering"] = 1] = "ordering";
    PropertyCategories[PropertyCategories["options"] = 2] = "options";
    PropertyCategories[PropertyCategories["fill"] = 3] = "fill";
    PropertyCategories[PropertyCategories["stroke"] = 4] = "stroke";
    PropertyCategories[PropertyCategories["label"] = 5] = "label";
    PropertyCategories[PropertyCategories["voltage"] = 6] = "voltage";
    PropertyCategories[PropertyCategories["current"] = 7] = "current";
    PropertyCategories[PropertyCategories["text"] = 8] = "text";
    PropertyCategories[PropertyCategories["info"] = 9] = "info";
})(PropertyCategories || (PropertyCategories = {}));
class PropertiesCollection extends Map {
    add(category, property) {
        if (this.has(category)) this.get(category).push(property);
        else this.set(category, [
            property
        ]);
    }
    sorted() {
        let properties = [];
        let key = Object.keys(PropertyCategories)[0];
        PropertyCategories[key];
        for(const element in PropertyCategories)if (isNaN(Number(element))) {
            //@ts-ignore
            let category = PropertyCategories[element];
            if (this.has(category)) properties.push(...this.get(category));
        }
        return properties;
    }
}
class PropertyController {
    static _instance;
    static get instance() {
        if (!PropertyController._instance) PropertyController._instance = new PropertyController();
        return PropertyController._instance;
    }
    viewProperties;
    propertiesEntries;
    propertiesTitle;
    multies = [];
    constructor(){
        this.propertiesTitle = document.getElementById("propertiesTitle");
        this.viewProperties = document.getElementById("view-properties");
        this.viewProperties.firstElementChild.prepend((0, _internal.MainController).instance.designName.getHTMLElement());
        this.propertiesEntries = document.getElementById("propertiesEntries");
        document.getElementById("resetViewButton").addEventListener("click", (ev)=>{
            (0, _internal.CanvasController).instance.resetView();
        });
        document.getElementById("fitViewButton").addEventListener("click", (ev)=>{
            (0, _internal.CanvasController).instance.fitView();
        });
    }
    update() {
        let components = (0, _internal.SelectionController).instance.currentlySelectedComponents;
        this.clearForm();
        if (components.length > 1) this.setMultiForm(components);
        else if (components.length === 1) this.setForm(components[0]);
        else this.setFormView();
        (0, _internal.MainController).instance.updateTooltips();
    }
    setMultiForm(components) {
        this.propertiesEntries.classList.remove("d-none");
        this.propertiesTitle.innerText = "Selection";
        let rows = [];
        let positioning = new (0, _internal.ButtonGridProperty)(2, [
            [
                "Rotate 90\xb0 CW",
                "rotate_right"
            ],
            [
                "Rotate 90\xb0 CCW",
                "rotate_left"
            ],
            [
                "Rotate 45\xb0 CW",
                "rotate_right"
            ],
            [
                "Rotate 45\xb0 CCW",
                "rotate_left"
            ],
            [
                "Flip vertically",
                [
                    "flip",
                    "rotateText"
                ]
            ],
            [
                "Flip horizontally",
                "flip"
            ]
        ], [
            (ev)=>{
                (0, _internal.SelectionController).instance.rotateSelection(-90);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                (0, _internal.SelectionController).instance.rotateSelection(90);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                (0, _internal.SelectionController).instance.rotateSelection(-45);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                (0, _internal.SelectionController).instance.rotateSelection(45);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                (0, _internal.SelectionController).instance.flipSelection(true);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                (0, _internal.SelectionController).instance.flipSelection(false);
                (0, _internal.Undo).addState();
            }
        ], false, [
            "Rotate the components 90 degrees clockwise",
            "Rotate the components 90 degrees counter clockwise",
            "Rotate the components 45 degrees clockwise",
            "Rotate the components 45 degrees counter clockwise",
            "Flip the components around its x-axis",
            "Flip the components around its y-axis"
        ]);
        rows.push(positioning.buildHTML());
        rows.push(new (0, _internal.SectionHeaderProperty)("Ordering").buildHTML());
        let ordering = new (0, _internal.ButtonGridProperty)(2, [
            [
                "Foreground",
                ""
            ],
            [
                "Background",
                ""
            ],
            [
                "Forward",
                ""
            ],
            [
                "Backward",
                ""
            ]
        ], [
            (ev)=>(0, _internal.CanvasController).instance.componentsToForeground((0, _internal.SelectionController).instance.currentlySelectedComponents),
            (ev)=>(0, _internal.CanvasController).instance.componentsToBackground((0, _internal.SelectionController).instance.currentlySelectedComponents),
            (ev)=>(0, _internal.CanvasController).instance.moveComponentsForward((0, _internal.SelectionController).instance.currentlySelectedComponents),
            (ev)=>(0, _internal.CanvasController).instance.moveComponentsBackward((0, _internal.SelectionController).instance.currentlySelectedComponents)
        ], false, [
            "Bring the components to the foreground",
            "Move the components to the background",
            "Move the components one step towards the foreground",
            "Move the components one step towards the background"
        ]);
        rows.push(ordering.buildHTML());
        rows.push(new (0, _internal.SectionHeaderProperty)("Grouping").buildHTML());
        let grouping = new (0, _internal.ButtonGridProperty)(1, [
            [
                "Group",
                ""
            ]
        ], [
            (ev)=>(0, _internal.GroupComponent).group((0, _internal.SelectionController).instance.currentlySelectedComponents)
        ]);
        rows.push(grouping.buildHTML());
        rows.push(new (0, _internal.SectionHeaderProperty)("Align").buildHTML());
        let alignment = new (0, _internal.ButtonGridProperty)(3, [
            [
                "",
                "align_horizontal_left"
            ],
            [
                "",
                "align_horizontal_center"
            ],
            [
                "",
                "align_horizontal_right"
            ],
            [
                "",
                "align_vertical_top"
            ],
            [
                "",
                "align_vertical_center"
            ],
            [
                "",
                "align_vertical_bottom"
            ]
        ], [
            (ev)=>(0, _internal.SelectionController).instance.alignSelection((0, _internal.AlignmentMode).START, true),
            (ev)=>(0, _internal.SelectionController).instance.alignSelection((0, _internal.AlignmentMode).CENTER, true),
            (ev)=>(0, _internal.SelectionController).instance.alignSelection((0, _internal.AlignmentMode).END, true),
            (ev)=>(0, _internal.SelectionController).instance.alignSelection((0, _internal.AlignmentMode).START, false),
            (ev)=>(0, _internal.SelectionController).instance.alignSelection((0, _internal.AlignmentMode).CENTER, false),
            (ev)=>(0, _internal.SelectionController).instance.alignSelection((0, _internal.AlignmentMode).END, false)
        ]);
        rows.push(alignment.buildHTML());
        rows.push(new (0, _internal.SectionHeaderProperty)("Distribute").buildHTML());
        let distribute = new (0, _internal.ButtonGridProperty)(2, [
            [
                "Center",
                "horizontal_distribute"
            ],
            [
                "Spacing",
                "align_justify_space_even"
            ],
            [
                "Center",
                "vertical_distribute"
            ],
            [
                "Spacing",
                "align_space_even"
            ]
        ], [
            (ev)=>(0, _internal.SelectionController).instance.distributeSelection((0, _internal.DistributionMode).CENTER, true),
            (ev)=>(0, _internal.SelectionController).instance.distributeSelection((0, _internal.DistributionMode).SPACE, true),
            (ev)=>(0, _internal.SelectionController).instance.distributeSelection((0, _internal.DistributionMode).CENTER, false),
            (ev)=>(0, _internal.SelectionController).instance.distributeSelection((0, _internal.DistributionMode).SPACE, false)
        ]);
        rows.push(distribute.buildHTML());
        this.propertiesEntries.append(...rows);
        const overlappingProperties = new PropertiesCollection();
        this.multies = [];
        let key = Object.keys(PropertyCategories)[0];
        PropertyCategories[key];
        // repeat overlap detection for all possible categories
        for(const element in PropertyCategories){
            if (!isNaN(Number(element))) continue;
            //@ts-ignore
            let category = PropertyCategories[element];
            const categoryMap = new Map();
            // in each category, loop over all components
            for (const component of components){
                const properties = component.properties.get(category);
                if (properties == undefined) continue;
                // keep track of all properties of a given id
                for (const property of properties){
                    if (property.id == "") continue;
                    if (categoryMap.has(property.id)) categoryMap.get(property.id).push(property);
                    else categoryMap.set(property.id, [
                        property
                    ]);
                }
            }
            const relevantProperties = [];
            // remove all properties, which are not present in every component, otherwise add properties
            for (const id of categoryMap.keys()){
                const properties = categoryMap.get(id);
                if (properties.length < components.length) categoryMap.set(id, []);
                else {
                    // get the multi edit version and save for housekeeping
                    const multi = properties[0].getMultiEditVersion(properties);
                    this.multies.push(multi);
                    relevantProperties.push(multi);
                }
            }
            overlappingProperties.set(category, relevantProperties);
        }
        this.propertiesEntries.append(...overlappingProperties.sorted().map((property)=>property.getHTMLElement()));
    }
    setForm(component) {
        this.propertiesEntries.classList.remove("d-none");
        this.propertiesTitle.innerText = component.displayName;
        this.propertiesEntries.append(...component.properties.sorted().map((property)=>property.getHTMLElement()));
    }
    setFormView() {
        this.viewProperties.classList.remove("d-none");
        this.propertiesTitle.innerText = "General settings";
        let minorSlider = document.getElementById("minorSliderInput");
        minorSlider.value = (0, _internal.CanvasController).instance.majorGridSubdivisions.toString();
        let majorSlider = document.getElementById("majorSliderInput");
        majorSlider.value = (0, _internal.CanvasController).instance.majorGridSizecm.toString();
        minorSlider.addEventListener("input", (ev)=>{
            this.changeGrid((0, _internal.CanvasController).instance.majorGridSizecm, Number.parseFloat(minorSlider.value));
        });
        majorSlider.addEventListener("input", (ev)=>{
            this.changeGrid(Number.parseFloat(majorSlider.value), (0, _internal.CanvasController).instance.majorGridSubdivisions);
        });
        this.changeGrid((0, _internal.CanvasController).instance.majorGridSizecm, (0, _internal.CanvasController).instance.majorGridSubdivisions);
    }
    setSliderValues(majorSizecm, majorSubdivisions) {
        let minorSlider = document.getElementById("minorSliderInput");
        minorSlider.value = majorSubdivisions.toString();
        let majorSlider = document.getElementById("majorSliderInput");
        majorSlider.value = majorSizecm.toString();
        this.changeGrid(majorSizecm, majorSubdivisions);
    }
    changeGrid(majorSizecm, majorSubdivisions) {
        (0, _internal.CanvasController).instance.changeGrid(majorSizecm, majorSubdivisions);
        let majorLabel = document.getElementById("majorLabel");
        majorLabel.innerText = majorSizecm + " cm";
        let minorLabel = document.getElementById("minorLabel");
        minorLabel.innerText = majorSubdivisions.toString();
        let gridInfo = document.getElementById("gridInfo");
        gridInfo.innerText = (majorSizecm / majorSubdivisions).toLocaleString(undefined, {
            maximumFractionDigits: 2
        }) + " cm";
    }
    clearForm() {
        for (const element of this.multies)element.remove();
        this.propertiesTitle.innerText = "Properties";
        this.viewProperties.classList.add("d-none");
        this.propertiesEntries.classList.add("d-none");
        this.propertiesEntries.innerText = "";
        while(this.propertiesEntries.lastElementChild)this.propertiesEntries.removeChild(this.propertiesEntries.lastElementChild);
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hk88F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EditableProperty", ()=>EditableProperty);
var _internal = require("../internal");
class EditableProperty {
    tooltip;
    element;
    _disabled;
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this.getHTMLElement(); // build component if not already done, otherwise disabling might not work sometimes
        this._disabled = value;
        this.disable(value);
    }
    _id;
    get id() {
        return this._id;
    }
    _value;
    get value() {
        return this._value;
    }
    set value(newVal) {
        this._value = newVal;
        if (!this.element) this.element = this.buildHTML();
        this.updateHTML();
    }
    changeListeners;
    constructor(initialValue, tooltip = "", id = ""){
        // make sure to be in drag_pan mode when changing any value
        this.changeListeners = [
            (ev)=>{
                (0, _internal.MainController).instance.switchMode((0, _internal.Modes).DRAG_PAN);
            }
        ];
        if (initialValue !== undefined) this._value = initialValue;
        this._id = id;
        this.tooltip = tooltip;
    }
    equivalent(properties) {
        if (properties.length < 2) return true;
        const first = properties[0];
        for (const property of properties.slice(1)){
            if (!this.eq(first.value, property.value)) return false;
        }
        return true;
    }
    getHTMLElement() {
        if (!this.element) {
            this.element = this.buildHTML();
            if (this.tooltip && this.element) {
                this.element.setAttribute("data-bs-title", this.tooltip);
                this.element.setAttribute("data-bs-toggle", "tooltip");
            }
        }
        return this.element;
    }
    removeHTMLElement() {
        if (this.element) {
            this.element.remove();
            this.element = null;
        }
    }
    getRow() {
        let row = document.createElement("div");
        row.classList.add("row", "g-2", "my-2");
        return row;
    }
    addChangeListener(changeListener) {
        this.changeListeners.push(changeListener);
    }
    removeChangeListener(changeListener) {
        let idx = this.changeListeners.findIndex((val)=>val == changeListener);
        if (idx >= 0) {
            this.changeListeners.splice(idx, 1);
            return true;
        }
        return false;
    }
    updateValue(newVal, updateHTML = false, notifyEventListeners = true) {
        if (this.eq(newVal, this.value)) return;
        let lastValue = this.value;
        this._value = newVal;
        let changeEvent = {
            previousValue: lastValue,
            value: this._value
        };
        if (updateHTML) {
            if (!this.element) this.element = this.buildHTML();
            this.updateHTML();
        }
        if (notifyEventListeners) for (const element of this.changeListeners)element(changeEvent);
    }
    remove() {
        for (const changeListener of this.changeListeners)this.removeChangeListener(changeListener);
        this.element?.remove();
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gAKSE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BooleanProperty", ()=>BooleanProperty);
var _internal = require("../internal");
class BooleanProperty extends (0, _internal.EditableProperty) {
    checkBox;
    label;
    constructor(label, initialValue, tooltip = "", id = ""){
        super(initialValue, tooltip, id);
        this.label = label;
    }
    eq(first, second) {
        if (first == null || second == null) return false;
        return first == second;
    }
    buildHTML() {
        let row = this.getRow();
        let col = document.createElement("div");
        col.classList.add("col-12", "input-group", "my-0");
        {
            let labelElement = document.createElement("label");
            labelElement.classList.add("input-group-text", "flex-grow-1");
            labelElement.innerHTML = this.label || "CheckBox";
            col.appendChild(labelElement);
            let checkBoxContainer = document.createElement("div");
            checkBoxContainer.classList.add("input-group-text", "form-switch");
            this.checkBox = document.createElement("input");
            this.checkBox.classList.add("form-check-input", "m-0");
            this.checkBox.setAttribute("type", "checkbox");
            this.checkBox.setAttribute("role", "switch");
            if (this.value != null) this.checkBox.checked = this.value;
            else this.checkBox.indeterminate = true;
            this.checkBox.addEventListener("change", (ev)=>{
                this.updateValue(this.checkBox.checked);
                (0, _internal.Undo).addState();
            });
            checkBoxContainer.appendChild(this.checkBox);
            col.appendChild(checkBoxContainer);
        }
        row.appendChild(col);
        return row;
    }
    disable(disabled = true) {
        this.checkBox.disabled = disabled;
    }
    updateHTML() {
        if (this.checkBox) this.checkBox.checked = this.value;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const result = new BooleanProperty(this.label, allEqual ? this.value : null, this.tooltip, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eDwSi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChoiceProperty", ()=>ChoiceProperty);
var _internal = require("../internal");
const indeterminateChoice = {
    key: "undetermined",
    name: "choose one"
};
class ChoiceProperty extends (0, _internal.EditableProperty) {
    label;
    selectElement;
    choiceOptions;
    get entries() {
        return this.choiceOptions;
    }
    constructor(label, choiceOptions, initialValue, tooltip = "", id = ""){
        super(initialValue, tooltip, id);
        this.label = label;
        this.choiceOptions = choiceOptions;
    }
    eq(first, second) {
        return first.key == second.key;
    }
    buildHTML() {
        let row = this.getRow();
        let col = document.createElement("div");
        col.classList.add("col-12", "input-group", "my-0");
        {
            let anchorLabel = document.createElement("label");
            anchorLabel.classList.add("input-group-text");
            anchorLabel.innerHTML = this.label;
            col.appendChild(anchorLabel);
            this.selectElement = document.createElement("select");
            this.selectElement.classList.add("form-select");
            this.selectElement.name = "anchor";
            for(let index = 0; index < this.choiceOptions.length; index++){
                const labelKey = this.choiceOptions[index].key;
                const labelName = this.choiceOptions[index].name;
                let optionElement = document.createElement("option");
                optionElement.value = labelKey;
                optionElement.innerHTML = labelName;
                optionElement.selected = this.value ? labelKey == this.value.key : false;
                this.selectElement.appendChild(optionElement);
            }
            this.selectElement.addEventListener("change", (ev)=>{
                this.updateValue(this.choiceOptions.find((el)=>el.key == this.selectElement.value));
                (0, _internal.Undo).addState();
            });
            col.appendChild(this.selectElement);
        }
        row.appendChild(col);
        return row;
    }
    disable(disabled = true) {
        this.selectElement.disabled = disabled;
    }
    updateHTML() {
        if (this.selectElement) for (const optionElement of this.selectElement.children)optionElement.selected = optionElement.value == this.value.key;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const options = allEqual ? [
            indeterminateChoice
        ] : [];
        options.push(...this.choiceOptions);
        const result = new ChoiceProperty(this.label, this.choiceOptions, allEqual ? properties[0].value : indeterminateChoice, this.tooltip, this.id);
        let removedUndeterminedChoice = false;
        result.addChangeListener((ev)=>{
            if (!removedUndeterminedChoice && ev.previousValue.key == "undetermined") {
                removedUndeterminedChoice = true;
                this.selectElement.removeChild(this.selectElement.firstChild);
            }
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bp8yV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextProperty", ()=>TextProperty);
var _internal = require("../internal");
class TextProperty extends (0, _internal.EditableProperty) {
    input;
    invalidDiv;
    label;
    validator = (value)=>"";
    constructor(label, initalValue, tooltip = "", validator = (value)=>"", id = ""){
        super(initalValue, tooltip, id);
        this.label = label;
        this.validator = validator;
    }
    buildHTML() {
        let row = this.getRow();
        let inputDiv = document.createElement("div");
        inputDiv.classList.add("col", "col-md-12", "my-0", "input-group", "has-validation");
        {
            let labelSpan = document.createElement("span");
            labelSpan.classList.add("input-group-text");
            labelSpan.innerHTML = this.label ?? "";
            inputDiv.appendChild(labelSpan);
            this.input = document.createElement("input");
            this.input.classList.add("form-control");
            this.input.setAttribute("type", "text");
            this.input.value = this.value ?? "";
            inputDiv.appendChild(this.input);
            this.invalidDiv = document.createElement("div");
            this.invalidDiv.classList.add("col-12", "invalid-feedback", "d-none");
            inputDiv.appendChild(this.invalidDiv);
        }
        row.appendChild(inputDiv);
        this.input.addEventListener("mousedown", (ev)=>{
            (0, _internal.CanvasController).instance.draggingFromInput = this.input;
        });
        let previousState = "";
        this.input.addEventListener("focusin", (ev)=>{
            previousState = this.value ?? "";
        });
        this.input.addEventListener("input", (ev)=>{
            let validationText = this.validator(this.input.value);
            this.changeInvalidStatus(validationText);
            if (validationText == "") this.updateValue(this.input.value);
        });
        this.input.addEventListener("focusout", (ev)=>{
            //first set what you see to the last known value, which should always be a valid value
            this.updateHTML();
            this.changeInvalidStatus("");
            if (this.value && previousState !== this.value) (0, _internal.Undo).addState();
        });
        return row;
    }
    disable(disabled = true) {
        this.input.disabled = disabled;
    }
    changeInvalidStatus(msg) {
        if (this.invalidDiv) {
            if (msg === "") {
                this.input.classList.remove("is-invalid");
                this.invalidDiv.classList.add("d-none");
                this.invalidDiv.innerHTML = "";
            } else {
                this.input.classList.add("is-invalid");
                this.input.classList.add("is-invalid");
                this.invalidDiv.classList.remove("d-none");
                this.invalidDiv.innerHTML = "Invalid! " + msg;
            }
        }
    }
    updateHTML() {
        if (this.input) this.input.value = this.value;
    }
    eq(first, second) {
        return first == second;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const result = new TextProperty(this.label, allEqual ? this.value : "*", this.tooltip, this.validator, this.id);
        result.addChangeListener((ev)=>{
            let invalid = false;
            for (const property of properties){
                property.updateValue(ev.value, true, true);
                if (!invalid && property.validator(ev.value) != "") invalid = true;
            }
            if (invalid) result.changeInvalidStatus("Multi-edit with invalid values! Adjust individual component fields.");
        });
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9NuDL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextAreaProperty", ()=>TextAreaProperty);
var _internal = require("../internal");
class TextAreaProperty extends (0, _internal.EditableProperty) {
    input;
    constructor(initalValue, tooltip = "", id = ""){
        super(initalValue, tooltip, id);
    }
    buildHTML() {
        let rowTextArea = this.getRow();
        let inputDiv = document.createElement("div");
        inputDiv.classList.add("col-12", "mt-0");
        this.input = document.createElement("textArea");
        this.input.classList.add("form-control");
        this.input.value = this.value ?? "";
        this.input.placeholder = "text component";
        inputDiv.appendChild(this.input);
        rowTextArea.appendChild(inputDiv);
        let previousState;
        this.input.addEventListener("focusin", (ev)=>{
            previousState = this.value;
        });
        this.input.addEventListener("input", (ev)=>{
            this.updateValue(this.input.value);
        });
        this.input.addEventListener("focusout", (ev)=>{
            if (this.value && previousState !== this.value) (0, _internal.Undo).addState();
        });
        this.input.addEventListener("mousedown", (ev)=>{
            (0, _internal.CanvasController).instance.draggingFromInput = this.input;
        });
        return rowTextArea;
    }
    disable(disabled = true) {
        this.input.disabled = disabled;
    }
    updateHTML() {
        if (this.input) this.input.value = this.value;
    }
    eq(first, second) {
        return first == second;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const result = new TextAreaProperty(allEqual ? this.value : "*", this.tooltip, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9lB9j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InfoProperty", ()=>InfoProperty);
var _internal = require("../internal");
class InfoProperty extends (0, _internal.EditableProperty) {
    valueElement;
    labelElement;
    labelString;
    constructor(label, initalValue, tooltip = "", id = ""){
        super(initalValue, tooltip, id);
        this.labelString = label;
    }
    buildHTML() {
        let row = document.createElement("div");
        row.classList.add("row", "mx-0", "my-2", "border", "border-info-subtle", "bg-info-subtle", "text-info-emphasis", "rounded");
        this.labelElement = document.createElement("span");
        this.labelElement.classList.add("text-start", "col-auto", "me-3");
        this.labelElement.innerHTML = this.labelString || "Label";
        row.appendChild(this.labelElement);
        this.valueElement = document.createElement("span");
        this.valueElement.classList.add("text-end", "col");
        this.valueElement.innerHTML = this.value || "";
        row.appendChild(this.valueElement);
        return row;
    }
    disable(disabled) {}
    eq(first, second) {
        return first == second;
    }
    updateHTML() {
        if (this.valueElement) this.valueElement.innerHTML = this.value ?? "";
    }
    getMultiEditVersion(properties) {
        const result = new InfoProperty(this.labelString, properties[0].value, this.tooltip, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"113v3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ButtonGridProperty", ()=>ButtonGridProperty);
var _internal = require("../internal");
class ButtonGridProperty extends (0, _internal.EditableProperty) {
    buttonsPerRow;
    labels;
    callbacks;
    materialSymbols;
    tooltips;
    buttons;
    constructor(buttonsPerRow, labels, callbacks, materialSymbols = false, tooltips = [], id = ""){
        super(undefined, "", id);
        if (labels.length !== callbacks.length) throw new Error("every button has to have a callback and a label");
        this.buttonsPerRow = buttonsPerRow;
        this.labels = labels;
        this.callbacks = callbacks;
        this.materialSymbols = materialSymbols;
        this.tooltips = tooltips;
        this.buttons = [];
    }
    eq(first, second) {
        return false;
    }
    buildHTML() {
        let row = this.getRow();
        for(let index = 0; index < this.labels.length; index++){
            const label = this.labels[index];
            const callback = this.callbacks[index];
            let col = document.createElement("div");
            col.classList.add("col-" + Math.round(12 / this.buttonsPerRow).toFixed(0));
            let button = document.createElement("button");
            button.classList.add("w-100", "btn", "btn-primary", "d-flex", "align-items-center", "justify-content-center", "gap-1");
            if (this.tooltips[index]) {
                button.setAttribute("data-bs-title", this.tooltips[index]);
                button.setAttribute("data-bs-toggle", "tooltip");
            }
            if (this.materialSymbols) button.classList.add("material-symbols-outlined");
            let labelSymbol = typeof label[1] == "string" ? label[1] : label[1][0];
            let labelSymbolClasses;
            if (typeof label[1] == "string") {
                labelSymbol = label[1];
                labelSymbolClasses = [];
            } else {
                labelSymbol = label[1][0];
                labelSymbolClasses = label[1][1].split(",");
            }
            if (labelSymbol) {
                let spanMat = document.createElement("span");
                if (labelSymbolClasses.length > 0) spanMat.classList.add("material-symbols-outlined", ...labelSymbolClasses);
                else spanMat.classList.add("material-symbols-outlined");
                spanMat.innerHTML = labelSymbol;
                button.appendChild(spanMat);
            }
            if (label[0]) {
                let spanMat = document.createElement("span");
                spanMat.innerHTML = label[0];
                button.appendChild(spanMat);
            }
            button.addEventListener("click", callback);
            this.buttons.push(button);
            col.appendChild(button);
            row.appendChild(col);
        }
        return row;
    }
    disable(disabled = true) {
        this.buttons.forEach((button)=>button.disabled = disabled);
    }
    updateHTML() {}
    getMultiEditVersion(properties) {
        const result = new ButtonGridProperty(this.buttonsPerRow, this.labels, this.callbacks, this.materialSymbols, this.tooltips, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"53K7Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MathJaxProperty", ()=>MathJaxProperty);
var _internal = require("../internal");
class MathJaxProperty extends (0, _internal.EditableProperty) {
    input;
    constructor(initialValue, tooltip = "", id = ""){
        super(initialValue ?? "", tooltip, id);
    }
    eq(first, second) {
        return first == second;
    }
    buildHTML() {
        let row = this.getRow();
        let col = document.createElement("div");
        col.classList.add("col", "col-md-12", "col-xxl", "my-0", "input-group");
        {
            let formulaSpan1 = document.createElement("span");
            formulaSpan1.classList.add("input-group-text");
            formulaSpan1.innerHTML = "$";
            col.appendChild(formulaSpan1);
            this.input = document.createElement("input");
            this.input.classList.add("form-control");
            this.input.type = "text";
            this.input.value = this.value ?? "";
            col.appendChild(this.input);
            let formulaSpan2 = document.createElement("div");
            formulaSpan2.classList.add("input-group-text");
            formulaSpan2.innerHTML = "$";
            col.appendChild(formulaSpan2);
            let previousState = "";
            this.input.addEventListener("focusin", (ev)=>{
                previousState = this.value ?? "";
            });
            this.input.addEventListener("input", (ev)=>{
                this.updateValue(this.input.value);
            });
            this.input.addEventListener("focusout", (ev)=>{
                if (this.value && previousState !== this.value) (0, _internal.Undo).addState();
            });
            this.input.addEventListener("mousedown", (ev)=>{
                (0, _internal.CanvasController).instance.draggingFromInput = this.input;
            });
        }
        row.appendChild(col);
        return row;
    }
    disable(disabled = true) {
        this.input.disabled = disabled;
    }
    updateHTML() {
        if (this.input) this.input.value = this.value;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const result = new MathJaxProperty(allEqual ? properties[0].value : "*", this.tooltip, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kPoUl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SliderProperty", ()=>SliderProperty);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
class SliderProperty extends (0, _internal.EditableProperty) {
    eq(first, second) {
        if (first == null || second == null) return false;
        return first.eq(second);
    }
    min;
    max;
    step;
    label;
    sliderInput;
    numberInput;
    unitLabel;
    fractionDigits;
    integerDigits;
    restrictToRange;
    constructor(label, min, max, step, initalValue, restrictToRange = false, tooltip = "", id = ""){
        super(initalValue, tooltip, id);
        this.label = label;
        this.min = min;
        this.max = max;
        this.step = step;
        this.restrictToRange = restrictToRange;
        if (step > 0) {
            this.fractionDigits = 0;
            let stepTemp = step;
            while(stepTemp < 1){
                stepTemp *= 10;
                this.fractionDigits += 1;
            }
        }
        this.integerDigits = 1;
        let maxDigits = Math.max(Math.abs(min), Math.abs(max));
        while(maxDigits > 1){
            this.integerDigits += 1;
            maxDigits /= 10;
        }
    }
    buildHTML() {
        let row = this.getRow();
        let col = document.createElement("div");
        col.classList.add("col-12", "my-0", "input-group");
        let distanceLabel = document.createElement("label");
        distanceLabel.classList.add("input-group-text", "fs-6");
        distanceLabel.innerHTML = this.label;
        distanceLabel.setAttribute("for", "labelDistanceSlider");
        col.appendChild(distanceLabel);
        this.sliderInput = document.createElement("input");
        this.sliderInput.classList.add("form-range", "w-25", "flex-grow-1", "h-100", "px-2", "border");
        this.sliderInput.id = "labelDistanceSlider";
        this.sliderInput.type = "range";
        this.sliderInput.min = this.min.toString();
        this.sliderInput.max = this.max.toString();
        this.sliderInput.step = this.step.toString();
        this.sliderInput.value = !Number.isNaN(this.value.value) ? this.value.value.toString() : ((this.max - this.min) / 2).toString();
        col.appendChild(this.sliderInput);
        this.numberInput = document.createElement("input");
        this.numberInput.classList.add("form-control", "fs-6");
        this.numberInput.type = "number";
        this.numberInput.value = !Number.isNaN(this.value.value) ? this.value.value.toString() : "*";
        this.numberInput.min = this.min.toString();
        this.numberInput.max = this.max.toString();
        this.numberInput.step = this.step.toString();
        col.appendChild(this.numberInput);
        let sliderChanged = ()=>{
            this.updateValue(new _svgJs.Number(Number.parseFloat(this.sliderInput.value), this.value.unit));
            this.updateNumberInput();
        };
        let numberChanged = ()=>{
            let newValue = Number.parseFloat(this.numberInput.value);
            if (!isNaN(newValue)) {
                if (this.restrictToRange) {
                    newValue = newValue < this.min ? this.min : newValue;
                    newValue = newValue > this.max ? this.max : newValue;
                }
                this.updateValue(new _svgJs.Number(newValue, this.value.unit));
                this.updateSliderInput();
            }
        };
        this.numberInput.addEventListener("input", numberChanged);
        this.numberInput.addEventListener("focusout", ()=>{
            this.updateNumberInput();
            (0, _internal.Undo).addState();
        });
        this.numberInput.addEventListener("mousedown", (ev)=>{
            (0, _internal.CanvasController).instance.draggingFromInput = this.numberInput;
        });
        this.sliderInput.addEventListener("input", sliderChanged);
        this.sliderInput.addEventListener("change", ()=>{
            (0, _internal.Undo).addState();
        });
        if (this.value.unit) {
            this.unitLabel = distanceLabel.cloneNode(true);
            this.unitLabel.innerText = this.value.unit;
            col.appendChild(this.unitLabel);
        }
        this.updateNumberInput();
        this.updateSliderInput();
        row.appendChild(col);
        return row;
    }
    disable(disabled = true) {
        this.sliderInput.disabled = disabled;
        this.numberInput.disabled = disabled;
    }
    updateNumberInput() {
        this.numberInput.value = !Number.isNaN(this.value.value) ? this.value.value.toString() : "*";
        if (this.unitLabel) this.unitLabel.innerText = !Number.isNaN(this.value.value) ? this.value.unit : "";
    }
    updateSliderInput() {
        this.sliderInput.value = !Number.isNaN(this.value.value) ? this.value.value.toString() : "*";
        if (this.unitLabel) this.unitLabel.innerText = !Number.isNaN(this.value.value) ? this.value.unit : "";
    }
    updateHTML() {
        if (this.sliderInput) {
            this.updateSliderInput();
            this.updateNumberInput();
        }
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const first = properties[0];
        const result = new SliderProperty(this.label, this.min, this.max, this.step, allEqual ? properties[0].value : new _svgJs.Number(NaN, first.value.unit), this.restrictToRange, this.tooltip, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fBkJN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SectionHeaderProperty", ()=>SectionHeaderProperty);
var _internal = require("../internal");
class SectionHeaderProperty extends (0, _internal.EditableProperty) {
    labelElement;
    eq(first, second) {
        return first == second;
    }
    buildHTML() {
        this.labelElement = document.createElement("span");
        this.labelElement.classList.add("col-12", "form-label", "mb-0", "fw-bold");
        this.labelElement.innerHTML = this.value ?? "";
        let row = this.getRow();
        row.appendChild(this.labelElement);
        return row;
    }
    disable(disabled) {}
    updateHTML() {
        if (this.labelElement) this.labelElement.innerHTML = this.value;
    }
    getMultiEditVersion(properties) {
        const result = new SectionHeaderProperty(properties[0].value, this.tooltip, this.id);
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"72Y1w":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ColorProperty", ()=>ColorProperty);
var _svgJs = require("@svgdotjs/svg.js");
var _editableProperty = require("./editableProperty");
var _internal = require("../internal");
class ColorProperty extends (0, _editableProperty.EditableProperty) {
    label;
    input;
    nullable;
    enabler;
    constructor(label, initialValue, nullable = true, tooltip = "", id = ""){
        super(initialValue, tooltip, id);
        this.label = label;
        this.nullable = nullable;
    }
    eq(first, second) {
        if (first == null && second == null || first === second) return true;
        if (first == null || second == null) return false;
        let f = first.rgb();
        let s = second.rgb();
        return f.r == s.r && f.g == s.g && f.b == s.b;
    }
    buildHTML() {
        let row = this.getRow();
        let col = document.createElement("div");
        col.classList.add("col-12", "input-group", "my-0");
        {
            let labelElement = document.createElement("label");
            labelElement.classList.add("input-group-text");
            labelElement.innerHTML = this.label || "Choose color";
            col.appendChild(labelElement);
            if (this.nullable) {
                let enablerDiv = document.createElement("div");
                enablerDiv.classList.add("input-group-text");
                this.enabler = document.createElement("input");
                this.enabler.classList.add("form-check-input", "mt-0");
                this.enabler.type = "checkbox";
                this.enabler.checked = this.value !== null;
                this.enabler.addEventListener("change", (ev)=>{
                    this.updateValue(this.enabler.checked ? new _svgJs.Color(this.input.value, "rgb") : null);
                    (0, _internal.Undo).addState();
                });
                enablerDiv.appendChild(this.enabler);
                col.appendChild(enablerDiv);
            }
            this.input = document.createElement("input");
            this.input.classList.add("form-control", "form-control-color");
            this.input.value = this.value ? this.value.toString() : "";
            this.input.setAttribute("type", "color");
            this.input.addEventListener("input", (ev)=>{
                if (this.nullable) this.updateValue(this.enabler.checked ? new _svgJs.Color(this.input.value, "rgb") : null);
                else this.updateValue(new _svgJs.Color(this.input.value, "rgb"));
            });
            this.input.addEventListener("change", (ev)=>{
                (0, _internal.Undo).addState();
            });
            col.appendChild(this.input);
        }
        row.appendChild(col);
        return row;
    }
    disable(disabled = true) {
        this.input.disabled = disabled;
        this.enabler.disabled = disabled;
    }
    updateHTML() {
        if (this.value) this.input.value = this.value.toString();
        if (this.enabler) this.enabler.checked = this.value != null;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const result = new ColorProperty(this.label, allEqual ? properties[0].value : null, this.nullable, this.tooltip, this.id);
        // result.enabler.indeterminate = !allEqual
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"@svgdotjs/svg.js":"fFByv","./editableProperty":"hk88F","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1aiK6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RadioButtonProperty", ()=>RadioButtonProperty);
var _internal = require("../internal");
class RadioButtonProperty extends (0, _internal.EditableProperty) {
    buttons = [];
    label;
    options;
    constructor(label, options, initialValue, tooltip = "", id = ""){
        super(initialValue, tooltip, id);
        this.options = options;
        this.label = label;
    }
    eq(first, second) {
        if (second == null || first == null) return false;
        return first.key === second.key;
    }
    buildHTML() {
        let row = this.getRow();
        let col = document.createElement("div");
        col.classList.add("col-12", "input-group", "my-0");
        {
            let labelElement = document.createElement("span");
            labelElement.classList.add("col-4", "input-group-text");
            labelElement.innerText = this.label;
            col.appendChild(labelElement);
            const btnLabelClasses = [
                "btn",
                "btn-outline-secondary",
                "fs-5",
                "d-flex",
                "align-items-center",
                "justify-content-center",
                "px-1",
                "flex-grow-1"
            ];
            for (const option of this.options){
                const id = this.id + "-" + option.key;
                let input = document.createElement("input");
                input.classList.add("btn-check");
                input.type = "radio";
                input.name = this.id;
                input.checked = this.value != null ? this.value.key === option.key : false;
                input.id = id;
                input.addEventListener("change", (ev)=>{
                    this.updateValue(option);
                    (0, _internal.Undo).addState();
                });
                col.appendChild(input);
                this.buttons.push(input);
                let labelElement = document.createElement("label");
                labelElement.classList.add(...btnLabelClasses);
                labelElement.innerText = option.name;
                if (option.isMaterialSymbol) labelElement.classList.add("material-symbols-outlined");
                labelElement.setAttribute("for", id);
                col.appendChild(labelElement);
            }
        }
        row.appendChild(col);
        return row;
    }
    disable(disabled) {
        for (const element of this.buttons)element.disabled = disabled ?? true;
    }
    updateHTML() {
        for (const button of this.buttons)button.checked = this.value != null ? button.name === this.value.key : false;
    }
    getMultiEditVersion(properties) {
        let allEqual = this.equivalent(properties);
        const result = new RadioButtonProperty(this.label, this.options, allEqual ? properties[0].value : null, this.tooltip, this.id);
        result.addChangeListener((ev)=>{
            for (const property of properties)property.updateValue(ev.value, true, true);
        });
        result.getHTMLElement();
        return result;
    }
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b9ZYS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Fillable", ()=>Fillable);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
function Fillable(Base) {
    class Fillable extends Base {
        fillInfo;
        fillColorProperty;
        fillOpacityProperty;
        constructor(...args){
            super(...args);
            this.fillInfo = {
                color: "default",
                opacity: 1
            };
            this.properties.add((0, _internal.PropertyCategories).fill, new (0, _internal.SectionHeaderProperty)("Fill", undefined, "fill:header"));
            this.fillOpacityProperty = new (0, _internal.SliderProperty)("Opacity", 0, 100, 1, new _svgJs.Number(this.fillInfo.opacity * 100, "%"), undefined, undefined, "fill:opacity");
            this.fillOpacityProperty.addChangeListener((ev)=>{
                this.fillInfo.opacity = ev.value.value / 100;
                this.updateTheme();
                this.update();
            });
            this.fillColorProperty = new (0, _internal.ColorProperty)("Color", null, undefined, undefined, "fill:color");
            this.fillColorProperty.addChangeListener((ev)=>{
                if (ev.value == null) {
                    this.fillInfo.color = "default";
                    this.fillInfo.opacity = 1;
                } else {
                    this.fillInfo.color = ev.value.toRgb();
                    this.fillInfo.opacity = this.fillOpacityProperty.value.value / 100;
                }
                this.updateTheme();
                this.update();
            });
            this.properties.add((0, _internal.PropertyCategories).fill, this.fillColorProperty);
            this.properties.add((0, _internal.PropertyCategories).fill, this.fillOpacityProperty);
        }
        toJson() {
            const data = super.toJson();
            let fill = {};
            let shouldFill = false;
            if (this.fillInfo.color != "default") {
                fill.color = this.fillInfo.color;
                shouldFill = true;
            }
            if (this.fillInfo.opacity != 1) {
                fill.opacity = this.fillInfo.opacity;
                shouldFill = true;
            }
            if (shouldFill) data.fill = fill;
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            if (saveObject.fill) {
                if (saveObject.fill.color) {
                    this.fillInfo.color = saveObject.fill.color;
                    this.fillColorProperty.value = new _svgJs.Color(saveObject.fill.color);
                }
                if (saveObject.fill.opacity != undefined) {
                    this.fillInfo.opacity = saveObject.fill.opacity;
                    this.fillOpacityProperty.value = new _svgJs.Number(saveObject.fill.opacity * 100, "%");
                }
            }
        }
        buildTikzCommand(command) {
            super.buildTikzCommand(command);
            if (this.fillInfo.opacity > 0) {
                if (this.fillInfo.color !== "default") {
                    let c = new _svgJs.Color(this.fillInfo.color);
                    command.options.push("fill=" + c.toTikzString());
                }
                if (this.fillInfo.opacity != 1) command.options.push("fill opacity=" + this.fillInfo.opacity.toString());
            }
        }
    }
    return Fillable;
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6kSOz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "strokeStyleChoices", ()=>strokeStyleChoices);
parcelHelpers.export(exports, "defaultStrokeStyleChoice", ()=>defaultStrokeStyleChoice);
parcelHelpers.export(exports, "Strokable", ()=>Strokable);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
const strokeStyleChoices = [
    {
        key: "solid",
        name: "solid",
        dasharray: [
            1,
            0
        ]
    },
    {
        key: "dotted",
        name: "dotted",
        dasharray: [
            1,
            4
        ]
    },
    {
        key: "denselydotted",
        name: "densely dotted",
        dasharray: [
            1,
            2
        ]
    },
    {
        key: "looselydotted",
        name: "loosely dotted",
        dasharray: [
            1,
            8
        ]
    },
    {
        key: "dashed",
        name: "dashed",
        dasharray: [
            4,
            4
        ]
    },
    {
        key: "denselydashed",
        name: "densely dashed",
        dasharray: [
            4,
            2
        ]
    },
    {
        key: "looselydashed",
        name: "loosely dashed",
        dasharray: [
            4,
            8
        ]
    },
    {
        key: "dashdot",
        name: "dash dot",
        dasharray: [
            4,
            2,
            1,
            2
        ]
    },
    {
        key: "denselydashdot",
        name: "densely dash dot",
        dasharray: [
            4,
            1,
            1,
            1
        ]
    },
    {
        key: "looselydashdot",
        name: "loosely dash dot",
        dasharray: [
            4,
            4,
            1,
            4
        ]
    },
    {
        key: "dashdotdot",
        name: "dash dot dot",
        dasharray: [
            4,
            2,
            1,
            2,
            1,
            2
        ]
    },
    {
        key: "denselydashdotdot",
        name: "densely dash dot dot",
        dasharray: [
            4,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        key: "looselydashdotdot",
        name: "loosely dash dot dot",
        dasharray: [
            4,
            4,
            1,
            4,
            1,
            4
        ]
    }
];
const defaultStrokeStyleChoice = strokeStyleChoices[0];
function Strokable(Base) {
    class Strokable extends Base {
        strokeInfo;
        strokeColorProperty;
        strokeOpacityProperty;
        strokeWidthProperty;
        strokeStyleProperty;
        constructor(...args){
            super(...args);
            this.strokeInfo = {
                color: "default",
                opacity: 1,
                width: new _svgJs.Number("1pt"),
                style: defaultStrokeStyleChoice.key
            };
            //add color property
            this.properties.add((0, _internal.PropertyCategories).stroke, new (0, _internal.SectionHeaderProperty)("Stroke", undefined, "stroke:header"));
            this.strokeOpacityProperty = new (0, _internal.SliderProperty)("Opacity", 0, 100, 1, new _svgJs.Number(this.strokeInfo.opacity * 100, "%"), undefined, undefined, "stroke:opacity");
            this.strokeOpacityProperty.addChangeListener((ev)=>{
                this.strokeInfo.opacity = ev.value.value / 100;
                this.updateTheme();
                this.update();
            });
            this.strokeColorProperty = new (0, _internal.ColorProperty)("Color", null, undefined, undefined, "stroke:color");
            this.strokeColorProperty.addChangeListener((ev)=>{
                if (ev.value == null) {
                    this.strokeInfo.color = "default";
                    this.strokeInfo.opacity = 1;
                } else {
                    this.strokeInfo.color = ev.value.toRgb();
                    this.strokeInfo.opacity = this.strokeOpacityProperty.value.value / 100;
                }
                this.updateTheme();
                this.update();
            });
            this.strokeWidthProperty = new (0, _internal.SliderProperty)("Width", 0, 10, 0.1, this.strokeInfo.width, undefined, undefined, "stroke:width");
            this.strokeWidthProperty.addChangeListener((ev)=>{
                this.strokeInfo.width = ev.value;
                this.updateTheme();
                this.update();
            });
            this.strokeStyleProperty = new (0, _internal.ChoiceProperty)("Style", strokeStyleChoices, defaultStrokeStyleChoice, undefined, "stroke:style");
            this.strokeStyleProperty.addChangeListener((ev)=>{
                this.strokeInfo.style = ev.value.key;
                this.updateTheme();
                this.update();
            });
            this.properties.add((0, _internal.PropertyCategories).stroke, this.strokeColorProperty);
            this.properties.add((0, _internal.PropertyCategories).stroke, this.strokeOpacityProperty);
            this.properties.add((0, _internal.PropertyCategories).stroke, this.strokeWidthProperty);
            this.properties.add((0, _internal.PropertyCategories).stroke, this.strokeStyleProperty);
        }
        toJson() {
            const data = super.toJson();
            let stroke = {};
            let shouldStroke = false;
            if (this.strokeInfo.color != "default") {
                stroke.color = this.strokeInfo.color;
                shouldStroke = true;
            }
            if (this.strokeInfo.opacity != 1) {
                stroke.opacity = this.strokeInfo.opacity;
                shouldStroke = true;
            }
            if (!this.strokeInfo.width.eq(new _svgJs.Number("1pt"))) {
                stroke.width = this.strokeInfo.width;
                shouldStroke = true;
            }
            if (this.strokeInfo.style != defaultStrokeStyleChoice.key) {
                stroke.style = this.strokeInfo.style;
                shouldStroke = true;
            }
            if (shouldStroke) data.stroke = stroke;
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            this.strokeInfo = {
                color: "default",
                opacity: 1,
                width: new _svgJs.Number("1pt"),
                style: defaultStrokeStyleChoice.key
            };
            this.strokeWidthProperty.value = this.strokeInfo.width;
            this.strokeColorProperty.value = null;
            this.strokeOpacityProperty.value = new _svgJs.Number(this.strokeInfo.opacity * 100, "%");
            this.strokeStyleProperty.value = defaultStrokeStyleChoice;
            if (saveObject.stroke) {
                if (saveObject.stroke.color) {
                    this.strokeInfo.color = saveObject.stroke.color;
                    this.strokeColorProperty.value = new _svgJs.Color(saveObject.stroke.color);
                }
                if (saveObject.stroke.opacity != undefined) {
                    this.strokeInfo.opacity = saveObject.stroke.opacity;
                    this.strokeOpacityProperty.value = new _svgJs.Number(saveObject.stroke.opacity * 100, "%");
                }
                if (saveObject.stroke.width) {
                    if (typeof saveObject.stroke.width != "string") // SVG.Number as object
                    this.strokeInfo.width = new _svgJs.Number(saveObject.stroke.width.value, saveObject.stroke.width.unit);
                    else // SVG.Number as string
                    this.strokeInfo.width = new _svgJs.Number(saveObject.stroke.width);
                    this.strokeWidthProperty.value = this.strokeInfo.width;
                }
                if (saveObject.stroke.style) {
                    this.strokeInfo.style = saveObject.stroke.style;
                    this.strokeStyleProperty.value = strokeStyleChoices.find((item)=>item.key == saveObject.stroke.style);
                }
            }
        }
        buildTikzCommand(command) {
            super.buildTikzCommand(command);
            let width = this.strokeInfo.width.convertToUnit("pt").value;
            if (this.strokeInfo.opacity > 0 && width > 0) {
                if (this.strokeInfo.color !== "default") {
                    let c = new _svgJs.Color(this.strokeInfo.color);
                    command.options.push("draw=" + c.toTikzString());
                } else command.options.push("draw");
                if (this.strokeInfo.opacity != 1) command.options.push("draw opacity=" + this.strokeInfo.opacity.toString());
                if (width != 0.4) command.options.push("line width=" + width + "pt");
                if (this.strokeInfo.style && this.strokeInfo.style != defaultStrokeStyleChoice.key) command.options.push((0, _internal.dashArrayToPattern)(this.strokeInfo.width, strokeStyleChoices.find((item)=>item.key == this.strokeInfo.style).dasharray));
            }
        }
    }
    return Strokable;
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cC9nW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Nameable", ()=>Nameable);
var _internal = require("../internal");
/**
 * names cannot contain punctuation, parentheses and some other symbols
 */ const invalidNameRegEx = /[\t\r\n\v.,:;()-]/;
function Nameable(Base) {
    class Nameable extends Base {
        /**
         * What will be used as the reference name in the tikz code (e.g. "\node[] (name) at (0,0){};"").
         * Not used for all components, e.g. wire
         */ name;
        constructor(...args){
            super(...args);
            const validator = (text)=>{
                if (text === "") // no name is always valid
                return "";
                if (text.match(invalidNameRegEx)) // check if characters are valid
                return "Contains forbidden characters!";
                for (const component of (0, _internal.MainController).instance.circuitComponents)// check if another component with the same name already exists
                if (component != this && "name" in component) {
                    let otherName = component.name;
                    if (text !== "" && otherName.value == text) return "Name is already taken!";
                }
                return "";
            };
            this.name = new (0, _internal.TextProperty)("Name", "", "", validator, "info:name");
            this.properties.add((0, _internal.PropertyCategories).info, new (0, _internal.SectionHeaderProperty)("TikZ name", undefined, "info:nameHeader"));
            this.properties.add((0, _internal.PropertyCategories).info, this.name);
        }
        toJson() {
            const data = super.toJson();
            if (this.name.value && this.name.value != "") data.name = this.name.value;
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            if (saveObject.name) this.name.updateValue(saveObject.name, true);
        }
        buildTikzName(ensureID = true) {
            let id = this.name.value;
            if (!id && ensureID) id = (0, _internal.ExportController).instance.createExportID("N");
            return id;
        }
    }
    return Nameable;
}

},{"../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aw6et":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PositionLabelable", ()=>PositionLabelable);
parcelHelpers.export(exports, "PathLabelable", ()=>PathLabelable);
parcelHelpers.export(exports, "generateLabelRender", ()=>generateLabelRender);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
function PositionLabelable(Base) {
    class PositionLabelable extends Base {
        anchorChoice;
        positionChoice;
        mathJaxLabel;
        labelReferenceChoices = [
            {
                key: "canvas",
                name: "Canvas"
            },
            {
                key: "component",
                name: "Component"
            }
        ];
        labelReferenceProperty;
        labelRendering;
        labelDistance;
        labelColor;
        constructor(...args){
            super(...args);
            //label section
            this.properties.add((0, _internal.PropertyCategories).label, new (0, _internal.SectionHeaderProperty)("Label", undefined, "label:header"));
            this.mathJaxLabel = new (0, _internal.MathJaxProperty)(undefined, undefined, "label:label");
            this.mathJaxLabel.addChangeListener((ev)=>this.generateLabelRender());
            this.properties.add((0, _internal.PropertyCategories).label, this.mathJaxLabel);
            this.labelReferenceProperty = new (0, _internal.ChoiceProperty)("Relative to", this.labelReferenceChoices, this.labelReferenceChoices[0], undefined, "label:relative");
            this.labelReferenceProperty.addChangeListener((ev)=>{
                this.updatePositionedLabel();
            });
            this.properties.add((0, _internal.PropertyCategories).label, this.labelReferenceProperty);
            this.anchorChoice = new (0, _internal.ChoiceProperty)("Anchor", (0, _internal.basicDirections), (0, _internal.defaultBasicDirection), undefined, "label:anchor");
            this.anchorChoice.addChangeListener((ev)=>this.updatePositionedLabel());
            this.properties.add((0, _internal.PropertyCategories).label, this.anchorChoice);
            this.positionChoice = new (0, _internal.ChoiceProperty)("Position", (0, _internal.basicDirections), (0, _internal.defaultBasicDirection), undefined, "label:position");
            this.positionChoice.addChangeListener((ev)=>this.updatePositionedLabel());
            this.properties.add((0, _internal.PropertyCategories).label, this.positionChoice);
            this.labelDistance = new (0, _internal.SliderProperty)("Gap", -0.5, 1, 0.01, new _svgJs.Number(0.12, "cm"), undefined, undefined, "label:gap");
            this.labelDistance.addChangeListener((ev)=>this.updatePositionedLabel());
            this.properties.add((0, _internal.PropertyCategories).label, this.labelDistance);
            this.labelColor = new (0, _internal.ColorProperty)("Color", null, undefined, undefined, "label:color");
            this.labelColor.addChangeListener((ev)=>{
                this.updateTheme();
                this.update();
            });
            this.properties.add((0, _internal.PropertyCategories).label, this.labelColor);
        }
        toJson() {
            const data = super.toJson();
            if (this.mathJaxLabel.value) {
                let labelWithoutRender = {
                    value: this.mathJaxLabel.value,
                    anchor: this.anchorChoice.value.key,
                    position: this.positionChoice.value.key,
                    relativeToComponent: this.labelReferenceProperty.value.key == "component" ? true : undefined,
                    distance: this.labelDistance.value.value != 0.12 ? this.labelDistance.value : undefined,
                    color: this.labelColor.value ? this.labelColor.value.toString() : undefined
                };
                data.label = labelWithoutRender;
            }
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            if (saveObject.label) {
                if (saveObject.label.distance) {
                    if (typeof saveObject.label.distance != "string") // SVG.Number as object
                    this.labelDistance.value = new _svgJs.Number(saveObject.label.distance.value, saveObject.label.distance.unit);
                    else // SVG.Number as string
                    this.labelDistance.value = new _svgJs.Number(saveObject.label.distance);
                } else this.labelDistance.value = new _svgJs.Number(0.12, "cm");
                this.anchorChoice.value = saveObject.label.anchor ? (0, _internal.basicDirections).find((item)=>item.key == saveObject.label.anchor) : (0, _internal.defaultBasicDirection);
                this.positionChoice.value = saveObject.label.position ? (0, _internal.basicDirections).find((item)=>item.key == saveObject.label.position) : (0, _internal.defaultBasicDirection);
                if ((0, _internal.SaveController).instance.currentlyLoadedSaveVersion != "") this.labelReferenceProperty.value = saveObject.label.relativeToComponent ? this.labelReferenceChoices[1] : this.labelReferenceChoices[0];
                else this.labelReferenceProperty.value = this.labelReferenceChoices[1];
                this.mathJaxLabel.value = saveObject.label.value;
                this.labelColor.value = saveObject.label.color ? new _svgJs.Color(saveObject.label.color) : null;
                this.generateLabelRender();
            }
        }
        buildTikzNodeLabel(reference) {
            if (this.mathJaxLabel.value && reference) {
                let labelDist = this.labelDistance.value.convertToUnit("cm");
                if (!isNaN(this.anchorPos.direction.absSquared())) labelDist = labelDist.minus(0.12);
                let labelShift = this.anchorPos.direction.mul(-labelDist.value);
                let posShift = "";
                if (labelShift.x !== 0) posShift += "xshift=" + (0, _selectionHelper.roundTikz)(labelShift.x) + "cm";
                if (labelShift.y !== 0) {
                    posShift += posShift == "" ? "" : ", ";
                    posShift += "yshift=" + (0, _selectionHelper.roundTikz)(-labelShift.y) + "cm";
                }
                posShift = posShift == "" ? "" : "[" + posShift + "]";
                let posStr;
                if (typeof reference == "string") posStr = this.positionChoice.value.key == (0, _internal.defaultBasicDirection).key ? reference + ".text" : reference + "." + this.labelPos.name;
                else posStr = reference.toTikzString(true);
                let latexStr = this.mathJaxLabel.value ? "$" + this.mathJaxLabel.value + "$" : "";
                latexStr = latexStr && this.labelColor.value ? "\\textcolor" + this.labelColor.value.toTikzString() + "{" + latexStr + "}" : latexStr;
                let labelCommand = {
                    position: "(" + posShift + posStr + ")",
                    options: [
                        "anchor=" + this.anchorPos.name
                    ],
                    additionalNodes: [],
                    content: latexStr
                };
                return labelCommand;
            }
            return null;
        }
        /**
         * Generate a label visualization via mathjax
         */ generateLabelRender() {
            // if a previous label was rendered, remove everything concerning that rendering
            this.labelRendering = generateLabelRender(this.labelRendering, this.mathJaxLabel);
            // add the label rendering to the visualization element
            this.visualization.add(this.labelRendering);
            this.update();
            this.updateTheme();
        }
        anchorPos;
        labelPos;
    }
    return PositionLabelable;
}
function PathLabelable(Base) {
    class PathLabelable extends Base {
        mathJaxLabel;
        labelRendering;
        labelDistance;
        labelColor;
        labelSide;
        constructor(...args){
            super(...args);
            //label section
            this.properties.add((0, _internal.PropertyCategories).label, new (0, _internal.SectionHeaderProperty)("Label", undefined, "label:header"));
            this.mathJaxLabel = new (0, _internal.MathJaxProperty)(undefined, undefined, "label:label");
            this.mathJaxLabel.addChangeListener((ev)=>this.generateLabelRender());
            this.properties.add((0, _internal.PropertyCategories).label, this.mathJaxLabel);
            this.labelDistance = new (0, _internal.SliderProperty)("Gap", -0.5, 1, 0.01, new _svgJs.Number(0.12, "cm"), undefined, undefined, "label:gap");
            this.labelDistance.addChangeListener((ev)=>this.updatePathLabel());
            this.properties.add((0, _internal.PropertyCategories).label, this.labelDistance);
            this.labelColor = new (0, _internal.ColorProperty)("Color", null, undefined, undefined, "label:color");
            this.labelColor.addChangeListener((ev)=>{
                this.updateTheme();
                this.update();
            });
            this.properties.add((0, _internal.PropertyCategories).label, this.labelColor);
            this.labelSide = new (0, _internal.BooleanProperty)("Switch side", undefined, undefined, "label:side");
            this.labelSide.addChangeListener((ev)=>this.updatePathLabel());
            this.properties.add((0, _internal.PropertyCategories).label, this.labelSide);
        }
        toJson() {
            const data = super.toJson();
            if (this.mathJaxLabel.value) {
                let label = {
                    value: this.mathJaxLabel.value,
                    otherSide: this.labelSide.value ? true : undefined,
                    distance: this.labelDistance.value.value != 0.12 ? this.labelDistance.value : undefined,
                    color: this.labelColor.value ? this.labelColor.value.toString() : undefined
                };
                data.label = label;
            }
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            if (saveObject.label) {
                this.labelSide.value = saveObject.label.otherSide ?? false;
                if (saveObject.label.distance) {
                    if (typeof saveObject.label.distance != "string") // SVG.Number as object
                    this.labelDistance.value = new _svgJs.Number(saveObject.label.distance.value, saveObject.label.distance.unit);
                    else // SVG.Number as string
                    this.labelDistance.value = new _svgJs.Number(saveObject.label.distance);
                } else this.labelDistance.value = new _svgJs.Number(0.12, "cm");
                this.mathJaxLabel.value = saveObject.label.value;
                this.labelColor.value = saveObject.label.color ? new _svgJs.Color(saveObject.label.color) : null;
                this.generateLabelRender();
            }
        }
        /**
         * Generate a label visualization via mathjax
         */ generateLabelRender() {
            this.labelRendering = generateLabelRender(this.labelRendering, this.mathJaxLabel);
            // add the label rendering to the visualization element
            this.visualization.add(this.labelRendering);
            this.update();
            this.updateTheme();
        }
        buildTikzPathLabel(to) {
            if (this.mathJaxLabel.value) {
                let distVal = this.labelDistance.value.convertToUnit("cm").minus(0.12).value;
                let distStr = (0, _selectionHelper.roundTikz)(distVal) + "cm";
                let shouldDist = this.labelDistance.value && Math.abs(distVal) > 0.0001;
                let latexStr = this.mathJaxLabel.value ? "$" + this.mathJaxLabel.value + "$" : "";
                latexStr = latexStr && this.labelColor.value ? "\\textcolor" + this.labelColor.value.toTikzString() + "{" + latexStr + "}" : latexStr;
                to.options.push("l" + (this.labelSide.value ? "_" : "") + "={" + latexStr + "}");
                if (shouldDist) to.options.push("label distance=" + distStr);
            }
        }
    }
    return PathLabelable;
}
function generateLabelRender(labelRendering, mathJaxLabel) {
    // if a previous label was rendered, remove everything concerning that rendering
    if (labelRendering) {
        let removeIDs = new Set();
        for (const element of labelRendering.find("use"))removeIDs.add(element.node.getAttribute("xlink:href"));
        for (const id of removeIDs)(0, _internal.CanvasController).instance.canvas.find(id)[0]?.remove();
        labelRendering.remove();
    }
    const transformGroup = (0, _internal.renderMathJax)(mathJaxLabel.value);
    // remove the current label and substitute with a new group element
    labelRendering = new _svgJs.G();
    labelRendering.addClass("pointerNone");
    labelRendering.add(transformGroup.element);
    return labelRendering;
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lvPBm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Voltageable", ()=>Voltageable);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
const voltageDirectionChoices = [
    {
        key: "",
        name: "default"
    },
    {
        key: ">",
        name: "forward"
    },
    {
        key: "<",
        name: "backward"
    }
];
const defaultVoltageDirectionChoice = voltageDirectionChoices[0];
let voltageDirectionBackward = false;
const voltagePositionChoices = [
    {
        key: "",
        name: "default"
    },
    {
        key: "_",
        name: "below"
    },
    {
        key: "^",
        name: "above"
    }
];
const defaultVoltagePositionChoice = voltagePositionChoices[0];
let voltagePositionAbove = false;
const voltageStyleChoices = [
    {
        key: "",
        name: "default"
    },
    {
        key: "american",
        name: "american"
    },
    {
        key: "raised",
        name: "raised"
    },
    {
        key: "straight",
        name: "straight"
    },
    {
        key: "european",
        name: "european"
    }
];
const defaultVoltageStyleChoice = voltageStyleChoices[1]; // american
let voltageEuropean = true;
let voltageStraight = false;
let voltageRaised = false;
const arrowStrokeWidth = 0.5;
const distanceFromLine = 0.08;
const currentArrowScale = 16;
const defaultRlen = 1.4;
const cmtopx = 4800 / 127; // 96px/2.54
function Voltageable(Base) {
    class Voltageable extends Base {
        voltageLabel;
        voltageLabelRendering;
        voltageArrowRendering;
        voltageRendering;
        voltageBumpB;
        voltageDistanceFromNode;
        voltageShift;
        voltagePosition;
        voltageDirection;
        voltageStyle;
        voltageShow;
        constructor(...args){
            super(...args);
            this.properties.add((0, _internal.PropertyCategories).voltage, new (0, _internal.SectionHeaderProperty)("Voltage label", undefined, "voltage:header"));
            this.voltageShow = new (0, _internal.BooleanProperty)("Show voltage", false, undefined, "voltage:show");
            this.voltageShow.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageShow);
            this.voltageLabel = new (0, _internal.MathJaxProperty)(undefined, undefined, "voltage:label");
            this.voltageLabel.addChangeListener((ev)=>this.generateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageLabel);
            this.voltageStyle = new (0, _internal.ChoiceProperty)("Style", voltageStyleChoices, defaultVoltageStyleChoice, undefined, "voltage:style");
            this.voltageStyle.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageStyle);
            this.voltagePosition = new (0, _internal.ChoiceProperty)("Position", voltagePositionChoices, defaultVoltagePositionChoice, undefined, "voltage:position");
            this.voltagePosition.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltagePosition);
            this.voltageDirection = new (0, _internal.ChoiceProperty)("Direction", voltageDirectionChoices, defaultVoltageDirectionChoice, undefined, "voltage:direction");
            this.voltageDirection.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageDirection);
            this.voltageBumpB = new (0, _internal.SliderProperty)("Bump", 0, 5, 0.1, new _svgJs.Number(1.5, ""), false, "How much the voltage arrow should bump away from the component", "voltage:bump");
            this.voltageBumpB.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageBumpB);
            this.voltageDistanceFromNode = new (0, _internal.SliderProperty)("Distance from node", 0, 1, 0.1, new _svgJs.Number(0.5, ""), true, "How far away from the component the voltage arrow should start/end", "voltage:distance");
            this.voltageDistanceFromNode.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageDistanceFromNode);
            this.voltageShift = new (0, _internal.SliderProperty)("Voltage shift", -1, 2, 0.1, new _svgJs.Number(0, ""), false, undefined, "voltage:shift");
            this.voltageShift.addChangeListener((ev)=>this.updateVoltageRender());
            this.properties.add((0, _internal.PropertyCategories).voltage, this.voltageShift);
        }
        generateVoltageRender() {
            this.voltageLabelRendering = (0, _internal.generateLabelRender)(this.voltageLabelRendering, this.voltageLabel);
            this.voltageLabelRendering.fill((0, _internal.defaultStroke));
            this.voltageRendering = new _svgJs.G();
            this.voltageRendering.add(this.voltageLabelRendering);
            this.visualization.add(this.voltageRendering);
            this.update();
            this.updateTheme();
        }
        generateVoltageArrow(start, end, northwestDelta, southeastDelta, scale, options) {
            const group = new _svgJs.G();
            if (!options) options = {};
            let mirror = scale.y < 0;
            const scaleFactor = Math.abs(scale.x);
            let distanceFromNode = this.voltageDistanceFromNode.value.value;
            let bump = this.voltageBumpB.value.value;
            let shift = this.voltageShift.value.value;
            let directionBackwards = voltageDirectionBackward;
            if (this.voltageDirection.value.key != defaultVoltageDirectionChoice.key) directionBackwards = this.voltageDirection.value.key == voltageDirectionChoices.at(-1).key;
            let positionAbove = voltagePositionAbove;
            if (this.voltagePosition.value.key != defaultVoltagePositionChoice.key) positionAbove = this.voltagePosition.value.key == voltagePositionChoices.at(-1).key;
            let above = positionAbove ? -1 : 1;
            let isEuropeanVoltage = this.voltageStyle.value.key == "european" || this.voltageStyle.value.key == "straight" || this.voltageStyle.value.key == "" && voltageEuropean;
            let isStraightVoltage = this.voltageStyle.value.key == "straight" || voltageStraight;
            let isRaisedVoltage = this.voltageStyle.value.key == "raised" || voltageRaised;
            let diff = end.sub(start);
            let angle = Math.atan2(diff.y, diff.x);
            let endTrans = end.rotate(angle, start, true);
            // in which direction the the anchor of the voltage label should point
            const sin4 = 0.06976; // the sin of 4 degrees
            let labelAnchor = new _svgJs.Point((0, _internal.approxCompare)(Math.sin(angle), 0, sin4), -(0, _internal.approxCompare)(Math.cos(angle), 0, sin4)).mul(above);
            const distFromLine = distanceFromLine * defaultRlen * scaleFactor * cmtopx;
            let absVShift = above * (1 + shift) * distFromLine;
            const midTrans = start.add(endTrans).div(2);
            const mid = start.add(end).div(2);
            const compStart = midTrans.add(new _svgJs.Point(northwestDelta.x * scaleFactor, 0));
            const compEnd = midTrans.add(new _svgJs.Point(southeastDelta.x * scaleFactor, 0));
            const arrowScale = cmtopx * defaultRlen / (currentArrowScale / scaleFactor) + 2 * arrowStrokeWidth;
            // calculate the points where the voltage arrow should start and end (flat, before rotation)
            const arrowOffset = arrowScale / Math.abs(compStart.x - start.x);
            let tmp = (0, _internal.interpolate)(start, compStart, arrowOffset);
            let Vfrom_flat = (0, _internal.interpolate)(tmp, compStart, distanceFromNode);
            tmp = (0, _internal.interpolate)(endTrans, compEnd, arrowOffset);
            let Vto_flat = (0, _internal.interpolate)(tmp, compEnd, distanceFromNode);
            const minYSize = 3;
            let sizing = southeastDelta;
            if (southeastDelta.y < minYSize) // set minimum size if no height is given
            sizing = new _svgJs.Point(southeastDelta.x, minYSize);
            if (positionAbove != mirror) {
                sizing = northwestDelta;
                if (northwestDelta.y > -minYSize) // set minimum size if no height is given
                sizing = new _svgJs.Point(northwestDelta.x, -minYSize);
            }
            sizing = mirror ? sizing.mul(-1) : sizing;
            let labPos = new _svgJs.Point(this.position);
            let Vfrom;
            let Vto;
            const labelOffset = new _svgJs.Point(0, above * 0.08 * cmtopx);
            if (isEuropeanVoltage) {
                //european
                let d;
                let arrowPos;
                let arrowAngle;
                const sin20 = 0.34202; // sin of 20 degrees
                if (isStraightVoltage) {
                    //straight voltages
                    let bottom = new _svgJs.Point(0, sizing.y);
                    let Vfrom1 = Vfrom_flat.add(bottom);
                    let Vto1 = Vto_flat.add(bottom);
                    Vfrom = Vfrom1.add(new _svgJs.Point(0, absVShift)).rotate(-angle, start, true);
                    Vto = Vto1.add(new _svgJs.Point(0, absVShift)).rotate(-angle, start, true);
                    d = `M${Vfrom.toSVGPathString()}L${Vto.toSVGPathString()}`;
                    arrowPos = Vto;
                    arrowAngle = angle;
                    if (directionBackwards) {
                        arrowAngle += Math.PI;
                        arrowPos = Vfrom;
                    }
                    labPos = Vfrom.add(Vto).div(2);
                } else {
                    //curved voltage arrows
                    let C110 = (0, _internal.interpolate)(new _svgJs.Point(), new _svgJs.Point(-sin20 * Math.abs(sizing.y), sizing.y), bump * scaleFactor).add(mid).add(new _svgJs.Point(0, absVShift)).rotate(-angle, mid, true);
                    let C70 = (0, _internal.interpolate)(new _svgJs.Point(), new _svgJs.Point(sin20 * Math.abs(sizing.y), sizing.y), bump * scaleFactor).add(mid).add(new _svgJs.Point(0, absVShift)).rotate(-angle, mid, true);
                    Vfrom = Vfrom_flat.add(new _svgJs.Point(0, absVShift)).rotate(-angle, start, true);
                    Vto = Vto_flat.add(new _svgJs.Point(0, absVShift)).rotate(-angle, start, true);
                    d = `M${Vfrom.toSVGPathString()}C${C110.toSVGPathString()} ${C70.toSVGPathString()} ${Vto.toSVGPathString()}`;
                    labPos = C110.add(C70).div(2);
                    let arrowAngleDiff;
                    arrowPos = Vto;
                    if (directionBackwards) {
                        arrowAngleDiff = Vfrom.sub(C110);
                        arrowPos = Vfrom;
                    } else arrowAngleDiff = Vto.sub(C70);
                    arrowAngle = Math.atan2(arrowAngleDiff.y, arrowAngleDiff.x);
                }
                labPos = labPos.add(labelOffset.rotate(-angle, undefined, true));
                const path = new _svgJs.Path({
                    d: d
                });
                path.fill("none").stroke({
                    color: "var(--bs-body-color)",
                    width: arrowStrokeWidth
                });
                const arrowTip = (0, _internal.CanvasController).instance.canvas.use("currarrow").fill("var(--bs-body-color)");
                const arrowTipTransform = new _svgJs.Matrix({
                    translate: [
                        -1.7 + 2 * arrowStrokeWidth / arrowScale,
                        -0.8
                    ]
                }).lmultiply({
                    scale: arrowScale,
                    rotate: 180 * arrowAngle / Math.PI,
                    translate: arrowPos
                });
                arrowTip.transform(arrowTipTransform);
                group.add(path);
                group.add(arrowTip);
            } else {
                //american
                if (isRaisedVoltage) {
                    //raised voltages
                    let refHeight = 10;
                    absVShift += above * refHeight;
                    labelAnchor.x = 0;
                    labelAnchor.y = 0;
                }
                labPos = midTrans.add(new _svgJs.Point(0, sizing.y + absVShift));
                Vfrom = Vfrom_flat.add(new _svgJs.Point(0, absVShift));
                Vto = Vto_flat.add(new _svgJs.Point(0, absVShift));
                if (isRaisedVoltage) {
                    //raised voltages
                    Vfrom.y = labPos.y;
                    Vto.y = labPos.y;
                }
                Vfrom = Vfrom.rotate(-angle, start, true);
                Vto = Vto.rotate(-angle, start, true);
                labPos = labPos.rotate(-angle, start, true);
                const plus = new _svgJs.Path({
                    d: "M0 4.5 H9 M4.5 0V9"
                }).stroke({
                    linejoin: "round",
                    width: 0.5,
                    color: (0, _internal.defaultStroke)
                });
                const minus = new _svgJs.Path({
                    d: "M0 4.5 H9"
                }).stroke({
                    linejoin: "round",
                    width: 0.5,
                    color: (0, _internal.defaultStroke)
                });
                const plusBBox = plus.bbox();
                const plusHalfSize = new _svgJs.Point(plusBBox.w / 2, plusBBox.h / 2);
                const anchorOffset = plusHalfSize.add(plusHalfSize.mul(labelAnchor));
                if (directionBackwards) {
                    plus.transform({
                        translate: Vto.sub(anchorOffset)
                    });
                    minus.transform({
                        translate: Vfrom.sub(anchorOffset)
                    });
                } else {
                    plus.transform({
                        translate: Vfrom.sub(anchorOffset)
                    });
                    minus.transform({
                        translate: Vto.sub(anchorOffset)
                    });
                }
                group.add(plus);
                group.add(minus);
                if (!isRaisedVoltage) labPos = labPos.add(labelOffset.rotate(-angle, undefined, true));
            }
            return {
                arrow: group,
                labelPos: labPos,
                labelAnchorDir: labelAnchor
            };
        }
        toJson() {
            const data = super.toJson();
            if (this.voltageLabel.value != "") {
                const voltageLabel = {
                    label: this.voltageLabel.value
                };
                voltageLabel.bump = this.voltageBumpB.value.value != 1.5 ? this.voltageBumpB.value.value : undefined;
                voltageLabel.dist = this.voltageDistanceFromNode.value.value != 0.5 ? this.voltageDistanceFromNode.value.value : undefined;
                voltageLabel.shift = this.voltageShift.value.value != 0 ? this.voltageShift.value.value : undefined;
                voltageLabel.dir = this.voltageDirection.value.key != defaultVoltageDirectionChoice.key ? this.voltageDirection.value.key : undefined;
                voltageLabel.pos = this.voltagePosition.value.key != defaultVoltagePositionChoice.key ? this.voltagePosition.value.key : undefined;
                voltageLabel.style = this.voltageStyle.value.key != defaultVoltageStyleChoice.key ? this.voltageStyle.value.key : undefined;
                data.voltage = voltageLabel;
            }
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            if (saveObject.voltage) {
                this.voltageLabel.value = saveObject.voltage.label;
                if (saveObject.voltage.shift) this.voltageShift.value = new _svgJs.Number(saveObject.voltage.shift, "");
                if (saveObject.voltage.bump) this.voltageBumpB.value = new _svgJs.Number(saveObject.voltage.bump, "");
                if (saveObject.voltage.dist) this.voltageDistanceFromNode.value = new _svgJs.Number(saveObject.voltage.dist, "");
                if (saveObject.voltage.dir) this.voltageDirection.value = voltageDirectionChoices.find((value)=>value.key == saveObject.voltage.dir);
                if (saveObject.voltage.pos) this.voltagePosition.value = voltagePositionChoices.find((value)=>value.key == saveObject.voltage.pos);
                if (saveObject.voltage.style) this.voltageStyle.value = voltageStyleChoices.find((value)=>value.key == saveObject.voltage.style);
                this.generateVoltageRender();
            }
        }
        buildTikzVoltage(to) {
            // Only export voltage if show property is enabled
            if (this.voltageShow.value && this.voltageLabel.value != "") {
                const options = to.options;
                let voltageString = "v";
                if (this.voltagePosition.value.key != defaultVoltagePositionChoice.key) voltageString += this.voltagePosition.value.key;
                if (this.voltageDirection.value.key != defaultVoltageDirectionChoice.key) voltageString += this.voltageDirection.value.key;
                voltageString += "=$" + this.voltageLabel.value + "$";
                options.push(voltageString);
                if (this.voltageDistanceFromNode.value.value != 0.5) options.push("voltage/distance from node=" + this.voltageDistanceFromNode.value.value.toString());
                if (this.voltageBumpB.value.value != 1.5) options.push("voltage/bump b=" + this.voltageBumpB.value.value.toString());
                if (this.voltageShift.value.value != 0) options.push("voltage/shift=" + this.voltageShift.value.value.toString());
                if (this.voltageStyle.value.key != defaultVoltageStyleChoice.key) options.push("voltage=" + this.voltageStyle.value.key);
            }
        }
    }
    return Voltageable;
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dLPaW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Currentable", ()=>Currentable);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
let currentDirectionBackward = false;
let currentPositionStart = false;
let currentLabelBelow = false;
const arrowStrokeWidth = 0.5;
const currentArrowScale = 16;
const defaultRlen = 1.4;
const cmtopx = 4800 / 127; // 96px/2.54
function Currentable(Base) {
    class Currentable extends Base {
        currentLabel;
        currentLabelRendering;
        currentArrowRendering;
        currentRendering;
        currentDistance;
        currentPosition;
        currentDirection;
        currentLabelPosition;
        currentShift;
        currentArrowWidth;
        currentShow;
        constructor(...args){
            super(...args);
            this.properties.add((0, _internal.PropertyCategories).current, new (0, _internal.SectionHeaderProperty)("Current label", undefined, "current:header"));
            this.currentLabel = new (0, _internal.MathJaxProperty)(undefined, undefined, "current:label");
            this.currentShow = new (0, _internal.BooleanProperty)("Show current", false, undefined, "current:show");
            this.currentShow.addChangeListener((ev)=>this.updateCurrentRender());
            this.properties.add((0, _internal.PropertyCategories).current, this.currentShow);
            this.currentLabel.addChangeListener((ev)=>this.generateCurrentRender());
            this.properties.add((0, _internal.PropertyCategories).current, this.currentLabel);
            this.currentDirection = new (0, _internal.BooleanProperty)("Backwards", currentDirectionBackward, undefined, "current:backwards");
            this.currentDirection.addChangeListener((ev)=>{
                this.updateCurrentRender();
            });
            this.properties.add((0, _internal.PropertyCategories).current, this.currentDirection);
            this.currentLabelPosition = new (0, _internal.BooleanProperty)("Label below", currentLabelBelow, undefined, "current:below");
            this.currentLabelPosition.addChangeListener((ev)=>{
                this.updateCurrentRender();
            });
            this.properties.add((0, _internal.PropertyCategories).current, this.currentLabelPosition);
            this.currentPosition = new (0, _internal.BooleanProperty)("At start", currentPositionStart, undefined, "current:start");
            this.currentPosition.addChangeListener((ev)=>this.updateCurrentRender());
            this.properties.add((0, _internal.PropertyCategories).current, this.currentPosition);
            this.currentDistance = new (0, _internal.SliderProperty)("Distance", 0, 1, 0.1, new _svgJs.Number(0.5, ""), true, "How far along the line the current arrow is.", "current:distance");
            this.currentDistance.addChangeListener((ev)=>this.updateCurrentRender());
            this.properties.add((0, _internal.PropertyCategories).current, this.currentDistance);
            this.currentShift = new (0, _internal.SliderProperty)("Shift", -2, 2, 0.1, new _svgJs.Number(0, ""), false, "How much the current arrow should shift perpendicular to the component", "current:shift");
            this.currentShift.addChangeListener((ev)=>this.updateCurrentRender());
            this.properties.add((0, _internal.PropertyCategories).current, this.currentShift);
            this.currentArrowWidth = new (0, _internal.SliderProperty)("Current width", 0.5, 20, 0.5, new _svgJs.Number(10, ""), false, "Width of the current arrow shaft in pixels", "current:arrowwidth");
            this.currentArrowWidth.addChangeListener((ev)=>this.updateCurrentRender());
            this.properties.add((0, _internal.PropertyCategories).current, this.currentArrowWidth);
        }
        generateCurrentRender() {
            this.currentLabelRendering = (0, _internal.generateLabelRender)(this.currentLabelRendering, this.currentLabel);
            this.currentLabelRendering.fill("var(--bs-body-color)");
            this.currentRendering = new _svgJs.G();
            this.currentRendering.add(this.currentLabelRendering);
            this.visualization.add(this.currentRendering);
            this.update();
            this.updateTheme();
        }
        generateCurrentArrow(start, end, northwestDelta, southeastDelta, scale) {
            const group = new _svgJs.G();
            const scaleFactor = Math.abs(scale.x);
            let distance = this.currentDistance.value.value;
            let shift = this.currentShift.value.value;
            let directionBackwards = this.currentDirection.value;
            let positionStart = this.currentPosition.value;
            let labelPositionBelow = this.currentLabelPosition.value;
            let labelBelow = labelPositionBelow ? -1 : 1;
            let diff = end.sub(start);
            let angle = Math.atan2(diff.y, diff.x);
            let endTrans = end.rotate(angle, start, true);
            // in which direction the the anchor of the current label should point
            const sin4 = 0.06976; // the sin of 4 degrees
            let labelAnchor = new _svgJs.Point((0, _internal.approxCompare)(Math.sin(angle), 0, sin4), -(0, _internal.approxCompare)(Math.cos(angle), 0, sin4)).mul(-labelBelow);
            const midTrans = start.add(endTrans).div(2);
            const compStart = midTrans.add(new _svgJs.Point(northwestDelta.x * scaleFactor, 0));
            const compEnd = midTrans.add(new _svgJs.Point(southeastDelta.x * scaleFactor, 0));
            const arrowScale = cmtopx * defaultRlen / (currentArrowScale / scaleFactor) + 2 * arrowStrokeWidth;
            const arrowPositionTrans = positionStart ? (0, _internal.interpolate)(start, compStart, distance) : (0, _internal.interpolate)(compEnd, endTrans, distance);
            // Apply shift perpendicular to the component
            const shiftOffset = new _svgJs.Point(0, shift * cmtopx);
            const arrowPos = arrowPositionTrans.add(shiftOffset).rotate(-angle, start, true);
            const labelOffset = new _svgJs.Point(0, -labelBelow * 0.12 * cmtopx);
            let labPos = arrowPos.add(labelOffset.rotate(-angle, undefined, true));
            // Draw the arrow line (shaft)
            const arrowLength = 15; // Length of the arrow shaft in pixels
            const arrowAngle = angle + (directionBackwards ? Math.PI : 0);
            // Calculate line start and end positions along the component direction
            const lineStart = arrowPos.add(new _svgJs.Point(-arrowLength / 2, 0).rotate(angle, undefined, true));
            const lineEnd = arrowPos.add(new _svgJs.Point(arrowLength / 2, 0).rotate(angle, undefined, true));
            // Create the arrow line using Path (more reliable than Line)
            const pathData = `M ${lineStart.x} ${lineStart.y} L ${lineEnd.x} ${lineEnd.y}`;
            const arrowLine = new _svgJs.Path({
                d: pathData
            });
            arrowLine.fill("none").stroke({
                color: "var(--bs-body-color)",
                width: this.currentArrowWidth.value.value
            });
            // Draw the arrow tip
            const arrowTip = (0, _internal.CanvasController).instance.canvas.use("currarrow").fill("var(--bs-body-color)");
            const arrowTipTransform = new _svgJs.Matrix({
                translate: [
                    -0.85,
                    -0.8
                ]
            }).lmultiply({
                scale: arrowScale,
                rotate: 180 * arrowAngle / Math.PI,
                translate: arrowPos
            });
            arrowTip.transform(arrowTipTransform);
            // Add to group in correct order
            group.add(arrowLine);
            group.add(arrowTip);
            return {
                arrow: group,
                labelPos: labPos,
                labelAnchorDir: labelAnchor
            };
        }
        toJson() {
            const data = super.toJson();
            if (this.currentLabel.value != "") {
                const currentLabel = {
                    label: this.currentLabel.value
                };
                currentLabel.dist = this.currentDistance.value.value != 0.5 ? this.currentDistance.value.value : undefined;
                currentLabel.backwards = this.currentDirection.value ? true : undefined;
                currentLabel.start = this.currentPosition.value ? true : undefined;
                currentLabel.below = this.currentLabelPosition.value ? true : undefined;
                currentLabel.shift = this.currentShift.value.value != 0 ? this.currentShift.value.value : undefined;
                currentLabel.arrowWidth = this.currentArrowWidth.value.value != 10 ? this.currentArrowWidth.value.value : undefined;
                data.current = currentLabel;
            }
            return data;
        }
        applyJson(saveObject) {
            super.applyJson(saveObject);
            if (saveObject.current) {
                this.currentLabel.value = saveObject.current.label;
                if (saveObject.current.dist) this.currentDistance.value = new _svgJs.Number(saveObject.current.dist, "");
                if (saveObject.current.backwards) this.currentDirection.value = true;
                if (saveObject.current.start) this.currentPosition.value = true;
                if (saveObject.current.below) this.currentLabelPosition.value = true;
                if (saveObject.current.shift !== undefined) this.currentShift.value = new _svgJs.Number(saveObject.current.shift, "");
                if (saveObject.current.arrowWidth !== undefined) this.currentArrowWidth.value = new _svgJs.Number(saveObject.current.arrowWidth, "");
                this.generateCurrentRender();
            }
        }
        buildTikzCurrent(to) {
            // Only export current if show property is enabled
            if (this.currentShow.value && this.currentLabel.value != "") {
                const options = to.options;
                let currentString = "i";
                let labelPosString = this.currentLabelPosition.value ? "_" : "^";
                let dirString = this.currentDirection.value ? "<" : ">";
                if (this.currentPosition.value) {
                    // if position is start, the label position comes after the direction and both are required, exept:
                    if (this.currentLabelPosition.value == false && this.currentDirection.value == true) // if direction is backward and the label position is default above, the label position is not required
                    labelPosString = "";
                    currentString += dirString + labelPosString;
                } else {
                    // if position is end, the label position comes before the direction
                    if (this.currentDirection.value == false) {
                        // if direction is forward the label position is not required
                        dirString = "";
                        if (this.currentLabelPosition.value == false) // if the label position is default above and the direction is forward, the label position is also not required
                        labelPosString = "";
                    }
                    currentString += labelPosString + dirString;
                }
                currentString += "={$" + this.currentLabel.value + "$}";
                options.push(currentString);
                if (this.currentDistance.value.value != 0.5) options.push("current/distance=" + this.currentDistance.value.value.toString());
            // Note: CircuiTikZ does not support current/label/shift parameter
            // The shift feature is only for visual display in the designer
            }
        }
    }
    return Currentable;
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1yrgf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Every component in the circuit should be deriving from this class.
 */ parcelHelpers.export(exports, "CircuitComponent", ()=>CircuitComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _svgDraggableJs = require("@svgdotjs/svg.draggable.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class CircuitComponent {
    /**
     * the position of the component reference point in world coordinates
     */ position;
    /**
     * The vector from (0,0) to the reference position of the component (in local coordinates, i.e. without rotation, translation and scaling)
     */ referencePosition;
    /**
     * all properties, which should be able to be edited in the properties window have to be included here
     */ properties;
    /**
     * the name of the component (e.g. "Resistor", "Wire" or "Transformer")
     */ displayName;
    /**
     * For keeping track of the parent group of this component if one exists.
     */ parentGroup = null;
    /**
     * If the component is currently selected by the selection controller
     */ _isSelected = false;
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(value) {
        if (!value) {
            if (this.isSelectionReference) (0, _internal.SelectionController).instance.referenceComponent = null;
            this.isSelectionReference = false;
        }
        this._isSelected = value;
    }
    /**
     * the cached bounding box of the component in world coordinates. Useful for example for the selection controller
     */ _bbox;
    /**
     * getter for the cached bounding box
     */ get bbox() {
        return this._bbox;
    }
    /**
     * the SVG.js Element which represents the visualization/graphics of the component on the canvas. This includes the actual component as well the label, the element used for dragging and other parts. Should probably always be a group containing more svg components
     */ visualization;
    /**
     * The SVG.js Element which is used to visualize the selection of the component. Should probably always be a rectangle
     */ selectionElement = null;
    /**
     * The SVG.js Element which is used to visualize the component. This has to be added to the visualization element as a child @see CircuitComponent.visualization
     */ componentVisualization;
    /**
     * the element which can be grabbed and dragged. Mostly the whole visualization, but for some components it might be a sub-element
     */ dragElement;
    /**
     * A List of all the Snapping points of this component
     */ snappingPoints;
    /**
     * A map of all the properties which are used by this component. The key is the ID of the property, which can be used to filter for multi-component editing
     */ componentProperties = new Map();
    _isHovered = false;
    get isHovered() {
        return this._isHovered;
    }
    set isHovered(value) {
        this._isHovered = value;
        this.showSeletedOrHovered();
    }
    /**
     * The default constructor giving basic functionality. Never call this directly (only via super() in the constructor of the derived class).
     */ constructor(){
        this.position = new _svgJs.Point();
        this.finishedPlacing = false;
        this.referencePosition = new _svgJs.Point();
        //every time a component is initialized, it should be added to the component list for housekeeping
        (0, _internal.MainController).instance.addComponent(this);
        this.selectionElement = (0, _internal.CanvasController).instance.canvas.rect(0, 0).hide();
        this.selectionElement.node.classList.add("selectionElement");
        this.selectionElement.node.style.pointerEvents = "none";
        this.visualization = (0, _internal.CanvasController).instance.canvas.group();
        this.dragElement = this.visualization;
        this.displayName = "Circuit Component";
        this.properties = new (0, _internal.PropertiesCollection)();
        this.addPositioning();
        this.addZOrdering();
    }
    /**
     * Add z-index ordering to the properties window
     */ addZOrdering() {
        // all components should receive the possiblity to change their draw order/z order/depth
        let ordering = new (0, _internal.ButtonGridProperty)(2, [
            [
                "Foreground",
                ""
            ],
            [
                "Background",
                ""
            ],
            [
                "Forward",
                ""
            ],
            [
                "Backward",
                ""
            ]
        ], [
            (ev)=>(0, _internal.CanvasController).instance.componentsToForeground([
                    this
                ]),
            (ev)=>(0, _internal.CanvasController).instance.componentsToBackground([
                    this
                ]),
            (ev)=>(0, _internal.CanvasController).instance.moveComponentsForward([
                    this
                ]),
            (ev)=>(0, _internal.CanvasController).instance.moveComponentsBackward([
                    this
                ])
        ], false, [
            "Bring the component to the foreground",
            "Move the component to the background",
            "Move the component one step towards the foreground",
            "Move the component one step towards the background"
        ]);
        this.properties.add((0, _internal.PropertyCategories).ordering, new (0, _internal.SectionHeaderProperty)("Ordering"));
        this.properties.add((0, _internal.PropertyCategories).ordering, ordering);
    }
    /**
     * Add rotation and flipping to the properties window
     */ addPositioning() {
        let positioning = new (0, _internal.ButtonGridProperty)(2, [
            [
                "Rotate 90\xb0 CW",
                "rotate_right"
            ],
            [
                "Rotate 90\xb0 CCW",
                "rotate_left"
            ],
            [
                "Rotate 45\xb0 CW",
                "rotate_right"
            ],
            [
                "Rotate 45\xb0 CCW ",
                "rotate_left"
            ],
            [
                "Flip vertically",
                [
                    "flip",
                    "rotateText"
                ]
            ],
            [
                "Flip horizontally",
                "flip"
            ]
        ], [
            (ev)=>{
                this.rotate(-90);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                this.rotate(90);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                this.rotate(-45);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                this.rotate(45);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                this.flip(true);
                (0, _internal.Undo).addState();
            },
            (ev)=>{
                this.flip(false);
                (0, _internal.Undo).addState();
            }
        ], false, [
            "Rotate the component 90 degrees clockwise",
            "Rotate the component 90 degrees counter clockwise",
            "Rotate the component 45 degrees clockwise",
            "Rotate the component 45 degrees counter clockwise",
            "Flip the component around its x-axis",
            "Flip the component around its y-axis"
        ]);
        this.properties.add((0, _internal.PropertyCategories).manipulation, positioning);
    }
    /**
     * Set this component draggable or not
     * @param drag if dragging should be enabled
     */ draggable(drag) {
        if (drag) this.visualization.node.classList.add("draggable");
        else this.visualization.node.classList.remove("draggable");
        (0, _internal.SnapDragHandler).snapDrag(this, drag, this.dragElement);
    }
    /**
     * update the graphics corresponding to the component selection visualization
     */ recalculateSelectionVisuals() {
        if (this.selectionElement) {
            let box = this.visualization.bbox().transform(this.getTransformMatrix());
            this.selectionElement.size(box.w, box.h);
            this.selectionElement.center(box.cx, box.cy);
        }
    }
    viewAsSelected = false;
    /**
     * Show or hide the selection visualization of the component. This has to be distinct from the actual selection state due to how the selection controller works
     * @param show if the component should appear selected or not
     */ viewSelected(show) {
        this.viewAsSelected = show;
        this.showSeletedOrHovered();
    }
    showSeletedOrHovered() {
        if (this.viewAsSelected || this.isHovered) {
            (0, _internal.CanvasController).instance.canvas.put(this.selectionElement);
            this.selectionElement.show();
            const color = this.isHovered ? (0, _selectionHelper.hoverColor) : this.isSelectionReference ? (0, _selectionHelper.referenceColor) : (0, _selectionHelper.selectionColor);
            this.selectionElement.stroke({
                width: (0, _selectionHelper.selectedBoxWidth),
                color: color,
                dasharray: this.isSelectionReference ? "1, 1" : "4, 2"
            }).fill("none");
            this.recalculateSelectionVisuals();
        } else this.selectionElement.hide();
    }
    isSelectionReference = false;
    setAsSelectionReference() {
        if ((0, _internal.SelectionController).instance.referenceComponent) {
            (0, _internal.SelectionController).instance.referenceComponent.isSelectionReference = false;
            (0, _internal.SelectionController).instance.referenceComponent.viewSelected((0, _internal.SelectionController).instance.referenceComponent.isSelected);
        }
        this.isSelectionReference = true;
        this.viewSelected(true);
    }
    /**
     * Checks if the component is inside the selection visualization. The default implementation is a rect-rect intersection check between the selection rectangle and the component bounding box. Override this for a more sophisticated check
     * @param selectionRectangle where the current selection is requested
     * @returns true if the selection rectangle encompases (a part of) the component
     */ isInsideSelectionRectangle(selectionRectangle) {
        return (0, _selectionHelper.rectRectIntersection)(this.bbox, selectionRectangle);
    }
    /**
     * Converts the Component into a ComponentSaveObject or a derived type therof. This should encompass all information necessary to reproduce this component via {@link fromJson}
     * Override this in your subclass and call the super() method to ensure that the base class properties are also included.
     */ toJson() {
        let saveObject = {
            type: "component"
        };
        return saveObject;
    }
    /**
     * Override this in subclasses if it should provide a way of building (parts of) a tikz node or path command (remember to always call the superclass via super.buildTikzCommand)
     * @param command an object representing the components of a tikz command
     * @param contextData the context needed to build (parts of) the command
     */ buildTikzCommand(command) {}
    /**
     * convert this component to be used with the svg export, i.e. clones the visualization and handles all use elements. override this to add custom functionality like removing additional elements.
     * @param defs which definitions this component uses should be added to the map<id, element>. defs should be checked before adding to avoid duplicates
     */ toSVG(defs) {
        const copiedSVG = this.visualization.clone(true);
        for (const use of copiedSVG.find("use")){
            let id = use.node.getAttribute("xlink:href") ?? use.node.getAttribute("href");
            if (id) {
                id = id.startsWith("#") ? id.slice(1) : id;
                if (!defs.has(id)) {
                    const element = new _svgJs.Element(document.getElementById(id).cloneNode(true));
                    defs.set(id, element);
                }
            }
        }
        return copiedSVG;
    }
    /**
     * Convert a ComponentSaveObject to a component. This requires 2 steps:
     * 1) Define a public static fromJson method which returns an instance of the component. This should only handle proper initialization and no parameter setting. See NodeSymbolComponent
     * 2) Override the applyJson method which should contain a super.applyJson call. This method should only handle parameters not already handled by the respective super class(es)
     */ applyJson(saveObject) {
        // highest level doesn't do anything (essentially only the type but this is not used here)
        (0, _internal.SnapCursorController).instance.visible = false;
        this.finishedPlacing = true;
        this.draggable(true);
    }
    static jsonSaveMap = new Map();
    static fromJson(saveObject) {
        const ComponentConstructor = CircuitComponent.jsonSaveMap.get(saveObject.type);
        if (ComponentConstructor == undefined) throw new Error('There is no component of type "' + saveObject.type + '" defined. Every non-abstract class deriving from CircuitComponent (or one of its subclasses) should have a static block, which registers it by setting the type as the key and the class itself as the value of the jsonSaveMap static variable (see NodeSymbolComponent as a reference)');
        if (!Object.hasOwn(ComponentConstructor, "fromJson")) throw new Error(ComponentConstructor.name + " does not implement a fromJson method! See CircuitComponent.applyJson for more info.");
        // @ts-ignore
        const component = ComponentConstructor.fromJson(saveObject);
        if (component) {
            component.applyJson(saveObject);
            return component;
        }
    }
    /**
     * Obtain the transformation matrix which transforms an object from the local coordinates to the world coordiantes.
     * Default implementation returns the identity matrix, i.e. local coordinates = world coordinates.
     *
     * Override this!
     *
     * @returns the transformation matrix
     */ getTransformMatrix() {
        return new _svgJs.Matrix();
    }
    /**
     * Update the position of all snapping points associated with this component.
     * @param matrix which matrix to use. probably the one returned by {@link getTransformMatrix}
     */ recalculateSnappingPoints(matrix) {
        for (const snappingPoint of this.snappingPoints)snappingPoint.recalculate(matrix);
    }
    /**
     * remove the component from the canvas
     */ remove() {
        (0, _internal.SnapDragHandler).snapDrag(this, false);
        this.visualization.remove();
        this.viewSelected(false);
        this.selectionElement?.remove();
    }
    // component placement code
    /**
     * if the component is finished placing down/creating
     */ finishedPlacing = false;
    /**
     * Override this if the component can be rotated while placing down. @see CircuitComponent.rotate for details
     * @param angleDeg how far to rotate
     */ placeRotate(angleDeg) {}
    /**
     * Override this if the component can be flipped while placing down. @see CircuitComponent.flip for details
     * @param horizontal on which axis to rotate
     */ placeFlip(horizontal) {}
    /**
     * Returns the list of TikZ libraries which are required for this component to work. This is used to automatically include the libraries in the generated code.
     *
     * Override this to add libraries
     * @returns a list of tikz library names (strings)
     */ requiredTikzLibraries() {
        return [];
    }
}

},{"@svgdotjs/svg.js":"fFByv","@svgdotjs/svg.draggable.js":"7sIjU","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7sIjU":[function(require,module,exports,__globalThis) {
var _svgJs = require("@svgdotjs/svg.js");
const getCoordsFromEvent = (ev)=>{
    if (ev.changedTouches) ev = ev.changedTouches[0];
    return {
        x: ev.clientX,
        y: ev.clientY
    };
};
// Creates handler, saves it
class DragHandler {
    constructor(el){
        el.remember('_draggable', this);
        this.el = el;
        this.drag = this.drag.bind(this);
        this.startDrag = this.startDrag.bind(this);
        this.endDrag = this.endDrag.bind(this);
    }
    // Enables or disabled drag based on input
    init(enabled) {
        if (enabled) {
            this.el.on('mousedown.drag', this.startDrag);
            this.el.on('touchstart.drag', this.startDrag, {
                passive: false
            });
        } else {
            this.el.off('mousedown.drag');
            this.el.off('touchstart.drag');
        }
    }
    // Start dragging
    startDrag(ev) {
        const isMouse = !ev.type.indexOf('mouse');
        // Check for left button
        if (isMouse && ev.which !== 1 && ev.buttons !== 0) return;
        // Fire beforedrag event
        if (this.el.dispatch('beforedrag', {
            event: ev,
            handler: this
        }).defaultPrevented) return;
        // Prevent browser drag behavior as soon as possible
        ev.preventDefault();
        // Prevent propagation to a parent that might also have dragging enabled
        ev.stopPropagation();
        // Make sure that start events are unbound so that one element
        // is only dragged by one input only
        this.init(false);
        this.box = this.el.bbox();
        this.lastClick = this.el.point(getCoordsFromEvent(ev));
        const eventMove = (isMouse ? 'mousemove' : 'touchmove') + '.drag';
        const eventEnd = (isMouse ? 'mouseup' : 'touchend') + '.drag';
        // Bind drag and end events to window
        (0, _svgJs.on)(window, eventMove, this.drag, this, {
            passive: false
        });
        (0, _svgJs.on)(window, eventEnd, this.endDrag, this, {
            passive: false
        });
        // Fire dragstart event
        this.el.fire('dragstart', {
            event: ev,
            handler: this,
            box: this.box
        });
    }
    // While dragging
    drag(ev) {
        const { box, lastClick } = this;
        const currentClick = this.el.point(getCoordsFromEvent(ev));
        const dx = currentClick.x - lastClick.x;
        const dy = currentClick.y - lastClick.y;
        if (!dx && !dy) return box;
        const x = box.x + dx;
        const y = box.y + dy;
        this.box = new (0, _svgJs.Box)(x, y, box.w, box.h);
        this.lastClick = currentClick;
        if (this.el.dispatch('dragmove', {
            event: ev,
            handler: this,
            box: this.box,
            dx,
            dy
        }).defaultPrevented) return;
        this.move(x, y);
    }
    move(x, y) {
        // Svg elements bbox depends on their content even though they have
        // x, y, width and height - strange!
        // Thats why we handle them the same as groups
        if (this.el.type === 'svg') (0, _svgJs.G).prototype.move.call(this.el, x, y);
        else this.el.move(x, y);
    }
    endDrag(ev) {
        // final drag
        this.drag(ev);
        // fire dragend event
        this.el.fire('dragend', {
            event: ev,
            handler: this,
            box: this.box
        });
        // unbind events
        (0, _svgJs.off)(window, 'mousemove.drag');
        (0, _svgJs.off)(window, 'touchmove.drag');
        (0, _svgJs.off)(window, 'mouseup.drag');
        (0, _svgJs.off)(window, 'touchend.drag');
        // Rebind initial Events
        this.init(true);
    }
}
(0, _svgJs.extend)((0, _svgJs.Element), {
    draggable (enable = true) {
        const dragHandler = this.remember('_draggable') || new DragHandler(this);
        dragHandler.init(enable);
        return this;
    }
});

},{"@svgdotjs/svg.js":"fFByv"}],"6xV6c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * abstract super class for all path components
 * This includes all components that are represented by a path, i.e. are drawn via a tikz path command with 2 or more reference points, where said reference points should be adjustable.
 *
 * Examples are: resistors, capacitors, inductors, diodes, sources, polygons, wires, arrows, arcs, etc.
 *
 * Extend this class to create a new component which is represented by a path.
 *
 * PathComponents are edited/adjusted in world coordinates via their referencePoints. Transformations like translation (moving), rotation, scaling and flipping are done by adjusting changing the referencePoints
 */ parcelHelpers.export(exports, "PathComponent", ()=>PathComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class PathComponent extends (0, _internal.CircuitComponent) {
    /**
     * how many reference points this path component should consist of. Standard is 2, i.e. a path with a start and end point. Set this to -1 to allow an arbitrary number of points.
     */ pointLimit = 2;
    /**
     * the points of the path component in world coordinates
     */ referencePoints;
    /**
     * the SVG elements which represent the reference points of this path component
     * These are used to drag the reference points around.
     */ resizableSVGs;
    /**
     * if the component is currently being adjusted, i.e. the reference points are being shown
     */ isResizing = false;
    constructor(){
        super();
        this.referencePoints = [];
        this.resizableSVGs = [];
        (0, _internal.SnapCursorController).instance.visible = true;
    }
    moveRel(delta) {
        for(let index = 0; index < this.referencePoints.length; index++)this.referencePoints[index] = this.referencePoints[index].add(delta);
        this.update();
    }
    moveTo(position) {
        let diff = position.sub(this.position);
        this.moveRel(diff);
    }
    movePointTo(index, position) {
        if (index < 0 || index >= this.referencePoints.length) throw new Error(`Index ${index} out of bounds for reference points array of length ${this.referencePoints.length}`);
        this.referencePoints[index] = new _svgJs.Point(position);
        this.update();
    }
    recalculateResizePoints() {
        if (this.resizableSVGs.length == this.referencePoints.length) // const transformMatrix = this.getTransformMatrix()
        for(let index = 0; index < this.referencePoints.length; index++){
            const point = this.referencePoints[index];
            const viz = this.resizableSVGs[index];
            viz.center(point.x, point.y);
        }
    }
    resizable(enable) {
        if (this.isResizing == enable) return;
        this.isResizing = enable;
        if (enable) {
            let startPositions = [];
            for(let index = 0; index < this.referencePoints.length; index++){
                let elementSVG = (0, _selectionHelper.resizeSVG)();
                elementSVG.node.style.cursor = "move";
                this.resizableSVGs.push(elementSVG);
                startPositions.push(new _svgJs.Point());
                (0, _internal.AdjustDragHandler).snapDrag(this, elementSVG, true, {
                    dragStart: (pos)=>{
                        startPositions[index] = new _svgJs.Point(this.referencePoints[index]);
                    },
                    dragMove: (pos)=>{
                        this.movePointTo(index, pos);
                    },
                    dragEnd: ()=>{
                        return startPositions[index].eq(this.referencePoints[index]);
                    }
                });
            }
        } else {
            for (const pointSVG of this.resizableSVGs){
                (0, _internal.AdjustDragHandler).snapDrag(this, pointSVG, false);
                pointSVG?.remove();
            }
            this.resizableSVGs = [];
        }
        this.update();
    }
    toJson() {
        let data = super.toJson();
        data.points = this.referencePoints.map((point)=>point.simplifyForJson());
        return data;
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        this.referencePoints = saveObject.points ? saveObject.points.map((point)=>new _svgJs.Point(point)) : [];
    }
    rotate(angleDeg) {
        this.referencePoints = this.referencePoints.map((point)=>point.rotate(angleDeg, this.position));
        this.update();
    }
    flip(horizontalAxis) {}
    placeMove(pos, ev) {
        if (this.referencePoints.length > 0) this.movePointTo(this.referencePoints.length - 1, pos);
    }
    placeStep(pos, ev) {
        if (this.finishedPlacing) return true;
        if (this.referencePoints.length == 0) {
            this.referencePoints.push(pos.clone());
            this.visualization.show();
            this.updateTheme();
        } else {
            if (this.referencePoints.at(-2).eq(pos)) return true;
        }
        if (this.pointLimit > 0 && this.referencePoints.length >= this.pointLimit) {
            this.placeMove(pos, ev);
            this.referencePoints.push(new _svgJs.Point());
            return true;
        }
        this.referencePoints.push(pos);
        this.placeMove(pos, ev);
        return false;
    }
    placeFinish() {
        if (this.finishedPlacing) return;
        if (this.referencePoints.length == 0) this.placeStep(new _svgJs.Point());
        this.referencePoints.pop();
        if (this.referencePoints.length >= 2 && this.referencePoints.at(-1).eq(this.referencePoints.at(-2))) this.referencePoints.pop();
        if (this.referencePoints.length < 2) {
            // if not even 2 corner points -> no polygon, delete
            (0, _internal.MainController).instance.removeComponent(this);
            return;
        }
        this.finishedPlacing = true;
        this.update();
    }
    toTikzString() {
        let command = {
            options: [],
            additionalNodes: [],
            connectors: [],
            coordinates: []
        };
        this.buildTikzCommand(command);
        return (0, _internal.buildTikzStringFromPathCommand)(command);
    }
    buildTikzCommand(command) {
        super.buildTikzCommand(command);
        command.coordinates.push(...this.referencePoints);
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lAjjL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "basicDirections", ()=>basicDirections);
parcelHelpers.export(exports, "defaultBasicDirection", ()=>defaultBasicDirection);
/**
 * abstract super class for all node components.
 * This includes all components that are represented by a node, i.e. are drawn via a tikz node command at a single position.
 *
 * Examples are: transistors, ground, rectangles, text boxes, etc.
 *
 * Extend this class to create a new component which is represented by a node.
 *
 * NodeComponents are edited/adjusted in local coordinates. Transformations like translation (moving), rotation, scaling and flipping are done by changing the transformation Matrix
 */ parcelHelpers.export(exports, "NodeComponent", ()=>NodeComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _circuitComponent = require("./circuitComponent");
const basicDirections = [
    {
        key: "default",
        name: "default",
        direction: new _svgJs.Point(NaN, NaN)
    },
    {
        key: "center",
        name: "center",
        direction: new _svgJs.Point()
    },
    {
        key: "north",
        name: "north",
        direction: new _svgJs.Point(0, -1),
        pointer: "ns-resize"
    },
    {
        key: "south",
        name: "south",
        direction: new _svgJs.Point(0, 1),
        pointer: "ns-resize"
    },
    {
        key: "east",
        name: "east",
        direction: new _svgJs.Point(1, 0),
        pointer: "ew-resize"
    },
    {
        key: "west",
        name: "west",
        direction: new _svgJs.Point(-1, 0),
        pointer: "ew-resize"
    },
    {
        key: "northeast",
        name: "north east",
        direction: new _svgJs.Point(1, -1),
        pointer: "nesw-resize"
    },
    {
        key: "northwest",
        name: "north west",
        direction: new _svgJs.Point(-1, -1),
        pointer: "nwse-resize"
    },
    {
        key: "southeast",
        name: "south east",
        direction: new _svgJs.Point(1, 1),
        pointer: "nwse-resize"
    },
    {
        key: "southwest",
        name: "south west",
        direction: new _svgJs.Point(-1, 1),
        pointer: "nesw-resize"
    }
];
const defaultBasicDirection = basicDirections[0];
class NodeComponent extends (0, _internal.PositionLabelable)((0, _internal.Nameable)((0, _circuitComponent.CircuitComponent))) {
    /**
     * the current rotation angle in degrees
     */ rotationDeg = 0;
    scaleState;
    /**
     * the component size in local coordinates
     */ size;
    resizeVisualizations;
    isResizing = false;
    // where the text should go by default in local coordinates
    defaultTextPosition;
    constructor(){
        super();
        this.position = new _svgJs.Point();
        this.size = new _svgJs.Point();
        this.rotationDeg = 0;
        this.scaleState = new _svgJs.Point(1, 1);
        this.defaultTextPosition = new _svgJs.Point();
    }
    placeMove(pos) {
        this.moveTo(pos);
    }
    placeRotate(angleDeg) {
        this.rotate(angleDeg);
    }
    placeFlip(horizontal) {
        this.flip(horizontal);
    }
    placeStep(pos) {
        this.moveTo(pos);
        return true;
    }
    placeFinish() {
        // make draggable
        this.finishedPlacing = true;
        this.update();
    }
    remove() {
        super.remove();
        this.labelRendering?.remove();
    }
    moveRel(delta) {
        this.moveTo(this.position.add(delta));
    }
    getTransformMatrix() {
        return new _svgJs.Matrix({
            scaleX: this.scaleState.x,
            scaleY: this.scaleState.y,
            translate: [
                -this.referencePosition.x,
                -this.referencePosition.y
            ],
            origin: [
                this.referencePosition.x,
                this.referencePosition.y
            ]
        }).lmultiply(new _svgJs.Matrix({
            rotate: -this.rotationDeg,
            translate: [
                this.position.x,
                this.position.y
            ]
        }));
    }
    updateTheme() {
        let labelColor = (0, _internal.defaultStroke);
        if (this.labelColor && this.labelColor.value) labelColor = this.labelColor.value.toString();
        this.labelRendering?.fill(labelColor);
    }
    recalculateResizePoints() {}
    moveTo(position) {
        this.position = position.clone();
        this.update();
    }
    rotate(angleDeg) {
        this.rotationDeg += angleDeg;
        this.simplifyRotationAngle();
        this.update();
    }
    /**
     * helper method to always be between -180 and 180 degrees.
     */ simplifyRotationAngle() {
        // modulo with extra steps since js modulo is weird for negative numbers
        this.rotationDeg = ((this.rotationDeg + 180) % 360 + 360) % 360 - 180;
    }
    flip(horizontal) {
        if (horizontal) {
            this.scaleState.y *= -1;
            this.rotationDeg *= -1;
        } else {
            this.scaleState.y *= -1;
            this.rotationDeg = 180 - this.rotationDeg;
        }
        this.simplifyRotationAngle();
        this.update();
    }
    toJson() {
        const data = super.toJson();
        data.position = this.position.simplifyForJson();
        if (this.rotationDeg !== 0) data.rotation = this.rotationDeg;
        if (this.scaleState && (this.scaleState.x != 1 || this.scaleState.y != 1)) data.scale = this.scaleState;
        return data;
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        this.position = new _svgJs.Point(saveObject.position);
        // @ts-ignore
        if (saveObject.rotation || saveObject.rotationDeg) // @ts-ignore
        this.rotationDeg = saveObject.rotation ?? saveObject.rotationDeg;
        if (saveObject.scale) this.scaleState = new _svgJs.Point(saveObject.scale);
    }
    toTikzString() {
        let command = {
            additionalNodes: [],
            options: []
        };
        this.buildTikzCommand(command);
        return (0, _internal.buildTikzStringFromNodeCommand)(command);
    }
    buildTikzCommand(command) {
        super.buildTikzCommand(command);
        command.position = this.position;
        let [rotation, scale] = (0, _internal.simpifyRotationAndScale)(this.rotationDeg, this.scaleState);
        if (rotation !== 0) command.options.push("rotate=" + rotation);
        if (scale.x != 1) command.options.push("xscale=" + scale.x);
        if (scale.y != 1) command.options.push("yscale=" + scale.y);
        const shouldAddLabel = this.mathJaxLabel.value !== "";
        command.name = this.buildTikzName(shouldAddLabel);
        if (shouldAddLabel) command.additionalNodes.push(this.buildTikzNodeLabel(command.name));
    }
    updatePositionedLabel() {
        if (!this.mathJaxLabel.value || !this.labelRendering) return;
        let labelSVG = this.labelRendering;
        let transformMatrix = this.getTransformMatrix();
        let textPos; // in local coords
        let textDir; // normalized direction to size (length not normalized) in local coords
        let halfSize = this.size.div(2);
        // calculate the text position in world space
        if (this.positionChoice.value.key == defaultBasicDirection.key) {
            textPos = this.defaultTextPosition.transform(transformMatrix);
            this.labelPos = undefined;
            textDir = (0, _internal.closestBasicDirection)(this.defaultTextPosition.sub(halfSize).div(halfSize)).direction;
        } else {
            if (this.labelReferenceProperty.value.key == "canvas") {
                // the component should be placed absolute to the canvas
                // bring desired direction into local coordinates
                textDir = this.positionChoice.value.direction.transform(new _svgJs.Matrix({
                    rotate: -this.rotationDeg,
                    scaleX: Math.sign(this.scaleState.x),
                    scaleY: Math.sign(this.scaleState.y)
                }).inverse());
                // check which label direction should be used to get the final correct direction
                this.labelPos = (0, _internal.closestBasicDirection)(textDir);
            } else // just use whatever is selected
            this.labelPos = this.positionChoice.value;
            textDir = this.labelPos.direction;
            textPos = halfSize.add(textDir.mul(halfSize)).transform(transformMatrix);
        }
        let labelBBox = labelSVG.bbox();
        // calculate where on the label the anchor point should be
        let labelDist = this.labelDistance.value.convertToUnit("px").value ?? 0;
        if (this.anchorChoice.value.key == defaultBasicDirection.key) {
            //transform anchor direction back to global coordinates
            let labelRefDir = textDir.mul(-1).transform(new _svgJs.Matrix({
                rotate: -this.rotationDeg,
                scaleX: Math.sign(this.scaleState.x),
                scaleY: Math.sign(this.scaleState.y)
            }));
            // check which direction should be used to get the final correct direction
            this.anchorPos = (0, _internal.closestBasicDirection)(labelRefDir);
        } else // an explicit anchor was selected
        this.anchorPos = this.anchorChoice.value;
        let labelRef = this.anchorPos.direction;
        let ref = labelRef.add(1).div(2).mul(new _svgJs.Point(labelBBox.w, labelBBox.h)).add(new _svgJs.Point(labelBBox.x, labelBBox.y)).add(labelRef.mul(labelDist));
        labelSVG.transform({
            translate: textPos.sub(ref)
        });
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","./circuitComponent":"1yrgf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Xjna":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * used to place all components via user input
 */ parcelHelpers.export(exports, "ComponentPlacer", ()=>ComponentPlacer);
var _internal = require("../internal");
var _hotkeysJs = require("hotkeys-js");
var _hotkeysJsDefault = parcelHelpers.interopDefault(_hotkeysJs);
class ComponentPlacer {
    //singleton
    static _instance;
    /**
     * the currently placing component
     */ _component;
    get component() {
        return this._component;
    }
    previousComponent = null;
    constructor(){
        this.placeStep = this.placeStep.bind(this);
        this.placeMove = this.placeMove.bind(this);
        this.placeFinish = this.placeFinish.bind(this);
    }
    static get instance() {
        return ComponentPlacer._instance ?? (ComponentPlacer._instance = new ComponentPlacer());
    }
    static pointFromEvent(ev) {
        let pt = (0, _internal.CanvasController).eventToPoint(ev, false);
        // let pt:SVG.Point = new SVG.Point(ev.clientX, ev.clientY).transform(component.visualization.screenCTM().inverseO())
        if (!ev.shiftKey) pt = (0, _internal.SnapController).instance.snapPoint(pt, ComponentPlacer.instance.component);
        return pt;
    }
    /**
     * Initiate one placement step
     * @param ev which event is responsible for the placement step
     */ placeStep(ev) {
        if (ev instanceof MouseEvent && ev.button !== 0) return;
        if (window.TouchEvent && ev instanceof TouchEvent && ev.touches.length !== 0) return;
        let pt = ComponentPlacer.pointFromEvent(ev);
        if (this.component.placeStep(pt, ev)) this.placeFinish(ev);
        (0, _internal.SnapController).instance.recalculateAdditionalSnapPoints();
    }
    /**
     * Move the cursor/pointer/... while placing a component
     * @param ev which event is responsible for the movement
     */ placeMove(ev) {
        let pt = ComponentPlacer.pointFromEvent(ev);
        this.component.placeMove(pt, ev);
        (0, _internal.SnapController).instance.showSnapPoints(!ev.shiftKey);
        (0, _internal.SnapController).instance.recalculateAdditionalSnapPoints();
        (0, _internal.SnapCursorController).instance.moveTo(pt);
    }
    /**
     * Rotate the component while placing
     * @param angleDeg angle in degrees
     */ placeRotate(angleDeg) {
        if (this.component) this.component.placeRotate(angleDeg);
    }
    /**
     * Flip the component while placing
     * @param horizontal which axis to flip at
     */ placeFlip(horizontal) {
        if (this.component) this.component.placeFlip(horizontal);
    }
    /**
     * (Force) finish the component placement
     */ placeFinish(ev) {
        if (this.component) {
            this.component.placeFinish();
            this.cleanUp();
            (0, _internal.Undo).addState();
            // restart component placement for just finished component
            if (window.TouchEvent && !(ev instanceof TouchEvent)) {
                this.previousComponent = this.component;
                this.placeComponent(this.component.copyForPlacement());
            } else {
                this._component = null;
                (0, _internal.MainController).instance.switchMode((0, _internal.Modes).DRAG_PAN);
            }
        }
    }
    /**
     * cancel the component placement
     * @param ev which event is responsible for the cancellation
     */ placeCancel(ev) {
        let component = this.component;
        if (component) {
            component.placeFinish();
            (0, _internal.MainController).instance.removeComponent(component);
            this._component = null;
        }
        if (this.previousComponent) (0, _internal.SelectionController).instance.selectComponents([
            this.previousComponent
        ], (0, _internal.SelectionMode).RESET);
        this.previousComponent = null;
        this.cleanUp();
        (0, _internal.SnapCursorController).instance.visible = false;
        (0, _internal.MainController).instance.switchMode((0, _internal.Modes).DRAG_PAN);
    }
    /**
     * Get rid of now not needed event listeners
     */ cleanUp() {
        (0, _internal.SnapController).instance.showSnapPoints(false);
        //remove event listeners
        let canvas = (0, _internal.CanvasController).instance.canvas;
        canvas.off("mousemove", this.placeMove);
        canvas.off("touchmove", this.placeMove);
        canvas.off("mouseup", this.placeStep);
        canvas.off("touchend", this.placeStep);
        // canvas.off("dblclick",this.placeFinish)
        (0, _hotkeysJsDefault.default).unbind("enter", this.placeFinish);
    }
    /**
     * Place a new Component. The component should be an initialized instance of a CircuitComponent
     * @param component which component to place
     */ placeComponent(component) {
        (0, _internal.MainController).instance.switchMode((0, _internal.Modes).COMPONENT);
        this._component = component;
        (0, _internal.SnapController).instance.updateSnapPoints(component, false);
        (0, _internal.SnapController).instance.showSnapPoints();
        (0, _internal.PropertyController).instance.update();
        // add event listeners to canvas
        let canvas = (0, _internal.CanvasController).instance.canvas;
        canvas.on("mousemove", this.placeMove);
        canvas.on("touchmove", this.placeMove);
        canvas.on("mouseup", this.placeStep);
        canvas.on("touchend", this.placeStep);
        (0, _hotkeysJsDefault.default)("enter", {
            keyup: false,
            keydown: true
        }, this.placeFinish);
        // move once to actually place the component at the mouse position
        this.component.placeMove((0, _internal.CanvasController).instance.lastCanvasPoint);
        (0, _internal.SnapCursorController).instance.moveTo((0, _internal.SnapController).instance.snapPoint((0, _internal.CanvasController).instance.lastCanvasPoint, component));
        (0, _internal.SnapController).instance.recalculateAdditionalSnapPoints();
    }
}

},{"../internal":"f6vBb","hotkeys-js":"7tDMU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eN8C9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Representation of a symbol and its metadata
 */ parcelHelpers.export(exports, "ComponentSymbol", ()=>ComponentSymbol);
var _svgJs = require("@svgdotjs/svg.js");
var _impSVGNumber = require("../utils/impSVGNumber");
var _internal = require("../internal");
class ComponentSymbol extends _svgJs.Symbol {
    _mapping;
    possibleOptions;
    possibleEnumOptions;
    /**
     * what the component is called
     */ displayName;
    /**
     * the tikz id
     */ tikzName;
    /**
     * in which group the symbol is located
     */ groupName;
    viewBox;
    isNodeSymbol;
    symbolElement;
    /**
     * which tikz options where used for this symbol
     */ _tikzOptions;
    maxStroke = 0;
    constructor(componentMetadata){
        const variants = componentMetadata.getElementsByTagName("variant");
        const firstSymbol = componentMetadata.ownerDocument.getElementById(variants[0].getAttribute("for"));
        super(firstSymbol);
        this.isNodeSymbol = componentMetadata.getAttribute("type") == "node";
        this.tikzName = componentMetadata?.getAttribute("tikz") ?? null;
        this.displayName = componentMetadata?.getAttribute("display") ?? this.tikzName;
        this.groupName = componentMetadata?.getAttribute("group") ?? null;
        const tikzOptions = componentMetadata.getElementsByTagName("options")[0];
        if (tikzOptions) {
            this.possibleEnumOptions = Array.from(tikzOptions.getElementsByTagName("enumopt")).map((enumOption)=>{
                return {
                    options: Array.from(enumOption.getElementsByTagName("option")).map(this.optionMetadataToSymbolOption),
                    selectNone: enumOption.hasAttribute("selectNone") ? enumOption.getAttribute("selectNone") == "true" : true,
                    displayName: enumOption.getAttribute("name") ?? "Choose an option"
                };
            });
            this.possibleOptions = Array.from(tikzOptions.getElementsByTagName("option")).filter((option)=>{
                return option.parentElement.tagName == "options";
            }).map((option)=>this.optionMetadataToSymbolOption(option));
        } else {
            this.possibleOptions = [];
            this.possibleEnumOptions = [];
        }
        this.viewBox = new _svgJs.Box(variants[0].getAttribute("viewBox"));
        this._mapping = new Map();
        for (const variant of variants){
            // get options
            var symbolOptions = this.getOptionsFromOptionNames(Array.from(variant.getElementsByTagName("option")).map((option)=>option.getAttribute("name")));
            const symbolID = variant.getAttribute("for");
            const symbol = new _svgJs.Symbol(componentMetadata.ownerDocument.getElementById(symbolID));
            let maxStroke = 0;
            if (symbol.node.id) {
                symbol.node.querySelectorAll("[stroke-width]").forEach((item)=>{
                    let strokeWidth = Number.parseFloat(item.getAttribute("stroke-width"));
                    maxStroke = strokeWidth > maxStroke ? strokeWidth : maxStroke;
                });
                // udpate the bbox for a tighter fit
                let use = (0, _internal.CanvasController).instance.canvas.use(symbol.node.id);
                let usenode = use.node;
                const domrect = usenode.getBBox({
                    stroke: true,
                    markers: true
                });
                let box = new _svgJs.Box(domrect.x, domrect.y, domrect.width, domrect.height);
                variant.setAttribute("viewBox", box.toString());
                use.remove();
            }
            let pinArray = Array.from(variant.getElementsByTagName("pin")) ?? [];
            const pins = pinArray.map(this.parseAnchor, this);
            const defaultAnchor = pins.find((pin)=>pin.isDefault) || {
                name: "center",
                x: new _svgJs.Number(),
                y: new _svgJs.Number(),
                isDefault: true,
                point: new _svgJs.Point(0, 0)
            };
            const textPositionElement = variant.getElementsByTagName("textpos")[0];
            let textAnchor;
            if (textPositionElement) {
                textAnchor = this.parseAnchor(textPositionElement);
                textAnchor.name = "text";
            } else textAnchor = defaultAnchor;
            var variantObject = {
                mid: new _svgJs.Point((0, _impSVGNumber.ensureInPx)(variant.getAttribute("x") ?? 0), (0, _impSVGNumber.ensureInPx)(variant.getAttribute("y") ?? 0)),
                viewBox: new _svgJs.Box(variant.getAttribute("viewBox")),
                symbol: new _svgJs.Symbol(componentMetadata.ownerDocument.getElementById(symbolID)),
                pins: pins,
                textPosition: textAnchor,
                defaultAnchor: defaultAnchor,
                options: symbolOptions,
                maxStroke: maxStroke
            };
            const clickElement = symbol.rect(variantObject.viewBox.width, variantObject.viewBox.height).center(variantObject.viewBox.cx, variantObject.viewBox.cy);
            clickElement.fill("transparent").stroke("none").addClass("clickBackground");
            symbol.add(clickElement);
            this._mapping.set(this.optionsToStringArray(symbolOptions).join(", "), variantObject);
        }
        const first = this._mapping.values().toArray()[0];
        this.symbolElement = first.symbol;
        this.maxStroke = first.maxStroke;
    }
    optionMetadataToSymbolOption(option) {
        return {
            name: option.getAttribute("name"),
            displayName: option.getAttribute("display") ?? undefined
        };
    }
    optionsToStringArray(options) {
        return options.sort((a, b)=>{
            if (a.name < b.name) return -1;
            else if (a.name > b.name) return 1;
            return 0;
        }).map((option)=>{
            return option.name;
        });
    }
    getVariant(options) {
        return this._mapping.get(this.optionsToStringArray(options).join(", "));
    }
    /**
     * Parses an anchor (pin, anchor and textPosition). If `isDefault` is set, `this.defaultAnchor` will be set.
     *
     * @param {Element} anchorElement - the element to parse
     * @returns {TikZAnchor} the parsed anchor
     */ parseAnchor(anchorElement) {
        const numberRegEx = /^(\d*\.)?\d+$/; // "1", ".1", "1.1"; but not "1."
        let anchor = {
            name: anchorElement.getAttribute("name") || anchorElement.getAttribute("anchorname") || undefined,
            x: new _svgJs.Number(anchorElement.getAttribute("x") ?? "0"),
            y: new _svgJs.Number(anchorElement.getAttribute("y") ?? "0"),
            isDefault: Boolean(anchorElement.getAttribute("isDefault")) || Boolean(anchorElement.getAttribute("isdefault")) || false
        };
        if (typeof anchor.x === "string" && numberRegEx.test(anchor.x)) anchor.x = new _svgJs.Number(anchor.x);
        if (typeof anchor.y === "string" && numberRegEx.test(anchor.y)) anchor.y = new _svgJs.Number(anchor.y);
        if (typeof anchor.isDefault !== "boolean") anchor.isDefault = anchor.isDefault === "true";
        anchor.point = new _svgJs.Point((0, _impSVGNumber.ensureInPx)(anchor.x), (0, _impSVGNumber.ensureInPx)(anchor.y));
        return anchor;
    }
    getOptionsFromOptionNames(options) {
        const result = [];
        function optionsEqual(opt1, opt2) {
            const optionReplaced = opt2.replaceAll(" ", "-");
            return (opt1.displayName ? opt1.displayName.replaceAll(" ", "-") == optionReplaced : false) || opt1.name.replaceAll(" ", "-") == optionReplaced;
        }
        for (const option of options){
            let foundOption = this.possibleOptions.find((value)=>optionsEqual(value, option));
            if (foundOption) result.push(foundOption);
            else for (const enumOption of this.possibleEnumOptions){
                foundOption = enumOption.options.find((value)=>optionsEqual(value, option));
                if (foundOption) {
                    result.push(foundOption);
                    break;
                }
            }
        }
        return result;
    }
    getOptionsFromSymbolID(id) {
        const idSplit = id.split(this.tikzName.replaceAll(" ", "-"))[1];
        if (idSplit == "") return [];
        const options = idSplit.split("_").slice(1);
        return this.getOptionsFromOptionNames(options);
    }
}

},{"@svgdotjs/svg.js":"fFByv","../utils/impSVGNumber":"iUHL8","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d2BGD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The class representing all node components which are based on static symbols from the symbol database, i.e. node circuitikz symbols
 */ parcelHelpers.export(exports, "NodeSymbolComponent", ()=>NodeSymbolComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class NodeSymbolComponent extends (0, _internal.NodeComponent) {
    static jsonID = "node";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(NodeSymbolComponent.jsonID, NodeSymbolComponent);
    }
    /**
     * All the possible symbol variants for this node component.
     */ referenceSymbol;
    optionProperties;
    optionEnumProperties;
    componentVariant;
    scaleProperty;
    constructor(symbol){
        super();
        this.displayName = symbol.displayName;
        this.referenceSymbol = symbol;
        this.optionProperties = new Map();
        this.optionEnumProperties = new Map();
        this.scaleState = new _svgJs.Point(1, 1);
        this.scaleProperty = new (0, _internal.SliderProperty)("Scale", 0.1, 10, 0.01, new _svgJs.Number(1), true, undefined, "manipulation:scale");
        this.scaleProperty.addChangeListener((ev)=>{
            this.scaleState = new _svgJs.Point(Math.sign(this.scaleState.x) * ev.value.value, Math.sign(this.scaleState.y) * ev.value.value);
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).manipulation, this.scaleProperty);
        // initialize UI for options handling
        if (symbol.possibleOptions.length > 0 || symbol.possibleEnumOptions.length > 0) {
            this.properties.add((0, _internal.PropertyCategories).options, new (0, _internal.SectionHeaderProperty)("Options", undefined, "options:header"));
            for (const option of symbol.possibleOptions){
                const property = new (0, _internal.BooleanProperty)(option.displayName ?? option.name, false, undefined, "options:option" + option.name);
                property.addChangeListener((ev)=>{
                    this.updateOptions();
                });
                this.optionProperties.set(property, option);
                this.properties.add((0, _internal.PropertyCategories).options, property);
            }
            for (const enumOption of symbol.possibleEnumOptions){
                let choices = enumOption.selectNone ? [
                    {
                        key: "-",
                        name: "--default--"
                    }
                ] : [];
                enumOption.options.forEach((option)=>{
                    choices.push({
                        key: option.name,
                        name: option.displayName ?? option.name
                    });
                });
                const property = new (0, _internal.ChoiceProperty)(enumOption.displayName, choices, choices[0], undefined, "options:enum_" + enumOption.displayName);
                property.addChangeListener((ev)=>{
                    this.updateOptions();
                });
                this.optionEnumProperties.set(property, enumOption);
                this.properties.add((0, _internal.PropertyCategories).options, property);
            }
        }
        this.componentVariant = symbol.getVariant(this.optionsFromProperties());
        this.size = new _svgJs.Point(this.componentVariant.viewBox.w, this.componentVariant.viewBox.h);
        this.defaultTextPosition = this.componentVariant.textPosition.point.add(this.componentVariant.mid);
        this.componentVisualization = (0, _internal.CanvasController).instance.canvas.use(this.componentVariant.symbol);
        this.componentVisualization.fill((0, _internal.defaultFill));
        this.componentVisualization.stroke((0, _internal.defaultStroke));
        this.componentVisualization.node.style.color = (0, _internal.defaultStroke);
        this.referencePosition = this.componentVariant.mid;
        this.visualization.add(this.componentVisualization);
        this.dragElement = this.componentVisualization;
        this.addInfo();
        this.snappingPoints = this.componentVariant.pins.map((pin)=>new (0, _internal.SnapPoint)(this, pin.name, pin.point.add(this.componentVariant.mid)));
    }
    resizable(resize) {}
    optionsFromProperties() {
        const selectedOptions = [];
        this.optionProperties.forEach((option, property)=>{
            if (property.value) selectedOptions.push(option);
        });
        this.optionEnumProperties.forEach((option, property)=>{
            if (property.value.key != "-") selectedOptions.push(option.options.find((o)=>{
                return o.name == property.value.key;
            }));
        });
        return selectedOptions;
    }
    addInfo() {
        this.properties.add((0, _internal.PropertyCategories).info, new (0, _internal.SectionHeaderProperty)("Info"));
        // the tikz id of the component. e.g. "nmos" in "\node[nmos] at (0,0){};"
        this.properties.add((0, _internal.PropertyCategories).info, new (0, _internal.InfoProperty)("ID", this.referenceSymbol.tikzName));
    }
    setPropertiesFromOptions(options) {
        this.optionProperties.forEach((value, property)=>{
            if (options.find((op)=>op.name == value.name)) property.value = true;
            else property.value = false;
        });
        this.optionEnumProperties.forEach((enumOption, property)=>{
            let foundOption = false;
            for (const option of enumOption.options)if (options.find((op)=>op.name == option.name)) {
                foundOption = true;
                property.value = property.entries.find((entry)=>entry.key == option.name);
                break;
            }
            if (!foundOption) property.value = property.entries[0];
        });
        this.updateOptions();
    }
    updateOptions() {
        this.componentVariant = this.referenceSymbol.getVariant(this.optionsFromProperties());
        this.referencePosition = this.componentVariant.mid;
        this.componentVisualization.node.setAttribute("href", "#" + this.componentVariant.symbol.id());
        this.size = new _svgJs.Point(this.componentVariant.viewBox.w, this.componentVariant.viewBox.h);
        this.defaultTextPosition = this.componentVariant.textPosition.point.add(this.componentVariant.mid);
        this.snappingPoints = this.componentVariant.pins.map((pin)=>new (0, _internal.SnapPoint)(this, pin.name, pin.point.add(this.componentVariant.mid)));
        this.update();
    }
    getSnappingInfo() {
        return {
            trackedSnappingPoints: this.snappingPoints,
            additionalSnappingPoints: [
                new (0, _internal.SnapPoint)(this, "center", this.componentVariant.mid)
            ]
        };
    }
    update() {
        let m = this.getTransformMatrix();
        this.componentVisualization.transform(m);
        this._bbox = this.componentVariant.viewBox.transform(m);
        this.updatePositionedLabel();
        this.recalculateSelectionVisuals();
        this.recalculateSnappingPoints();
    }
    recalculateSelectionVisuals() {
        if (this.selectionElement) {
            // use the saved position instead of the bounding box (bbox position fails in safari)
            let bbox = this.componentVariant.viewBox;
            let maxStroke = this.componentVariant.maxStroke;
            this.selectionElement.size(bbox.w + maxStroke + (0, _selectionHelper.selectedBoxWidth), bbox.h + maxStroke + (0, _selectionHelper.selectedBoxWidth)).transform(this.getTransformMatrix().multiply(new _svgJs.Matrix({
                translate: [
                    bbox.x - ((0, _selectionHelper.selectedBoxWidth) + maxStroke) / 2,
                    bbox.y - ((0, _selectionHelper.selectedBoxWidth) + maxStroke) / 2
                ]
            })));
        }
    }
    toJson() {
        let data = super.toJson();
        data.type = NodeSymbolComponent.jsonID;
        data.id = this.referenceSymbol.tikzName;
        if (this.componentVariant.options.length > 0) data.options = this.componentVariant.options.map((option)=>option.displayName ?? option.name);
        if (this.name.value) data.name = this.name.value;
        return data;
    }
    toTikzString() {
        let command = {
            options: [
                this.referenceSymbol.tikzName
            ],
            additionalNodes: []
        };
        this.buildTikzCommand(command);
        return (0, _internal.buildTikzStringFromNodeCommand)(command);
    }
    buildTikzCommand(command) {
        command.options.push(...this.referenceSymbol.optionsToStringArray(this.optionsFromProperties()));
        super.buildTikzCommand(command);
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        let options = saveObject.options ?? [];
        this.setPropertiesFromOptions(this.referenceSymbol.getOptionsFromOptionNames(options));
        this.scaleProperty.value = new _svgJs.Number(Math.abs(this.scaleState.x));
        this.update();
        this.updateTheme();
    }
    static fromJson(saveObject) {
        let symbol;
        if ((0, _internal.SaveController).instance.currentlyLoadedSaveVersion != "") symbol = (0, _internal.MainController).instance.symbols.find((symbol)=>symbol.tikzName == saveObject.id);
        else {
            let idParts = saveObject.id.split("_");
            symbol = (0, _internal.MainController).instance.symbols.find((symbol)=>symbol.tikzName == idParts[1].replaceAll("-", " "));
            saveObject.options = idParts.slice(2);
        }
        if (symbol) {
            let nodeComponent = new NodeSymbolComponent(symbol);
            return nodeComponent;
        } else {
            console.error("no node symbol found for saveObject: " + JSON.stringify(saveObject));
            return null;
        }
    }
    copyForPlacement() {
        let newComponent = new NodeSymbolComponent(this.referenceSymbol);
        newComponent.rotationDeg = this.rotationDeg;
        newComponent.scaleState = new _svgJs.Point(this.scaleState);
        return newComponent;
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eLq3m":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PathSymbolComponent", ()=>PathSymbolComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class PathSymbolComponent extends (0, _internal.Currentable)((0, _internal.Voltageable)((0, _internal.PathLabelable)((0, _internal.Nameable)((0, _internal.PathComponent))))) {
    static jsonID = "path";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(PathSymbolComponent.jsonID, PathSymbolComponent);
    }
    referenceSymbol;
    startLine;
    endLine;
    startLineSelection;
    endLineSelection;
    selectionRect;
    dragStartLine;
    dragEndLine;
    /**
     * the vector in local coordinates from componentVariant.mid to the point where the first half of the path line should end
     */ relSymbolStart;
    /**
     * the vector in local coordinates from componentVariant.mid to the point where the second half of the path line should start
     */ relSymbolEnd;
    rotationDeg = 0;
    mirror;
    invert;
    scaleProperty;
    /**
     * the scale of the component, i.e. how much it is scaled compared to the original symbol size. this also includes mirroring and inverting.
     * It is greatly discouraged to use this property to scale the component, since an elegant solution in tikz does not exist for that.
     */ scaleState;
    optionProperties;
    optionEnumProperties;
    componentVariant;
    constructor(symbol){
        super();
        this.scaleState = new _svgJs.Point(1, 1);
        this.scaleProperty = new (0, _internal.SliderProperty)("Scale", 0.1, 10, 0.01, new _svgJs.Number(1), true, undefined, "manipulation:scale");
        this.scaleProperty.addChangeListener((ev)=>{
            this.scaleState = new _svgJs.Point(Math.sign(this.scaleState.x) * ev.value.value, Math.sign(this.scaleState.y) * ev.value.value);
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).manipulation, this.scaleProperty);
        this.optionProperties = new Map();
        this.optionEnumProperties = new Map();
        if (symbol.possibleOptions.length > 0 || symbol.possibleEnumOptions.length > 0) {
            this.properties.add((0, _internal.PropertyCategories).options, new (0, _internal.SectionHeaderProperty)("Options", undefined, "options:header"));
            for (const option of symbol.possibleOptions){
                const property = new (0, _internal.BooleanProperty)(option.displayName ?? option.name, false, undefined, "options:option" + option.name);
                property.addChangeListener((ev)=>{
                    this.updateOptions();
                });
                this.optionProperties.set(property, option);
                this.properties.add((0, _internal.PropertyCategories).options, property);
            }
            for (const enumOption of symbol.possibleEnumOptions){
                let choices = enumOption.selectNone ? [
                    {
                        key: "-",
                        name: "--default--"
                    }
                ] : [];
                enumOption.options.forEach((option)=>{
                    choices.push({
                        key: option.name,
                        name: option.displayName ?? option.name
                    });
                });
                const property = new (0, _internal.ChoiceProperty)(enumOption.displayName, choices, choices[0], undefined, "options:enum_" + enumOption.displayName);
                property.addChangeListener((ev)=>{
                    this.updateOptions();
                });
                this.optionEnumProperties.set(property, enumOption);
                this.properties.add((0, _internal.PropertyCategories).options, property);
            }
        }
        this.componentVariant = symbol.getVariant(this.optionsFromProperties());
        this.componentVisualization = (0, _internal.CanvasController).instance.canvas.use(this.componentVariant.symbol);
        this.componentVisualization.fill((0, _internal.defaultFill));
        this.componentVisualization.stroke((0, _internal.defaultStroke));
        this.componentVisualization.node.style.color = (0, _internal.defaultStroke);
        this.displayName = symbol.displayName;
        this.referenceSymbol = symbol;
        this.scaleState = new _svgJs.Point(1, 1);
        let startPinIndex = this.componentVariant.pins.findIndex((value)=>value.name === "START");
        let endPinIndex = this.componentVariant.pins.findIndex((value)=>value.name === "END");
        this.relSymbolStart = this.componentVariant.pins.at(startPinIndex).point;
        this.relSymbolEnd = this.componentVariant.pins.at(endPinIndex).point;
        this.startLine = (0, _internal.CanvasController).instance.canvas.line().fill("none").stroke({
            color: (0, _internal.defaultStroke),
            width: 1.0
        });
        this.endLine = this.startLine.clone(true);
        this.dragStartLine = (0, _internal.CanvasController).instance.canvas.line().fill("none").stroke({
            width: (0, _selectionHelper.selectionSize),
            color: "transparent"
        });
        this.dragEndLine = this.dragStartLine.clone(true);
        this.selectionElement.remove();
        this.selectionElement = (0, _internal.CanvasController).instance.canvas.group();
        this.startLineSelection = (0, _internal.CanvasController).instance.canvas.line().fill("none");
        this.endLineSelection = (0, _internal.CanvasController).instance.canvas.line().fill("none");
        this.selectionRect = (0, _internal.CanvasController).instance.canvas.rect(0, 0).fill("none");
        this.selectionElement.add(this.selectionRect);
        this.selectionElement.add(this.startLineSelection);
        this.selectionElement.add(this.endLineSelection);
        this.selectionElement.hide();
        this.visualization.add(this.componentVisualization);
        this.visualization.add(this.startLine);
        this.visualization.add(this.endLine);
        this.visualization.add(this.dragStartLine);
        this.visualization.add(this.dragEndLine);
        this.visualization.hide();
        this.properties.add((0, _internal.PropertyCategories).manipulation, new (0, _internal.SectionHeaderProperty)("Symbol Orientation", undefined, "manipulation:header"));
        this.mirror = new (0, _internal.BooleanProperty)("Mirror", false, undefined, "manipulation:mirror");
        this.mirror.addChangeListener((ev)=>{
            this.scaleState.y *= -1;
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).manipulation, this.mirror);
        this.invert = new (0, _internal.BooleanProperty)("Invert", false, undefined, "manipulation:invert");
        this.invert.addChangeListener((ev)=>{
            this.scaleState.x *= -1;
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).manipulation, this.invert);
        this.addInfo();
        this.snappingPoints = [
            new (0, _internal.SnapPoint)(this, null, new _svgJs.Point(0, 0)),
            new (0, _internal.SnapPoint)(this, null, new _svgJs.Point(0, 0)),
            ...this.componentVariant.pins.filter((_, index)=>!(index == startPinIndex || index == endPinIndex)).map((pin)=>new (0, _internal.SnapPoint)(this, pin.name, pin.point.add(this.componentVariant.mid)))
        ];
    }
    updateVoltageRender() {
        this.voltageArrowRendering?.remove();
        // Require a valid geometry and rendering group before updating
        if (!this.referencePoints || this.referencePoints.length < 2 || !this.voltageRendering) return;
        if (this.voltageLabel.value != "") {
            let voltageArrow = this.generateVoltageArrow(this.referencePoints[0], this.referencePoints[1], this.componentVariant.mid.mul(-1), new _svgJs.Point(this.componentVariant.viewBox.x2, this.componentVariant.viewBox.y2).sub(this.componentVariant.mid), this.scaleState);
            this.voltageArrowRendering = voltageArrow.arrow;
            this.voltageRendering.add(this.voltageArrowRendering);
            const voltageLabelBbox = this.voltageLabelRendering.bbox();
            const voltageLabelReference = new _svgJs.Point(voltageLabelBbox.cx, voltageLabelBbox.cy).add(new _svgJs.Point(voltageLabelBbox.w / 2, voltageLabelBbox.h / 2).mul(voltageArrow.labelAnchorDir));
            this.voltageLabelRendering.transform(new _svgJs.Matrix({
                translate: voltageArrow.labelPos.sub(voltageLabelReference)
            }));
        }
    }
    updateCurrentRender() {
        this.currentArrowRendering?.remove();
        // Require a valid geometry and rendering group before updating
        if (!this.referencePoints || this.referencePoints.length < 2 || !this.currentRendering) return;
        // Show current arrow if currentShow is enabled OR if there's a label
        if (this.currentShow.value || this.currentLabel.value != "") {
            let currentArrow = this.generateCurrentArrow(this.referencePoints[0], this.referencePoints[1], this.componentVariant.mid.mul(-1), new _svgJs.Point(this.componentVariant.viewBox.x2, this.componentVariant.viewBox.y2).sub(this.componentVariant.mid), this.scaleState);
            this.currentArrowRendering = currentArrow.arrow;
            this.currentRendering.add(this.currentArrowRendering);
            const currentLabelBbox = this.currentLabelRendering.bbox();
            const currentLabelReference = new _svgJs.Point(currentLabelBbox.cx, currentLabelBbox.cy).add(new _svgJs.Point(currentLabelBbox.w / 2, currentLabelBbox.h / 2).mul(currentArrow.labelAnchorDir));
            this.currentLabelRendering.transform(new _svgJs.Matrix({
                translate: currentArrow.labelPos.sub(currentLabelReference)
            }));
        }
    }
    addInfo() {
        this.properties.add((0, _internal.PropertyCategories).info, new (0, _internal.SectionHeaderProperty)("Info"));
        this.properties.add((0, _internal.PropertyCategories).info, new (0, _internal.InfoProperty)("ID", this.referenceSymbol.tikzName));
    }
    optionsFromProperties() {
        const selectedOptions = [];
        this.optionProperties.forEach((option, property)=>{
            if (property.value) selectedOptions.push(option);
        });
        this.optionEnumProperties.forEach((option, property)=>{
            if (property.value.key != "-") selectedOptions.push(option.options.find((o)=>{
                return o.name == property.value.key;
            }));
        });
        return selectedOptions;
    }
    setPropertiesFromOptions(options) {
        this.optionProperties.forEach((value, property)=>{
            if (options.find((op)=>op.name == value.name)) property.value = true;
            else property.value = false;
        });
        this.optionEnumProperties.forEach((enumOption, property)=>{
            let foundOption = false;
            for (const option of enumOption.options)if (options.find((op)=>op.name == option.name)) {
                foundOption = true;
                property.value = property.entries.find((entry)=>entry.key == option.name);
                break;
            }
            if (!foundOption) property.value = property.entries[0];
        });
        this.updateOptions();
    }
    moveStartTo(position) {
        this.referencePoints[0] = position;
        this.update();
    }
    moveEndTo(position) {
        this.referencePoints[1] = position;
        this.update();
    }
    flip(horizontal) {
        let newPos1 = new _svgJs.Point(this.referencePoints[0].x, this.referencePoints[1].y);
        let newPos2 = new _svgJs.Point(this.referencePoints[1].x, this.referencePoints[0].y);
        if (horizontal) {
            this.referencePoints[0] = newPos1;
            this.referencePoints[1] = newPos2;
        } else {
            this.referencePoints[0] = newPos2;
            this.referencePoints[1] = newPos1;
        }
        this.mirror.updateValue(!this.mirror.value);
        this.update();
    }
    recalculateSnappingPoints() {
        const inverseTransform = this.getTransformMatrix().inverse();
        this.snappingPoints[0].updateRelPosition(this.referencePoints[0].transform(inverseTransform));
        this.snappingPoints[1].updateRelPosition(this.referencePoints[1].transform(inverseTransform));
        super.recalculateSnappingPoints();
    }
    updateOptions() {
        this.componentVariant = this.referenceSymbol.getVariant(this.optionsFromProperties());
        this.componentVisualization.node.setAttribute("href", "#" + this.componentVariant.symbol.id());
        let startPinIndex = this.componentVariant.pins.findIndex((value)=>value.name === "START");
        let endPinIndex = this.componentVariant.pins.findIndex((value)=>value.name === "END");
        this.snappingPoints = [
            new (0, _internal.SnapPoint)(this, null, new _svgJs.Point(0, 0)),
            new (0, _internal.SnapPoint)(this, null, new _svgJs.Point(0, 0)),
            ...this.componentVariant.pins.filter((_, index)=>!(index == startPinIndex || index == endPinIndex)).map((pin)=>new (0, _internal.SnapPoint)(this, pin.name, pin.point.add(this.componentVariant.mid)))
        ];
        this.update();
    }
    getSnappingInfo() {
        if (this.finishedPlacing) return {
            trackedSnappingPoints: this.snappingPoints,
            additionalSnappingPoints: []
        };
        else return {
            trackedSnappingPoints: [],
            additionalSnappingPoints: this.referencePoints.length > 0 ? [
                new (0, _internal.SnapPoint)(this, "", new _svgJs.Point())
            ] : []
        };
    }
    update() {
        // Guard against invalid or incomplete reference points
        if (!this.referencePoints || this.referencePoints.length < 2) return;
        this.position = this.referencePoints[0].add(this.referencePoints[1]).div(2);
        const angle = Math.atan2(this.referencePoints[0].y - this.referencePoints[1].y, this.referencePoints[1].x - this.referencePoints[0].x);
        this.rotationDeg = angle * 180 / Math.PI;
        let m = this.getTransformMatrix();
        this.componentVisualization.transform(m);
        // For rmeter and rmeterwa, calculate line endpoints differently since symbol doesn't rotate
        const keepHorizontal = this.referenceSymbol.tikzName === "rmeter" || this.referenceSymbol.tikzName === "rmeterwa";
        let startLineEndPoint;
        let endLineStartPoint;
        if (keepHorizontal) {
            // For horizontal meters, the connection points are at the left and right edges of the symbol
            // We need to calculate where the wires meet the symbol circle
            const symbolMid = this.componentVariant.mid;
            const radius = Math.abs(this.relSymbolStart.x); // Distance from center to edge
            // Calculate the angle from center to each reference point
            const angleToStart = Math.atan2(this.referencePoints[0].y - this.position.y, this.referencePoints[0].x - this.position.x);
            const angleToEnd = Math.atan2(this.referencePoints[1].y - this.position.y, this.referencePoints[1].x - this.position.x);
            // Connection points on the circle edge
            startLineEndPoint = new _svgJs.Point(this.position.x + radius * Math.cos(angleToStart) * this.scaleState.x, this.position.y + radius * Math.sin(angleToStart) * this.scaleState.y);
            endLineStartPoint = new _svgJs.Point(this.position.x + radius * Math.cos(angleToEnd) * this.scaleState.x, this.position.y + radius * Math.sin(angleToEnd) * this.scaleState.y);
        } else {
            // Normal behavior for other components
            startLineEndPoint = this.relSymbolStart.add(this.componentVariant.mid).transform(m);
            endLineStartPoint = this.relSymbolEnd.add(this.componentVariant.mid).transform(m);
        }
        if (this.invert.value) {
            let switchPos = startLineEndPoint;
            startLineEndPoint = endLineStartPoint;
            endLineStartPoint = switchPos;
        }
        this.recalculateResizePoints();
        this.startLine.plot(this.referencePoints[0].x, this.referencePoints[0].y, startLineEndPoint.x, startLineEndPoint.y);
        this.endLine.plot(this.referencePoints[1].x, this.referencePoints[1].y, endLineStartPoint.x, endLineStartPoint.y);
        this.startLineSelection.plot(this.referencePoints[0].x, this.referencePoints[0].y, startLineEndPoint.x, startLineEndPoint.y);
        this.endLineSelection.plot(this.referencePoints[1].x, this.referencePoints[1].y, endLineStartPoint.x, endLineStartPoint.y);
        this.dragStartLine.plot(this.referencePoints[0].x, this.referencePoints[0].y, startLineEndPoint.x, startLineEndPoint.y);
        this.dragEndLine.plot(this.referencePoints[1].x, this.referencePoints[1].y, endLineStartPoint.x, endLineStartPoint.y);
        this.updatePathLabel();
        this.updateVoltageRender();
        this.updateCurrentRender();
        this._bbox = this.visualization.bbox();
        this.referencePosition = this.position.sub(new _svgJs.Point(this._bbox.x, this._bbox.y));
        this.recalculateSelectionVisuals();
        this.recalculateSnappingPoints();
    }
    recalculateSelectionVisuals() {
        if (this.selectionElement) {
            // use the saved position instead of the bounding box (bbox position fails in safari)
            let bbox = this.componentVariant.viewBox;
            this.selectionRect.center(bbox.cx, bbox.cy).size(bbox.w + (0, _selectionHelper.selectedBoxWidth), bbox.h + (0, _selectionHelper.selectedBoxWidth)).transform(this.getTransformMatrix());
        }
    }
    viewSelected(show) {
        super.viewSelected(show);
        this.resizable(this.isSelected && show && (0, _internal.SelectionController).instance.currentlySelectedComponents.length == 1);
    }
    /**
     * For tikz path symbols, this getTransformMatrix returns the transformation necessary for the symbol from local symbol coodinates to world coordinates
     */ getTransformMatrix() {
        const symbolRel = this.componentVariant.mid;
        // For rmeter and rmeterwa, keep the symbol horizontal (don't rotate)
        const keepHorizontal = this.referenceSymbol.tikzName === "rmeter" || this.referenceSymbol.tikzName === "rmeterwa";
        const rotationAngle = keepHorizontal ? 0 : -this.rotationDeg;
        return new _svgJs.Matrix({
            scaleX: this.scaleState.x,
            scaleY: this.scaleState.y,
            translate: [
                -symbolRel.x,
                -symbolRel.y
            ],
            origin: [
                symbolRel.x,
                symbolRel.y
            ]
        }).lmultiply(new _svgJs.Matrix({
            rotate: rotationAngle,
            translate: [
                this.position.x,
                this.position.y
            ]
        }));
    }
    updateTheme() {
        let labelColor = (0, _internal.defaultStroke);
        if (this.labelColor && this.labelColor.value) labelColor = this.labelColor.value.toString();
        this.labelRendering?.fill(labelColor);
    }
    isInsideSelectionRectangle(selectionRectangle) {
        // if 1 of the 2 lines hanging of the symbol intersect the selection rect -> should select
        if ((0, _selectionHelper.lineRectIntersection)(this.startLine, selectionRectangle) || (0, _selectionHelper.lineRectIntersection)(this.endLine, selectionRectangle)) return true;
        const bbox = this.componentVariant.viewBox;
        // get the corner points of the bounding box and rotate each of them to their proper positions
        const transform = this.getTransformMatrix();
        const boxPoints = [
            new _svgJs.Point(bbox.x, bbox.y).transform(transform),
            new _svgJs.Point(bbox.x2, bbox.y).transform(transform),
            new _svgJs.Point(bbox.x2, bbox.y2).transform(transform),
            new _svgJs.Point(bbox.x, bbox.y2).transform(transform)
        ];
        // if all of these points are inside the selection rect -> should select
        if (boxPoints.map((value)=>(0, _selectionHelper.pointInsideRect)(value, selectionRectangle)).every((value)=>value)) return true;
        //necessary to check if the complete selection rect is inside the component
        let selectionRectInside = true;
        // if at least one line defined by 2 of the 4 corner points intersects the selection rect -> should select
        for(let index = 0; index < boxPoints.length; index++){
            const p1 = boxPoints[index];
            const p2 = boxPoints[(index + 1) % boxPoints.length];
            if ((0, _selectionHelper.lineRectIntersection)([
                [
                    p1.x,
                    p1.y
                ],
                [
                    p2.x,
                    p2.y
                ]
            ], selectionRectangle)) return true;
            else selectionRectInside = selectionRectInside && p2.sub(p1).rotate(-90).dot(new _svgJs.Point(selectionRectangle.cx, selectionRectangle.cy).sub(p1)) > 0;
        }
        // no intersection between the selection rect and the component or selection rect inside component
        return selectionRectInside;
    }
    toJson() {
        let data = super.toJson();
        data.type = PathSymbolComponent.jsonID;
        data.id = this.referenceSymbol.tikzName;
        if (this.componentVariant.options.length > 0) data.options = this.componentVariant.options.map((option)=>option.displayName ?? option.name);
        if (this.scaleState && (this.scaleState.x != 1 || this.scaleState.y != 1)) data.scale = this.scaleState;
        return data;
    }
    toTikzString() {
        // Skip invalid components that don't have two reference points
        if (!this.referencePoints || this.referencePoints.length < 2) return "";
        let command = {
            options: [
                "draw"
            ],
            additionalNodes: [],
            coordinates: [],
            connectors: []
        };
        this.buildTikzCommand(command);
        return (0, _internal.buildTikzStringFromPathCommand)(command);
    }
    buildTikzCommand(command) {
        super.buildTikzCommand(command);
        let options = [
            this.referenceSymbol.tikzName
        ];
        options.push(...this.referenceSymbol.optionsToStringArray(this.optionsFromProperties()));
        if (this.mirror.value) options.push("mirror");
        if (this.invert.value) options.push("invert");
        const scaleFactor = this.scaleProperty.value.value != 1 ? new _svgJs.Number(this.scaleProperty.value.value * 1.4, "cm") : undefined;
        if (scaleFactor) options.push("/tikz/circuitikz/bipoles/length=" + scaleFactor.value.toPrecision(3) + scaleFactor.unit);
        let to = {
            options: options,
            name: this.name.value
        };
        // For rmeter and rmeterwa, add the 't' parameter for text inside meter
        if (this.referenceSymbol.tikzName === "rmeter") // rmeter is for voltage measurement, add t=V
        options.push("t=V");
        else if (this.referenceSymbol.tikzName === "rmeterwa") // rmeterwa is for current measurement, add t=A
        options.push("t=A");
        this.buildTikzPathLabel(to);
        this.buildTikzVoltage(to);
        this.buildTikzCurrent(to);
        // Only add connector when we have at least two coordinates
        if (command.coordinates.length >= 2) command.connectors.push(to);
    }
    remove() {
        (0, _internal.SnapDragHandler).snapDrag(this, false);
        this.resizable(false);
        this.viewSelected(false);
        this.visualization.remove();
        this.selectionElement?.remove();
        this.labelRendering?.remove();
    }
    copyForPlacement() {
        return new PathSymbolComponent(this.referenceSymbol);
    }
    static idNoOptions(id) {
        return id.split("_").slice(0, 2).join("_");
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        let options = saveObject.options ?? [];
        this.setPropertiesFromOptions(this.referenceSymbol.getOptionsFromOptionNames(options));
        if (saveObject.scale) {
            this.scaleState = new _svgJs.Point(saveObject.scale);
            this.scaleProperty.updateValue(new _svgJs.Number(Math.abs(saveObject.scale.x)));
        }
        this.mirror.value = this.scaleState.y < 0;
        this.invert.value = this.scaleState.x < 0;
        this.scaleProperty.value = new _svgJs.Number(Math.abs(this.scaleState.x));
        this.update();
        this.visualization.show();
    }
    static fromJson(saveObject) {
        let symbol;
        if ((0, _internal.SaveController).instance.currentlyLoadedSaveVersion != "") symbol = (0, _internal.MainController).instance.symbols.find((symbol)=>symbol.tikzName == saveObject.id);
        else {
            let idParts = saveObject.id.split("_");
            symbol = (0, _internal.MainController).instance.symbols.find((symbol)=>symbol.tikzName == idParts[1].replaceAll("-", " "));
            saveObject.options = idParts.slice(2);
            // @ts-ignore
            saveObject.points = [
                saveObject.start,
                saveObject.end
            ];
        }
        if (symbol) {
            let pathComponent = new PathSymbolComponent(symbol);
            return pathComponent;
        } else {
            console.error("no path symbol found for saveObject: " + JSON.stringify(saveObject));
            return null;
        }
    }
    updatePathLabel() {
        if (!this.mathJaxLabel || !this.labelRendering) return;
        let labelSVG = this.labelRendering;
        // breaking points where the label is parallel to the path or to the x axis. in degrees
        const breakVertical = 70;
        const breakHorizontal = 21;
        let pathDiff = this.referencePoints[1].sub(this.referencePoints[0]);
        // the bounding boxes for the label and the symbol
        let labelBBox = labelSVG.bbox();
        let labelHalfSize = new _svgJs.Point(labelBBox.w, labelBBox.h).div(2);
        let symbolBBox = this.componentVisualization.bbox();
        let symbolHalfSize = new _svgJs.Point(symbolBBox.w, symbolBBox.h).div(2);
        // the nominal reference point of the label (bottom center)
        let labelRef = new _svgJs.Point(labelBBox.cx, labelBBox.y2);
        // the rotation angle of the label (not always identical to the path rotation angle)
        let rotAngle = this.rotationDeg;
        if (rotAngle > 90 || rotAngle < -90) {
            // left halfplane -> don't show label upside down -> rotate the label by additional 180 deg
            rotAngle += 180;
            // the dafault label reference point should now be the top center
            labelRef.y = labelBBox.y;
        }
        // mirroring the symbol should not impact the label except from shifting its position to stay close to the symbol (only relevant for asymetric symbols)
        let referenceoffsetY = this.scaleState.y < 0 ? this.componentVariant.mid.y - symbolBBox.h : -this.componentVariant.mid.y;
        referenceoffsetY *= Math.abs(this.scaleState.y);
        // nominally the reference point of the symbol is its center (w.r.t. the x coordinate for a path which is horizontal)
        let referenceOffsetX = 0;
        let other = this.labelSide.value ? -1 : 1;
        if (other < 0) {
            labelRef.y = labelBBox.y - labelRef.y;
            referenceoffsetY += symbolBBox.h * Math.abs(this.scaleState.y);
        }
        // if the path is close to horizontal or vertical according to the break points
        let nearHorizontal = Math.abs(this.rotationDeg) < breakHorizontal || Math.abs(this.rotationDeg) > 180 - breakHorizontal;
        let nearVertical = Math.abs(this.rotationDeg) > breakVertical && Math.abs(this.rotationDeg) < 180 - breakVertical;
        if (nearHorizontal) {
            // the label should not be rotated w.r.t. the x axis
            rotAngle = 0;
            let right = Math.sign(pathDiff.x);
            let up = Math.sign(this.rotationDeg);
            //the offset where the rotation pivot point should lie (for both label and symbol)
            let horizontalOffset = Math.min(labelHalfSize.x, symbolHalfSize.x) * up;
            referenceOffsetX = horizontalOffset * right * other;
            labelRef.x += horizontalOffset * other;
        } else if (nearVertical) {
            // the label should not be rotated w.r.t. the x axis
            rotAngle = 0;
            let right = Math.sign(pathDiff.x);
            let up = Math.sign(this.rotationDeg);
            //the offset where the rotation pivot point should lie (for both label and symbol)
            let verticalOffset = Math.min(labelHalfSize.y, symbolHalfSize.x) * right * other;
            referenceOffsetX = -verticalOffset * up;
            labelRef.y = labelBBox.cy + verticalOffset;
            labelRef.x += labelHalfSize.x * (up * other);
        }
        referenceoffsetY -= other * (this.labelDistance.value ? this.labelDistance.value.convertToUnit("px").value : 0);
        // where the anchor point of the symbol is located relative to the midAbs point
        let referenceOffset = new _svgJs.Point(referenceOffsetX, referenceoffsetY).transform(new _svgJs.Matrix({
            rotate: -this.rotationDeg
        }));
        // actually move and rotate the label to the correct position
        let compRef = this.position.add(referenceOffset);
        let movePos = compRef.sub(labelRef);
        labelSVG.transform({
            rotate: -rotAngle,
            ox: labelRef.x,
            oy: labelRef.y,
            translate: [
                movePos.x,
                movePos.y
            ]
        });
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"65cLX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WireDirection", ()=>WireDirection);
parcelHelpers.export(exports, "arrowTips", ()=>arrowTips);
parcelHelpers.export(exports, "defaultArrowTip", ()=>defaultArrowTip);
/**
 * The component responsible for multi segmented wires (polylines)/wires
 */ parcelHelpers.export(exports, "WireComponent", ()=>WireComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _dragHandlers = require("../snapDrag/dragHandlers");
var _selectionHelper = require("../utils/selectionHelper");
var WireDirection;
(function(WireDirection) {
    WireDirection["Straight"] = "--";
    WireDirection["HV"] = "-|";
    WireDirection["VH"] = "|-";
})(WireDirection || (WireDirection = {}));
function oppositeDirection(direction) {
    switch(direction){
        case WireDirection.HV:
            return WireDirection.VH;
        case WireDirection.VH:
            return WireDirection.HV;
        default:
            return WireDirection.Straight;
    }
}
const arrowTips = [
    {
        key: "none",
        name: "none",
        tikz: "",
        setBack: 0
    },
    {
        key: "stealth",
        name: "stealth",
        tikz: "stealth",
        setBack: 0.5
    },
    {
        key: "stealthR",
        name: "stealth reversed",
        tikz: "stealth reversed",
        setBack: 0.5
    },
    {
        key: "latex",
        name: "latex",
        tikz: "latex",
        setBack: 0.5
    },
    {
        key: "latexR",
        name: "latex reversed",
        tikz: "latex reversed",
        setBack: 0.5
    },
    {
        key: "to",
        name: "to",
        tikz: "to",
        setBack: 0.1,
        strokeFactor: 0.7,
        refXY: new _svgJs.Point(-1, -0.6)
    },
    {
        key: "toR",
        name: "to reversed",
        tikz: "to reversed",
        setBack: 0.4,
        strokeFactor: 0.7,
        refXY: new _svgJs.Point(-1, -0.6)
    },
    {
        key: "line",
        name: "line",
        tikz: "|",
        setBack: 0,
        strokeFactor: 1,
        refXY: new _svgJs.Point(-0.5, -0.5)
    }
];
const defaultArrowTip = arrowTips[0];
class WireComponent extends (0, _internal.Currentable)((0, _internal.Strokable)((0, _internal.PathComponent))) {
    static jsonID = "wire";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(WireComponent.jsonID, WireComponent);
    }
    /**
     * the wire directions when drawing
     */ wireDirections;
    // useful for placing
    previousPlacingDirection = new _svgJs.Point(1, 0);
    // essentially the main visualisation
    wire;
    // a wider copy of wire, but invisible, Meant for dragging the wire
    draggableWire;
    // the svg elements where adjusting the wire is possible
    adjustmentPoints = [];
    arrowEndChoice;
    arrowStartChoice;
    startArrowElement;
    endArrowElement;
    static arrowSymbols;
    onlyStraight;
    defaultArrowHead;
    constructor(onlyStraight = false, defaultArrowHead = false){
        super();
        this.onlyStraight = onlyStraight;
        this.defaultArrowHead = defaultArrowHead;
        this.referencePoints = [];
        this.pointLimit = -1;
        this.wireDirections = [];
        this.displayName = "Wire";
        this.wire = (0, _internal.CanvasController).instance.canvas.polyline();
        this.wire.fill("none");
        this.draggableWire = (0, _internal.CanvasController).instance.canvas.polyline();
        this.draggableWire.attr({
            "fill": "none",
            "stroke": "transparent",
            "stroke-width": (0, _selectionHelper.selectionSize)
        });
        // override default value
        this.strokeWidthProperty.value = new _svgJs.Number("1.0pt");
        this.strokeInfo.width = this.strokeWidthProperty.value;
        this.visualization.add(this.wire);
        this.visualization.add(this.draggableWire);
        this.snappingPoints = [];
        this.properties.add((0, _internal.PropertyCategories).options, new (0, _internal.SectionHeaderProperty)("Arrows", undefined, "arrows:header"));
        this.arrowStartChoice = new (0, _internal.ChoiceProperty)("Start", arrowTips, defaultArrowTip, undefined, "arrows:start");
        this.arrowStartChoice.addChangeListener((ev)=>{
            this.updateArrowTypesAndColors();
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).options, this.arrowStartChoice);
        this.arrowEndChoice = new (0, _internal.ChoiceProperty)("End", arrowTips, this.defaultArrowHead ? arrowTips[3] : defaultArrowTip, undefined, "arrows:end");
        this.arrowEndChoice.addChangeListener((ev)=>{
            this.updateArrowTypesAndColors();
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).options, this.arrowEndChoice);
        if (!WireComponent.arrowSymbols) {
            WireComponent.arrowSymbols = new Map();
            for (const tip of arrowTips)WireComponent.arrowSymbols.set(tip.key, document.getElementById(tip.key));
        }
    }
    lineWidthToArrowScale() {
        let scale = this.strokeInfo.width.convertToUnit("pt").value * 4.5 + 2.8; // magic numbers for converting the line width to the scale value
        return scale;
    }
    updateArrowTypesAndColors() {
        let arrowColor = this.strokeInfo.color;
        if (arrowColor == "default") arrowColor = (0, _internal.defaultStroke);
        this.startArrowElement?.remove();
        this.startArrowElement = null;
        if (this.arrowStartChoice.value.key != defaultArrowTip.key) {
            this.startArrowElement = (0, _internal.CanvasController).instance.canvas.group();
            this.startArrowElement.addTo(this.visualization);
            this.startArrowElement.stroke({
                color: arrowColor,
                opacity: this.strokeInfo.opacity
            });
            this.startArrowElement.fill({
                color: arrowColor,
                opacity: this.strokeInfo.opacity
            });
            const arrowPath = document.getElementById(this.arrowStartChoice.value.key);
            for (const element of arrowPath.children)this.startArrowElement.node.append(element.cloneNode(true));
        }
        this.endArrowElement?.remove();
        this.endArrowElement = null;
        if (this.arrowEndChoice.value.key != defaultArrowTip.key) {
            this.endArrowElement = (0, _internal.CanvasController).instance.canvas.group();
            this.endArrowElement.addTo(this.visualization);
            this.endArrowElement.stroke({
                color: arrowColor,
                opacity: this.strokeInfo.opacity
            });
            this.endArrowElement.fill({
                color: arrowColor,
                opacity: this.strokeInfo.opacity
            });
            const arrowPath = document.getElementById(this.arrowEndChoice.value.key);
            for (const element of arrowPath.children)this.endArrowElement.node.append(element.cloneNode(true));
        }
    }
    updateArrowTransforms(startArrowReference, endArrowReference) {
        const scale = this.lineWidthToArrowScale();
        const strokeWidth = this.strokeInfo.width.convertToUnit("px").value / scale;
        if (this.arrowStartChoice.value.key != defaultArrowTip.key) {
            let wireDirection = this.referencePoints.at(0).sub(startArrowReference);
            let rotationAngleDeg = Math.atan2(wireDirection.y, wireDirection.x) * 180 / Math.PI;
            let refXY = this.arrowStartChoice.value.refXY ?? new _svgJs.Point(-1, -0.5);
            this.startArrowElement.transform(new _svgJs.Matrix({
                translate: this.referencePoints.at(0).toArray(),
                rotate: rotationAngleDeg,
                scale: [
                    scale,
                    scale
                ]
            }).multiply({
                translate: refXY.toArray()
            }));
            this.startArrowElement.attr("stroke-width", strokeWidth * (this.arrowStartChoice.value.strokeFactor ?? 0));
        }
        if (this.arrowEndChoice.value.key != defaultArrowTip.key) {
            let wireDirection = this.referencePoints.at(-1).sub(endArrowReference);
            let rotationAngleDeg = Math.atan2(wireDirection.y, wireDirection.x) * 180 / Math.PI;
            let refXY = this.arrowEndChoice.value.refXY ?? new _svgJs.Point(-1, -0.5);
            this.endArrowElement.transform(new _svgJs.Matrix({
                translate: this.referencePoints.at(-1).toArray(),
                rotate: rotationAngleDeg,
                scale: [
                    scale,
                    scale
                ]
            }).multiply({
                translate: refXY.toArray()
            }));
            this.endArrowElement.attr("stroke-width", strokeWidth * (this.arrowEndChoice.value.strokeFactor ?? 0));
        }
    }
    updateTheme() {
        let strokeColor = this.strokeInfo.color;
        if (strokeColor == "default") strokeColor = "var(--bs-body-color)";
        this.updateArrowTypesAndColors();
        this.wire.stroke({
            color: strokeColor,
            opacity: this.strokeInfo.opacity,
            width: this.strokeInfo.opacity == 0 ? 0 : this.strokeInfo.width.convertToUnit("px").value,
            dasharray: this.strokeStyleProperty.value.dasharray.map((factor)=>this.strokeInfo.width.times(factor).toString()).join(" ")
        });
        // Update current label color if exists
        if (this.currentLabelRendering) this.currentLabelRendering.fill(strokeColor);
        if (this.currentArrowRendering) this.currentArrowRendering.fill(strokeColor);
        if (this.finishedPlacing) this.update();
    }
    updateCurrentRender() {
        this.currentArrowRendering?.remove();
        // Show current arrow if currentShow is enabled OR if there's a label
        if ((this.currentShow.value || this.currentLabel.value != "") && this.referencePoints.length >= 2) {
            // For wire, we draw current on the first or last segment depending on currentPosition
            const positionStart = this.currentPosition.value;
            // Get start and end points for the segment where current will be drawn
            let segmentStart;
            let segmentEnd;
            if (positionStart) {
                // Draw on first segment
                segmentStart = this.referencePoints[0];
                segmentEnd = this.referencePoints[1];
            } else {
                // Draw on last segment
                segmentStart = this.referencePoints[this.referencePoints.length - 2];
                segmentEnd = this.referencePoints[this.referencePoints.length - 1];
            }
            // For wire, we don't have component bounds, so use zero deltas
            const zeroDelta = new _svgJs.Point(0, 0);
            const scale = new _svgJs.Point(1, 1);
            let currentArrow = this.generateCurrentArrow(segmentStart, segmentEnd, zeroDelta, zeroDelta, scale);
            this.currentArrowRendering = currentArrow.arrow;
            this.currentRendering.add(this.currentArrowRendering);
            const currentLabelBbox = this.currentLabelRendering.bbox();
            const currentLabelReference = new _svgJs.Point(currentLabelBbox.cx, currentLabelBbox.cy).add(new _svgJs.Point(currentLabelBbox.w / 2, currentLabelBbox.h / 2).mul(currentArrow.labelAnchorDir));
            this.currentLabelRendering.dmove(currentArrow.labelPos.x - currentLabelReference.x, currentArrow.labelPos.y - currentLabelReference.y);
        } else this.currentLabelRendering?.dmove(0, 0);
    }
    recalculateSnappingPoints() {
        super.recalculateSnappingPoints(this.getTransformMatrix());
    }
    getSnappingInfo() {
        if (this.finishedPlacing) // only snap to the snapping points
        return {
            trackedSnappingPoints: this.snappingPoints,
            additionalSnappingPoints: []
        };
        else // only snap the cursor
        return {
            trackedSnappingPoints: [],
            additionalSnappingPoints: this.referencePoints.length > 0 ? [
                new (0, _internal.SnapPoint)(this, "center", new _svgJs.Point())
            ] : []
        };
    }
    resizable(resize) {
        if (resize == this.isResizing) return;
        this.isResizing = resize;
        if (resize) {
            // pre calculate the direction of the wire as a vector from the wiredirection objects
            let dirs = [];
            for(let index = 0; index < this.wireDirections.length; index++){
                let rel = this.referencePoints[index + 1].sub(this.referencePoints[index]);
                dirs[index] = this.wireDirections[index] == WireDirection.VH ? new _svgJs.Point(0, Math.sign(rel.y)) : new _svgJs.Point(Math.sign(rel.x), 0);
            }
            // add dragging to all corner points
            for(let index = 0; index < this.referencePoints.length; index++){
                const element = (0, _selectionHelper.resizeSVG)();
                element.node.style.cursor = "move";
                this.adjustmentPoints.push(element);
                let startPos;
                (0, _dragHandlers.AdjustDragHandler).snapDrag(this, element, resize, {
                    dragStart: (pos)=>{
                        startPos = this.referencePoints[index];
                    },
                    dragMove: (pos, ev)=>{
                        if (ev && (ev.ctrlKey || (0, _internal.MainController).instance.isMac && ev.metaKey)) {
                            // wires from and to this point should be straight
                            if (index > 0) // is not first point
                            this.wireDirections[index - 1] = WireDirection.Straight;
                            if (index < this.wireDirections.length) // is not last point
                            this.wireDirections[index] = WireDirection.Straight;
                        } else {
                            // change the wire direction if necessary
                            if (index > 0) {
                                // from the last point to this point
                                dirs[index - 1] = this.directionVecFromPos(pos.sub(this.referencePoints[index - 1]), dirs[index - 1]);
                                this.wireDirections[index - 1] = this.wireDirectionFromDirectionVec(dirs[index - 1], ev);
                            }
                            if (index < this.adjustmentPoints.length - 1) {
                                // from this point to the next point
                                let rel = pos.sub(this.referencePoints[index + 1]);
                                dirs[index] = this.directionVecFromPos(rel, dirs[index]);
                                let dir = dirs[index].x != 0 ? new _svgJs.Point(0, rel.y) : new _svgJs.Point(rel.x, 0);
                                this.wireDirections[index] = this.wireDirectionFromDirectionVec(dir, ev);
                            }
                        }
                        this.referencePoints[index] = pos;
                        this.update();
                    },
                    dragEnd: ()=>{
                        this.update();
                        return !this.referencePoints[index].eq(startPos);
                    }
                });
            }
            this.update();
        } else {
            for (const point of this.adjustmentPoints){
                (0, _dragHandlers.AdjustDragHandler).snapDrag(this, point, false);
                point.remove();
            }
            this.adjustmentPoints = [];
        }
    }
    recalculateResizePoints() {
        const transformMatrix = this.getTransformMatrix();
        for(let index = 0; index < this.adjustmentPoints.length; index++){
            const viz = this.adjustmentPoints[index];
            const point = this.referencePoints[index].transform(transformMatrix);
            viz.center(point.x, point.y);
        }
    }
    rotate(angleDeg) {
        if (Math.abs(angleDeg) == 45) // no 45 degree rotations
        return;
        this.referencePoints = this.referencePoints.map((point)=>point.rotate(angleDeg, this.position));
        if (Math.abs(angleDeg) == 90) this.wireDirections = this.wireDirections.map(oppositeDirection);
        this.update();
    }
    update() {
        //recalculate the bounding box and position
        this._bbox = (0, _internal.bboxFromPoints)(this.referencePoints);
        this.position = new _svgJs.Point(this._bbox.cx, this._bbox.cy);
        // generate all the points in the wire from the corner points and the wire directions
        let pointArray = this.pointsFromCornerPoints();
        let startArrowRef = pointArray.at(1).clone();
        startArrowRef = startArrowRef.eq(this.referencePoints.at(0)) ? (pointArray.at(2) ?? new _svgJs.Point()).clone() : startArrowRef;
        let endArrowRef = pointArray.at(-2).clone();
        endArrowRef = endArrowRef.eq(this.referencePoints.at(-1)) ? (pointArray.at(-3) ?? new _svgJs.Point()).clone() : endArrowRef;
        // first update the relative positions of the snapping points w.r.t. the wire, i.e. the start and end positions
        let pointsNoArrow = pointArray.map((point)=>point.clone());
        // adjust end points for arrow heads
        const arrowSize = this.lineWidthToArrowScale();
        if (this.arrowStartChoice.value.key !== defaultArrowTip.key) {
            let firstRef = pointArray[1].sub(pointArray[0]);
            let firstRefLength = firstRef.abs();
            if (firstRefLength > 0) pointArray[0] = pointArray[0].add(firstRef.div(firstRefLength).mul(arrowSize * this.arrowStartChoice.value.setBack));
        }
        if (this.arrowEndChoice.value.key !== defaultArrowTip.key) {
            let numPoints = pointArray.length - 1;
            let secondRef = pointArray[numPoints - 1].sub(pointArray[numPoints]);
            let secondRefLength = secondRef.abs();
            if (secondRefLength > 0) pointArray[numPoints] = pointArray[numPoints].add(secondRef.div(secondRefLength).mul(arrowSize * this.arrowEndChoice.value.setBack));
        }
        //update arrows. has to be done before bbox calculation, otherwise, the arrow tips are not shown in the bounding box
        this.updateArrowTransforms(startArrowRef, endArrowRef);
        // actually plot the points
        let plotPoints = new _svgJs.PointArray(pointArray.map((val)=>val.toArray()));
        this.wire.clear();
        this.wire.plot(plotPoints);
        this.draggableWire.clear();
        this.draggableWire.plot(plotPoints);
        //recalculate the snapping point offsets
        if (this.snappingPoints.length == pointsNoArrow.length) //update the existing snap points
        for(let index = 0; index < this.snappingPoints.length; index++){
            const snapPoint = this.snappingPoints[index];
            const point = pointsNoArrow[index];
            snapPoint.updateRelPosition(point);
        }
        else // a point was added -> redo snap points
        this.snappingPoints = pointsNoArrow.map((point, idx)=>new (0, _internal.SnapPoint)(this, idx == 0 ? "START" : idx == pointsNoArrow.length - 1 ? "END" : "", point));
        // update visuals
        this.recalculateSelectionVisuals();
        this.recalculateSnappingPoints();
        this.recalculateResizePoints();
        // update current annotation if exists
        this.updateCurrentRender();
    }
    pointsFromCornerPoints() {
        let pointArray = [
            this.referencePoints[0].clone()
        ];
        for(let index = 0; index < this.wireDirections.length; index++){
            const direction = this.wireDirections[index];
            const previousPoint = this.referencePoints[index];
            const point = this.referencePoints[index + 1];
            if (direction == WireDirection.HV && previousPoint.x != point.x && previousPoint.y != point.y) pointArray.push(new _svgJs.Point(point.x, previousPoint.y));
            else if (direction == WireDirection.VH && previousPoint.x != point.x && previousPoint.y != point.y) pointArray.push(new _svgJs.Point(previousPoint.x, point.y));
            pointArray.push(point.clone());
        }
        return pointArray;
    }
    recalculateSelectionVisuals() {
        if (this.selectionElement) {
            const transformMatrix = this.getTransformMatrix();
            const transformMatrixInv = transformMatrix.inverse();
            let bbox = this.bbox;
            const strokeWidth = this.strokeInfo.width.convertToUnit("px").value;
            bbox = new _svgJs.Box(bbox.x - strokeWidth / 2, bbox.y - strokeWidth / 2, bbox.w + strokeWidth, bbox.h + strokeWidth);
            if (this.startArrowElement) {
                const currentTransform = new _svgJs.Matrix(this.startArrowElement.transform());
                const arrowTransform = currentTransform.lmultiply(transformMatrixInv);
                const startBBox = this.startArrowElement.bbox().transform(arrowTransform);
                bbox = bbox.merge(startBBox);
            }
            if (this.endArrowElement) {
                const currentTransform = new _svgJs.Matrix(this.endArrowElement.transform());
                const arrowTransform = currentTransform.lmultiply(transformMatrixInv);
                const endBBox = this.endArrowElement.bbox().transform(arrowTransform);
                bbox = bbox.merge(endBBox);
            }
            this.selectionElement.size(bbox.width + (0, _selectionHelper.selectedBoxWidth), bbox.height + (0, _selectionHelper.selectedBoxWidth));
            this.selectionElement.center(bbox.cx, bbox.cy);
            this.selectionElement.transform(transformMatrix);
        }
    }
    isInsideSelectionRectangle(selectionRectangle) {
        //essentially check each wire segment via a wire rect intersection
        const transformMatrix = this.getTransformMatrix();
        let pointsArray = this.pointsFromCornerPoints().map((point)=>point.transform(transformMatrix));
        for(let idx = 0; idx < pointsArray.length - 1; idx++){
            const p1 = pointsArray[idx];
            const p2 = pointsArray[idx + 1];
            if ((0, _selectionHelper.pointInsideRect)(p1, selectionRectangle)) return true;
            if ((0, _selectionHelper.lineRectIntersection)([
                [
                    p1.x,
                    p1.y
                ],
                [
                    p2.x,
                    p2.y
                ]
            ], selectionRectangle)) return true;
        }
        return false;
    }
    viewSelected(show) {
        super.viewSelected(show);
        this.resizable(this.isSelected && show && (0, _internal.SelectionController).instance.currentlySelectedComponents.length == 1);
    }
    toJson() {
        let data = super.toJson();
        data.type = WireComponent.jsonID;
        data.directions = this.wireDirections;
        if (this.arrowStartChoice.value.key !== defaultArrowTip.key) data.startArrow = this.arrowStartChoice.value.key;
        if (this.arrowEndChoice.value.key !== defaultArrowTip.key) data.endArrow = this.arrowEndChoice.value.key;
        return data;
    }
    static fromJson(saveObject) {
        if ((0, _internal.SaveController).instance.currentlyLoadedSaveVersion == "") {
            //@ts-ignore
            let points = [
                saveObject.start
            ];
            let directions = [];
            //@ts-ignore
            for (const segment of saveObject.segments){
                points.push(segment.endPoint);
                directions.push(segment.direction);
            }
            saveObject.points = points;
            saveObject.directions = directions;
        }
        return new WireComponent();
    }
    buildTikzCommand(command) {
        super.buildTikzCommand(command);
        let arrowOptions = [];
        if (this.arrowStartChoice.value.key !== defaultArrowTip.key) {
            arrowOptions.push(this.arrowStartChoice.value.tikz);
            arrowOptions.push("-");
        }
        if (this.arrowEndChoice.value.key !== defaultArrowTip.key) {
            if (arrowOptions.length == 0) arrowOptions.push("-");
            arrowOptions.push(this.arrowEndChoice.value.tikz);
        }
        if (arrowOptions.length > 0) command.options.push(arrowOptions.join(""));
        // Add current annotation if specified
        if (this.currentLabel && this.currentLabel.value != "") {
            let currentString = "i";
            let labelPosString = this.currentLabelPosition.value ? "_" : "^";
            let dirString = this.currentDirection.value ? "<" : ">";
            if (this.currentPosition.value) {
                // if position is start, the label position comes after the direction and both are required, except:
                if (this.currentLabelPosition.value == false && this.currentDirection.value == true) // if direction is backward and the label position is default above, the label position is not required
                labelPosString = "";
                currentString += dirString + labelPosString;
            } else {
                // if position is end, the label position comes before the direction
                if (this.currentDirection.value == false) {
                    // if direction is forward the label position is not required
                    dirString = "";
                    if (this.currentLabelPosition.value == false) // if the label position is default above and the direction is forward, the label position is also not required
                    labelPosString = "";
                }
                currentString += labelPosString + dirString;
            }
            currentString += "={$" + this.currentLabel.value + "$}";
            command.options.push(currentString);
            if (this.currentDistance.value.value != 0.5) command.options.push("current/distance=" + this.currentDistance.value.value.toString());
        }
        let pointArray = this.referencePoints.map((point)=>point);
        for(let index = 0; index < this.wireDirections.length; index++){
            const previousPoint = pointArray[index];
            const point = pointArray[index + 1];
            let dir = this.wireDirections[index];
            if (dir == WireDirection.HV && previousPoint.y == point.y) dir = WireDirection.Straight;
            if (dir == WireDirection.VH && previousPoint.x == point.x) dir = WireDirection.Straight;
            if (!dir) dir = WireDirection.Straight;
            command.connectors.push(dir);
        }
    }
    copyForPlacement() {
        return new WireComponent(this.onlyStraight, this.defaultArrowHead);
    }
    remove() {
        this.visualization.remove();
        this.viewSelected(false);
        this.selectionElement?.remove();
        if (this.finishedPlacing) this.draggable(false);
    }
    placeMove(pos, ev) {
        //only move the last corner point in the array
        if (this.referencePoints.length > 1) {
            let previousPoint = this.referencePoints.at(-2);
            let relToPreviousPoint = pos.sub(previousPoint);
            this.previousPlacingDirection = this.directionVecFromPos(relToPreviousPoint, this.previousPlacingDirection);
            this.wireDirections[this.wireDirections.length - 1] = this.wireDirectionFromDirectionVec(this.previousPlacingDirection, ev);
            this.referencePoints[this.referencePoints.length - 1] = pos;
            this.update();
        }
    }
    /**
     * This essentially adjusts the wire direction if necessary. If the cursor crosses the axis perpendicular to the previous initial direction of the wire segment, this axis should now be the initial direction of the wire segment
     * @param relPos the current position relative to the position of the previous point
     * @param lastDirection in which direction the wire was previously starting
     * @returns the adjusted direction
     */ directionVecFromPos(relPos, lastDirection) {
        var dir = lastDirection.clone();
        if (relPos.y != 0 && relPos.x * lastDirection.x < 0) {
            dir.x = 0;
            dir.y = Math.sign(relPos.y);
        } else if (relPos.x != 0 && relPos.y * lastDirection.y < 0) {
            dir.x = Math.sign(relPos.x);
            dir.y = 0;
        }
        return dir;
    }
    wireDirectionFromDirectionVec(directionVec, ev) {
        if (this.onlyStraight || ev && (ev.ctrlKey || (0, _internal.MainController).instance.isMac && ev.metaKey)) return WireDirection.Straight;
        else if (directionVec.x != 0) return WireDirection.HV;
        else if (directionVec.y != 0) return WireDirection.VH;
    }
    placeStep(pos) {
        if (this.finishedPlacing) return true;
        if (this.referencePoints.length > 0) {
            //if there already exists a wire, check if the same point was placed twice --> if so, the wire placement should end
            let previousPoint = this.referencePoints.at(-2); // there is never only one corner point in the array
            if (pos.eq(previousPoint)) return true;
        } else {
            this.referencePoints.push(pos.clone());
            this.updateTheme();
        }
        this.referencePoints.push(pos);
        this.wireDirections.push(WireDirection.HV);
        this.previousPlacingDirection.x = 1;
        this.previousPlacingDirection.y = 0;
        this.placeMove(pos);
        return false;
    }
    placeFinish() {
        if (this.finishedPlacing) //was already called
        return;
        if (this.referencePoints.length == 0) this.placeStep(new _svgJs.Point());
        // remove the point which was currently being placed (not actually part of the wire)
        this.referencePoints.pop();
        this.wireDirections.pop();
        if (this.referencePoints.length >= 2 && this.referencePoints.at(-1).eq(this.referencePoints.at(-2))) {
            // the last two points where equal -> remove one more
            this.referencePoints.pop();
            this.wireDirections.pop();
        }
        if (this.referencePoints.length < 2) {
            // if not event 2 corner points --> not a wire
            (0, _internal.MainController).instance.removeComponent(this);
            return;
        }
        this.updateTheme();
        this.update();
        this.finishedPlacing = true;
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        this.wireDirections = saveObject.directions ?? [];
        while(this.wireDirections.length < this.referencePoints.length - 1)this.wireDirections.push(WireDirection.Straight);
        if (saveObject.startArrow) this.arrowStartChoice.value = arrowTips.find((item)=>item.key == saveObject.startArrow);
        if (saveObject.endArrow) this.arrowEndChoice.value = arrowTips.find((item)=>item.key == saveObject.endArrow);
        this.updateTheme();
        this.update();
        this.finishedPlacing = true;
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../snapDrag/dragHandlers":"8WwEC","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8WwEC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SnapDragHandler", ()=>SnapDragHandler);
parcelHelpers.export(exports, "AdjustDragHandler", ()=>AdjustDragHandler);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
function getHighestParentGroup(component) {
    let parent = component;
    while(parent.parentGroup)parent = parent.parentGroup;
    return parent;
}
let currentlyDragging = null;
class SnapDragHandler {
    componentReference;
    element;
    startedDragging = false;
    didDrag = false;
    constructor(componentReference, element){
        this.componentReference = componentReference;
        this.element = element;
        this.element.remember("_snapDragHandler", this);
        this.element.draggable(true);
        this.element.on("dragstart", this.dragStart, this, {
            passive: true
        });
        this.element.on("dragmove.namespace", this.dragMove, this);
        this.element.on("dragend", this.dragEnd, this, {
            passive: true
        });
        this.element.on("mouseenter", (ev)=>{
            getHighestParentGroup(this.componentReference).isHovered = currentlyDragging ? this.componentReference == currentlyDragging : true;
        });
        this.element.on("mouseleave", (ev)=>{
            getHighestParentGroup(this.componentReference).isHovered = this.didDrag;
        });
    }
    static snapDrag(componentReference, enable, element = componentReference.visualization) {
        let snapDragHandler = element.remember("_snapDragHandler") ?? (enable ? new SnapDragHandler(componentReference, element) : null);
        if (enable === false && snapDragHandler) {
            // enable === false --> not undefined
            // if the snapDragHandler gets removed while currently moving, this means that the component placement is cancelled, i.e. no state should be added
            if (snapDragHandler.startedDragging) snapDragHandler.dragEnd(null, false);
            snapDragHandler.removeHandler();
            return null;
        }
        return snapDragHandler;
    }
    removeHandler() {
        this.element.off("dragstart", this.dragStart);
        this.element.off("dragmove.namespace", this.dragMove);
        this.element.off("dragend", this.dragEnd);
        this.element.off("mouseenter");
        this.element.off("mouseleave");
        this.element.draggable(false);
        this.element.forget("_snapDragHandler");
        this.element.forget("_draggable");
    }
    dragOffset;
    dragStart(ev) {
        this.startedDragging = true;
        currentlyDragging = this.componentReference;
        this.element.node.classList.add("dragging");
        this.element.parent().node.classList.add("dragging");
        this.dragOffset = this.componentReference.position.sub((0, _internal.CanvasController).eventToPoint(ev.detail.event, false));
        (0, _internal.SnapController).instance.updateSnapPoints(getHighestParentGroup(this.componentReference), false);
    }
    dragMove(ev) {
        this.didDrag = true;
        ev.preventDefault();
        const draggedPoint = (0, _internal.CanvasController).eventToPoint(ev.detail.event, false).add(this.dragOffset);
        // calculate where the selection/component should be placed
        let shiftKey = ev.detail.event.shiftKey;
        let destination = shiftKey ? draggedPoint : (0, _internal.SnapController).instance.snapPoint(draggedPoint, this.componentReference);
        (0, _internal.SnapController).instance.showSnapPoints(!shiftKey);
        let parent = getHighestParentGroup(this.componentReference);
        if (parent.isSelected) //move the whole selection to the destination
        (0, _internal.SelectionController).instance.moveSelectionRel(destination.sub(this.componentReference.position));
        else parent.moveTo(destination.add(parent.position.sub(this.componentReference.position)));
        (0, _internal.SnapController).instance.recalculateAdditionalSnapPoints();
    }
    dragEnd(ev, trackState = true) {
        if (!this.startedDragging) return;
        currentlyDragging = null;
        let parent = getHighestParentGroup(this.componentReference);
        if (!this.didDrag) {
            // didn't move at all -> essentially clicked the component --> select the component instead; no Undo state
            let ctrlCommand = ev.detail.event.ctrlKey || (0, _internal.MainController).instance.isMac && ev.detail.event.metaKey;
            let selectionMode = ev.detail.event.shiftKey ? (0, _internal.SelectionMode).ADD : ctrlCommand ? (0, _internal.SelectionMode).SUB : (0, _internal.SelectionMode).RESET;
            if (selectionMode == (0, _internal.SelectionMode).RESET && (0, _internal.SelectionController).instance.currentlySelectedComponents.includes(parent) && (0, _internal.SelectionController).instance.currentlySelectedComponents.length > 1) (0, _internal.SelectionController).instance.setReference(parent);
            else (0, _internal.SelectionController).instance.selectComponents([
                parent
            ], selectionMode);
            trackState = false;
        }
        // reset drag states
        this.didDrag = false;
        this.startedDragging = false;
        this.element.node.classList.remove("dragging");
        this.element.parent().node.classList.remove("dragging");
        (0, _internal.SnapController).instance.showSnapPoints(false);
        if (window.TouchEvent && ev.detail?.event instanceof TouchEvent) {
            const clientXY = ev.detail.event.touches?.[0] ?? ev.detail.event.changedTouches?.[0];
            const contextMenuEvent = new PointerEvent("contextmenu", {
                clientX: clientXY.clientX,
                clientY: clientXY.clientY
            });
            Promise.resolve().then(()=>this.element.node.dispatchEvent(contextMenuEvent));
        }
        // only recalculate snapping points after movement is done! (since they are part of the movement which would lead to eratic behaviour)
        if (parent.isSelected) for (const component of (0, _internal.SelectionController).instance.currentlySelectedComponents)component.recalculateSnappingPoints();
        else parent.recalculateSnappingPoints();
        if (trackState) (0, _internal.Undo).addState();
    }
}
class AdjustDragHandler {
    dragCallbacks;
    element;
    componentReference;
    startedDragging = false;
    didDrag = false;
    constructor(componentReference, element, callbacks){
        this.element = element;
        this.componentReference = componentReference;
        this.dragCallbacks = callbacks;
        this.element.remember("_adjustDragHandler", this);
        this.element.draggable(true);
        this.element.on("dragstart", this.dragStart, this, {
            passive: true
        });
        this.element.on("dragmove.namespace", this.dragMove, this);
        this.element.on("dragend", this.dragEnd, this, {
            passive: true
        });
        this.element.on("mouseenter", (ev)=>{
            this.componentReference.isHovered = currentlyDragging ? this.componentReference == currentlyDragging : true;
        });
        this.element.on("mouseleave", (ev)=>{
            this.componentReference.isHovered = this.didDrag;
        });
    }
    static snapDrag(componentReference, element, enable, callbacks = {}) {
        let adjustDragHandler = element.remember("_adjustDragHandler") ?? (enable ? new AdjustDragHandler(componentReference, element, callbacks) : null);
        if (enable === false && adjustDragHandler) {
            // enable === false --> not undefined
            // if the snapDragHandler gets removed while currently moving, this means that the component placement is cancelled, i.e. no state should be added
            if (adjustDragHandler.startedDragging) adjustDragHandler.dragEnd(null, false);
            adjustDragHandler.removeHandler();
            return null;
        }
        return adjustDragHandler;
    }
    /**
     * Remove the handler and deactivate `draggable` feature.
     */ removeHandler() {
        this.element.off("dragstart", this.dragStart);
        this.element.off("dragmove.namespace", this.dragMove);
        this.element.off("dragend", this.dragEnd);
        this.element.off("mouseenter");
        this.element.off("mouseleave");
        this.element.draggable(false);
        this.element.forget("_adjustDragHandler");
        this.element.forget("_draggable");
    }
    //- listener -------------------------------------------------------------------------------------------------------
    /**
     * Listener for the "dragstart" event. Changes the cursor symbol using the class "dragging".
     * @param {DragEvent} event
     */ dragStart(event) {
        this.startedDragging = true;
        currentlyDragging = this.componentReference;
        this.element.node.classList.add("dragging");
        this.element.parent().node.classList.add("dragging");
        (0, _internal.SnapController).instance.updateSnapPoints(this.componentReference, true);
        if (this.dragCallbacks && this.dragCallbacks.dragStart) {
            const draggedPoint = new _svgJs.Point(event.detail.box.cx, event.detail.box.cy);
            let shiftKey = event.detail.event.shiftKey;
            let destination = shiftKey ? draggedPoint : (0, _internal.SnapController).instance.snapPoint(draggedPoint, this.componentReference);
            this.dragCallbacks.dragStart(destination, event.detail.event);
            (0, _internal.SnapController).instance.recalculateAdditionalSnapPoints();
        }
    }
    /**
     * Handler for the dragging event. Alters the default behavior to enable snapping to grid and to other components.
     *
     * @private
     * @param {DragEvent} event - the dragging event.
     */ dragMove(event) {
        event.preventDefault();
        if (window.TouchEvent && event.detail.event instanceof TouchEvent && event.detail.event.touches.length > 1) {
            this.didDrag = true;
            this.dragEnd(event, true);
            return;
        }
        this.didDrag = true;
        const draggedPoint = new _svgJs.Point(event.detail.box.cx, event.detail.box.cy);
        let shiftKey = event.detail.event.shiftKey;
        let destination = shiftKey ? draggedPoint : (0, _internal.SnapController).instance.snapPoint(draggedPoint, this.componentReference);
        (0, _internal.SnapController).instance.showSnapPoints(!shiftKey);
        if (this.dragCallbacks && this.dragCallbacks.dragMove) this.dragCallbacks.dragMove(destination, event.detail.event);
        (0, _internal.SnapController).instance.recalculateAdditionalSnapPoints();
    }
    /**
     * Listener for the "dragend" event. Undo the cursor change from {@link "#dragStart"}.
     * @param {DragEvent} event
     */ dragEnd(event, trackState = true) {
        if (!this.startedDragging) return;
        currentlyDragging = null;
        if (!this.didDrag) {
            // didn't move at all -> essentially clicked the component --> select the component instead
            let ctrlCommand = event.detail.event.ctrlKey || (0, _internal.MainController).instance.isMac && event.detail.event.metaKey;
            let selectionMode = event.detail.event.shiftKey ? (0, _internal.SelectionMode).ADD : ctrlCommand ? (0, _internal.SelectionMode).SUB : (0, _internal.SelectionMode).RESET;
            if (selectionMode == (0, _internal.SelectionMode).RESET && (0, _internal.SelectionController).instance.currentlySelectedComponents.includes(this.componentReference) && (0, _internal.SelectionController).instance.currentlySelectedComponents.length > 1) (0, _internal.SelectionController).instance.setReference(this.componentReference);
            else (0, _internal.SelectionController).instance.selectComponents([
                this.componentReference
            ], selectionMode);
            trackState = false;
        }
        this.didDrag = false;
        this.startedDragging = false;
        this.element.node.classList.remove("dragging");
        this.element.parent().node.classList.remove("dragging");
        (0, _internal.SnapController).instance.showSnapPoints(false);
        let shouldUndo = false;
        if (this.dragCallbacks && this.dragCallbacks.dragEnd) shouldUndo = this.dragCallbacks.dragEnd();
        this.componentReference.recalculateSnappingPoints();
        if (trackState && shouldUndo) (0, _internal.Undo).addState();
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jLqoY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dashArrayToPattern", ()=>dashArrayToPattern);
parcelHelpers.export(exports, "ShapeComponent", ()=>ShapeComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
const dashArrayToPattern = (linewidth, dasharray)=>{
    let pattern = [];
    for(let index = 0; index < dasharray.length - 1; index += 2){
        const onElement = dasharray[index];
        const offElement = dasharray[index + 1];
        pattern.push("on " + linewidth.times(onElement).toString());
        pattern.push("off " + linewidth.times(offElement).toString());
    }
    return "dash pattern={" + pattern.join(" ") + "}";
};
class ShapeComponent extends (0, _internal.Strokable)((0, _internal.Fillable)((0, _internal.NodeComponent))) {
    placePoint;
    constructor(){
        super();
        this.resizeVisualizations = new Map();
        this.snappingPoints = [];
        (0, _internal.CanvasController).instance.canvas.add(this.visualization);
    }
    moveTo(position) {
        this.position = position;
        this.update();
    }
    rotate(angleDeg) {
        this.rotationDeg += angleDeg;
        this.simplifyRotationAngle();
        this.update();
    }
    flip(horizontal) {
        this.rotationDeg = (horizontal ? 0 : 180) - this.rotationDeg;
        this.simplifyRotationAngle();
        this.update();
    }
    recalculateResizePoints() {
        const halfsize = this.size.div(2);
        const transformMatrix = this.getTransformMatrix();
        for (const [dir, viz] of this.resizeVisualizations){
            let pos = halfsize.add(halfsize.mul(dir.direction)).transform(transformMatrix);
            viz.center(pos.x, pos.y);
        }
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        this.placePoint = this.position;
        this.size = new _svgJs.Point(saveObject.size);
        this.referencePosition = this.size.div(2);
    }
    toJson() {
        const data = super.toJson();
        data.size = this.size;
        return data;
    }
    getTransformMatrix() {
        return new _svgJs.Matrix({
            scaleX: this.scaleState.x,
            scaleY: this.scaleState.y,
            translate: [
                -this.referencePosition.x,
                -this.referencePosition.y
            ],
            origin: [
                this.referencePosition.x,
                this.referencePosition.y
            ]
        }).lmultiply(new _svgJs.Matrix({
            rotate: -this.rotationDeg,
            translate: [
                this.position.x,
                this.position.y
            ]
        }));
    }
    update() {
        let strokeWidth = this.strokeInfo.width.convertToUnit("px").value;
        let transformMatrix = this.getTransformMatrix();
        const halfSize = this.size.div(2);
        this.dragElement.size(this.size.x, this.size.y);
        this.dragElement.transform(transformMatrix);
        this.componentVisualization.size(this.size.x < strokeWidth ? 0 : this.size.x - strokeWidth, this.size.y < strokeWidth ? 0 : this.size.y - strokeWidth);
        this.componentVisualization.center(halfSize.x, halfSize.y);
        this.componentVisualization.transform(transformMatrix);
        this.defaultTextPosition = halfSize;
        this._bbox = this.dragElement.bbox().transform(transformMatrix);
        //update resize pointers
        if (this.isResizing) for (const [direction, viz] of this.resizeVisualizations.entries()){
            const directionTransformed = direction.direction.transform(new _svgJs.Matrix({
                rotate: -this.rotationDeg,
                scaleX: this.scaleState.x,
                scaleY: this.scaleState.y
            }));
            viz.node.style.cursor = (0, _internal.closestBasicDirection)(directionTransformed).pointer;
        }
        this.recalculateSelectionVisuals();
        this.recalculateSnappingPoints();
        this.recalculateResizePoints();
        this.updatePositionedLabel();
    }
    recalculateSelectionVisuals() {
        if (this.selectionElement) this.selectionElement.size(this.size.x + (0, _selectionHelper.selectedBoxWidth), this.size.y + (0, _selectionHelper.selectedBoxWidth)).center(this.size.x / 2, this.size.y / 2).transform(this.getTransformMatrix());
    }
    updateTheme() {
        let strokeColor = this.strokeInfo.color;
        if (strokeColor == "default") strokeColor = (0, _internal.defaultStroke);
        this.componentVisualization?.stroke({
            color: strokeColor,
            opacity: this.strokeInfo.opacity,
            width: this.strokeInfo.opacity == 0 ? 0 : this.strokeInfo.width.convertToUnit("px").value,
            dasharray: this.strokeStyleProperty.value.dasharray.map((factor)=>this.strokeInfo.width.times(factor).toString()).join(" ")
        });
        let fillColor = this.fillInfo.color;
        if (fillColor == "default") fillColor = "none";
        this.componentVisualization?.fill({
            color: fillColor,
            opacity: this.fillInfo.opacity
        });
        let labelColor = (0, _internal.defaultStroke);
        if (this.labelColor.value) labelColor = this.labelColor.value.toString();
        this.labelRendering?.fill(labelColor);
    }
    remove() {
        for (const [dir, viz] of this.resizeVisualizations){
            (0, _internal.AdjustDragHandler).snapDrag(this, viz, false);
            viz.remove();
        }
        (0, _internal.SnapDragHandler).snapDrag(this, false);
        this.visualization.remove();
        this.draggable(false);
        this.resizable(false);
        this.viewSelected(false);
        this.selectionElement?.remove();
    }
    getSnappingInfo() {
        return {
            trackedSnappingPoints: this.snappingPoints,
            additionalSnappingPoints: []
        };
    }
    viewSelected(show) {
        super.viewSelected(show);
        this.resizable(this.isSelected && show && (0, _internal.SelectionController).instance.currentlySelectedComponents.length == 1);
    }
    resizable(resize) {
        // general method: work with positions in non rotated reference frame (rotation of rotated positions has to be compensated --> inverse transform Matrix). Rotation is done in update via the transformMatrix
        if (resize == this.isResizing) return;
        this.isResizing = resize;
        if (resize) {
            let originalPos;
            let originalSize;
            let transformMatrixInv;
            const getInitialDim = ()=>{
                originalPos = this.position.clone();
                originalSize = this.size.clone();
                transformMatrixInv = this.getTransformMatrix().inverse();
            };
            for (const direction of (0, _internal.basicDirections)){
                if (direction.key == (0, _internal.defaultBasicDirection).key || direction.key == "center") continue;
                let viz = (0, _selectionHelper.resizeSVG)();
                this.resizeVisualizations.set(direction, viz);
                let startPoint;
                let oppositePoint;
                (0, _internal.AdjustDragHandler).snapDrag(this, viz, true, {
                    dragStart: (pos)=>{
                        getInitialDim();
                        let positionLocal = originalPos.transform(transformMatrixInv);
                        startPoint = positionLocal.add(direction.direction.mul(originalSize).div(2));
                        oppositePoint = positionLocal.add(direction.direction.mul(originalSize).div(-2));
                    },
                    dragMove: (pos, ev)=>{
                        pos = pos.transform(transformMatrixInv);
                        if (ev && ev.ctrlKey && direction.direction.x * direction.direction.y != 0) {
                            // get closest point on one of the two diagonals
                            let diff = pos.sub(oppositePoint);
                            if (diff.x * diff.y < 0) pos = new _svgJs.Point(pos.x - pos.y, pos.y - pos.x).add(oppositePoint.x + oppositePoint.y).div(2);
                            else pos = new _svgJs.Point(oppositePoint.x - oppositePoint.y, oppositePoint.y - oppositePoint.x).add(pos.x + pos.y).div(2);
                        }
                        let dirAbs = new _svgJs.Point(Math.abs(direction.direction.x), Math.abs(direction.direction.y));
                        let delta = pos.sub(startPoint);
                        this.size.x = direction.direction.x ? Math.abs(pos.x - oppositePoint.x) : originalSize.x;
                        this.size.y = direction.direction.y ? Math.abs(pos.y - oppositePoint.y) : originalSize.y;
                        this.referencePosition = this.size.div(2);
                        this.position = originalPos.add(delta.mul(dirAbs.div(2)).rotate(this.rotationDeg));
                        this.update();
                    },
                    dragEnd: ()=>{
                        return true;
                    }
                });
            }
            this.update();
        } else {
            for (const [dir, viz] of this.resizeVisualizations){
                (0, _internal.AdjustDragHandler).snapDrag(this, viz, false);
                viz.remove();
            }
            this.resizeVisualizations.clear();
        }
    }
    placeMove(pos, ev) {
        if (!this.placePoint) ;
        else {
            let secondPoint;
            if (ev && ev.ctrlKey) {
                // get point on one of the two diagonals
                let diff = pos.sub(this.placePoint);
                if (diff.x * diff.y < 0) secondPoint = new _svgJs.Point(pos.x - pos.y, pos.y - pos.x).add(this.placePoint.x + this.placePoint.y).div(2);
                else secondPoint = new _svgJs.Point(this.placePoint.x - this.placePoint.y, this.placePoint.y - this.placePoint.x).add(pos.x + pos.y).div(2);
            } else secondPoint = pos;
            this.position = this.placePoint.add(secondPoint).div(2);
            this.size = new _svgJs.Point(Math.abs(secondPoint.x - this.placePoint.x), Math.abs(secondPoint.y - this.placePoint.y));
            this.referencePosition = this.size.div(2);
            this.update();
        }
    }
    placeStep(pos, ev) {
        if (this.finishedPlacing) return true;
        if (!this.placePoint) {
            this.placePoint = pos;
            this.position = pos;
            this.size = new _svgJs.Point();
            this.referencePosition = this.size.div(2);
            this.componentVisualization.show();
            this.updateTheme();
            return false;
        }
        this.placeMove(pos, ev);
        return true;
    }
    placeFinish() {
        if (this.finishedPlacing) return;
        if (!this.placePoint) this.placeStep(new _svgJs.Point());
        this.finishedPlacing = true;
        this.update();
        this.componentVisualization.show();
        this.updateTheme();
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2wU8d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fontSizes", ()=>fontSizes);
parcelHelpers.export(exports, "defaultFontSize", ()=>defaultFontSize);
parcelHelpers.export(exports, "TextAlign", ()=>TextAlign);
parcelHelpers.export(exports, "TextJustify", ()=>TextJustify);
parcelHelpers.export(exports, "RectangleComponent", ()=>RectangleComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
const fontSizes = [
    {
        key: "tiny",
        name: "tiny",
        size: 5
    },
    {
        key: "scriptsize",
        name: "scriptsize",
        size: 7
    },
    {
        key: "footnotesize",
        name: "footnotesize",
        size: 8
    },
    {
        key: "small",
        name: "small",
        size: 9
    },
    {
        key: "normalsize",
        name: "normalsize",
        size: 10
    },
    {
        key: "large",
        name: "large",
        size: 12
    },
    {
        key: "Large",
        name: "Large",
        size: 14.4
    },
    {
        key: "LARGE",
        name: "LARGE",
        size: 17.28
    },
    {
        key: "huge",
        name: "huge",
        size: 20.74
    },
    {
        key: "Huge",
        name: "Huge",
        size: 24.88
    }
];
const defaultFontSize = fontSizes[4];
var TextAlign;
(function(TextAlign) {
    TextAlign[TextAlign["LEFT"] = 0] = "LEFT";
    TextAlign[TextAlign["CENTER"] = 1] = "CENTER";
    TextAlign[TextAlign["RIGHT"] = 2] = "RIGHT";
    TextAlign[TextAlign["JUSTIFY"] = 3] = "JUSTIFY";
})(TextAlign || (TextAlign = {}));
var TextJustify;
(function(TextJustify) {
    TextJustify[TextJustify["START"] = -1] = "START";
    TextJustify[TextJustify["CENTER"] = 0] = "CENTER";
    TextJustify[TextJustify["END"] = 1] = "END";
})(TextJustify || (TextJustify = {}));
class RectangleComponent extends (0, _internal.ShapeComponent) {
    static jsonID = "rect";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(RectangleComponent.jsonID, RectangleComponent);
    }
    text;
    textAreaProperty;
    textAreaPlaceHolder;
    textAreaHyphenation;
    textAreaAlign;
    textAreaJustify;
    textFontSize;
    textInnerSep;
    textColor;
    textSVG;
    createAsText;
    useHyphenation;
    constructor(createAsText = false){
        super();
        this.createAsText = createAsText;
        this.useHyphenation = false;
        this.displayName = "Rectangle";
        this.componentVisualization = (0, _internal.CanvasController).instance.canvas.rect(0, 0);
        this.componentVisualization.hide();
        this.dragElement = (0, _internal.CanvasController).instance.canvas.rect(0, 0);
        this.dragElement.attr({
            fill: "transparent",
            stroke: "none"
        });
        this.visualization.add(this.componentVisualization);
        this.visualization.add(this.dragElement);
        this.properties.add((0, _internal.PropertyCategories).text, new (0, _internal.SectionHeaderProperty)("Text", undefined, "text:header"));
        this.textAreaProperty = new (0, _internal.TextAreaProperty)("", undefined, "text:area");
        if (createAsText) this.strokeStyleProperty.value = (0, _internal.strokeStyleChoices)[1];
        this.textAreaProperty.addChangeListener((ev)=>{
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textAreaProperty);
        this.textAreaPlaceHolder = new (0, _internal.BooleanProperty)("Placeholder", createAsText, undefined, "text:placeholder");
        this.textAreaPlaceHolder.addChangeListener((ev)=>{
            this.createAsText = ev.value;
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textAreaPlaceHolder);
        this.textAreaHyphenation = new (0, _internal.BooleanProperty)("Hyphenation", this.useHyphenation, undefined, "text:hyphenation");
        this.textAreaHyphenation.addChangeListener((ev)=>{
            this.useHyphenation = ev.value;
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textAreaHyphenation);
        this.textAreaAlign = new (0, _internal.RadioButtonProperty)("Align", [
            {
                key: "LEFT",
                name: "format_align_left",
                isMaterialSymbol: true,
                numberID: TextAlign.LEFT
            },
            {
                key: "CENTER",
                name: "format_align_center",
                isMaterialSymbol: true,
                numberID: TextAlign.CENTER
            },
            {
                key: "RIGHT",
                name: "format_align_right",
                isMaterialSymbol: true,
                numberID: TextAlign.RIGHT
            },
            {
                key: "JUSTIFY",
                name: "format_align_justify",
                isMaterialSymbol: true,
                numberID: TextAlign.JUSTIFY
            }
        ], {
            key: "LEFT",
            name: "format_align_left",
            isMaterialSymbol: true,
            numberID: TextAlign.LEFT
        }, undefined, "text:align");
        this.textAreaAlign.addChangeListener((ev)=>{
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textAreaAlign);
        this.textAreaJustify = new (0, _internal.RadioButtonProperty)("Justify", [
            {
                key: "START",
                name: "vertical_align_top",
                isMaterialSymbol: true,
                numberID: TextJustify.START
            },
            {
                key: "CENTER",
                name: "vertical_align_center",
                isMaterialSymbol: true,
                numberID: TextJustify.CENTER
            },
            {
                key: "END",
                name: "vertical_align_bottom",
                isMaterialSymbol: true,
                numberID: TextJustify.END
            }
        ], {
            key: "START",
            name: "vertical_align_top",
            isMaterialSymbol: true,
            numberID: TextJustify.START
        }, undefined, "text:justify");
        this.textAreaJustify.addChangeListener((ev)=>{
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textAreaJustify);
        this.textFontSize = new (0, _internal.ChoiceProperty)("Fontsize", fontSizes, defaultFontSize, undefined, "text:fontsize");
        this.textFontSize.addChangeListener((ev)=>{
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textFontSize);
        this.textInnerSep = new (0, _internal.SliderProperty)("Inner sep", 0, 10, 0.1, new _svgJs.Number(5, "pt"), undefined, undefined, "text:innersep");
        this.textInnerSep.addChangeListener((ev)=>{
            this.update();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textInnerSep);
        this.textColor = new (0, _internal.ColorProperty)("Color", null, undefined, undefined, "text:color");
        this.textColor.addChangeListener((ev)=>{
            this.updateText();
        });
        this.properties.add((0, _internal.PropertyCategories).text, this.textColor);
        this.selectionElement = (0, _internal.CanvasController).instance.canvas.rect(0, 0).hide();
    }
    recalculateSnappingPoints(matrix) {
        let relPositions = [];
        let halfSize = this.size.div(2);
        for (const anchor of (0, _internal.basicDirections)){
            if (anchor.key == (0, _internal.defaultBasicDirection).key) continue;
            relPositions.push({
                relPos: halfSize.mul(anchor.direction),
                anchorname: anchor.name
            });
        }
        if (!this.snappingPoints || this.snappingPoints.length == 0) for (const element of relPositions)this.snappingPoints.push(new (0, _internal.SnapPoint)(this, element.anchorname, element.relPos.add(halfSize)));
        else for(let index = 0; index < relPositions.length; index++){
            const relPos = relPositions[index].relPos;
            const snappingPoint = this.snappingPoints[index];
            snappingPoint.updateRelPosition(relPos.add(halfSize));
            snappingPoint.recalculate();
        }
    }
    isInsideSelectionRectangle(selectionRectangle) {
        const rect = new _svgJs.Box(this.position.x - this.size.x / 2, this.position.y - this.size.y / 2, this.size.x, this.size.y);
        return (0, _selectionHelper.rectRectIntersection)(rect, selectionRectangle, this.rotationDeg);
    }
    update() {
        super.update();
        this.updateText();
    }
    toJson() {
        const data = super.toJson();
        data.type = RectangleComponent.jsonID;
        data.size = this.size.simplifyForJson();
        if (this.textAreaProperty.value) {
            let textData = {
                text: undefined
            };
            let hasText = false;
            if (this.textAreaProperty.value != undefined && this.textAreaProperty.value !== "") {
                textData.text = this.textAreaProperty.value;
                if (this.textAreaAlign.value.numberID !== TextAlign.LEFT) textData.align = this.textAreaAlign.value.numberID;
                if (this.textAreaJustify.value.numberID !== TextJustify.START) textData.justify = this.textAreaJustify.value.numberID;
                if (this.textFontSize.value.key !== defaultFontSize.key) textData.fontSize = this.textFontSize.value.key;
                if (this.textInnerSep.value.value !== 5) textData.innerSep = this.textInnerSep.value;
                if (this.textColor.value) textData.color = this.textColor.value.toString();
                hasText = true;
            }
            textData.showPlaceholderText = this.createAsText || undefined;
            textData.useHyphenation = this.useHyphenation || undefined;
            if (hasText || this.createAsText) data.text = textData;
        }
        return data;
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        if (saveObject.text) {
            let text = {
                text: saveObject.text.text == undefined ? "" : saveObject.text.text,
                align: saveObject.text.align ?? TextAlign.LEFT,
                justify: saveObject.text.justify ?? TextJustify.START,
                showPlaceholderText: saveObject.text.showPlaceholderText ?? false,
                useHyphenation: saveObject.text.useHyphenation ?? false
            };
            this.createAsText = text.showPlaceholderText;
            this.useHyphenation = text.useHyphenation;
            this.textAreaProperty.value = text.text;
            this.textAreaPlaceHolder.value = this.createAsText;
            this.textAreaHyphenation.value = this.useHyphenation;
            this.textAreaAlign.value = Object.values(this.textAreaAlign.options).find((item)=>item.numberID == text.align) ?? this.textAreaAlign.options[0];
            this.textAreaJustify.value = Object.values(this.textAreaJustify.options).find((item)=>item.numberID == text.justify) ?? this.textAreaJustify.options[0];
            this.textFontSize.value = saveObject.text.fontSize ? fontSizes.find((item)=>item.key == saveObject.text.fontSize) : defaultFontSize;
            if (saveObject.text.innerSep) {
                if (!(typeof saveObject.text.innerSep == "string")) // SVG.Number as object
                this.textInnerSep.value = new _svgJs.Number(saveObject.text.innerSep.value, saveObject.text.innerSep.unit);
                else // SVG.Number as string
                this.textInnerSep.value = new _svgJs.Number(saveObject.text.innerSep);
            } else this.textInnerSep.value = new _svgJs.Number("5pt");
            this.textColor.value = saveObject.text.color ? new _svgJs.Color(saveObject.text.color) : null;
        }
        this.update();
        this.componentVisualization.show();
        this.updateTheme();
    }
    static fromJson(saveObject) {
        let rectComponent = new RectangleComponent();
        return rectComponent;
    }
    /**
     * override placeFinish: change the default look of the component if the rectangle was created as a text component
     */ placeFinish() {
        super.placeFinish();
        if (this.createAsText) {
            this.strokeOpacityProperty.value = new _svgJs.Number(0, "%");
            this.strokeInfo.opacity = this.strokeOpacityProperty.value.value / 100;
            this.updateTheme();
            this.strokeStyleProperty.value = (0, _internal.strokeStyleChoices)[0];
            this.update();
        }
    }
    buildTikzCommand(command) {
        command.options.push("shape=rectangle");
        super.buildTikzCommand(command);
        let strokeWidth = this.strokeInfo.width.convertToUnit("px").value;
        command.options.push("minimum width=" + (0, _selectionHelper.roundTikz)(new _svgJs.Number(this.size.x - strokeWidth, "px").convertToUnit("cm").value) + "cm");
        command.options.push("minimum height=" + (0, _selectionHelper.roundTikz)(new _svgJs.Number(this.size.y - strokeWidth, "px").convertToUnit("cm").value) + "cm");
        if (this.textAreaProperty.value) {
            let options = [];
            //treat justify like left aligned
            let alignDir = this.textAreaAlign.value.numberID == TextAlign.JUSTIFY ? -1 : this.textAreaAlign.value.numberID - 1;
            let dir = new _svgJs.Point(alignDir, this.textAreaJustify.value.numberID);
            // which anchor and position corresponds to the direction?
            let anchor = (0, _internal.basicDirections).find((item)=>item.direction.eq(dir)).name;
            let pos = this.position.add(dir.mul(this.size.div(2)).rotate(this.rotationDeg));
            options.push("anchor=" + anchor);
            switch(this.textAreaAlign.value.numberID){
                case TextAlign.LEFT:
                    options.push("align=left");
                    break;
                case TextAlign.CENTER:
                    options.push("align=center");
                    break;
                case TextAlign.RIGHT:
                    options.push("align=right");
                    break;
                default:
                    options.push("align=justify");
                    break;
            }
            // text dimensions
            let innerSep = this.textInnerSep.value.plus(this.strokeInfo.width);
            let textWidth = new _svgJs.Number(this.size.x, "px").minus(innerSep.times(2)).convertToUnit("cm");
            options.push(`text width=${(0, _selectionHelper.roundTikz)(textWidth.value)}cm`);
            options.push(`inner sep=${innerSep.toString()}`);
            //escape special characters
            const replaceDict = {
                "#": "\\#",
                "$": "\\$",
                "%": "\\%",
                "&": "\\&",
                "_": "\\_",
                "{": "\\{",
                "}": "\\}",
                "~": "\\textasciitilde",
                "^": "\\textasciicircum",
                "\\": "\\textbackslash",
                "\n": "\\\\"
            };
            const mathjaxParser = new (0, _internal.MathjaxParser)();
            const sections = [];
            const textSections = mathjaxParser.parse(this.textAreaProperty.value);
            for (const section of textSections)if (section.type == "text") sections.push(section.text.replaceAll(/[\#\%\$\&\_\{\}\~\^\\\n]/g, (match)=>replaceDict[match]));
            else sections.push("$" + section.text + "$");
            let escapedText = sections.join(" ");
            let fontStr = this.textFontSize.value.key == defaultFontSize.key ? "" : `\\${this.textFontSize.value.name} `;
            let latexStr = `${fontStr}${escapedText}`;
            latexStr = this.textColor.value ? "\\textcolor" + this.textColor.value.toTikzString() + "{" + latexStr + "}" : latexStr;
            command.additionalNodes.push({
                options: options,
                position: pos,
                content: latexStr,
                additionalNodes: []
            });
        }
    }
    toSVG(defs) {
        const copiedSVG = super.toSVG(defs);
        if (this.textSVG) {
            let texts = copiedSVG.find("text");
            for (const textElement of texts){
                let transform = textElement.transform();
                let fontSize = new _svgJs.Number(textElement.attr("font-size")).convertToUnit("px").value;
                let fill = textElement.fill();
                let g = new _svgJs.G();
                g.fill(fill);
                g.transform(transform);
                let tspans = textElement.find("tspan");
                for (const tspanElement of tspans){
                    let pathString = (0, _internal.textToSVG).getD(tspanElement.node.textContent, {
                        x: Number.parseFloat(tspanElement.node.getAttribute("x")),
                        y: Number.parseFloat(tspanElement.node.getAttribute("y")),
                        fontSize: fontSize
                    });
                    let path = new _svgJs.Path({
                        d: pathString
                    });
                    g.add(path);
                }
                textElement.parent().add(g);
                textElement.remove();
            }
            if (!this.textAreaProperty.value) copiedSVG.removeElement(copiedSVG.find(".textSVG")[0]);
            this.textSVG.removeClass("textSVG");
            copiedSVG.findOne(".textSVG")?.removeClass("textSVG");
        }
        return copiedSVG;
    }
    copyForPlacement() {
        return new RectangleComponent(this.createAsText);
    }
    updateText() {
        this.textSVG?.remove();
        if (this.textAreaProperty.value || this.createAsText) {
            let textData = {
                text: this.textAreaProperty.value || (this.createAsText ? "text component" : "")
            };
            textData.align = this.textAreaAlign.value.numberID ?? TextAlign.LEFT;
            textData.justify = this.textAreaJustify.value.numberID ?? TextJustify.START;
            textData.fontSize = this.textFontSize.value.key;
            textData.color = this.textColor.value?.toString() || "var(--bs-emphasis-color)";
            const innerSep = this.textInnerSep.value.convertToUnit("px").value;
            let strokeWidth = this.strokeInfo.width.convertToUnit("px").value;
            let w = this.size.x - strokeWidth * 2 - 2 * innerSep;
            let h = this.size.y - strokeWidth * 2 - 2 * innerSep;
            const textPos = this.position.sub(new _svgJs.Point(w > 0 ? w : 0, h > 0 ? h : 0).div(2));
            const textBox = new _svgJs.Box(textPos.x, textPos.y, w > 0 ? w : 0, h > 0 ? h : 0);
            if (this.textSVG) {
                let removeIDs = new Set();
                for (const element of this.textSVG.find("use"))removeIDs.add(element.node.getAttribute("xlink:href"));
                for (const id of removeIDs)(0, _internal.CanvasController).instance.canvas.find(id)[0]?.remove();
            }
            this.textSVG = (0, _internal.convertTextToNativeSVGText)(textData, textBox, this.useHyphenation);
            let transformMatrix = new _svgJs.Matrix({
                rotate: -this.rotationDeg,
                origin: [
                    this.position.x,
                    this.position.y
                ]
            });
            this.textSVG.transform(transformMatrix);
            this.textSVG.node.style.pointerEvents = "none";
            this.visualization.add(this.textSVG);
        }
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i8ejU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EllipseComponent", ()=>EllipseComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class EllipseComponent extends (0, _internal.ShapeComponent) {
    static jsonID = "ellipse";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(EllipseComponent.jsonID, EllipseComponent);
    }
    get isCircle() {
        return Math.abs(this.size.x - this.size.y) < 1e-5;
    }
    constructor(){
        super();
        this.displayName = "Ellipse";
        this.componentVisualization = (0, _internal.CanvasController).instance.canvas.ellipse(0, 0);
        this.componentVisualization.hide();
        this.dragElement = (0, _internal.CanvasController).instance.canvas.ellipse(0, 0);
        this.dragElement.attr({
            fill: "transparent",
            stroke: "none"
        });
        this.visualization.add(this.componentVisualization);
        this.visualization.add(this.dragElement);
    }
    update() {
        super.update();
        this.componentVisualization.center(this.referencePosition.x, this.referencePosition.y);
        this.dragElement.center(this.referencePosition.x, this.referencePosition.y);
    }
    recalculateSnappingPoints(matrix) {
        let relPositions = [];
        let halfSize = this.size.div(2);
        for (const anchor of (0, _internal.basicDirections)){
            if (anchor.key == (0, _internal.defaultBasicDirection).key) continue;
            let dirLength = anchor.direction.abs();
            dirLength = dirLength == 0 ? 1 : dirLength;
            relPositions.push({
                relPos: halfSize.mul(anchor.direction.div(dirLength)),
                anchorname: anchor.name
            });
            if (dirLength > 1) relPositions.push({
                relPos: halfSize.mul(anchor.direction),
                anchorname: ""
            });
        }
        if (!this.snappingPoints || this.snappingPoints.length == 0) for (const element of relPositions)this.snappingPoints.push(new (0, _internal.SnapPoint)(this, element.anchorname, element.relPos.add(halfSize)));
        else for(let index = 0; index < relPositions.length; index++){
            const relPos = relPositions[index].relPos;
            const snappingPoint = this.snappingPoints[index];
            snappingPoint.updateRelPosition(relPos.add(halfSize));
            snappingPoint.recalculate();
        }
    }
    toJson() {
        const data = super.toJson();
        data.type = EllipseComponent.jsonID;
        return data;
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        this.update();
        this.componentVisualization.show();
        this.updateTheme();
    }
    static fromJson(saveObject) {
        return new EllipseComponent();
    }
    buildTikzCommand(command) {
        if (this.isCircle) command.options.push("shape=circle");
        else command.options.push("shape=ellipse");
        super.buildTikzCommand(command);
        let strokeWidth = this.strokeInfo.width.convertToUnit("px").value;
        command.options.push("minimum width=" + (0, _selectionHelper.roundTikz)(new _svgJs.Number(this.size.x - strokeWidth, "px").convertToUnit("cm").value) + "cm");
        if (!this.isCircle) command.options.push("minimum height=" + (0, _selectionHelper.roundTikz)(new _svgJs.Number(this.size.y - strokeWidth, "px").convertToUnit("cm").value) + "cm");
    }
    requiredTikzLibraries() {
        return this.isCircle ? [] : [
            "shapes.geometric"
        ];
    }
    isInsideSelectionRectangle(selectionRectangle) {
        if ((0, _selectionHelper.pointInsideRect)(this.position, selectionRectangle)) // if the center of the ellipse is inside the rectangle -> done
        return true;
        //the corner points of the selection rectangle
        let boxPoints = [
            [
                selectionRectangle.x,
                selectionRectangle.y
            ],
            [
                selectionRectangle.x2,
                selectionRectangle.y
            ],
            [
                selectionRectangle.x2,
                selectionRectangle.y2
            ],
            [
                selectionRectangle.x,
                selectionRectangle.y2
            ]
        ];
        // apply transformation, which transforms the ellipse into a unit circle at the origin, to the box points -> the box points now describe some rotated parallelogram instead of a rectangle. this essentially transforms the calculation to an easier problem
        const points = boxPoints.map((point)=>new _svgJs.Point(point[0], point[1]).sub(this.position).rotate(-this.rotationDeg).div(this.size.div(2)));
        for(let index = 0; index < points.length - 1; index++){
            const A = points[index];
            const B = points[(index + 1) % points.length];
            if (A.absSquared() <= 1 || B.absSquared() <= 1) // at least one corner point of the parallelogram is in the unit circle -> collision
            return true;
            // from here: no corner point of the current line segment is in the unit circle -> check if line segement cuts through the unit circle
            const AB = B.sub(A);
            const AC = A.mul(-1);
            // t*AB is the projection of AC onto AB, i.e. the closest point of the line described by A and B to the origin
            const t = AC.dot(AB) / AB.absSquared();
            if (t <= 1 && t >= 0) {
                // the closest point of the line through A and B to the origin lies on the line segment AB -> collision possible
                const P = A.add(AB.mul(t));
                if (P.absSquared() <= 1) // the closest point lies inside the unit circle -> collision
                return true;
            }
        }
        return false;
    }
    copyForPlacement() {
        return new EllipseComponent();
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"I5TWf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PolygonComponent", ()=>PolygonComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class PolygonComponent extends (0, _internal.PositionLabelable)((0, _internal.Strokable)((0, _internal.Fillable)((0, _internal.PathComponent)))) {
    static jsonID = "polygon";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(PolygonComponent.jsonID, PolygonComponent);
    }
    constructor(){
        super();
        this.snappingPoints = [];
        (0, _internal.CanvasController).instance.canvas.add(this.visualization);
        this.displayName = "Polygon";
        this.position = new _svgJs.Point();
        this.componentVisualization = (0, _internal.CanvasController).instance.canvas.polygon();
        this.dragElement = (0, _internal.CanvasController).instance.canvas.polygon();
        this.dragElement.attr({
            fill: "transparent",
            stroke: "none"
        });
        this.visualization.add(this.componentVisualization);
        this.visualization.add(this.dragElement);
    }
    getSnappingInfo() {
        return {
            trackedSnappingPoints: this.snappingPoints,
            additionalSnappingPoints: []
        };
    }
    recalculateSnappingPoints(matrix) {
        let positions = [];
        let halfSize = this.size.div(2);
        for (const anchor of (0, _internal.basicDirections)){
            // basic dirs
            if (anchor.key == (0, _internal.defaultBasicDirection).key) continue;
            positions.push({
                relPos: this.position.add(halfSize.mul(anchor.direction)),
                anchorname: anchor.name
            });
        }
        for(let index = 0; index < this.referencePoints.length; index++){
            //the corner points as well as the center between 2 connected points
            const p1 = this.referencePoints[index];
            const p2 = this.referencePoints[(index + 1) % this.referencePoints.length];
            positions.push({
                relPos: p1,
                anchorname: ""
            });
            positions.push({
                relPos: p1.add(p2).div(2),
                anchorname: ""
            });
        }
        if (!this.snappingPoints || this.snappingPoints.length != positions.length) {
            this.snappingPoints.forEach((snapPoint)=>snapPoint.show(false));
            this.snappingPoints = [];
            for (const position of positions)this.snappingPoints.push(new (0, _internal.SnapPoint)(this, position.anchorname, position.relPos));
        } else {
            const recalcMatrix = new _svgJs.Matrix();
            for(let index = 0; index < positions.length; index++){
                const relPos = positions[index].relPos;
                const snappingPoint = this.snappingPoints[index];
                snappingPoint.updateRelPosition(relPos);
                snappingPoint.recalculate(recalcMatrix);
            }
        }
    }
    viewSelected(show) {
        super.viewSelected(show);
        this.resizable(this.isSelected && show && (0, _internal.SelectionController).instance.currentlySelectedComponents.length == 1);
    }
    toJson() {
        let data = super.toJson();
        data.type = PolygonComponent.jsonID;
        return data;
    }
    applyJson(saveObject) {
        super.applyJson(saveObject);
        this.update();
        this.updateTheme();
    }
    static fromJson(saveObject) {
        if ((0, _internal.SaveController).instance.currentlyLoadedSaveVersion == "") {
            //@ts-ignore
            let rotation = saveObject.rotationDeg ?? 0;
            //@ts-ignore
            let scale = saveObject.scale ? new _svgJs.Point(saveObject.scale) : new _svgJs.Point(1, 1);
            let bbox = (0, _internal.bboxFromPoints)(saveObject.points);
            let transformMatrix = new _svgJs.Matrix({
                rotate: rotation,
                scale: [
                    scale.x,
                    scale.y
                ],
                origin: [
                    bbox.cx,
                    bbox.cy
                ]
            });
            saveObject.points = saveObject.points.map((point)=>new _svgJs.Point(point).transform(transformMatrix));
        }
        return new PolygonComponent();
    }
    updateTheme() {
        let strokeColor = this.strokeInfo.color;
        if (strokeColor == "default") strokeColor = (0, _internal.defaultStroke);
        this.componentVisualization?.stroke({
            color: strokeColor,
            opacity: this.strokeInfo.opacity,
            width: this.strokeInfo.opacity == 0 ? 0 : this.strokeInfo.width.convertToUnit("px").value,
            dasharray: this.strokeStyleProperty.value.dasharray.map((factor)=>this.strokeInfo.width.times(factor).toString()).join(" ")
        });
        let fillColor = this.fillInfo.color;
        if (fillColor == "default") fillColor = "none";
        this.componentVisualization?.fill({
            color: fillColor,
            opacity: this.fillInfo.opacity
        });
        let labelColor = (0, _internal.defaultStroke);
        if (this.labelColor.value) labelColor = this.labelColor.value.toString();
        this.labelRendering?.fill(labelColor);
    }
    buildTikzCommand(command) {
        super.buildTikzCommand(command);
        if (this.mathJaxLabel.value !== "" && this.textPos) command.additionalNodes.push(this.buildTikzNodeLabel(this.textPos));
        this.referencePoints.forEach(()=>command.connectors.push("--"));
        command.coordinates.push("cycle");
    }
    requiredTikzLibraries() {
        return [];
    }
    isInsideSelectionRectangle(selectionRectangle) {
        let points = this.referencePoints;
        for(let idx = 0; idx < points.length; idx++){
            const p1 = points[idx];
            const p2 = points[(idx + 1) % points.length];
            if ((0, _selectionHelper.lineRectIntersection)(new _svgJs.Line().plot(p1.x, p1.y, p2.x, p2.y), selectionRectangle)) return true;
        }
        // TODO selection rectangle inside polygon?
        return false;
    }
    size;
    update() {
        let pointsArray = this.referencePoints.map((point)=>point.toArray());
        const bbox = (0, _internal.bboxFromPoints)(this.referencePoints);
        this._bbox = bbox;
        this.size = new _svgJs.Point(bbox.w, bbox.h);
        this.position = new _svgJs.Point(bbox.cx, bbox.cy);
        this.dragElement.plot(pointsArray);
        this.componentVisualization.plot(pointsArray);
        this.referencePosition = this.position.sub(new _svgJs.Point(this.bbox.x, this.bbox.y));
        this.recalculateSelectionVisuals();
        this.recalculateSnappingPoints();
        this.recalculateResizePoints();
        this.updatePositionedLabel();
    }
    recalculateSelectionVisuals() {
        if (this.selectionElement) {
            let strokeWidth = this.strokeInfo.width.convertToUnit("px").value;
            let additionalWidth = (0, _selectionHelper.selectedBoxWidth) + strokeWidth + 2;
            this.selectionElement.size(this.size.x + additionalWidth, this.size.y + additionalWidth).center(this.position.x, this.position.y);
        }
    }
    placeMove(pos, ev) {
        if (this.referencePoints.length < 1) ;
        else {
            let placePoint = this.referencePoints.at(-2);
            let secondPoint;
            if (ev && ev.ctrlKey) {
                // get point on one of the two diagonals
                let diff = pos.sub(placePoint);
                if (diff.x * diff.y < 0) secondPoint = new _svgJs.Point(pos.x - pos.y, pos.y - pos.x).add(placePoint.x + placePoint.y).div(2);
                else secondPoint = new _svgJs.Point(placePoint.x - placePoint.y, placePoint.y - placePoint.x).add(pos.x + pos.y).div(2);
            } else secondPoint = pos;
            this.referencePoints[this.referencePoints.length - 1] = secondPoint;
            this.update();
        }
    }
    placeStep(pos, ev) {
        if (this.finishedPlacing) return true;
        if (this.referencePoints.length == 0) {
            this.referencePoints.push(pos.clone());
            this.componentVisualization.show();
            this.updateTheme();
        } else {
            if (this.referencePoints.at(-2).eq(pos)) return true;
        }
        this.referencePoints.push(pos);
        this.placeMove(pos, ev);
        return false;
    }
    placeFinish() {
        if (this.finishedPlacing) return;
        if (this.referencePoints.length == 0) this.placeStep(new _svgJs.Point());
        this.referencePoints.pop();
        if (this.referencePoints.length >= 2 && this.referencePoints.at(-1).eq(this.referencePoints.at(-2))) this.referencePoints.pop();
        if (this.referencePoints.length < 2) {
            // if not even 2 corner points -> no polygon, delete
            (0, _internal.MainController).instance.removeComponent(this);
            return;
        }
        this.finishedPlacing = true;
        this.componentVisualization.show();
        this.updateTheme();
        this.update();
    }
    copyForPlacement() {
        return new PolygonComponent();
    }
    // private labelPos: DirectionInfo
    textPos;
    updatePositionedLabel() {
        if (!this.mathJaxLabel.value || !this.labelRendering) return;
        let labelSVG = this.labelRendering;
        let bbox = this.bbox;
        let halfSize = this.size.div(2);
        let textDir; // normalized direction to size (length not normalized) in local coords
        let textPosNoTrans = new _svgJs.Point();
        this.labelPos = this.positionChoice.value;
        if (this.positionChoice.value.key != (0, _internal.defaultBasicDirection).key) {
            textDir = this.positionChoice.value.direction;
            textPosNoTrans = halfSize.mul(this.positionChoice.value.direction);
            this.textPos = this.position.add(textPosNoTrans);
        } else {
            textDir = new _svgJs.Point();
            textPosNoTrans = new _svgJs.Point();
            this.textPos = this.position;
        }
        let labelBBox = labelSVG.bbox();
        // calculate where on the label the anchor point should be
        let labelDist = this.labelDistance.value.convertToUnit("px").value ?? 0;
        if (this.anchorChoice.value.key == (0, _internal.defaultBasicDirection).key) {
            //transform anchor direction back to global coordinates
            let labelRefDir = textDir.mul(-1);
            // check which direction should be used to get the final correct direction
            this.anchorPos = (0, _internal.closestBasicDirection)(labelRefDir);
        } else // an explicit anchor was selected
        this.anchorPos = this.anchorChoice.value;
        let labelRef = this.anchorPos.direction;
        let ref = labelRef.add(1).div(2).mul(new _svgJs.Point(labelBBox.w, labelBBox.h)).add(new _svgJs.Point(labelBBox.x, labelBBox.y)).add(labelRef.mul(labelDist));
        // acutally move the label
        labelSVG.transform({
            translate: this.textPos.sub(ref)
        });
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3qwR8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GroupComponent", ()=>GroupComponent);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class GroupComponent extends (0, _internal.CircuitComponent) {
    static jsonID = "group";
    static{
        (0, _internal.CircuitComponent).jsonSaveMap.set(GroupComponent.jsonID, GroupComponent);
    }
    groupedComponents = [];
    constructor(components){
        super();
        (0, _internal.MainController).instance.circuitComponents.pop(); // add later at specific index instead
        this.displayName = "Group";
        this.snappingPoints = [];
        this.groupedComponents.push(...components);
        const idx = this.visualization.parent().index(components[0].visualization);
        this.visualization.parent().add(this.visualization, idx);
        let firstIndex = -1;
        for (const component of components){
            const idx = (0, _internal.MainController).instance.circuitComponents.indexOf(component);
            firstIndex = firstIndex < 0 ? idx : firstIndex;
            (0, _internal.MainController).instance.circuitComponents.splice(idx, 1);
            component.parentGroup = this;
            component.viewSelected(false);
            this.visualization.add(component.visualization);
        }
        (0, _internal.MainController).instance.circuitComponents.splice(firstIndex, 0, this); // added here
        this.properties.add((0, _internal.PropertyCategories).ordering, new (0, _internal.SectionHeaderProperty)("Grouping"));
        let grouping = new (0, _internal.ButtonGridProperty)(1, [
            [
                "Ungroup",
                ""
            ]
        ], [
            (ev)=>this.ungroup()
        ], undefined, undefined, "ordering:ungroup");
        this.properties.add((0, _internal.PropertyCategories).ordering, grouping);
        this.update();
        (0, _internal.SelectionController).instance.selectComponents([
            this
        ], (0, _internal.SelectionMode).RESET);
        this.snappingPoints = this.groupedComponents.map((component)=>component.snappingPoints).flat();
    }
    static group(circuitComponents) {
        new GroupComponent(circuitComponents);
        (0, _internal.Undo).addState();
    }
    ungroup() {
        const idx = (0, _internal.MainController).instance.circuitComponents.indexOf(this);
        (0, _internal.MainController).instance.circuitComponents.splice(idx, 1, ...this.groupedComponents);
        const parent = this.visualization.parent();
        const currentIdx = parent.index(this.visualization);
        for(let index = 0; index < this.groupedComponents.length; index++){
            const component = this.groupedComponents[index];
            component.parentGroup = null;
            parent.add(component.visualization, currentIdx + index);
        }
        (0, _internal.SelectionController).instance.selectComponents(this.groupedComponents, (0, _internal.SelectionMode).RESET);
        this.groupedComponents = [];
        this.remove();
        (0, _internal.Undo).addState();
    }
    isInsideSelectionRectangle(selectionRectangle) {
        return (0, _selectionHelper.rectRectIntersection)(this._bbox, selectionRectangle);
    }
    getSnappingInfo() {
        return {
            additionalSnappingPoints: [],
            trackedSnappingPoints: this.snappingPoints
        };
    }
    draggable(drag) {
        for (const element of this.groupedComponents)element.draggable(drag);
    }
    resizable(resize) {
    // Not all components are resizable, so this is not implemented here
    }
    recalculateResizePoints() {
    //No resizing for now
    }
    moveTo(position) {
        const rel = position.sub(this.position);
        for (const component of this.groupedComponents)component.moveRel(rel);
        this.update();
    }
    rotate(angleDeg) {
        for (const element of this.groupedComponents){
            element.moveTo(element.position.rotate(angleDeg, this.position));
            element.rotate(angleDeg);
        }
        this.update();
    }
    flip(horizontal) {
        for (const element of this.groupedComponents){
            const moveRel = element.position.sub(this.position).mul(new _svgJs.Point(horizontal ? 0 : -2, horizontal ? -2 : 0));
            element.moveRel(moveRel);
            element.flip(horizontal);
        }
        this.update();
    }
    update() {
        this._bbox = undefined;
        for (const component of this.groupedComponents)if (this._bbox) this._bbox = this._bbox.merge(component.bbox);
        else this._bbox = component.bbox;
        this.position = new _svgJs.Point(this._bbox.cx, this._bbox.cy);
        this.referencePosition = this.position.sub(new _svgJs.Point(this._bbox.x, this._bbox.y));
        this.recalculateSelectionVisuals();
    }
    recalculateSelectionVisuals() {
        if (this.selectionElement) {
            let box = this.bbox;
            this.selectionElement.size(box.w, box.h);
            this.selectionElement.center(this.position.x, this.position.y);
        }
    }
    toJson() {
        let componentSaveObjects = [];
        for (const component of this.groupedComponents)componentSaveObjects.push(component.toJson());
        let saveObject = {
            type: GroupComponent.jsonID,
            components: componentSaveObjects
        };
        return saveObject;
    }
    static fromJson(saveObject) {
        let components = [];
        for (const saveObj of saveObject.components)components.push((0, _internal.CircuitComponent).fromJson(saveObj));
        return new GroupComponent(components);
    }
    toTikzString() {
        let outStr = [];
        for (const component of this.groupedComponents)outStr.push(component.toTikzString());
        return outStr.join("\n\t");
    }
    toSVG(defs) {
        let group = new _svgJs.G();
        for (const element of this.groupedComponents)group.add(element.toSVG(defs));
        return group;
    }
    copyForPlacement() {
        //not needed
        return;
    }
    remove() {
        this.viewSelected(false);
        this.selectionElement?.remove();
        for (const component of this.groupedComponents)component.remove();
        this.visualization.remove();
    }
    placeMove(pos, ev) {
        //not needed
        return;
    }
    placeStep(pos, ev) {
        //not needed
        return;
    }
    placeFinish() {
        //not needed
        return;
    }
    moveRel(delta) {
        for (const component of this.groupedComponents)component.moveRel(delta);
        this.update();
    }
    updateTheme() {
    // not needed
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fGtGO":[function(require,module,exports,__globalThis) {
/**
 * @module snapController
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Controller for snapping points, objects, etc. to the grid or other already added components.
 * @class
 */ parcelHelpers.export(exports, "SnapController", ()=>SnapController);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
class SnapController {
    static _instance;
    static get instance() {
        if (!SnapController._instance) SnapController._instance = new SnapController();
        return SnapController._instance;
    }
    fixedSnapPoints = [];
    movingSnapPoints = [];
    additionalSnapPoints = [];
    whereSnap = [];
    constructor(){}
    recalculateAdditionalSnapPoints() {
        this.additionalSnapPoints.forEach((snapPoint)=>snapPoint.recalculate());
    }
    updateSnapPoints(currentComponent, adjustOnly = false) {
        //reset
        this.fixedSnapPoints.forEach((snapPoint)=>snapPoint.show(false));
        this.movingSnapPoints.forEach((snapPoint)=>snapPoint.show(false));
        this.additionalSnapPoints.forEach((snapPoint)=>snapPoint.show(false));
        this.fixedSnapPoints = [];
        this.movingSnapPoints = [];
        this.additionalSnapPoints = [];
        if (currentComponent) {
            if (currentComponent.isSelected && !adjustOnly) {
                for (const component of (0, _internal.MainController).instance.circuitComponents)if (component.isSelected) {
                    if (currentComponent === component) {
                        let snappingInfo = component.getSnappingInfo();
                        this.movingSnapPoints.push(...snappingInfo.trackedSnappingPoints);
                        this.additionalSnapPoints.push(...snappingInfo.additionalSnappingPoints);
                    } else this.movingSnapPoints.push(...component.snappingPoints);
                } else this.fixedSnapPoints.push(...component.snappingPoints);
            } else for (const component of (0, _internal.MainController).instance.circuitComponents){
                if (component !== currentComponent) this.fixedSnapPoints.push(...component.snappingPoints);
                else if (!adjustOnly) {
                    let snappingInfo = component.getSnappingInfo();
                    this.movingSnapPoints.push(...snappingInfo.trackedSnappingPoints);
                    this.additionalSnapPoints.push(...snappingInfo.additionalSnappingPoints);
                }
            }
        } else for (const component of (0, _internal.MainController).instance.circuitComponents)this.fixedSnapPoints.push(...component.snappingPoints);
        this.showSnapPoints(this.whereSnap.length > 0);
    }
    /**
     * show or hide the snap points on the canvas (doesn't show grid points)
     */ showSnapPoints(show = true) {
        if (show == this._snapPointsShown) return;
        if (show) {
            this.fixedSnapPoints.forEach((snapPoint)=>{
                snapPoint.show(true, false);
            });
            this.movingSnapPoints.forEach((snapPoint)=>{
                snapPoint.show(true, true);
            });
            this.additionalSnapPoints.forEach((snapPoint)=>{
                snapPoint.show(true, true);
            });
        } else {
            this.fixedSnapPoints.forEach((snapPoint)=>{
                snapPoint.show(false);
            });
            this.movingSnapPoints.forEach((snapPoint)=>{
                snapPoint.show(false);
            });
            this.additionalSnapPoints.forEach((snapPoint)=>{
                snapPoint.show(false);
            });
            while(this.whereSnap.length > 0)this.whereSnap.pop().remove();
        }
        this._snapPointsShown = show;
    }
    _snapPointsShown = false;
    get snapPointsShown() {
        return this._snapPointsShown;
    }
    /**
     * Snap a point to the grid or one of the added snap points.
     * Calculations done in px since the node snap points are defined in px
     */ snapPoint(pos, component) {
        // 1. Calculate grid snap points
        const canvasController = (0, _internal.CanvasController).instance;
        let gridSpacing = new _svgJs.Number(canvasController.majorGridSizecm / canvasController.majorGridSubdivisions, "cm").convertToUnit("px").value;
        // take zoom level into account (canvas.screenctm().a): zoomed in means smaller maximum distance
        const maxSnapDistance = new _svgJs.Number(1, "cm").convertToUnit("px").value / (0, _internal.CanvasController).instance.canvas.node.getScreenCTM().a;
        const maxSnapDistance2 = maxSnapDistance * maxSnapDistance;
        let relSnapPoints = this.movingSnapPoints.map((snapPoint)=>snapPoint.relToComponentAnchor().add(snapPoint.componentReference.position).sub(component.position));
        if (this.additionalSnapPoints) relSnapPoints.push(...this.additionalSnapPoints.map((snapPoint)=>snapPoint.relToComponentAnchor()));
        if (relSnapPoints.length < 1) relSnapPoints.push(new _svgJs.Point());
        const movingSnapPoints = relSnapPoints.map((point)=>pos.add(point));
        if (!(0, _internal.CanvasController).instance.gridVisible) // effectively only snap the origin
        gridSpacing = 1e9;
        // directly calculate the closest grid snapping point to each possible relSnapPoint and filter which is closest overall
        let distStruct = movingSnapPoints.reduce(/**
         * @param {DistStruct} prevVal - helper struct for finding snap point with lowest dist. to a grid point
         * @param {SVG.Point} movSnapPoint - possible point to snap to (grid)
         * @returns {DistStruct}
         */ (prevVal, movSnapPoint)=>{
            const x = Math.round(movSnapPoint.x / gridSpacing) * gridSpacing;
            const y = Math.round(movSnapPoint.y / gridSpacing) * gridSpacing;
            const gridPoint = new _svgJs.Point(x, y);
            return this.reduceSinglePointPair(movSnapPoint, gridPoint, prevVal, maxSnapDistance2);
        }, {
            dist: Number.MAX_VALUE,
            snapPoints: []
        });
        // 2. calculate bounds where a closer point could lie
        let relSnapPointsMinX = relSnapPoints[0].x, relSnapPointsMaxX = relSnapPoints[0].x, relSnapPointsMinY = relSnapPoints[0].y, relSnapPointsMaxY = relSnapPoints[0].y;
        for (const point of relSnapPoints){
            if (point.x < relSnapPointsMinX) relSnapPointsMinX = point.x;
            else if (point.x > relSnapPointsMaxX) relSnapPointsMaxX = point.x;
            if (point.y < relSnapPointsMinY) relSnapPointsMinY = point.y;
            else if (point.y > relSnapPointsMaxY) relSnapPointsMaxY = point.y;
        }
        const xMin = relSnapPointsMinX + pos.x - maxSnapDistance;
        const yMin = relSnapPointsMinY + pos.y - maxSnapDistance;
        const xMax = relSnapPointsMaxX + pos.x + maxSnapDistance;
        const yMax = relSnapPointsMaxY + pos.y + maxSnapDistance;
        // 3. filter remaining snap points
        const filteredFixSnapPoints = this.fixedSnapPoints.filter((point)=>point.x >= xMin && point.x <= xMax && point.y >= yMin && point.y <= yMax);
        // 4. snap to non grid points
        if (filteredFixSnapPoints.length > 0) distStruct = this.getSnapDistStruct(movingSnapPoints, filteredFixSnapPoints, distStruct);
        // 5. Calculate snapped point using vector
        if (distStruct.snapPoints.length == 0) distStruct.vector = new _svgJs.Point();
        else this.positionSnapPoints(distStruct.snapPoints);
        return distStruct.vector.add(pos);
    }
    positionSnapPoints(positions) {
        while(positions.length < this.whereSnap.length)this.whereSnap.pop().remove();
        while(positions.length > this.whereSnap.length)this.whereSnap.push((0, _internal.CanvasController).instance.canvas.circle(4).fill("none").stroke({
            color: "var(--bs-yellow)"
        }));
        for(let index = 0; index < positions.length; index++){
            const position = positions[index];
            const snap = this.whereSnap[index];
            snap.center(position.x, position.y);
        }
    }
    /**
     * Snap absolute points to absolute positions. The point with the lowest distance is returned with its additional
     * information ({@link DistStruct}). As this function supports multiple possible (moving) snap points, the returned
     * vector should be used for moving the object to the snapped position.
     */ getSnapDistStruct(movingSnapPoints, fixedSnapPoints, initialDistStruct, maxSnapDistance2) {
        if (!initialDistStruct) initialDistStruct = {
            dist: Number.MAX_VALUE,
            snapPoints: []
        };
        if (!maxSnapDistance2) maxSnapDistance2 = Number.MAX_VALUE;
        return movingSnapPoints.reduce((prevVal, movSnapPoint)=>fixedSnapPoints.reduce((prevVal, fixSnapPoint)=>{
                return this.reduceSinglePointPair(movSnapPoint, fixSnapPoint, prevVal, maxSnapDistance2);
            }, prevVal), initialDistStruct);
    }
    reduceSinglePointPair(movingSnapPoint, fixedSnapPoint, previousDist, maxSnapDistance2) {
        const vector = fixedSnapPoint.sub(movingSnapPoint);
        // check if the already established move vector makes the current point pair intersect, i.e. the vectors are the same
        if (previousDist.vector?.eq(vector, 1e-2)) {
            //if so, we are done and add the point to the array
            previousDist.snapPoints.push(fixedSnapPoint);
            return previousDist;
        }
        const squaredDistance = vector.absSquared();
        if (squaredDistance > previousDist.dist || squaredDistance > maxSnapDistance2) return previousDist;
        previousDist.dist = squaredDistance;
        previousDist.vector = vector;
        previousDist.snapPoints = [
            fixedSnapPoint
        ];
        return previousDist;
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d5mkJ":[function(require,module,exports,__globalThis) {
/**
 * @module snapCursorController
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Realizes an in canvas cursor. Can be used to visualize the point to snap to.
 * @class
 */ parcelHelpers.export(exports, "SnapCursorController", ()=>SnapCursorController);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
class SnapCursorController {
    static _instance;
    static get instance() {
        if (!SnapCursorController._instance) SnapCursorController._instance = new SnapCursorController();
        return SnapCursorController._instance;
    }
    cursorViewBox;
    cursor;
    constructor(){
        const cursorSymbol = new _svgJs.Symbol(document.getElementById("snapCursor"));
        this.cursor = (0, _internal.CanvasController).instance.canvas.use(cursorSymbol);
        this.cursor.id("snapCursorUse");
        this.cursorViewBox = cursorSymbol.viewbox();
        this.cursor.width(this.cursorViewBox.width);
        this.cursor.height(this.cursorViewBox.height);
        // CanvasController.instance.canvas.add(this.cursor);
        this.cursor.hide();
    }
    /**
     * Moves the cursor to a new position.
     *
     * @param {SVG.Point} position - the new position
     */ moveTo(position) {
        this.cursor.center(position.x, position.y);
    }
    /**
     * Show or hide the cursor.
     *
     * @param {boolean} b - the visibility
     */ set visible(b) {
        if (b) this.cursor.show();
        else this.cursor.hide();
    }
    /**
     * Get the visibility.
     *
     * @returns {boolean} the visibility
     */ get visible() {
        return this.cursor.visible();
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4M1ai":[function(require,module,exports,__globalThis) {
/**
 * @module snapPoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Realizes a point which is relative to another point. This can be used to recreate CircuiTikZ anchors, which are
 * relative to components. This is useful for snap points.
 */ parcelHelpers.export(exports, "SnapPoint", ()=>SnapPoint);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
var _selectionHelper = require("../utils/selectionHelper");
class SnapPoint extends _svgJs.Point {
    componentReference;
    anchorName;
    relPosition;
    element;
    constructor(componentReference, anchorName, relPosition){
        super();
        this.componentReference = componentReference;
        this.anchorName = anchorName;
        this.relPosition = relPosition;
        this.recalculate();
    }
    recalculate(transformMatrix = this.componentReference.getTransformMatrix()) {
        const point = this.relPosition.transform(transformMatrix);
        this.x = point.x;
        this.y = point.y;
        if (this.element) this.element.center(this.x, this.y);
    }
    updateRelPosition(relPosition) {
        this.relPosition = relPosition;
    }
    relToComponentAnchor() {
        return this.sub(this.componentReference.position);
    }
    show(show = true, moving = false) {
        if (show) {
            if (!this.element) {
                const container = (0, _internal.CanvasController).instance.canvas;
                this.element = container.circle(4).fill("none").stroke({
                    color: moving ? "var(--bs-cyan)" : (0, _selectionHelper.selectionColor),
                    width: 1
                });
                this.element.node.style.pointerEvents = "none";
                this.componentReference.visualization.before(this.element);
                this.element.center(this.x, this.y);
            }
        } else {
            this.element?.remove();
            this.element = null;
        }
    }
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","../utils/selectionHelper":"joOxp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2ip9f":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "textToSVG", ()=>textToSVG);
parcelHelpers.export(exports, "loadTextConverter", ()=>loadTextConverter);
// this function converts text into an SVG group containing the text tags and mathjax renderings
// it uses the Mathjax parser to parse the text and then renders the mathjax elements
parcelHelpers.export(exports, "convertTextToNativeSVGText", ()=>convertTextToNativeSVGText);
parcelHelpers.export(exports, "renderMathJax", ()=>renderMathJax);
parcelHelpers.export(exports, "MathjaxParser", ()=>MathjaxParser);
var _svgJs = require("@svgdotjs/svg.js");
var _textToSvg = require("text-to-svg");
var _textToSvgDefault = parcelHelpers.interopDefault(_textToSvg);
var _internal = require("../internal");
const syllableRegex = /([^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?)|[^aeiouy]+$/gi;
let textToSVG;
function loadTextConverter() {
    return new Promise((resolve)=>{
        (0, _textToSvgDefault.default).load("https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/font/Serif/cmunrm.woff", (err, tTSVG)=>{
            textToSVG = tTSVG;
            resolve();
        });
    });
}
function convertTextToNativeSVGText(text, textBox, useHyphenation = false) {
    const fontSizept = (0, _internal.fontSizes).find((fs)=>fs.key == text.fontSize).size;
    const fontSize = fontSizept.toString() + "pt";
    // used to parse the text into text and mathjax elements
    const mathjaxParser = new MathjaxParser();
    const explicitLines = text.text.split("\n").map((line)=>line.trim());
    const lines = [];
    for (const line of explicitLines){
        const textSections = mathjaxParser.parse(line);
        const renderedSections = [];
        for (const section of textSections)if (section.type == "inline") {
            const rendered = renderMathJax(section.text, fontSizept);
            renderedSections.push(rendered);
        } else section.text.split(/\s+/).forEach((word)=>{
            renderedSections.push(word);
        });
        const wrappedLines = wrapLine(renderedSections, fontSize, textBox.w, useHyphenation);
        lines.push(...wrappedLines);
    }
    // return svgText
    return layoutText(lines, text, textBox);
}
function layoutText(lines, text, textBox) {
    const fontSizept = (0, _internal.fontSizes).find((fs)=>fs.key == text.fontSize).size;
    const fontSizepx = fontSizept * 4 / 3;
    const fontSize = fontSizept.toString() + "pt";
    const spaceWidth = getTextMetrics(" ", fontSize).width;
    const lineSpacing = 0.414; // the standard line spacing in em
    const group = new _svgJs.G();
    const renderedElements = new _svgJs.G();
    renderedElements.fill(text.color == "default" ? "black" : text.color);
    let tspans = [];
    let lineTspans = [];
    const defaultTextMetrics = getTextMetrics("pH", fontSize);
    const defaultAscent = defaultTextMetrics.actualBoundingBoxAscent;
    const defaultDescent = defaultTextMetrics.actualBoundingBoxDescent;
    let currentBaselineYPos = 0;
    for(let index = 0; index < lines.length; index++){
        const line = lines[index];
        line.ascent = index > 0 ? Math.max(line.ascent, defaultAscent) : line.ascent;
        line.descent = index < lines.length - 1 ? Math.max(line.descent, defaultDescent) : line.descent;
        currentBaselineYPos += line.ascent;
        const remainingLineSpace = textBox.w - line.totalWidth;
        const xoffset = text.align == (0, _internal.TextAlign).RIGHT ? remainingLineSpace : text.align == (0, _internal.TextAlign).CENTER ? remainingLineSpace / 2 : 0;
        const currentSpaceWidth = text.align == (0, _internal.TextAlign).JUSTIFY ? remainingLineSpace / (line.elements.length - 1) + spaceWidth : spaceWidth;
        let currentXPos = 0;
        for(let elementIndex = 0; elementIndex < line.elements.length; elementIndex++){
            const element = line.elements[elementIndex];
            if (typeof element.element == "string") lineTspans.push(`<tspan x="${xoffset + currentXPos}" y="${currentBaselineYPos}" >${element.element}</tspan>`);
            else {
                const renderedElement = element.element;
                const containerGroup = new _svgJs.G();
                containerGroup.add(renderedElement);
                containerGroup.transform({
                    translateX: xoffset + currentXPos,
                    translateY: currentBaselineYPos
                });
                renderedElements.add(containerGroup);
            }
            currentXPos += currentSpaceWidth + element.width;
        }
        tspans.push(lineTspans.join(""));
        lineTspans = [];
        currentBaselineYPos += line.descent + (index < lines.length - 1 ? fontSizepx * lineSpacing : 0);
    }
    const ypos = textBox.y + (text.justify + 1) / 2 * (textBox.h - currentBaselineYPos);
    const textPos = new _svgJs.Point(textBox.x, ypos);
    let svgText = new _svgJs.Text();
    svgText.transform({
        translateX: textPos.x,
        translateY: textPos.y
    });
    svgText.fill(text.color == "default" ? "black" : text.color);
    svgText.node.innerHTML = tspans.join("\n");
    svgText.attr("font-family", "Computer Modern Serif");
    svgText.stroke("none");
    svgText.attr("font-size", fontSize);
    group.add(svgText);
    renderedElements.transform({
        translateX: textPos.x,
        translateY: textPos.y
    });
    group.add(renderedElements);
    return group;
}
// greedy algorithm to fully use up the text rectangle. maybe change to KnuthPlass line breaking later on
function wrapLine(line, fontSize, maxWidth, useHyphenation) {
    const completedLines = [];
    let currentLine = [];
    let currentLineWidth = 0;
    let currentMaxAscent = 0;
    let currentMaxDescent = 0;
    const spaceWidth = getTextMetrics(" ", fontSize).width;
    line.forEach((element, index)=>{
        let elementWidth = 0;
        let elementAscent = 0;
        let elementDescent = 0;
        const startSpace = currentLineWidth > 0 ? spaceWidth : 0;
        if (typeof element === "string") {
            // if the element is a string
            let textMetrics = getTextMetrics(element, fontSize);
            elementWidth = textMetrics.width;
            elementAscent = textMetrics.actualBoundingBoxAscent;
            elementDescent = textMetrics.actualBoundingBoxDescent;
            if (currentLineWidth + startSpace + elementWidth > maxWidth) {
                if (useHyphenation) {
                    const syllables = element.match(syllableRegex);
                    // if syllables is not empty, fit the word into the linewidth while respecting the bounding box
                    if (syllables) {
                        let fittedSyllables = fitWord(syllables, currentLineWidth + startSpace, maxWidth, fontSize);
                        // Add syllables to lines
                        for(let i = 0; i < fittedSyllables.length; i++){
                            let textMetrics = getTextMetrics(fittedSyllables[i], fontSize);
                            elementWidth = textMetrics.width;
                            elementAscent = textMetrics.actualBoundingBoxAscent;
                            elementDescent = textMetrics.actualBoundingBoxDescent;
                            if (elementWidth > 0) {
                                // Add the fitted syllable to the current line
                                currentLine.push({
                                    ascent: elementAscent,
                                    descent: elementDescent,
                                    width: elementWidth,
                                    element: fittedSyllables[i]
                                });
                                currentLineWidth += elementWidth + (i == 0 ? startSpace : 0);
                                currentMaxAscent = Math.max(currentMaxAscent, elementAscent);
                                currentMaxDescent = Math.max(currentMaxDescent, elementDescent);
                            }
                            // Add to completed lines if it's not the last fitted syllable
                            if (i < fittedSyllables.length - 1) {
                                completedLines.push({
                                    elements: currentLine,
                                    totalWidth: currentLineWidth,
                                    ascent: currentMaxAscent,
                                    descent: currentMaxDescent
                                });
                                // reset for the next line
                                currentLine = [];
                                currentLineWidth = 0;
                                currentMaxAscent = 0;
                                currentMaxDescent = 0;
                            }
                        }
                    }
                } else {
                    //no hyphenation, just add the current line to the completed lines and start a new line with the current element
                    completedLines.push({
                        elements: currentLine,
                        totalWidth: currentLineWidth,
                        ascent: currentMaxAscent,
                        descent: currentMaxDescent
                    });
                    currentLine = [
                        {
                            ascent: elementAscent,
                            descent: elementDescent,
                            width: elementWidth,
                            element: element
                        }
                    ];
                    currentLineWidth = elementWidth;
                    currentMaxAscent = elementAscent;
                    currentMaxDescent = elementDescent;
                }
            } else {
                // the current element fits into the current line
                // add the current element to the current line
                currentLine.push({
                    ascent: elementAscent,
                    descent: elementDescent,
                    width: elementWidth,
                    element: element
                });
                currentLineWidth += elementWidth + startSpace;
                currentMaxAscent = Math.max(currentMaxAscent, elementAscent);
                currentMaxDescent = Math.max(currentMaxDescent, elementDescent);
            }
        } else {
            // the element is a mathjax rendering
            // the ascent depends on the baseline alignment
            elementAscent = (1 + element.baselineAlignmentRatio) * element.height;
            elementDescent = element.height - elementAscent;
            elementWidth = element.width;
            if (currentLineWidth + startSpace + elementWidth > maxWidth) {
                // if the element does not fit into the current line, add the current line to the completed lines
                completedLines.push({
                    elements: currentLine,
                    totalWidth: currentLineWidth,
                    ascent: currentMaxAscent,
                    descent: currentMaxDescent
                });
                // and start a new line with the current element
                currentLine = [
                    {
                        ascent: elementAscent,
                        descent: elementDescent,
                        width: elementWidth,
                        element: element.element
                    }
                ];
                currentLineWidth = elementWidth;
                currentMaxAscent = elementAscent;
                currentMaxDescent = elementDescent;
            } else {
                // the current element fits into the current line
                // add the current element to the current line
                currentLine.push({
                    ascent: elementAscent,
                    descent: elementDescent,
                    width: elementWidth,
                    element: element.element
                });
                currentLineWidth += elementWidth + startSpace;
                currentMaxAscent = Math.max(currentMaxAscent, elementAscent);
                currentMaxDescent = Math.max(currentMaxDescent, elementDescent);
            }
        }
        // Add the last line if it's the final element
        if (index === line.length - 1 && currentLine.length > 0) completedLines.push({
            elements: currentLine,
            totalWidth: currentLineWidth,
            ascent: currentMaxAscent,
            descent: currentMaxDescent
        });
    });
    // remove empty lines
    return completedLines.filter((line)=>line.elements.length > 0);
}
// fit the word into the current line width
// if the word is too long, split it into syllables and add a hyphen
function fitWord(syllables, currentLineWidth, maxWidth, fontSize) {
    let remainingSyllables = [];
    let currentLine = "";
    const min = currentLineWidth > 0 ? 0 : 1; // if an empty line is used, at least one syllable should be written in that line
    for(let index = syllables.length; index >= min; index--){
        currentLine = syllables.slice(0, index).join("") + (index < syllables.length && index > 0 ? "-" : "");
        remainingSyllables = syllables.slice(index);
        let leftWidth = getTextMetrics(currentLine, fontSize).width;
        if (currentLineWidth + leftWidth < maxWidth) break;
    }
    let remainingLines = [];
    if (remainingSyllables.length > 0) remainingLines = fitWord(remainingSyllables, 0, maxWidth, fontSize);
    return [
        currentLine
    ].concat(remainingLines);
}
// get the metrics of a string
// this is used to get the width of the string and the ascent and descent of the font
// the ascent and descent are used to calculate the position of the text
function getTextMetrics(text, fontSize) {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    context.font = `${fontSize} "Computer Modern Serif"`;
    return context.measureText(text);
}
function renderMathJax(text, fontSize = 10) {
    // @ts-ignore
    window.MathJax.texReset();
    // @ts-ignore
    const node = window.MathJax.tex2svg(text, {
        display: false
    });
    // mathjax renders the text via an svg container. That container also contains definitions and SVG.Use elements. get that container
    let svgElement = new _svgJs.Svg(node.querySelector("svg"));
    // move the label definitions to the overall definitions of the canvas
    let backgroundDefs = (0, _internal.CanvasController).instance.canvas.findOne("#backgroundDefs");
    let defs = svgElement.findOne("defs");
    for (const def of defs.children())backgroundDefs.put(def);
    defs.remove();
    // 1.971 magic number (how large 1em, i.e. font size, is in terms of ex) for the font used in MathJax.
    // 1.137 is a correction factor to make the normal text ex align with the mathjax ex (looks better). this is a bit of a hack
    let exem = 1 / (1.971 * 1.137);
    //convert width and height from ex to pt via expt and then to px
    let widthStr = svgElement.node.getAttribute("width");
    let width = new _svgJs.Number(new _svgJs.Number(widthStr).value * exem * fontSize, "pt").convertToUnit("px");
    let heightStr = svgElement.node.getAttribute("height");
    let height = new _svgJs.Number(new _svgJs.Number(heightStr).value * exem * fontSize, "pt").convertToUnit("px");
    let size = new _svgJs.Point(width.value, height.value);
    // remove unnecessary data
    for (const elementGroup of svgElement.find("use"))elementGroup.node.removeAttribute("data-c");
    let groupElements = svgElement.find("g");
    for (const elementGroup of groupElements)elementGroup.node.removeAttribute("data-mml-node");
    // remove unnecessary svg groups
    for (const elementGroup of groupElements){
        let children = elementGroup.children();
        if (children.length == 1 && !elementGroup.node.hasAttributes()) {
            elementGroup.parent().put(children[0]);
            elementGroup.remove();
        } else if (elementGroup.fill() == "currentColor") elementGroup.fill("inherit");
    }
    //remove background of mathjax error message
    for (const elementGroup of svgElement.find("rect"))if (elementGroup.node.hasAttribute("data-background")) elementGroup.remove();
    // the current rendering svg viewbox
    let svgViewBox = svgElement.viewbox();
    // scale such that px size is actually correct for rendering
    let scale = size.div(new _svgJs.Point(svgViewBox.w, svgViewBox.h));
    let m = new _svgJs.Matrix({
        scaleX: scale.x,
        scaleY: scale.y
    });
    // add all symbol components to a group
    let transformGroup = new _svgJs.G();
    for (const child of svgElement.children())transformGroup.add(child);
    // apply the transformation --> the symbol now has the correct size and no rotation
    transformGroup.transform(m);
    let renderInfo = {
        element: transformGroup,
        baselineAlignmentRatio: new _svgJs.Number(svgElement.node.style.verticalAlign).value / svgElement.node.height.baseVal.valueInSpecifiedUnits,
        width: size.x,
        height: size.y
    };
    return renderInfo;
}
class MathjaxParser {
    // adjusted from https://github.com/bersling/mathjax-parser
    config;
    parse(inputText, config) {
        //set a default config
        this.config = config || {
            inlineMath: [
                [
                    "$",
                    "$"
                ],
                [
                    "\\(",
                    "\\)"
                ]
            ]
        };
        const delimiterArray = this.buildDelimiterArray(this.config);
        const state = this.findDelimiterPairs(delimiterArray, inputText);
        let result = [];
        let startIdx = 0;
        for(let index = 0; index < state.matchedDelimiterSets.length; index++){
            const delimiterSet = state.matchedDelimiterSets[index];
            if (delimiterSet.start.index > startIdx) {
                // after finding the delimiter pairs, we need to replace the escaped dollar signs with a single dollar sign in order to show only the dollar sign in the ui
                const adjustedText = inputText.slice(startIdx, delimiterSet.start.index).replace(/\\\$/g, "$");
                result.push({
                    text: adjustedText.trim(),
                    type: "text"
                });
            }
            let innerStart = delimiterSet.start.index + delimiterSet.start.delimiterGroup.group[0].length;
            let outerEnd = delimiterSet.end.index + delimiterSet.end.delimiterGroup.group[1].length;
            result.push({
                text: inputText.slice(innerStart, delimiterSet.end.index),
                type: delimiterSet.start.delimiterGroup.type
            });
            startIdx = outerEnd;
        }
        if (startIdx < inputText.length) {
            // after finding the delimiter pairs, we need to replace the escaped dollar signs with a single dollar sign in order to show only the dollar sign in the ui
            const adjustedText = inputText.slice(startIdx).replace(/\\\$/g, "$");
            result.push({
                text: adjustedText.trim(),
                type: "text"
            });
        }
        return result;
    }
    buildDelimiterArray(config) {
        let delimiterArray = [];
        let insertAtIndex = (idx, delimiterArray, grp, type)=>{
            delimiterArray.splice(idx, 0, {
                group: grp,
                type: type
            });
        };
        let findIndex = (delimiterArray, startDelimiter)=>{
            let index = 0;
            for(let i = 0; i < delimiterArray.length; i++){
                if (startDelimiter.indexOf(delimiterArray[i].group[0]) > -1) break;
                ++index;
            }
            return index;
        };
        config.inlineMath.forEach((grp)=>{
            let idx = findIndex(delimiterArray, grp[0]);
            insertAtIndex(idx, delimiterArray, grp, "inline");
        });
        return delimiterArray;
    }
    findDelimiterPairs(delimiterArray, textContent) {
        //Iterate through all delimiters, trying to find matching delimiters
        let state = {
            matchedDelimiterSets: []
        };
        let idx = 0;
        while(idx < textContent.length){
            //if all occurrences of delimiters so far are closed (i.e. have 'end'), we're looking for a new opening delimiter
            if (state.matchedDelimiterSets.length === 0 || state.matchedDelimiterSets[state.matchedDelimiterSets.length - 1].end) {
                let isMatch = false;
                delimiterArray.some((delimiterGroup)=>{
                    if (this.isMatchingIndex(textContent, idx, delimiterGroup.group[0])) {
                        state.lastMatchedGroup = delimiterGroup;
                        MathjaxParser.pushStart(state.matchedDelimiterSets, idx, delimiterGroup);
                        isMatch = true;
                        return true;
                    }
                });
                if (isMatch) idx += state.lastMatchedGroup.group[0].length;
                else ++idx;
            } else if (this.isMatchingIndex(textContent, idx, state.lastMatchedGroup.group[1])) {
                MathjaxParser.pushEnd(state.matchedDelimiterSets, idx, state.lastMatchedGroup);
                idx += state.lastMatchedGroup.group[1].length;
            } else ++idx;
        }
        this.cleanOccurrences(state.matchedDelimiterSets);
        return state;
    }
    cleanOccurrences = (occurrences)=>{
        if (occurrences.length > 0) {
            if (!occurrences[occurrences.length - 1].end) occurrences.pop();
        }
    };
    static pushStart(matchedDelimiterSets, idx, delimiterGroup) {
        matchedDelimiterSets.push({
            start: {
                index: idx,
                delimiterGroup: delimiterGroup,
                isStart: true
            },
            end: undefined
        });
    }
    static pushEnd(matchedDelimiterSets, idx, delimiterGroup) {
        matchedDelimiterSets[matchedDelimiterSets.length - 1].end = {
            index: idx,
            delimiterGroup: delimiterGroup,
            isStart: false
        };
    }
    isMatchingIndex(text, idx, delimiter) {
        //check number of consecutive escape characters "\" before the delimiter. If uneven, the current delimiter is escaped and not actually matching
        if (idx > 0 && text.slice(0, idx).match(/\\*$/gi)[0].length % 2 == 1) return false;
        return text.slice(idx, idx + delimiter.length) === delimiter;
    }
}

},{"@svgdotjs/svg.js":"fFByv","text-to-svg":"bM870","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bM870":[function(require,module,exports,__globalThis) {
/**
 * Copyright (c) 2016 Hideki Shiro
 */ module.exports = require("e946b4c0a03267cb");

},{"e946b4c0a03267cb":"iesqq"}],"iesqq":[function(require,module,exports,__globalThis) {
var __dirname = "node_modules/text-to-svg/build/src";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var opentype = _interopRequireWildcard(require("4be3124b8927ae6b"));
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    else {
        var newObj = {};
        if (obj != null) {
            for(var key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                if (desc.get || desc.set) Object.defineProperty(newObj, key, desc);
                else newObj[key] = obj[key];
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var DEFAULT_FONT = require("bd8e04e51f93172c").join(__dirname, '../fonts/ipag.ttf'); // Private method
function parseAnchorOption(anchor) {
    var horizontal = anchor.match(/left|center|right/gi) || [];
    horizontal = horizontal.length === 0 ? 'left' : horizontal[0];
    var vertical = anchor.match(/baseline|top|bottom|middle/gi) || [];
    vertical = vertical.length === 0 ? 'baseline' : vertical[0];
    return {
        horizontal: horizontal,
        vertical: vertical
    };
}
var TextToSVG = /*#__PURE__*/ function() {
    function TextToSVG(font) {
        _classCallCheck(this, TextToSVG);
        this.font = font;
    }
    _createClass(TextToSVG, [
        {
            key: "getWidth",
            value: function getWidth(text, options) {
                var fontSize = options.fontSize || 72;
                var kerning = 'kerning' in options ? options.kerning : true;
                var fontScale = 1 / this.font.unitsPerEm * fontSize;
                var width = 0;
                var glyphs = this.font.stringToGlyphs(text);
                for(var i = 0; i < glyphs.length; i++){
                    var glyph = glyphs[i];
                    if (glyph.advanceWidth) width += glyph.advanceWidth * fontScale;
                    if (kerning && i < glyphs.length - 1) {
                        var kerningValue = this.font.getKerningValue(glyph, glyphs[i + 1]);
                        width += kerningValue * fontScale;
                    }
                    if (options.letterSpacing) width += options.letterSpacing * fontSize;
                    else if (options.tracking) width += options.tracking / 1000 * fontSize;
                }
                return width;
            }
        },
        {
            key: "getHeight",
            value: function getHeight(fontSize) {
                var fontScale = 1 / this.font.unitsPerEm * fontSize;
                return (this.font.ascender - this.font.descender) * fontScale;
            }
        },
        {
            key: "getMetrics",
            value: function getMetrics(text) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var fontSize = options.fontSize || 72;
                var anchor = parseAnchorOption(options.anchor || '');
                var width = this.getWidth(text, options);
                var height = this.getHeight(fontSize);
                var fontScale = 1 / this.font.unitsPerEm * fontSize;
                var ascender = this.font.ascender * fontScale;
                var descender = this.font.descender * fontScale;
                var x = options.x || 0;
                switch(anchor.horizontal){
                    case 'left':
                        x -= 0;
                        break;
                    case 'center':
                        x -= width / 2;
                        break;
                    case 'right':
                        x -= width;
                        break;
                    default:
                        throw new Error("Unknown anchor option: ".concat(anchor.horizontal));
                }
                var y = options.y || 0;
                switch(anchor.vertical){
                    case 'baseline':
                        y -= ascender;
                        break;
                    case 'top':
                        y -= 0;
                        break;
                    case 'middle':
                        y -= height / 2;
                        break;
                    case 'bottom':
                        y -= height;
                        break;
                    default:
                        throw new Error("Unknown anchor option: ".concat(anchor.vertical));
                }
                var baseline = y + ascender;
                return {
                    x: x,
                    y: y,
                    baseline: baseline,
                    width: width,
                    height: height,
                    ascender: ascender,
                    descender: descender
                };
            }
        },
        {
            key: "getD",
            value: function getD(text) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var fontSize = options.fontSize || 72;
                var kerning = 'kerning' in options ? options.kerning : true;
                var letterSpacing = 'letterSpacing' in options ? options.letterSpacing : false;
                var tracking = 'tracking' in options ? options.tracking : false;
                var metrics = this.getMetrics(text, options);
                var path = this.font.getPath(text, metrics.x, metrics.baseline, fontSize, {
                    kerning: kerning,
                    letterSpacing: letterSpacing,
                    tracking: tracking
                });
                return path.toPathData();
            }
        },
        {
            key: "getPath",
            value: function getPath(text) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var attributes = Object.keys(options.attributes || {}).map(function(key) {
                    return "".concat(key, "=\"").concat(options.attributes[key], "\"");
                }).join(' ');
                var d = this.getD(text, options);
                if (attributes) return "<path ".concat(attributes, " d=\"").concat(d, "\"/>");
                return "<path d=\"".concat(d, "\"/>");
            }
        },
        {
            key: "getSVG",
            value: function getSVG(text) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var metrics = this.getMetrics(text, options);
                var svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"".concat(metrics.width, "\" height=\"").concat(metrics.height, "\">");
                svg += this.getPath(text, options);
                svg += '</svg>';
                return svg;
            }
        },
        {
            key: "getDebugSVG",
            value: function getDebugSVG(text) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                options = JSON.parse(JSON.stringify(options));
                options.x = options.x || 0;
                options.y = options.y || 0;
                var metrics = this.getMetrics(text, options);
                var box = {
                    width: Math.max(metrics.x + metrics.width, 0) - Math.min(metrics.x, 0),
                    height: Math.max(metrics.y + metrics.height, 0) - Math.min(metrics.y, 0)
                };
                var origin = {
                    x: box.width - Math.max(metrics.x + metrics.width, 0),
                    y: box.height - Math.max(metrics.y + metrics.height, 0)
                }; // Shift text based on origin
                options.x += origin.x;
                options.y += origin.y;
                var svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"".concat(box.width, "\" height=\"").concat(box.height, "\">");
                svg += "<path fill=\"none\" stroke=\"red\" stroke-width=\"1\" d=\"M0,".concat(origin.y, "L").concat(box.width, ",").concat(origin.y, "\"/>"); // X Axis
                svg += "<path fill=\"none\" stroke=\"red\" stroke-width=\"1\" d=\"M".concat(origin.x, ",0L").concat(origin.x, ",").concat(box.height, "\"/>"); // Y Axis
                svg += this.getPath(text, options);
                svg += '</svg>';
                return svg;
            }
        }
    ], [
        {
            key: "loadSync",
            value: function loadSync() {
                var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_FONT;
                return new TextToSVG(opentype.loadSync(file));
            }
        },
        {
            key: "load",
            value: function load(url, cb) {
                opentype.load(url, function(err, font) {
                    if (err !== null) return cb(err, null);
                    return cb(null, new TextToSVG(font));
                });
            }
        }
    ]);
    return TextToSVG;
}();
exports.default = TextToSVG;
module.exports = exports.default;

},{"4be3124b8927ae6b":"ekOZi","bd8e04e51f93172c":"gfVel"}],"ekOZi":[function(require,module,exports,__globalThis) {
// opentype.js
// https://github.com/opentypejs/opentype.js
// (c) 2015 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.
/* global DataView, Uint8Array, XMLHttpRequest  */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Font", ()=>(0, _fontDefault.default));
parcelHelpers.export(exports, "Glyph", ()=>(0, _glyphDefault.default));
parcelHelpers.export(exports, "Path", ()=>(0, _pathDefault.default));
parcelHelpers.export(exports, "BoundingBox", ()=>(0, _bboxDefault.default));
parcelHelpers.export(exports, "_parse", ()=>(0, _parseDefault.default));
parcelHelpers.export(exports, "parse", ()=>parseBuffer);
parcelHelpers.export(exports, "load", ()=>load);
parcelHelpers.export(exports, "loadSync", ()=>loadSync);
var _stringPrototypeCodepointat = require("string.prototype.codepointat");
var _tinyInflate = require("tiny-inflate");
var _tinyInflateDefault = parcelHelpers.interopDefault(_tinyInflate);
var _font = require("./font");
var _fontDefault = parcelHelpers.interopDefault(_font);
var _glyph = require("./glyph");
var _glyphDefault = parcelHelpers.interopDefault(_glyph);
var _encoding = require("./encoding");
var _parse = require("./parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _bbox = require("./bbox");
var _bboxDefault = parcelHelpers.interopDefault(_bbox);
var _path = require("./path");
var _pathDefault = parcelHelpers.interopDefault(_path);
var _util = require("./util");
var _cmap = require("./tables/cmap");
var _cmapDefault = parcelHelpers.interopDefault(_cmap);
var _cff = require("./tables/cff");
var _cffDefault = parcelHelpers.interopDefault(_cff);
var _fvar = require("./tables/fvar");
var _fvarDefault = parcelHelpers.interopDefault(_fvar);
var _glyf = require("./tables/glyf");
var _glyfDefault = parcelHelpers.interopDefault(_glyf);
var _gpos = require("./tables/gpos");
var _gposDefault = parcelHelpers.interopDefault(_gpos);
var _gsub = require("./tables/gsub");
var _gsubDefault = parcelHelpers.interopDefault(_gsub);
var _head = require("./tables/head");
var _headDefault = parcelHelpers.interopDefault(_head);
var _hhea = require("./tables/hhea");
var _hheaDefault = parcelHelpers.interopDefault(_hhea);
var _hmtx = require("./tables/hmtx");
var _hmtxDefault = parcelHelpers.interopDefault(_hmtx);
var _kern = require("./tables/kern");
var _kernDefault = parcelHelpers.interopDefault(_kern);
var _ltag = require("./tables/ltag");
var _ltagDefault = parcelHelpers.interopDefault(_ltag);
var _loca = require("./tables/loca");
var _locaDefault = parcelHelpers.interopDefault(_loca);
var _maxp = require("./tables/maxp");
var _maxpDefault = parcelHelpers.interopDefault(_maxp);
var _name = require("./tables/name");
var _nameDefault = parcelHelpers.interopDefault(_name);
var _os2 = require("./tables/os2");
var _os2Default = parcelHelpers.interopDefault(_os2);
var _post = require("./tables/post");
var _postDefault = parcelHelpers.interopDefault(_post);
var _meta = require("./tables/meta");
var _metaDefault = parcelHelpers.interopDefault(_meta);
/**
 * The opentype library.
 * @namespace opentype
 */ // File loaders /////////////////////////////////////////////////////////
/**
 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} path - The path of the file
 * @param  {Function} callback - The function to call when the font load completes
 */ function loadFromFile(path, callback) {
    const fs = require("34413938fdf0fe6f");
    fs.readFile(path, function(err, buffer) {
        if (err) return callback(err.message);
        callback(null, (0, _util.nodeBufferToArrayBuffer)(buffer));
    });
}
/**
 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} url - The URL of the font file.
 * @param  {Function} callback - The function to call when the font load completes
 */ function loadFromUrl(url, callback) {
    const request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        if (request.response) return callback(null, request.response);
        else return callback('Font could not be loaded: ' + request.statusText);
    };
    request.onerror = function() {
        callback('Font could not be loaded');
    };
    request.send();
}
// Table Directory Entries //////////////////////////////////////////////
/**
 * Parses OpenType table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */ function parseOpenTypeTableEntries(data, numTables) {
    const tableEntries = [];
    let p = 12;
    for(let i = 0; i < numTables; i += 1){
        const tag = (0, _parseDefault.default).getTag(data, p);
        const checksum = (0, _parseDefault.default).getULong(data, p + 4);
        const offset = (0, _parseDefault.default).getULong(data, p + 8);
        const length = (0, _parseDefault.default).getULong(data, p + 12);
        tableEntries.push({
            tag: tag,
            checksum: checksum,
            offset: offset,
            length: length,
            compression: false
        });
        p += 16;
    }
    return tableEntries;
}
/**
 * Parses WOFF table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */ function parseWOFFTableEntries(data, numTables) {
    const tableEntries = [];
    let p = 44; // offset to the first table directory entry.
    for(let i = 0; i < numTables; i += 1){
        const tag = (0, _parseDefault.default).getTag(data, p);
        const offset = (0, _parseDefault.default).getULong(data, p + 4);
        const compLength = (0, _parseDefault.default).getULong(data, p + 8);
        const origLength = (0, _parseDefault.default).getULong(data, p + 12);
        let compression;
        if (compLength < origLength) compression = 'WOFF';
        else compression = false;
        tableEntries.push({
            tag: tag,
            offset: offset,
            compression: compression,
            compressedLength: compLength,
            length: origLength
        });
        p += 20;
    }
    return tableEntries;
}
/**
 * @typedef TableData
 * @type Object
 * @property {DataView} data - The DataView
 * @property {number} offset - The data offset.
 */ /**
 * @param  {DataView}
 * @param  {Object}
 * @return {TableData}
 */ function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        const inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        const outBuffer = new Uint8Array(tableEntry.length);
        (0, _tinyInflateDefault.default)(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        const view = new DataView(outBuffer.buffer, 0);
        return {
            data: view,
            offset: 0
        };
    } else return {
        data: data,
        offset: tableEntry.offset
    };
}
// Public API ///////////////////////////////////////////////////////////
/**
 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
 * Throws an error if the font could not be parsed.
 * @param  {ArrayBuffer}
 * @return {opentype.Font}
 */ function parseBuffer(buffer) {
    let indexToLocFormat;
    let ltagTable;
    // Since the constructor can also be called to create new fonts from scratch, we indicate this
    // should be an empty font that we'll fill with our own data.
    const font = new (0, _fontDefault.default)({
        empty: true
    });
    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.
    const data = new DataView(buffer, 0);
    let numTables;
    let tableEntries = [];
    const signature = (0, _parseDefault.default).getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        font.outlinesFormat = 'truetype';
        numTables = (0, _parseDefault.default).getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = (0, _parseDefault.default).getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        const flavor = (0, _parseDefault.default).getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) font.outlinesFormat = 'truetype';
        else if (flavor === 'OTTO') font.outlinesFormat = 'cff';
        else throw new Error('Unsupported OpenType flavor ' + signature);
        numTables = (0, _parseDefault.default).getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else throw new Error('Unsupported OpenType signature ' + signature);
    let cffTableEntry;
    let fvarTableEntry;
    let glyfTableEntry;
    let gposTableEntry;
    let gsubTableEntry;
    let hmtxTableEntry;
    let kernTableEntry;
    let locaTableEntry;
    let nameTableEntry;
    let metaTableEntry;
    let p;
    for(let i = 0; i < numTables; i += 1){
        const tableEntry = tableEntries[i];
        let table;
        switch(tableEntry.tag){
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = (0, _cmapDefault.default).parse(table.data, table.offset);
                font.encoding = new (0, _encoding.CmapEncoding)(font.tables.cmap);
                break;
            case 'cvt ':
                table = uncompressTable(data, tableEntry);
                p = new (0, _parseDefault.default).Parser(table.data, table.offset);
                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'fpgm':
                table = uncompressTable(data, tableEntry);
                p = new (0, _parseDefault.default).Parser(table.data, table.offset);
                font.tables.fpgm = p.parseByteList(tableEntry.length);
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = (0, _headDefault.default).parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = (0, _hheaDefault.default).parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = (0, _ltagDefault.default).parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = (0, _maxpDefault.default).parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = (0, _os2Default.default).parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = (0, _postDefault.default).parse(table.data, table.offset);
                font.glyphNames = new (0, _encoding.GlyphNames)(font.tables.post);
                break;
            case 'prep':
                table = uncompressTable(data, tableEntry);
                p = new (0, _parseDefault.default).Parser(table.data, table.offset);
                font.tables.prep = p.parseByteList(tableEntry.length);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }
    const nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = (0, _nameDefault.default).parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;
    if (glyfTableEntry && locaTableEntry) {
        const shortVersion = indexToLocFormat === 0;
        const locaTable = uncompressTable(data, locaTableEntry);
        const locaOffsets = (0, _locaDefault.default).parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        const glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = (0, _glyfDefault.default).parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
    } else if (cffTableEntry) {
        const cffTable = uncompressTable(data, cffTableEntry);
        (0, _cffDefault.default).parse(cffTable.data, cffTable.offset, font);
    } else throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    const hmtxTable = uncompressTable(data, hmtxTableEntry);
    (0, _hmtxDefault.default).parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
    (0, _encoding.addGlyphNames)(font);
    if (kernTableEntry) {
        const kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = (0, _kernDefault.default).parse(kernTable.data, kernTable.offset);
    } else font.kerningPairs = {};
    if (gposTableEntry) {
        const gposTable = uncompressTable(data, gposTableEntry);
        font.tables.gpos = (0, _gposDefault.default).parse(gposTable.data, gposTable.offset);
        font.position.init();
    }
    if (gsubTableEntry) {
        const gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = (0, _gsubDefault.default).parse(gsubTable.data, gsubTable.offset);
    }
    if (fvarTableEntry) {
        const fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = (0, _fvarDefault.default).parse(fvarTable.data, fvarTable.offset, font.names);
    }
    if (metaTableEntry) {
        const metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = (0, _metaDefault.default).parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }
    return font;
}
/**
 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
 * with two arguments `(err, font)`. The `err` will be null on success,
 * the `font` is a Font object.
 * We use the node.js callback convention so that
 * opentype.js can integrate with frameworks like async.js.
 * @alias opentype.load
 * @param  {string} url - The URL of the font to load.
 * @param  {Function} callback - The callback.
 */ function load(url, callback) {
    const isNode = typeof window === 'undefined';
    const loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function(err, arrayBuffer) {
        if (err) return callback(err);
        let font;
        try {
            font = parseBuffer(arrayBuffer);
        } catch (e) {
            return callback(e, null);
        }
        return callback(null, font);
    });
}
/**
 * Synchronously load the font from a URL or file.
 * When done, returns the font object or throws an error.
 * @alias opentype.loadSync
 * @param  {string} url - The URL of the font to load.
 * @return {opentype.Font}
 */ function loadSync(url) {
    const fs = require("34413938fdf0fe6f");
    const buffer = fs.readFileSync(url);
    return parseBuffer((0, _util.nodeBufferToArrayBuffer)(buffer));
}

},{"string.prototype.codepointat":"aP8B5","tiny-inflate":"84OtU","./font":"iT8Dd","./glyph":"1MjxB","./encoding":"lPZPs","./parse":"8RdJX","./bbox":"iyMxz","./path":"gWom8","./util":"hbBh1","./tables/cmap":"j8yze","./tables/cff":"b7PSm","./tables/fvar":"5EEA5","./tables/glyf":"5Ol2G","./tables/gpos":"jTIcF","./tables/gsub":"kFRDp","./tables/head":"4F1f7","./tables/hhea":"hxeGk","./tables/hmtx":"8K6zn","./tables/kern":"RCH2q","./tables/ltag":"6woWu","./tables/loca":"fgton","./tables/maxp":"eUb67","./tables/name":"1D4sA","./tables/os2":"7A4bk","./tables/post":"jd3Uk","./tables/meta":"k28Ba","34413938fdf0fe6f":"eoH60","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aP8B5":[function(require,module,exports,__globalThis) {
/*! https://mths.be/codepointat v0.2.0 by @mathias */ if (!String.prototype.codePointAt) (function() {
    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
    var defineProperty = function() {
        // IE 8 only supports `Object.defineProperty` on DOM elements
        try {
            var object = {};
            var $defineProperty = Object.defineProperty;
            var result = $defineProperty(object, object, object) && $defineProperty;
        } catch (error) {}
        return result;
    }();
    var codePointAt = function(position) {
        if (this == null) throw TypeError();
        var string = String(this);
        var size = string.length;
        // `ToInteger`
        var index = position ? Number(position) : 0;
        if (index != index) index = 0;
        // Account for out-of-bounds indices:
        if (index < 0 || index >= size) return undefined;
        // Get the first code unit
        var first = string.charCodeAt(index);
        var second;
        if (first >= 0xD800 && first <= 0xDBFF && // high surrogate
        size > index + 1 // there is a next code unit
        ) {
            second = string.charCodeAt(index + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
        return first;
    };
    if (defineProperty) defineProperty(String.prototype, 'codePointAt', {
        'value': codePointAt,
        'configurable': true,
        'writable': true
    });
    else String.prototype.codePointAt = codePointAt;
})();

},{}],"84OtU":[function(require,module,exports,__globalThis) {
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
    this.table = new Uint16Array(16); /* table of code length counts */ 
    this.trans = new Uint16Array(288); /* code -> symbol translation table */ 
}
function Data(source, dest) {
    this.source = source;
    this.sourceIndex = 0;
    this.tag = 0;
    this.bitcount = 0;
    this.dest = dest;
    this.destLen = 0;
    this.ltree = new Tree(); /* dynamic length/symbol tree */ 
    this.dtree = new Tree(); /* dynamic distance tree */ 
}
/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */ var sltree = new Tree();
var sdtree = new Tree();
/* extra bits and base tables for length codes */ var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
/* extra bits and base tables for distance codes */ var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
/* special ordering of code length codes */ var clcidx = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]);
/* used by tinf_decode_trees, avoids allocations every call */ var code_tree = new Tree();
var lengths = new Uint8Array(320);
/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */ /* build extra bits and base tables */ function tinf_build_bits_base(bits, base, delta, first) {
    var i, sum;
    /* build bits table */ for(i = 0; i < delta; ++i)bits[i] = 0;
    for(i = 0; i < 30 - delta; ++i)bits[i + delta] = i / delta | 0;
    /* build base table */ for(sum = first, i = 0; i < 30; ++i){
        base[i] = sum;
        sum += 1 << bits[i];
    }
}
/* build the fixed huffman trees */ function tinf_build_fixed_trees(lt, dt) {
    var i;
    /* build fixed length tree */ for(i = 0; i < 7; ++i)lt.table[i] = 0;
    lt.table[7] = 24;
    lt.table[8] = 152;
    lt.table[9] = 112;
    for(i = 0; i < 24; ++i)lt.trans[i] = 256 + i;
    for(i = 0; i < 144; ++i)lt.trans[24 + i] = i;
    for(i = 0; i < 8; ++i)lt.trans[168 + i] = 280 + i;
    for(i = 0; i < 112; ++i)lt.trans[176 + i] = 144 + i;
    /* build fixed distance tree */ for(i = 0; i < 5; ++i)dt.table[i] = 0;
    dt.table[5] = 32;
    for(i = 0; i < 32; ++i)dt.trans[i] = i;
}
/* given an array of code lengths, build a tree */ var offs = new Uint16Array(16);
function tinf_build_tree(t, lengths, off, num) {
    var i, sum;
    /* clear code length count table */ for(i = 0; i < 16; ++i)t.table[i] = 0;
    /* scan symbol lengths, and sum code length counts */ for(i = 0; i < num; ++i)t.table[lengths[off + i]]++;
    t.table[0] = 0;
    /* compute offset table for distribution sort */ for(sum = 0, i = 0; i < 16; ++i){
        offs[i] = sum;
        sum += t.table[i];
    }
    /* create code->symbol translation table (symbols sorted by code) */ for(i = 0; i < num; ++i)if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
}
/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */ /* get one bit from source stream */ function tinf_getbit(d) {
    /* check if tag is empty */ if (!d.bitcount--) {
        /* load next tag */ d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
    }
    /* shift bit out of tag */ var bit = d.tag & 1;
    d.tag >>>= 1;
    return bit;
}
/* read a num bit value from a stream and add base */ function tinf_read_bits(d, num, base) {
    if (!num) return base;
    while(d.bitcount < 24){
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
    }
    var val = d.tag & 0xffff >>> 16 - num;
    d.tag >>>= num;
    d.bitcount -= num;
    return val + base;
}
/* given a data stream and a tree, decode a symbol */ function tinf_decode_symbol(d, t) {
    while(d.bitcount < 24){
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
    }
    var sum = 0, cur = 0, len = 0;
    var tag = d.tag;
    /* get more bits while code value is above sum */ do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t.table[len];
        cur -= t.table[len];
    }while (cur >= 0);
    d.tag = tag;
    d.bitcount -= len;
    return t.trans[sum + cur];
}
/* given a data stream, decode dynamic trees from it */ function tinf_decode_trees(d, lt, dt) {
    var hlit, hdist, hclen;
    var i, num, length;
    /* get 5 bits HLIT (257-286) */ hlit = tinf_read_bits(d, 5, 257);
    /* get 5 bits HDIST (1-32) */ hdist = tinf_read_bits(d, 5, 1);
    /* get 4 bits HCLEN (4-19) */ hclen = tinf_read_bits(d, 4, 4);
    for(i = 0; i < 19; ++i)lengths[i] = 0;
    /* read code lengths for code length alphabet */ for(i = 0; i < hclen; ++i){
        /* get 3 bits code length (0-7) */ var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i]] = clen;
    }
    /* build code length tree */ tinf_build_tree(code_tree, lengths, 0, 19);
    /* decode code lengths for the dynamic trees */ for(num = 0; num < hlit + hdist;){
        var sym = tinf_decode_symbol(d, code_tree);
        switch(sym){
            case 16:
                /* copy previous code length 3-6 times (read 2 bits) */ var prev = lengths[num - 1];
                for(length = tinf_read_bits(d, 2, 3); length; --length)lengths[num++] = prev;
                break;
            case 17:
                /* repeat code length 0 for 3-10 times (read 3 bits) */ for(length = tinf_read_bits(d, 3, 3); length; --length)lengths[num++] = 0;
                break;
            case 18:
                /* repeat code length 0 for 11-138 times (read 7 bits) */ for(length = tinf_read_bits(d, 7, 11); length; --length)lengths[num++] = 0;
                break;
            default:
                /* values 0-15 represent the actual code lengths */ lengths[num++] = sym;
                break;
        }
    }
    /* build dynamic trees */ tinf_build_tree(lt, lengths, 0, hlit);
    tinf_build_tree(dt, lengths, hlit, hdist);
}
/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */ /* given a stream and two trees, inflate a block of data */ function tinf_inflate_block_data(d, lt, dt) {
    while(true){
        var sym = tinf_decode_symbol(d, lt);
        /* check for end of block */ if (sym === 256) return TINF_OK;
        if (sym < 256) d.dest[d.destLen++] = sym;
        else {
            var length, dist, offs;
            var i;
            sym -= 257;
            /* possibly get more bits from length code */ length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
            dist = tinf_decode_symbol(d, dt);
            /* possibly get more bits from distance code */ offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
            /* copy match */ for(i = offs; i < offs + length; ++i)d.dest[d.destLen++] = d.dest[i];
        }
    }
}
/* inflate an uncompressed block of data */ function tinf_inflate_uncompressed_block(d) {
    var length, invlength;
    var i;
    /* unread from bitbuffer */ while(d.bitcount > 8){
        d.sourceIndex--;
        d.bitcount -= 8;
    }
    /* get length */ length = d.source[d.sourceIndex + 1];
    length = 256 * length + d.source[d.sourceIndex];
    /* get one's complement of length */ invlength = d.source[d.sourceIndex + 3];
    invlength = 256 * invlength + d.source[d.sourceIndex + 2];
    /* check length */ if (length !== (~invlength & 0x0000ffff)) return TINF_DATA_ERROR;
    d.sourceIndex += 4;
    /* copy block */ for(i = length; i; --i)d.dest[d.destLen++] = d.source[d.sourceIndex++];
    /* make sure we start next block on a byte boundary */ d.bitcount = 0;
    return TINF_OK;
}
/* inflate stream from source to dest */ function tinf_uncompress(source, dest) {
    var d = new Data(source, dest);
    var bfinal, btype, res;
    do {
        /* read final block flag */ bfinal = tinf_getbit(d);
        /* read block type (2 bits) */ btype = tinf_read_bits(d, 2, 0);
        /* decompress block */ switch(btype){
            case 0:
                /* decompress uncompressed block */ res = tinf_inflate_uncompressed_block(d);
                break;
            case 1:
                /* decompress block with fixed huffman trees */ res = tinf_inflate_block_data(d, sltree, sdtree);
                break;
            case 2:
                /* decompress block with dynamic huffman trees */ tinf_decode_trees(d, d.ltree, d.dtree);
                res = tinf_inflate_block_data(d, d.ltree, d.dtree);
                break;
            default:
                res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK) throw new Error('Data error');
    }while (!bfinal);
    if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === 'function') return d.dest.slice(0, d.destLen);
        else return d.dest.subarray(0, d.destLen);
    }
    return d.dest;
}
/* -------------------- *
 * -- initialization -- *
 * -------------------- */ /* build fixed huffman trees */ tinf_build_fixed_trees(sltree, sdtree);
/* build extra bits and base tables */ tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
/* fix a special case */ length_bits[28] = 0;
length_base[28] = 258;
module.exports = tinf_uncompress;

},{}],"iT8Dd":[function(require,module,exports,__globalThis) {
// The Font object
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _path = require("./path");
var _pathDefault = parcelHelpers.interopDefault(_path);
var _sfnt = require("./tables/sfnt");
var _sfntDefault = parcelHelpers.interopDefault(_sfnt);
var _encoding = require("./encoding");
var _glyphset = require("./glyphset");
var _glyphsetDefault = parcelHelpers.interopDefault(_glyphset);
var _position = require("./position");
var _positionDefault = parcelHelpers.interopDefault(_position);
var _substitution = require("./substitution");
var _substitutionDefault = parcelHelpers.interopDefault(_substitution);
var _util = require("./util");
var _hintingtt = require("./hintingtt");
var _hintingttDefault = parcelHelpers.interopDefault(_hintingtt);
var _bidi = require("./bidi");
var _bidiDefault = parcelHelpers.interopDefault(_bidi);
var _featureQuery = require("./features/featureQuery");
var _featureQueryDefault = parcelHelpers.interopDefault(_featureQuery);
/**
 * @typedef FontOptions
 * @type Object
 * @property {Boolean} empty - whether to create a new empty font
 * @property {string} familyName
 * @property {string} styleName
 * @property {string=} fullName
 * @property {string=} postScriptName
 * @property {string=} designer
 * @property {string=} designerURL
 * @property {string=} manufacturer
 * @property {string=} manufacturerURL
 * @property {string=} license
 * @property {string=} licenseURL
 * @property {string=} version
 * @property {string=} description
 * @property {string=} copyright
 * @property {string=} trademark
 * @property {Number} unitsPerEm
 * @property {Number} ascender
 * @property {Number} descender
 * @property {Number} createdTimestamp
 * @property {string=} weightClass
 * @property {string=} widthClass
 * @property {string=} fsSelection
 */ /**
 * A Font represents a loaded OpenType font file.
 * It contains a set of glyphs and methods to draw text on a drawing context,
 * or to get a path representing the text.
 * @exports opentype.Font
 * @class
 * @param {FontOptions}
 * @constructor
 */ function Font(options) {
    options = options || {};
    if (!options.empty) {
        // Check that we've provided the minimum set of names.
        (0, _util.checkArgument)(options.familyName, 'When creating a new Font object, familyName is required.');
        (0, _util.checkArgument)(options.styleName, 'When creating a new Font object, styleName is required.');
        (0, _util.checkArgument)(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        (0, _util.checkArgument)(options.ascender, 'When creating a new Font object, ascender is required.');
        (0, _util.checkArgument)(options.descender, 'When creating a new Font object, descender is required.');
        (0, _util.checkArgument)(options.descender < 0, 'Descender should be negative (e.g. -512).');
        // OS X will complain if the names are empty, so we put a single space everywhere by default.
        this.names = {
            fontFamily: {
                en: options.familyName || ' '
            },
            fontSubfamily: {
                en: options.styleName || ' '
            },
            fullName: {
                en: options.fullName || options.familyName + ' ' + options.styleName
            },
            // postScriptName may not contain any whitespace
            postScriptName: {
                en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')
            },
            designer: {
                en: options.designer || ' '
            },
            designerURL: {
                en: options.designerURL || ' '
            },
            manufacturer: {
                en: options.manufacturer || ' '
            },
            manufacturerURL: {
                en: options.manufacturerURL || ' '
            },
            license: {
                en: options.license || ' '
            },
            licenseURL: {
                en: options.licenseURL || ' '
            },
            version: {
                en: options.version || 'Version 0.1'
            },
            description: {
                en: options.description || ' '
            },
            copyright: {
                en: options.copyright || ' '
            },
            trademark: {
                en: options.trademark || ' '
            }
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = {
            os2: {
                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
            }
        };
    }
    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
    this.glyphs = new (0, _glyphsetDefault.default).GlyphSet(this, options.glyphs || []);
    this.encoding = new (0, _encoding.DefaultEncoding)(this);
    this.position = new (0, _positionDefault.default)(this);
    this.substitution = new (0, _substitutionDefault.default)(this);
    this.tables = this.tables || {};
    Object.defineProperty(this, 'hinting', {
        get: function() {
            if (this._hinting) return this._hinting;
            if (this.outlinesFormat === 'truetype') return this._hinting = new (0, _hintingttDefault.default)(this);
        }
    });
}
/**
 * Check if the font has a glyph for the given character.
 * @param  {string}
 * @return {Boolean}
 */ Font.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};
/**
 * Convert the given character to a single glyph index.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {Number}
 */ Font.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};
/**
 * Convert the given character to a single Glyph object.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {opentype.Glyph}
 */ Font.prototype.charToGlyph = function(c) {
    const glyphIndex = this.charToGlyphIndex(c);
    let glyph = this.glyphs.get(glyphIndex);
    if (!glyph) // .notdef
    glyph = this.glyphs.get(0);
    return glyph;
};
/**
 * Convert the given text to a list of Glyph objects.
 * Note that there is no strict one-to-one mapping between characters and
 * glyphs, so the list of returned glyphs can be larger or smaller than the
 * length of the given string.
 * @param  {string}
 * @param  {GlyphRenderOptions} [options]
 * @return {opentype.Glyph[]}
 */ Font.prototype.stringToGlyphs = function(s, options) {
    options = options || this.defaultRenderOptions;
    const bidi = new (0, _bidiDefault.default)();
    // Create and register 'glyphIndex' state modifier
    const charToGlyphIndexMod = (token)=>this.charToGlyphIndex(token.char);
    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);
    const arabFeatureQuery = new (0, _featureQueryDefault.default)(this);
    const arabFeatures = [
        'init',
        'medi',
        'fina',
        'rlig'
    ];
    bidi.applyFeatures(arabFeatures.map((tag)=>{
        let query = {
            tag,
            script: 'arab'
        };
        let feature = arabFeatureQuery.getFeature(query);
        if (!!feature) return feature;
    }));
    const indexes = bidi.getTextGlyphs(s);
    let length = indexes.length;
    // Apply substitutions on glyph indexes
    if (options.features) {
        const script = options.script || this.substitution.getDefaultScriptName();
        let manyToOne = [];
        if (options.features.liga) manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language));
        if (options.features.rlig) manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language));
        for(let i = 0; i < length; i += 1)for(let j = 0; j < manyToOne.length; j++){
            const ligature = manyToOne[j];
            const components = ligature.sub;
            const compCount = components.length;
            let k = 0;
            while(k < compCount && components[k] === indexes[i + k])k++;
            if (k === compCount) {
                indexes.splice(i, compCount, ligature.by);
                length = length - compCount + 1;
            }
        }
    }
    // convert glyph indexes to glyph objects
    const glyphs = new Array(length);
    const notdef = this.glyphs.get(0);
    for(let i = 0; i < length; i += 1)glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
    return glyphs;
};
/**
 * @param  {string}
 * @return {Number}
 */ Font.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};
/**
 * @param  {string}
 * @return {opentype.Glyph}
 */ Font.prototype.nameToGlyph = function(name) {
    const glyphIndex = this.nameToGlyphIndex(name);
    let glyph = this.glyphs.get(glyphIndex);
    if (!glyph) // .notdef
    glyph = this.glyphs.get(0);
    return glyph;
};
/**
 * @param  {Number}
 * @return {String}
 */ Font.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) return '';
    return this.glyphNames.glyphIndexToName(gid);
};
/**
 * Retrieve the value of the kerning pair between the left glyph (or its index)
 * and the right glyph (or its index). If no kerning pair is found, return 0.
 * The kerning value gets added to the advance width when calculating the spacing
 * between glyphs.
 * For GPOS kerning, this method uses the default script and language, which covers
 * most use cases. To have greater control, use font.position.getKerningValue .
 * @param  {opentype.Glyph} leftGlyph
 * @param  {opentype.Glyph} rightGlyph
 * @return {Number}
 */ Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    const gposKerning = this.position.defaultKerningTables;
    if (gposKerning) return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
    // "kern" table
    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
};
/**
 * @typedef GlyphRenderOptions
 * @type Object
 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
 * @property {string} [language='dflt'] - language system used to determine which features to apply.
 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
 * @property {boolean} [kerning=true] - whether to include kerning values
 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
 */ Font.prototype.defaultRenderOptions = {
    kerning: true,
    features: {
        liga: true,
        rlig: true
    }
};
/**
 * Helper function that invokes the given callback for each glyph in the given text.
 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
 * @param {string} text - The text to apply.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @param  {Function} callback
 */ Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    const fontScale = 1 / this.unitsPerEm * fontSize;
    const glyphs = this.stringToGlyphs(text, options);
    let kerningLookups;
    if (options.kerning) {
        const script = options.script || this.position.getDefaultScriptName();
        kerningLookups = this.position.getKerningTables(script, options.language);
    }
    for(let i = 0; i < glyphs.length; i += 1){
        const glyph = glyphs[i];
        callback.call(this, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) x += glyph.advanceWidth * fontScale;
        if (options.kerning && i < glyphs.length - 1) {
            // We should apply position adjustment lookups in a more generic way.
            // Here we only use the xAdvance value.
            const kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) : this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
        if (options.letterSpacing) x += options.letterSpacing * fontSize;
        else if (options.tracking) x += options.tracking / 1000 * fontSize;
    }
    return x;
};
/**
 * Create a Path object that represents the given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path}
 */ Font.prototype.getPath = function(text, x, y, fontSize, options) {
    const fullPath = new (0, _pathDefault.default)();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        const glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
    });
    return fullPath;
};
/**
 * Create an array of Path objects that represent the glyphs of a given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path[]}
 */ Font.prototype.getPaths = function(text, x, y, fontSize, options) {
    const glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        const glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
    });
    return glyphPaths;
};
/**
 * Returns the advance width of a text.
 *
 * This is something different than Path.getBoundingBox() as for example a
 * suffixed whitespace increases the advanceWidth but not the bounding box
 * or an overhanging letter like a calligraphic 'f' might have a quite larger
 * bounding box than its advance width.
 *
 * This corresponds to canvas2dContext.measureText(text).width
 *
 * @param  {string} text - The text to create.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return advance width
 */ Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
};
/**
 * Draw the text on the given drawing context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 */ Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};
/**
 * Draw the points of all glyphs in the text.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */ Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};
/**
 * Draw lines indicating important font measurements for all glyphs in the text.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */ Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};
/**
 * @param  {string}
 * @return {string}
 */ Font.prototype.getEnglishName = function(name) {
    const translations = this.names[name];
    if (translations) return translations.en;
};
/**
 * Validate
 */ Font.prototype.validate = function() {
    const warnings = [];
    const _this = this;
    function assert(predicate, message) {
        if (!predicate) warnings.push(message);
    }
    function assertNamePresent(name) {
        const englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0, 'No English ' + name + ' specified.');
    }
    // Identification information
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');
    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};
/**
 * Convert the font object to a SFNT data structure.
 * This structure contains all the necessary tables and metadata to create a binary OTF file.
 * @return {opentype.Table}
 */ Font.prototype.toTables = function() {
    return (0, _sfntDefault.default).fontToTable(this);
};
/**
 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
 */ Font.prototype.toBuffer = function() {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
/**
 * Converts a `opentype.Font` into an `ArrayBuffer`
 * @return {ArrayBuffer}
 */ Font.prototype.toArrayBuffer = function() {
    const sfntTable = this.toTables();
    const bytes = sfntTable.encode();
    const buffer = new ArrayBuffer(bytes.length);
    const intArray = new Uint8Array(buffer);
    for(let i = 0; i < bytes.length; i++)intArray[i] = bytes[i];
    return buffer;
};
/**
 * Initiate a download of the OpenType font.
 */ Font.prototype.download = function(fileName) {
    const familyName = this.getEnglishName('fontFamily');
    const styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    const arrayBuffer = this.toArrayBuffer();
    if ((0, _util.isBrowser)()) {
        window.URL = window.URL || window.webkitURL;
        if (window.URL) {
            const dataView = new DataView(arrayBuffer);
            const blob = new Blob([
                dataView
            ], {
                type: 'font/opentype'
            });
            let link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = fileName;
            let event = document.createEvent('MouseEvents');
            event.initEvent('click', true, false);
            link.dispatchEvent(event);
        } else console.warn('Font file could not be downloaded. Try using a different browser.');
    } else {
        const fs = require("b1ebbc0ce89d18e5");
        const buffer = (0, _util.arrayBufferToNodeBuffer)(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
/**
 * @private
 */ Font.prototype.fsSelectionValues = {
    ITALIC: 0x001,
    UNDERSCORE: 0x002,
    NEGATIVE: 0x004,
    OUTLINED: 0x008,
    STRIKEOUT: 0x010,
    BOLD: 0x020,
    REGULAR: 0x040,
    USER_TYPO_METRICS: 0x080,
    WWS: 0x100,
    OBLIQUE: 0x200 //512
};
/**
 * @private
 */ Font.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};
/**
 * @private
 */ Font.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK: 900
};
exports.default = Font;

},{"./path":"gWom8","./tables/sfnt":"aPDdQ","./encoding":"lPZPs","./glyphset":"d9O7P","./position":"5To8e","./substitution":"iDhKK","./util":"hbBh1","./hintingtt":"lRqI7","./bidi":"nSHVg","./features/featureQuery":"7BAni","b1ebbc0ce89d18e5":"eoH60","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gWom8":[function(require,module,exports,__globalThis) {
// Geometric objects
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bbox = require("./bbox");
var _bboxDefault = parcelHelpers.interopDefault(_bbox);
/**
 * A bzier path containing a set of path commands similar to a SVG path.
 * Paths can be drawn on a context using `draw`.
 * @exports opentype.Path
 * @class
 * @constructor
 */ function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}
/**
 * @param  {number} x
 * @param  {number} y
 */ Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};
/**
 * @param  {number} x
 * @param  {number} y
 */ Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};
/**
 * Draws cubic curve
 * @function
 * curveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */ /**
 * Draws cubic curve
 * @function
 * bezierCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 * @see curveTo
 */ Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};
/**
 * Draws quadratic curve
 * @function
 * quadraticCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */ /**
 * Draws quadratic curve
 * @function
 * quadTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */ Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};
/**
 * Closes the path
 * @function closePath
 * @memberof opentype.Path.prototype
 */ /**
 * Close the path
 * @function close
 * @memberof opentype.Path.prototype
 */ Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};
/**
 * Add the given path or list of commands to the commands of this path.
 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
 */ Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) pathOrCommands = pathOrCommands.commands;
    else if (pathOrCommands instanceof (0, _bboxDefault.default)) {
        const box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }
    Array.prototype.push.apply(this.commands, pathOrCommands);
};
/**
 * Calculate the bounding box of the path.
 * @returns {opentype.BoundingBox}
 */ Path.prototype.getBoundingBox = function() {
    const box = new (0, _bboxDefault.default)();
    let startX = 0;
    let startY = 0;
    let prevX = 0;
    let prevY = 0;
    for(let i = 0; i < this.commands.length; i++){
        const cmd = this.commands[i];
        switch(cmd.type){
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path command ' + cmd.type);
        }
    }
    if (box.isEmpty()) box.addPoint(0, 0);
    return box;
};
/**
 * Draw the path to a 2D context.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
 */ Path.prototype.draw = function(ctx) {
    ctx.beginPath();
    for(let i = 0; i < this.commands.length; i += 1){
        const cmd = this.commands[i];
        if (cmd.type === 'M') ctx.moveTo(cmd.x, cmd.y);
        else if (cmd.type === 'L') ctx.lineTo(cmd.x, cmd.y);
        else if (cmd.type === 'C') ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        else if (cmd.type === 'Q') ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        else if (cmd.type === 'Z') ctx.closePath();
    }
    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }
    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};
/**
 * Convert the Path to a string of path data instructions
 * See http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */ Path.prototype.toPathData = function(decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;
    function floatToString(v) {
        if (Math.round(v) === v) return '' + Math.round(v);
        else return v.toFixed(decimalPlaces);
    }
    function packValues() {
        let s = '';
        for(let i = 0; i < arguments.length; i += 1){
            const v = arguments[i];
            if (v >= 0 && i > 0) s += ' ';
            s += floatToString(v);
        }
        return s;
    }
    let d = '';
    for(let i = 0; i < this.commands.length; i += 1){
        const cmd = this.commands[i];
        if (cmd.type === 'M') d += 'M' + packValues(cmd.x, cmd.y);
        else if (cmd.type === 'L') d += 'L' + packValues(cmd.x, cmd.y);
        else if (cmd.type === 'C') d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        else if (cmd.type === 'Q') d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        else if (cmd.type === 'Z') d += 'Z';
    }
    return d;
};
/**
 * Convert the path to an SVG <path> element, as a string.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */ Path.prototype.toSVG = function(decimalPlaces) {
    let svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) svg += ' fill="none"';
        else svg += ' fill="' + this.fill + '"';
    }
    if (this.stroke) svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    svg += '/>';
    return svg;
};
/**
 * Convert the path to a DOM element.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {SVGPathElement}
 */ Path.prototype.toDOMElement = function(decimalPlaces) {
    const temporaryPath = this.toPathData(decimalPlaces);
    const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    newPath.setAttribute('d', temporaryPath);
    return newPath;
};
exports.default = Path;

},{"./bbox":"iyMxz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iyMxz":[function(require,module,exports,__globalThis) {
// The Bounding Box object
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 + 3 * Math.pow(1 - t, 2) * t * v1 + 3 * (1 - t) * Math.pow(t, 2) * v2 + Math.pow(t, 3) * v3;
}
/**
 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
 * It is used to calculate the bounding box of a glyph or text path.
 *
 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
 *
 * @exports opentype.BoundingBox
 * @class
 * @constructor
 */ function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}
/**
 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
 */ BoundingBox.prototype.isEmpty = function() {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
/**
 * Add the point to the bounding box.
 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
 * @param {number} x - The X coordinate of the point.
 * @param {number} y - The Y coordinate of the point.
 */ BoundingBox.prototype.addPoint = function(x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) this.x1 = x;
        if (x > this.x2) this.x2 = x;
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) this.y1 = y;
        if (y > this.y2) this.y2 = y;
    }
};
/**
 * Add a X coordinate to the bounding box.
 * This extends the bounding box to include the X coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} x - The X coordinate of the point.
 */ BoundingBox.prototype.addX = function(x) {
    this.addPoint(x, null);
};
/**
 * Add a Y coordinate to the bounding box.
 * This extends the bounding box to include the Y coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} y - The Y coordinate of the point.
 */ BoundingBox.prototype.addY = function(y) {
    this.addPoint(null, y);
};
/**
 * Add a Bzier curve to the bounding box.
 * This extends the bounding box to include the entire Bzier.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the first control point.
 * @param {number} y1 - The Y coordinate of the first control point.
 * @param {number} x2 - The X coordinate of the second control point.
 * @param {number} y2 - The Y coordinate of the second control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */ BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
    // and https://github.com/icons8/svg-path-bounding-box
    const p0 = [
        x0,
        y0
    ];
    const p1 = [
        x1,
        y1
    ];
    const p2 = [
        x2,
        y2
    ];
    const p3 = [
        x,
        y
    ];
    this.addPoint(x0, y0);
    this.addPoint(x, y);
    for(let i = 0; i <= 1; i++){
        const b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        const a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        const c = 3 * p1[i] - 3 * p0[i];
        if (a === 0) {
            if (b === 0) continue;
            const t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t));
                if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t));
            }
            continue;
        }
        const b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) continue;
        const t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));
            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));
        }
        const t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));
            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));
        }
    }
};
/**
 * Add a quadratic curve to the bounding box.
 * This extends the bounding box to include the entire quadratic curve.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the control point.
 * @param {number} y1 - The Y coordinate of the control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */ BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
    const cp1x = x0 + 2 / 3 * (x1 - x0);
    const cp1y = y0 + 2 / 3 * (y1 - y0);
    const cp2x = cp1x + 1 / 3 * (x - x0);
    const cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};
exports.default = BoundingBox;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aPDdQ":[function(require,module,exports,__globalThis) {
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
var _cmap = require("./cmap");
var _cmapDefault = parcelHelpers.interopDefault(_cmap);
var _cff = require("./cff");
var _cffDefault = parcelHelpers.interopDefault(_cff);
var _head = require("./head");
var _headDefault = parcelHelpers.interopDefault(_head);
var _hhea = require("./hhea");
var _hheaDefault = parcelHelpers.interopDefault(_hhea);
var _hmtx = require("./hmtx");
var _hmtxDefault = parcelHelpers.interopDefault(_hmtx);
var _ltag = require("./ltag");
var _ltagDefault = parcelHelpers.interopDefault(_ltag);
var _maxp = require("./maxp");
var _maxpDefault = parcelHelpers.interopDefault(_maxp);
var _name = require("./name");
var _nameDefault = parcelHelpers.interopDefault(_name);
var _os2 = require("./os2");
var _os2Default = parcelHelpers.interopDefault(_os2);
var _post = require("./post");
var _postDefault = parcelHelpers.interopDefault(_post);
var _gsub = require("./gsub");
var _gsubDefault = parcelHelpers.interopDefault(_gsub);
var _meta = require("./meta");
var _metaDefault = parcelHelpers.interopDefault(_meta);
function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}
function computeCheckSum(bytes) {
    while(bytes.length % 4 !== 0)bytes.push(0);
    let sum = 0;
    for(let i = 0; i < bytes.length; i += 4)sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];
    sum %= Math.pow(2, 32);
    return sum;
}
function makeTableRecord(tag, checkSum, offset, length) {
    return new (0, _tableDefault.default).Record('Table Record', [
        {
            name: 'tag',
            type: 'TAG',
            value: tag !== undefined ? tag : ''
        },
        {
            name: 'checkSum',
            type: 'ULONG',
            value: checkSum !== undefined ? checkSum : 0
        },
        {
            name: 'offset',
            type: 'ULONG',
            value: offset !== undefined ? offset : 0
        },
        {
            name: 'length',
            type: 'ULONG',
            value: length !== undefined ? length : 0
        }
    ]);
}
function makeSfntTable(tables) {
    const sfnt = new (0, _tableDefault.default).Table('sfnt', [
        {
            name: 'version',
            type: 'TAG',
            value: 'OTTO'
        },
        {
            name: 'numTables',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'searchRange',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'entrySelector',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'rangeShift',
            type: 'USHORT',
            value: 0
        }
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    const highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;
    const recordFields = [];
    const tableFields = [];
    let offset = sfnt.sizeOf() + makeTableRecord().sizeOf() * sfnt.numTables;
    while(offset % 4 !== 0){
        offset += 1;
        tableFields.push({
            name: 'padding',
            type: 'BYTE',
            value: 0
        });
    }
    for(let i = 0; i < tables.length; i += 1){
        const t = tables[i];
        (0, _checkDefault.default).argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        const tableLength = t.sizeOf();
        const tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({
            name: tableRecord.tag + ' Table Record',
            type: 'RECORD',
            value: tableRecord
        });
        tableFields.push({
            name: t.tableName + ' table',
            type: 'RECORD',
            value: t
        });
        offset += tableLength;
        (0, _checkDefault.default).argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while(offset % 4 !== 0){
            offset += 1;
            tableFields.push({
                name: 'padding',
                type: 'BYTE',
                value: 0
            });
        }
    }
    // Table records need to be sorted alphabetically.
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) return 1;
        else return -1;
    });
    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}
// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for(let i = 0; i < chars.length; i += 1){
        const glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            const glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }
    return notFoundMetrics;
}
function average(vs) {
    let sum = 0;
    for(let i = 0; i < vs.length; i += 1)sum += vs[i];
    return sum / vs.length;
}
// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    const xMins = [];
    const yMins = [];
    const xMaxs = [];
    const yMaxs = [];
    const advanceWidths = [];
    const leftSideBearings = [];
    const rightSideBearings = [];
    let firstCharIndex;
    let lastCharIndex = 0;
    let ulUnicodeRange1 = 0;
    let ulUnicodeRange2 = 0;
    let ulUnicodeRange3 = 0;
    let ulUnicodeRange4 = 0;
    for(let i = 0; i < font.glyphs.length; i += 1){
        const glyph = font.glyphs.get(i);
        const unicode = glyph.unicode | 0;
        if (isNaN(glyph.advanceWidth)) throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        if (firstCharIndex > unicode || firstCharIndex === undefined) // ignore .notdef char
        {
            if (unicode > 0) firstCharIndex = unicode;
        }
        if (lastCharIndex < unicode) lastCharIndex = unicode;
        const position = (0, _os2Default.default).getUnicodeRange(unicode);
        if (position < 32) ulUnicodeRange1 |= 1 << position;
        else if (position < 64) ulUnicodeRange2 |= 1 << position - 32;
        else if (position < 96) ulUnicodeRange3 |= 1 << position - 64;
        else if (position < 123) ulUnicodeRange4 |= 1 << position - 96;
        else throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        const metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }
    const globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;
    const headTable = (0, _headDefault.default).make({
        flags: 3,
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });
    const hheaTable = (0, _hheaDefault.default).make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });
    const maxpTable = (0, _maxpDefault.default).make(font.glyphs.length);
    const os2Table = (0, _os2Default.default).make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection,
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1,
        sxHeight: metricsForChar(font, 'xyvw', {
            yMax: Math.round(globals.ascender / 2)
        }).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0,
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });
    const hmtxTable = (0, _hmtxDefault.default).make(font.glyphs);
    const cmapTable = (0, _cmapDefault.default).make(font.glyphs);
    const englishFamilyName = font.getEnglishName('fontFamily');
    const englishStyleName = font.getEnglishName('fontSubfamily');
    const englishFullName = englishFamilyName + ' ' + englishStyleName;
    let postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    const names = {};
    for(let n in font.names)names[n] = font.names[n];
    if (!names.uniqueID) names.uniqueID = {
        en: font.getEnglishName('manufacturer') + ':' + englishFullName
    };
    if (!names.postScriptName) names.postScriptName = {
        en: postScriptName
    };
    if (!names.preferredFamily) names.preferredFamily = font.names.fontFamily;
    if (!names.preferredSubfamily) names.preferredSubfamily = font.names.fontSubfamily;
    const languageTags = [];
    const nameTable = (0, _nameDefault.default).make(names, languageTags);
    const ltagTable = languageTags.length > 0 ? (0, _ltagDefault.default).make(languageTags) : undefined;
    const postTable = (0, _postDefault.default).make();
    const cffTable = (0, _cffDefault.default).make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [
            0,
            globals.yMin,
            globals.ascender,
            globals.advanceWidthMax
        ]
    });
    const metaTable = font.metas && Object.keys(font.metas).length > 0 ? (0, _metaDefault.default).make(font.metas) : undefined;
    // The order does not matter because makeSfntTable() will sort them.
    const tables = [
        headTable,
        hheaTable,
        maxpTable,
        os2Table,
        nameTable,
        cmapTable,
        postTable,
        cffTable,
        hmtxTable
    ];
    if (ltagTable) tables.push(ltagTable);
    // Optional tables
    if (font.tables.gsub) tables.push((0, _gsubDefault.default).make(font.tables.gsub));
    if (metaTable) tables.push(metaTable);
    const sfntTable = makeSfntTable(tables);
    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    const bytes = sfntTable.encode();
    const checkSum = computeCheckSum(bytes);
    const tableFields = sfntTable.fields;
    let checkSumAdjusted = false;
    for(let i = 0; i < tableFields.length; i += 1)if (tableFields[i].name === 'head table') {
        tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
        checkSumAdjusted = true;
        break;
    }
    if (!checkSumAdjusted) throw new Error('Could not find head table with checkSum to adjust.');
    return sfntTable;
}
exports.default = {
    make: makeSfntTable,
    fontToTable: fontToSfntTable,
    computeCheckSum
};

},{"../check":"184gJ","../table":"8eeDl","./cmap":"j8yze","./cff":"b7PSm","./head":"4F1f7","./hhea":"hxeGk","./hmtx":"8K6zn","./ltag":"6woWu","./maxp":"eUb67","./name":"1D4sA","./os2":"7A4bk","./post":"jd3Uk","./gsub":"kFRDp","./meta":"k28Ba","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"184gJ":[function(require,module,exports,__globalThis) {
// Run-time checking of preconditions.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "argument", ()=>argument);
parcelHelpers.export(exports, "assert", ()=>argument);
function fail(message) {
    throw new Error(message);
}
// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
function argument(predicate, message) {
    if (!predicate) fail(message);
}
exports.default = {
    fail,
    argument,
    assert: argument
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8eeDl":[function(require,module,exports,__globalThis) {
// Table metadata
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("./check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _types = require("./types");
/**
 * @exports opentype.Table
 * @class
 * @param {string} tableName
 * @param {Array} fields
 * @param {Object} options
 * @constructor
 */ function Table(tableName, fields, options) {
    for(let i = 0; i < fields.length; i += 1){
        const field = fields[i];
        this[field.name] = field.value;
    }
    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        const optionKeys = Object.keys(options);
        for(let i = 0; i < optionKeys.length; i += 1){
            const k = optionKeys[i];
            const v = options[k];
            if (this[k] !== undefined) this[k] = v;
        }
    }
}
/**
 * Encodes the table and returns an array of bytes
 * @return {Array}
 */ Table.prototype.encode = function() {
    return (0, _types.encode).TABLE(this);
};
/**
 * Get the size of the table.
 * @return {number}
 */ Table.prototype.sizeOf = function() {
    return (0, _types.sizeOf).TABLE(this);
};
/**
 * @private
 */ function ushortList(itemName, list, count) {
    if (count === undefined) count = list.length;
    const fields = new Array(list.length + 1);
    fields[0] = {
        name: itemName + 'Count',
        type: 'USHORT',
        value: count
    };
    for(let i = 0; i < list.length; i++)fields[i + 1] = {
        name: itemName + i,
        type: 'USHORT',
        value: list[i]
    };
    return fields;
}
/**
 * @private
 */ function tableList(itemName, records, itemCallback) {
    const count = records.length;
    const fields = new Array(count + 1);
    fields[0] = {
        name: itemName + 'Count',
        type: 'USHORT',
        value: count
    };
    for(let i = 0; i < count; i++)fields[i + 1] = {
        name: itemName + i,
        type: 'TABLE',
        value: itemCallback(records[i], i)
    };
    return fields;
}
/**
 * @private
 */ function recordList(itemName, records, itemCallback) {
    const count = records.length;
    let fields = [];
    fields[0] = {
        name: itemName + 'Count',
        type: 'USHORT',
        value: count
    };
    for(let i = 0; i < count; i++)fields = fields.concat(itemCallback(records[i], i));
    return fields;
}
// Common Layout Tables
/**
 * @exports opentype.Coverage
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */ function Coverage(coverageTable) {
    if (coverageTable.format === 1) Table.call(this, 'coverageTable', [
        {
            name: 'coverageFormat',
            type: 'USHORT',
            value: 1
        }
    ].concat(ushortList('glyph', coverageTable.glyphs)));
    else (0, _checkDefault.default).assert(false, 'Can\'t create coverage table format 2 yet.');
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;
function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable', recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
        const script = scriptRecord.script;
        let defaultLangSys = script.defaultLangSys;
        (0, _checkDefault.default).assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
        return [
            {
                name: 'scriptTag' + i,
                type: 'TAG',
                value: scriptRecord.tag
            },
            {
                name: 'script' + i,
                type: 'TABLE',
                value: new Table('scriptTable', [
                    {
                        name: 'defaultLangSys',
                        type: 'TABLE',
                        value: new Table('defaultLangSys', [
                            {
                                name: 'lookupOrder',
                                type: 'USHORT',
                                value: 0
                            },
                            {
                                name: 'reqFeatureIndex',
                                type: 'USHORT',
                                value: defaultLangSys.reqFeatureIndex
                            }
                        ].concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))
                    }
                ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                    const langSys = langSysRecord.langSys;
                    return [
                        {
                            name: 'langSysTag' + i,
                            type: 'TAG',
                            value: langSysRecord.tag
                        },
                        {
                            name: 'langSys' + i,
                            type: 'TABLE',
                            value: new Table('langSys', [
                                {
                                    name: 'lookupOrder',
                                    type: 'USHORT',
                                    value: 0
                                },
                                {
                                    name: 'reqFeatureIndex',
                                    type: 'USHORT',
                                    value: langSys.reqFeatureIndex
                                }
                            ].concat(ushortList('featureIndex', langSys.featureIndexes)))
                        }
                    ];
                })))
            }
        ];
    }));
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;
/**
 * @exports opentype.FeatureList
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */ function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable', recordList('featureRecord', featureListTable, function(featureRecord, i) {
        const feature = featureRecord.feature;
        return [
            {
                name: 'featureTag' + i,
                type: 'TAG',
                value: featureRecord.tag
            },
            {
                name: 'feature' + i,
                type: 'TABLE',
                value: new Table('featureTable', [
                    {
                        name: 'featureParams',
                        type: 'USHORT',
                        value: feature.featureParams
                    }
                ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))
            }
        ];
    }));
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;
/**
 * @exports opentype.LookupList
 * @class
 * @param {opentype.Table}
 * @param {Object}
 * @constructor
 * @extends opentype.Table
 */ function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
        let subtableCallback = subtableMakers[lookupTable.lookupType];
        (0, _checkDefault.default).assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [
            {
                name: 'lookupType',
                type: 'USHORT',
                value: lookupTable.lookupType
            },
            {
                name: 'lookupFlag',
                type: 'USHORT',
                value: lookupTable.lookupFlag
            }
        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;
// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
// Don't use offsets inside Records (probable bug), only in Tables.
exports.default = {
    Table,
    Record: Table,
    Coverage,
    ScriptList,
    FeatureList,
    LookupList,
    ushortList,
    tableList,
    recordList
};

},{"./check":"184gJ","./types":"lc3FJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lc3FJ":[function(require,module,exports,__globalThis) {
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "sizeOf", ()=>sizeOf);
var _check = require("./check");
var _checkDefault = parcelHelpers.interopDefault(_check);
const LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
const LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31
/**
 * @exports opentype.decode
 * @class
 */ const decode = {};
/**
 * @exports opentype.encode
 * @class
 */ const encode = {};
/**
 * @exports opentype.sizeOf
 * @class
 */ const sizeOf = {};
// Return a function that always returns the same value.
function constant(v) {
    return function() {
        return v;
    };
}
// OpenType data types //////////////////////////////////////////////////////
/**
 * Convert an 8-bit unsigned integer to a list of 1 byte.
 * @param {number}
 * @returns {Array}
 */ encode.BYTE = function(v) {
    (0, _checkDefault.default).argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [
        v
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.BYTE = constant(1);
/**
 * Convert a 8-bit signed integer to a list of 1 byte.
 * @param {string}
 * @returns {Array}
 */ encode.CHAR = function(v) {
    return [
        v.charCodeAt(0)
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.CHAR = constant(1);
/**
 * Convert an ASCII string to a list of bytes.
 * @param {string}
 * @returns {Array}
 */ encode.CHARARRAY = function(v) {
    const b = [];
    for(let i = 0; i < v.length; i += 1)b[i] = v.charCodeAt(i);
    return b;
};
/**
 * @param {Array}
 * @returns {number}
 */ sizeOf.CHARARRAY = function(v) {
    return v.length;
};
/**
 * Convert a 16-bit unsigned integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */ encode.USHORT = function(v) {
    return [
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.USHORT = constant(2);
/**
 * Convert a 16-bit signed integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */ encode.SHORT = function(v) {
    // Two's complement
    if (v >= LIMIT16) v = -(2 * LIMIT16 - v);
    return [
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.SHORT = constant(2);
/**
 * Convert a 24-bit unsigned integer to a list of 3 bytes.
 * @param {number}
 * @returns {Array}
 */ encode.UINT24 = function(v) {
    return [
        v >> 16 & 0xFF,
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.UINT24 = constant(3);
/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */ encode.ULONG = function(v) {
    return [
        v >> 24 & 0xFF,
        v >> 16 & 0xFF,
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.ULONG = constant(4);
/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */ encode.LONG = function(v) {
    // Two's complement
    if (v >= LIMIT32) v = -(2 * LIMIT32 - v);
    return [
        v >> 24 & 0xFF,
        v >> 16 & 0xFF,
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.LONG = constant(4);
encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;
encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;
encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;
/**
 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
 * @param {number}
 * @returns {Array}
 */ encode.LONGDATETIME = function(v) {
    return [
        0,
        0,
        0,
        0,
        v >> 24 & 0xFF,
        v >> 16 & 0xFF,
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.LONGDATETIME = constant(8);
/**
 * Convert a 4-char tag to a list of 4 bytes.
 * @param {string}
 * @returns {Array}
 */ encode.TAG = function(v) {
    (0, _checkDefault.default).argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [
        v.charCodeAt(0),
        v.charCodeAt(1),
        v.charCodeAt(2),
        v.charCodeAt(3)
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.TAG = constant(4);
// CFF data types ///////////////////////////////////////////////////////////
encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;
encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;
encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;
encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;
// Convert a numeric operand or charstring number to a variable-size list of bytes.
/**
 * Convert a numeric operand or charstring number to a variable-size list of bytes.
 * @param {number}
 * @returns {Array}
 */ encode.NUMBER = function(v) {
    if (v >= -107 && v <= 107) return [
        v + 139
    ];
    else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [
            (v >> 8) + 247,
            v & 0xFF
        ];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [
            (v >> 8) + 251,
            v & 0xFF
        ];
    } else if (v >= -32768 && v <= 32767) return encode.NUMBER16(v);
    else return encode.NUMBER32(v);
};
/**
 * @param {number}
 * @returns {number}
 */ sizeOf.NUMBER = function(v) {
    return encode.NUMBER(v).length;
};
/**
 * Convert a signed number between -32768 and +32767 to a three-byte value.
 * This ensures we always use three bytes, but is not the most compact format.
 * @param {number}
 * @returns {Array}
 */ encode.NUMBER16 = function(v) {
    return [
        28,
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.NUMBER16 = constant(3);
/**
 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
 * This is useful if you want to be sure you always use four bytes,
 * at the expense of wasting a few bytes for smaller numbers.
 * @param {number}
 * @returns {Array}
 */ encode.NUMBER32 = function(v) {
    return [
        29,
        v >> 24 & 0xFF,
        v >> 16 & 0xFF,
        v >> 8 & 0xFF,
        v & 0xFF
    ];
};
/**
 * @constant
 * @type {number}
 */ sizeOf.NUMBER32 = constant(5);
/**
 * @param {number}
 * @returns {Array}
 */ encode.REAL = function(v) {
    let value = v.toString();
    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    const m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        const epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }
    let nibbles = '';
    for(let i = 0, ii = value.length; i < ii; i += 1){
        const c = value[i];
        if (c === 'e') nibbles += value[++i] === '-' ? 'c' : 'b';
        else if (c === '.') nibbles += 'a';
        else if (c === '-') nibbles += 'e';
        else nibbles += c;
    }
    nibbles += nibbles.length & 1 ? 'f' : 'ff';
    const out = [
        30
    ];
    for(let i = 0, ii = nibbles.length; i < ii; i += 2)out.push(parseInt(nibbles.substr(i, 2), 16));
    return out;
};
/**
 * @param {number}
 * @returns {number}
 */ sizeOf.REAL = function(v) {
    return encode.REAL(v).length;
};
encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;
encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;
/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */ decode.UTF8 = function(data, offset, numBytes) {
    const codePoints = [];
    const numChars = numBytes;
    for(let j = 0; j < numChars; j++, offset += 1)codePoints[j] = data.getUint8(offset);
    return String.fromCharCode.apply(null, codePoints);
};
/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */ decode.UTF16 = function(data, offset, numBytes) {
    const codePoints = [];
    const numChars = numBytes / 2;
    for(let j = 0; j < numChars; j++, offset += 2)codePoints[j] = data.getUint16(offset);
    return String.fromCharCode.apply(null, codePoints);
};
/**
 * Convert a JavaScript string to UTF16-BE.
 * @param {string}
 * @returns {Array}
 */ encode.UTF16 = function(v) {
    const b = [];
    for(let i = 0; i < v.length; i += 1){
        const codepoint = v.charCodeAt(i);
        b[b.length] = codepoint >> 8 & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }
    return b;
};
/**
 * @param {string}
 * @returns {number}
 */ sizeOf.UTF16 = function(v) {
    return v.length * 2;
};
// Data for converting old eight-bit Macintosh encodings to Unicode.
// This representation is optimized for decoding; encoding is slower
// and needs more memory. The assumption is that all opentype.js users
// want to open fonts, but saving a font will be comparatively rare
// so it can be more expensive. Keyed by IANA character set name.
//
// Python script for generating these strings:
//
//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
//     print(s.encode('utf-8'))
/**
 * @private
 */ const eightBitMacEncodings = {
    'x-mac-croatian': "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\u2020\xb0\xa2\xa3\xa7\u2022\xb6\xdf\xae\u0160\u2122\xb4\xa8\u2260\u017D\xd8\u221E\xb1\u2264\u2265\u2206\xb5\u2202\u2211\u220F\u0161\u222B\xaa\xba\u03A9\u017E\xf8\xbf\xa1\xac\u221A\u0192\u2248\u0106\xab\u010C\u2026\xa0\xc0\xc3\xd5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xf7\u25CA\uF8FF\xa9\u2044\u20AC\u2039\u203A\xc6\xbb\u2013\xb7\u201A\u201E\u2030\xc2\u0107\xc1\u010D\xc8\xcd\xce\xcf\xcc\xd3\xd4\u0111\xd2\xda\xdb\xd9\u0131\u02C6\u02DC\xaf\u03C0\xcb\u02DA\xb8\xca\xe6\u02C7",
    'x-mac-cyrillic': "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xb0\u0490\xa3\xa7\u2022\xb6\u0406\xae\xa9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xb1\u2264\u2265\u0456\xb5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xac\u221A\u0192\u2248\u2206\xab\xbb\u2026\xa0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xf7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E",
    'x-mac-gaelic': "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\u2020\xb0\xa2\xa3\xa7\u2022\xb6\xdf\xae\xa9\u2122\xb4\xa8\u2260\xc6\xd8\u1E02\xb1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xe6\xf8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xab\xbb\u2026\xa0\xc0\xc3\xd5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xff\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xb7\u1EF2\u1EF3\u204A\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\u2663\xd2\xda\xdb\xd9\u0131\xdd\xfd\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
    'x-mac-greek': "\xc4\xb9\xb2\xc9\xb3\xd6\xdc\u0385\xe0\xe2\xe4\u0384\xa8\xe7\xe9\xe8\xea\xeb\xa3\u2122\xee\xef\u2022\xbd\u2030\xf4\xf6\xa6\u20AC\xf9\xfb\xfc\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xdf\xae\xa9\u03A3\u03AA\xa7\u2260\xb0\xb7\u0391\xb1\u2264\u2265\xa5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xac\u039F\u03A1\u2248\u03A4\xab\xbb\u2026\xa0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xf7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xad",
    'x-mac-icelandic': "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xdd\xb0\xa2\xa3\xa7\u2022\xb6\xdf\xae\xa9\u2122\xb4\xa8\u2260\xc6\xd8\u221E\xb1\u2264\u2265\xa5\xb5\u2202\u2211\u220F\u03C0\u222B\xaa\xba\u03A9\xe6\xf8\xbf\xa1\xac\u221A\u0192\u2248\u2206\xab\xbb\u2026\xa0\xc0\xc3\xd5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xf7\u25CA\xff\u0178\u2044\u20AC\xd0\xf0\xde\xfe\xfd\xb7\u201A\u201E\u2030\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\uF8FF\xd2\xda\xdb\xd9\u0131\u02C6\u02DC\xaf\u02D8\u02D9\u02DA\xb8\u02DD\u02DB\u02C7",
    'x-mac-inuit': "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xb0\u14A1\u14A5\u14A6\u2022\xb6\u14A7\xae\xa9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xa0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
    'x-mac-ce': "\xc4\u0100\u0101\xc9\u0104\xd6\xdc\xe1\u0105\u010C\xe4\u010D\u0106\u0107\xe9\u0179\u017A\u010E\xed\u010F\u0112\u0113\u0116\xf3\u0117\xf4\xf6\xf5\xfa\u011A\u011B\xfc\u2020\xb0\u0118\xa3\xa7\u2022\xb6\xdf\xae\xa9\u2122\u0119\xa8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xac\u221A\u0144\u0147\u2206\xab\xbb\u2026\xa0\u0148\u0150\xd5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xf7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xc1\u0164\u0165\xcd\u017D\u017E\u016A\xd3\xd4\u016B\u016E\xda\u016F\u0170\u0171\u0172\u0173\xdd\xfd\u0137\u017B\u0141\u017C\u0122\u02C7",
    macintosh: "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\u2020\xb0\xa2\xa3\xa7\u2022\xb6\xdf\xae\xa9\u2122\xb4\xa8\u2260\xc6\xd8\u221E\xb1\u2264\u2265\xa5\xb5\u2202\u2211\u220F\u03C0\u222B\xaa\xba\u03A9\xe6\xf8\xbf\xa1\xac\u221A\u0192\u2248\u2206\xab\xbb\u2026\xa0\xc0\xc3\xd5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xf7\u25CA\xff\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xb7\u201A\u201E\u2030\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\uF8FF\xd2\xda\xdb\xd9\u0131\u02C6\u02DC\xaf\u02D8\u02D9\u02DA\xb8\u02DD\u02DB\u02C7",
    'x-mac-romanian': "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\u2020\xb0\xa2\xa3\xa7\u2022\xb6\xdf\xae\xa9\u2122\xb4\xa8\u2260\u0102\u0218\u221E\xb1\u2264\u2265\xa5\xb5\u2202\u2211\u220F\u03C0\u222B\xaa\xba\u03A9\u0103\u0219\xbf\xa1\xac\u221A\u0192\u2248\u2206\xab\xbb\u2026\xa0\xc0\xc3\xd5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xf7\u25CA\xff\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xb7\u201A\u201E\u2030\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\uF8FF\xd2\xda\xdb\xd9\u0131\u02C6\u02DC\xaf\u02D8\u02D9\u02DA\xb8\u02DD\u02DB\u02C7",
    'x-mac-turkish': "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\u2020\xb0\xa2\xa3\xa7\u2022\xb6\xdf\xae\xa9\u2122\xb4\xa8\u2260\xc6\xd8\u221E\xb1\u2264\u2265\xa5\xb5\u2202\u2211\u220F\u03C0\u222B\xaa\xba\u03A9\xe6\xf8\xbf\xa1\xac\u221A\u0192\u2248\u2206\xab\xbb\u2026\xa0\xc0\xc3\xd5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xf7\u25CA\xff\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xb7\u201A\u201E\u2030\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\uF8FF\xd2\xda\xdb\xd9\uF8A0\u02C6\u02DC\xaf\u02D8\u02D9\u02DA\xb8\u02DD\u02DB\u02C7"
};
/**
 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
 * string, or 'undefined' if the encoding is unsupported. For example, we do
 * not support Chinese, Japanese or Korean because these would need large
 * mapping tables.
 * @param {DataView} dataView
 * @param {number} offset
 * @param {number} dataLength
 * @param {string} encoding
 * @returns {string}
 */ decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
    const table = eightBitMacEncodings[encoding];
    if (table === undefined) return undefined;
    let result = '';
    for(let i = 0; i < dataLength; i++){
        const c = dataView.getUint8(offset + i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c <= 0x7F) result += String.fromCharCode(c);
        else result += table[c & 0x7F];
    }
    return result;
};
// Helper function for encode.MACSTRING. Returns a dictionary for mapping
// Unicode character codes to their 8-bit MacOS equivalent. This table
// is not exactly a super cheap data structure, but we do not care because
// encoding Macintosh strings is only rarely needed in typical applications.
const macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
let macEncodingCacheKeys;
const getMacEncodingTable = function(encoding) {
    // Since we use encoding as a cache key for WeakMap, it has to be
    // a String object and not a literal. And at least on NodeJS 2.10.1,
    // WeakMap requires that the same String instance is passed for cache hits.
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for(let e in eightBitMacEncodings)/*jshint -W053 */ // Suppress "Do not use String as a constructor."
        macEncodingCacheKeys[e] = new String(e);
    }
    const cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) return undefined;
    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
    // since garbage collection may run at any time, it could also kick in
    // between the calls to cache.has() and cache.get(). In that case,
    // we would return 'undefined' even though we do support the encoding.
    if (macEncodingTableCache) {
        const cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) return cachedTable;
    }
    const decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) return undefined;
    const encodingTable = {};
    for(let i = 0; i < decodingTable.length; i++)encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    if (macEncodingTableCache) macEncodingTableCache.set(cacheKey, encodingTable);
    return encodingTable;
};
/**
 * Encodes an old-style Macintosh string. Returns a byte array upon success.
 * If the requested encoding is unsupported, or if the input string contains
 * a character that cannot be expressed in the encoding, the function returns
 * 'undefined'.
 * @param {string} str
 * @param {string} encoding
 * @returns {Array}
 */ encode.MACSTRING = function(str, encoding) {
    const table = getMacEncodingTable(encoding);
    if (table === undefined) return undefined;
    const result = [];
    for(let i = 0; i < str.length; i++){
        let c = str.charCodeAt(i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) // str contains a Unicode character that cannot be encoded
            // in the requested encoding.
            return undefined;
        }
        result[i] = c;
    // result.push(c);
    }
    return result;
};
/**
 * @param {string} str
 * @param {string} encoding
 * @returns {number}
 */ sizeOf.MACSTRING = function(str, encoding) {
    const b = encode.MACSTRING(str, encoding);
    if (b !== undefined) return b.length;
    else return 0;
};
// Helper for encode.VARDELTAS
function isByteEncodable(value) {
    return value >= -128 && value <= 127;
}
// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
    let runLength = 0;
    const numDeltas = deltas.length;
    while(pos < numDeltas && runLength < 64 && deltas[pos] === 0){
        ++pos;
        ++runLength;
    }
    result.push(0x80 | runLength - 1);
    return pos;
}
// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
    let runLength = 0;
    const numDeltas = deltas.length;
    let pos = offset;
    while(pos < numDeltas && runLength < 64){
        const value = deltas[pos];
        if (!isByteEncodable(value)) break;
        // Within a byte-encoded run of deltas, a single zero is best
        // stored literally as 0x00 value. However, if we have two or
        // more zeroes in a sequence, it is better to start a new run.
        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
        // when starting a new run.
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) break;
        ++pos;
        ++runLength;
    }
    result.push(runLength - 1);
    for(let i = offset; i < pos; ++i)result.push(deltas[i] + 256 & 0xff);
    return pos;
}
// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsWords(deltas, offset, result) {
    let runLength = 0;
    const numDeltas = deltas.length;
    let pos = offset;
    while(pos < numDeltas && runLength < 64){
        const value = deltas[pos];
        // Within a word-encoded run of deltas, it is easiest to start
        // a new run (with a different encoding) whenever we encounter
        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
        // needs 7 bytes when storing the zero inside the current run
        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
        // new run (40 66 66 80 40 77 77).
        if (value === 0) break;
        // Within a word-encoded run of deltas, a single value in the
        // range (-128..127) should be encoded within the current run
        // because it is more compact. For example, the sequence
        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
        // a new run (40 66 66 00 02 40 77 77).
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) break;
        ++pos;
        ++runLength;
    }
    result.push(0x40 | runLength - 1);
    for(let i = offset; i < pos; ++i){
        const val = deltas[i];
        result.push(val + 0x10000 >> 8 & 0xff, val + 0x100 & 0xff);
    }
    return pos;
}
/**
 * Encode a list of variation adjustment deltas.
 *
 * Variation adjustment deltas are used in gvar and cvar tables.
 * They indicate how points (in gvar) or values (in cvar) get adjusted
 * when generating instances of variation fonts.
 *
 * @see https://www.microsoft.com/typography/otspec/gvar.htm
 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
 * @param {Array}
 * @return {Array}
 */ encode.VARDELTAS = function(deltas) {
    let pos = 0;
    const result = [];
    while(pos < deltas.length){
        const value = deltas[pos];
        if (value === 0) pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        else if (value >= -128 && value <= 127) pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        else pos = encodeVarDeltaRunAsWords(deltas, pos, result);
    }
    return result;
};
// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
/**
 * @param {Array} l
 * @returns {Array}
 */ encode.INDEX = function(l) {
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offsets, then again to encode the offsets using the fitting data type.
    let offset = 1; // First offset is always 1.
    const offsets = [
        offset
    ];
    const data = [];
    for(let i = 0; i < l.length; i += 1){
        const v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }
    if (data.length === 0) return [
        0,
        0
    ];
    const encodedOffsets = [];
    const offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
    const offsetEncoder = [
        undefined,
        encode.BYTE,
        encode.USHORT,
        encode.UINT24,
        encode.ULONG
    ][offSize];
    for(let i = 0; i < offsets.length; i += 1){
        const encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }
    return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data);
};
/**
 * @param {Array}
 * @returns {number}
 */ sizeOf.INDEX = function(v) {
    return encode.INDEX(v).length;
};
/**
 * Convert an object to a CFF DICT structure.
 * The keys should be numeric.
 * The values should be objects containing name / type / value.
 * @param {Object} m
 * @returns {Array}
 */ encode.DICT = function(m) {
    let d = [];
    const keys = Object.keys(m);
    const length = keys.length;
    for(let i = 0; i < length; i += 1){
        // Object.keys() return string keys, but our keys are always numeric.
        const k = parseInt(keys[i], 0);
        const v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }
    return d;
};
/**
 * @param {Object}
 * @returns {number}
 */ sizeOf.DICT = function(m) {
    return encode.DICT(m).length;
};
/**
 * @param {number}
 * @returns {Array}
 */ encode.OPERATOR = function(v) {
    if (v < 1200) return [
        v
    ];
    else return [
        12,
        v - 1200
    ];
};
/**
 * @param {Array} v
 * @param {string}
 * @returns {Array}
 */ encode.OPERAND = function(v, type) {
    let d = [];
    if (Array.isArray(type)) for(let i = 0; i < type.length; i += 1){
        (0, _checkDefault.default).argument(v.length === type.length, 'Not enough arguments given for type' + type);
        d = d.concat(encode.OPERAND(v[i], type[i]));
    }
    else {
        if (type === 'SID') d = d.concat(encode.NUMBER(v));
        else if (type === 'offset') // We make it easy for ourselves and always encode offsets as
        // 4 bytes. This makes offset calculation for the top dict easier.
        d = d.concat(encode.NUMBER32(v));
        else if (type === 'number') d = d.concat(encode.NUMBER(v));
        else if (type === 'real') d = d.concat(encode.REAL(v));
        else throw new Error('Unknown operand type ' + type);
    }
    return d;
};
encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;
// memoize charstring encoding using WeakMap if available
const wmm = typeof WeakMap === 'function' && new WeakMap();
/**
 * Convert a list of CharString operations to bytes.
 * @param {Array}
 * @returns {Array}
 */ encode.CHARSTRING = function(ops) {
    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
    if (wmm) {
        const cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) return cachedValue;
    }
    let d = [];
    const length = ops.length;
    for(let i = 0; i < length; i += 1){
        const op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }
    if (wmm) wmm.set(ops, d);
    return d;
};
/**
 * @param {Array}
 * @returns {number}
 */ sizeOf.CHARSTRING = function(ops) {
    return encode.CHARSTRING(ops).length;
};
// Utility functions ////////////////////////////////////////////////////////
/**
 * Convert an object containing name / type / value to bytes.
 * @param {Object}
 * @returns {Array}
 */ encode.OBJECT = function(v) {
    const encodingFunction = encode[v.type];
    (0, _checkDefault.default).argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};
/**
 * @param {Object}
 * @returns {number}
 */ sizeOf.OBJECT = function(v) {
    const sizeOfFunction = sizeOf[v.type];
    (0, _checkDefault.default).argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};
/**
 * Convert a table object to bytes.
 * A table contains a list of fields containing the metadata (name, type and default value).
 * The table itself has the field values set as attributes.
 * @param {opentype.Table}
 * @returns {Array}
 */ encode.TABLE = function(table) {
    let d = [];
    const length = table.fields.length;
    const subtables = [];
    const subtableOffsets = [];
    for(let i = 0; i < length; i += 1){
        const field = table.fields[i];
        const encodingFunction = encode[field.type];
        (0, _checkDefault.default).argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        let value = table[field.name];
        if (value === undefined) value = field.value;
        const bytes = encodingFunction(value);
        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([
                0,
                0
            ]);
            subtables.push(bytes);
        } else d = d.concat(bytes);
    }
    for(let i = 0; i < subtables.length; i += 1){
        const o = subtableOffsets[i];
        const offset = d.length;
        (0, _checkDefault.default).argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[i]);
    }
    return d;
};
/**
 * @param {opentype.Table}
 * @returns {number}
 */ sizeOf.TABLE = function(table) {
    let numBytes = 0;
    const length = table.fields.length;
    for(let i = 0; i < length; i += 1){
        const field = table.fields[i];
        const sizeOfFunction = sizeOf[field.type];
        (0, _checkDefault.default).argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        let value = table[field.name];
        if (value === undefined) value = field.value;
        numBytes += sizeOfFunction(value);
        // Subtables take 2 more bytes for offsets.
        if (field.type === 'TABLE') numBytes += 2;
    }
    return numBytes;
};
encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;
// Merge in a list of bytes.
encode.LITERAL = function(v) {
    return v;
};
sizeOf.LITERAL = function(v) {
    return v.length;
};

},{"./check":"184gJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j8yze":[function(require,module,exports,__globalThis) {
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
function parseCmapTableFormat12(cmap, p) {
    //Skip reserved.
    p.parseUShort();
    // Length in bytes of the sub-tables.
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();
    let groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};
    for(let i = 0; i < groupCount; i += 1){
        const startCharCode = p.parseULong();
        const endCharCode = p.parseULong();
        let startGlyphId = p.parseULong();
        for(let c = startCharCode; c <= endCharCode; c += 1){
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
}
function parseCmapTableFormat4(cmap, p, data, start, offset) {
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    // segCount is stored x 2.
    let segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};
    const endCountParser = new (0, _parseDefault.default).Parser(data, start + offset + 14);
    const startCountParser = new (0, _parseDefault.default).Parser(data, start + offset + 16 + segCount * 2);
    const idDeltaParser = new (0, _parseDefault.default).Parser(data, start + offset + 16 + segCount * 4);
    const idRangeOffsetParser = new (0, _parseDefault.default).Parser(data, start + offset + 16 + segCount * 6);
    let glyphIndexOffset = start + offset + 16 + segCount * 8;
    for(let i = 0; i < segCount - 1; i += 1){
        let glyphIndex;
        const endCount = endCountParser.parseUShort();
        const startCount = startCountParser.parseUShort();
        const idDelta = idDeltaParser.parseShort();
        const idRangeOffset = idRangeOffsetParser.parseUShort();
        for(let c = startCount; c <= endCount; c += 1){
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;
                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = (0, _parseDefault.default).getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) glyphIndex = glyphIndex + idDelta & 0xFFFF;
            } else glyphIndex = c + idDelta & 0xFFFF;
            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}
// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4 and 12.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    const cmap = {};
    cmap.version = (0, _parseDefault.default).getUShort(data, start);
    (0, _checkDefault.default).argument(cmap.version === 0, 'cmap table version should be 0.');
    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
    cmap.numTables = (0, _parseDefault.default).getUShort(data, start + 2);
    let offset = -1;
    for(let i = cmap.numTables - 1; i >= 0; i -= 1){
        const platformId = (0, _parseDefault.default).getUShort(data, start + 4 + i * 8);
        const encodingId = (0, _parseDefault.default).getUShort(data, start + 4 + i * 8 + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {
            offset = (0, _parseDefault.default).getULong(data, start + 4 + i * 8 + 4);
            break;
        }
    }
    if (offset === -1) // There is no cmap table in the font that we support.
    throw new Error('No valid cmap sub-tables found.');
    const p = new (0, _parseDefault.default).Parser(data, start + offset);
    cmap.format = p.parseUShort();
    if (cmap.format === 12) parseCmapTableFormat12(cmap, p);
    else if (cmap.format === 4) parseCmapTableFormat4(cmap, p, data, start, offset);
    else throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
    return cmap;
}
function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0,
        glyphIndex: glyphIndex
    });
}
function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}
// Make cmap table, format 4 by default, 12 if needed only
function makeCmapTable(glyphs) {
    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
    let isPlan0Only = true;
    let i;
    // Check if we need to add cmap format 12 or if format 4 only is fine
    for(i = glyphs.length - 1; i > 0; i -= 1){
        const g = glyphs.get(i);
        if (g.unicode > 65535) {
            console.log('Adding CMAP format 12 (needed!)');
            isPlan0Only = false;
            break;
        }
    }
    let cmapTable = [
        {
            name: 'version',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'numTables',
            type: 'USHORT',
            value: isPlan0Only ? 1 : 2
        },
        // CMAP 4 header
        {
            name: 'platformID',
            type: 'USHORT',
            value: 3
        },
        {
            name: 'encodingID',
            type: 'USHORT',
            value: 1
        },
        {
            name: 'offset',
            type: 'ULONG',
            value: isPlan0Only ? 12 : 20
        }
    ];
    if (!isPlan0Only) cmapTable = cmapTable.concat([
        // CMAP 12 header
        {
            name: 'cmap12PlatformID',
            type: 'USHORT',
            value: 3
        },
        {
            name: 'cmap12EncodingID',
            type: 'USHORT',
            value: 10
        },
        {
            name: 'cmap12Offset',
            type: 'ULONG',
            value: 0
        }
    ]);
    cmapTable = cmapTable.concat([
        // CMAP 4 Subtable
        {
            name: 'format',
            type: 'USHORT',
            value: 4
        },
        {
            name: 'cmap4Length',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'language',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'segCountX2',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'searchRange',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'entrySelector',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'rangeShift',
            type: 'USHORT',
            value: 0
        }
    ]);
    const t = new (0, _tableDefault.default).Table('cmap', cmapTable);
    t.segments = [];
    for(i = 0; i < glyphs.length; i += 1){
        const glyph = glyphs.get(i);
        for(let j = 0; j < glyph.unicodes.length; j += 1)addSegment(t, glyph.unicodes[j], i);
        t.segments = t.segments.sort(function(a, b) {
            return a.start - b.start;
        });
    }
    addTerminatorSegment(t);
    const segCount = t.segments.length;
    let segCountToRemove = 0;
    // CMAP 4
    // Set up parallel segment arrays.
    let endCounts = [];
    let startCounts = [];
    let idDeltas = [];
    let idRangeOffsets = [];
    let glyphIds = [];
    // CMAP 12
    let cmap12Groups = [];
    // Reminder this loop is not following the specification at 100%
    // The specification -> find suites of characters and make a group
    // Here we're doing one group for each letter
    // Doing as the spec can save 8 times (or more) space
    for(i = 0; i < segCount; i += 1){
        const segment = t.segments[i];
        // CMAP 4
        if (segment.end <= 65535 && segment.start <= 65535) {
            endCounts = endCounts.concat({
                name: 'end_' + i,
                type: 'USHORT',
                value: segment.end
            });
            startCounts = startCounts.concat({
                name: 'start_' + i,
                type: 'USHORT',
                value: segment.start
            });
            idDeltas = idDeltas.concat({
                name: 'idDelta_' + i,
                type: 'SHORT',
                value: segment.delta
            });
            idRangeOffsets = idRangeOffsets.concat({
                name: 'idRangeOffset_' + i,
                type: 'USHORT',
                value: segment.offset
            });
            if (segment.glyphId !== undefined) glyphIds = glyphIds.concat({
                name: 'glyph_' + i,
                type: 'USHORT',
                value: segment.glyphId
            });
        } else // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
        segCountToRemove += 1;
        // CMAP 12
        // Skip Terminator Segment
        if (!isPlan0Only && segment.glyphIndex !== undefined) {
            cmap12Groups = cmap12Groups.concat({
                name: 'cmap12Start_' + i,
                type: 'ULONG',
                value: segment.start
            });
            cmap12Groups = cmap12Groups.concat({
                name: 'cmap12End_' + i,
                type: 'ULONG',
                value: segment.end
            });
            cmap12Groups = cmap12Groups.concat({
                name: 'cmap12Glyph_' + i,
                type: 'ULONG',
                value: segment.glyphIndex
            });
        }
    }
    // CMAP 4 Subtable
    t.segCountX2 = (segCount - segCountToRemove) * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;
    t.fields = t.fields.concat(endCounts);
    t.fields.push({
        name: 'reservedPad',
        type: 'USHORT',
        value: 0
    });
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);
    t.cmap4Length = 14 + // Subtable header
    endCounts.length * 2 + 2 + // reservedPad
    startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
    if (!isPlan0Only) {
        // CMAP 12 Subtable
        const cmap12Length = 16 + // Subtable header
        cmap12Groups.length * 4;
        t.cmap12Offset = 20 + t.cmap4Length;
        t.fields = t.fields.concat([
            {
                name: 'cmap12Format',
                type: 'USHORT',
                value: 12
            },
            {
                name: 'cmap12Reserved',
                type: 'USHORT',
                value: 0
            },
            {
                name: 'cmap12Length',
                type: 'ULONG',
                value: cmap12Length
            },
            {
                name: 'cmap12Language',
                type: 'ULONG',
                value: 0
            },
            {
                name: 'cmap12nGroups',
                type: 'ULONG',
                value: cmap12Groups.length / 3
            }
        ]);
        t.fields = t.fields.concat(cmap12Groups);
    }
    return t;
}
exports.default = {
    parse: parseCmapTable,
    make: makeCmapTable
};

},{"../check":"184gJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8RdJX":[function(require,module,exports,__globalThis) {
// Parsing utility functions
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Parser", ()=>Parser);
var _check = require("./check");
var _checkDefault = parcelHelpers.interopDefault(_check);
// Retrieve an unsigned byte from the DataView.
function getByte(dataView, offset) {
    return dataView.getUint8(offset);
}
// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}
// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
function getShort(dataView, offset) {
    return dataView.getInt16(offset, false);
}
// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
}
// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
function getFixed(dataView, offset) {
    const decimal = dataView.getInt16(offset, false);
    const fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
}
// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
function getTag(dataView, offset) {
    let tag = '';
    for(let i = offset; i < offset + 4; i += 1)tag += String.fromCharCode(dataView.getInt8(i));
    return tag;
}
// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
function getOffset(dataView, offset, offSize) {
    let v = 0;
    for(let i = 0; i < offSize; i += 1){
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }
    return v;
}
// Retrieve a number of bytes from start offset to the end offset from the DataView.
function getBytes(dataView, startOffset, endOffset) {
    const bytes = [];
    for(let i = startOffset; i < endOffset; i += 1)bytes.push(dataView.getUint8(i));
    return bytes;
}
// Convert the list of bytes to a string.
function bytesToString(bytes) {
    let s = '';
    for(let i = 0; i < bytes.length; i += 1)s += String.fromCharCode(bytes[i]);
    return s;
}
const typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};
// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}
Parser.prototype.parseByte = function() {
    const v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};
Parser.prototype.parseChar = function() {
    const v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};
Parser.prototype.parseCard8 = Parser.prototype.parseByte;
Parser.prototype.parseUShort = function() {
    const v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
Parser.prototype.parseShort = function() {
    const v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseF2Dot14 = function() {
    const v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseULong = function() {
    const v = getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};
Parser.prototype.parseOffset32 = Parser.prototype.parseULong;
Parser.prototype.parseFixed = function() {
    const v = getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};
Parser.prototype.parseString = function(length) {
    const dataView = this.data;
    const offset = this.offset + this.relativeOffset;
    let string = '';
    this.relativeOffset += length;
    for(let i = 0; i < length; i++)string += String.fromCharCode(dataView.getUint8(offset + i));
    return string;
};
Parser.prototype.parseTag = function() {
    return this.parseString(4);
};
// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
// + Since until 2038 those bits will be filled by zeros we can ignore them.
Parser.prototype.parseLongDateTime = function() {
    let v = getULong(this.data, this.offset + this.relativeOffset + 4);
    // Subtract seconds between 01/01/1904 and 01/01/1970
    // to convert Apple Mac timestamp to Standard Unix timestamp
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};
Parser.prototype.parseVersion = function(minorBase) {
    const major = getUShort(this.data, this.offset + this.relativeOffset);
    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // Default returns the correct number if minor = 0xN000 where N is 0-9
    // Set minorBase to 1 for tables that use minor = N where N is 0-9
    const minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    if (minorBase === undefined) minorBase = 0x1000;
    return major + minor / minorBase / 10;
};
Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) amount = 1;
    this.relativeOffset += typeOffsets[type] * amount;
};
///// Parsing lists and records ///////////////////////////////
// Parse a list of 32 bit unsigned integers.
Parser.prototype.parseULongList = function(count) {
    if (count === undefined) count = this.parseULong();
    const offsets = new Array(count);
    const dataView = this.data;
    let offset = this.offset + this.relativeOffset;
    for(let i = 0; i < count; i++){
        offsets[i] = dataView.getUint32(offset);
        offset += 4;
    }
    this.relativeOffset += count * 4;
    return offsets;
};
// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
// or provided as an argument.
Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function(count) {
    if (count === undefined) count = this.parseUShort();
    const offsets = new Array(count);
    const dataView = this.data;
    let offset = this.offset + this.relativeOffset;
    for(let i = 0; i < count; i++){
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return offsets;
};
// Parses a list of 16 bit signed integers.
Parser.prototype.parseShortList = function(count) {
    const list = new Array(count);
    const dataView = this.data;
    let offset = this.offset + this.relativeOffset;
    for(let i = 0; i < count; i++){
        list[i] = dataView.getInt16(offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return list;
};
// Parses a list of bytes.
Parser.prototype.parseByteList = function(count) {
    const list = new Array(count);
    const dataView = this.data;
    let offset = this.offset + this.relativeOffset;
    for(let i = 0; i < count; i++)list[i] = dataView.getUint8(offset++);
    this.relativeOffset += count;
    return list;
};
/**
 * Parse a list of items.
 * Record count is optional, if omitted it is read from the stream.
 * itemCallback is one of the Parser methods.
 */ Parser.prototype.parseList = function(count, itemCallback) {
    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    const list = new Array(count);
    for(let i = 0; i < count; i++)list[i] = itemCallback.call(this);
    return list;
};
Parser.prototype.parseList32 = function(count, itemCallback) {
    if (!itemCallback) {
        itemCallback = count;
        count = this.parseULong();
    }
    const list = new Array(count);
    for(let i = 0; i < count; i++)list[i] = itemCallback.call(this);
    return list;
};
/**
 * Parse a list of records.
 * Record count is optional, if omitted it is read from the stream.
 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
 */ Parser.prototype.parseRecordList = function(count, recordDescription) {
    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    const records = new Array(count);
    const fields = Object.keys(recordDescription);
    for(let i = 0; i < count; i++){
        const rec = {};
        for(let j = 0; j < fields.length; j++){
            const fieldName = fields[j];
            const fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this);
        }
        records[i] = rec;
    }
    return records;
};
Parser.prototype.parseRecordList32 = function(count, recordDescription) {
    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseULong();
    }
    const records = new Array(count);
    const fields = Object.keys(recordDescription);
    for(let i = 0; i < count; i++){
        const rec = {};
        for(let j = 0; j < fields.length; j++){
            const fieldName = fields[j];
            const fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this);
        }
        records[i] = rec;
    }
    return records;
};
// Parse a data structure into an object
// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
Parser.prototype.parseStruct = function(description) {
    if (typeof description === 'function') return description.call(this);
    else {
        const fields = Object.keys(description);
        const struct = {};
        for(let j = 0; j < fields.length; j++){
            const fieldName = fields[j];
            const fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this);
        }
        return struct;
    }
};
/**
 * Parse a GPOS valueRecord
 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
 * valueFormat is optional, if omitted it is read from the stream.
 */ Parser.prototype.parseValueRecord = function(valueFormat) {
    if (valueFormat === undefined) valueFormat = this.parseUShort();
    if (valueFormat === 0) // valueFormat2 in kerning pairs is most often 0
    // in this case return undefined instead of an empty object, to save space
    return;
    const valueRecord = {};
    if (valueFormat & 0x0001) valueRecord.xPlacement = this.parseShort();
    if (valueFormat & 0x0002) valueRecord.yPlacement = this.parseShort();
    if (valueFormat & 0x0004) valueRecord.xAdvance = this.parseShort();
    if (valueFormat & 0x0008) valueRecord.yAdvance = this.parseShort();
    // Device table (non-variable font) / VariationIndex table (variable font) not supported
    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
    if (valueFormat & 0x0010) {
        valueRecord.xPlaDevice = undefined;
        this.parseShort();
    }
    if (valueFormat & 0x0020) {
        valueRecord.yPlaDevice = undefined;
        this.parseShort();
    }
    if (valueFormat & 0x0040) {
        valueRecord.xAdvDevice = undefined;
        this.parseShort();
    }
    if (valueFormat & 0x0080) {
        valueRecord.yAdvDevice = undefined;
        this.parseShort();
    }
    return valueRecord;
};
/**
 * Parse a list of GPOS valueRecords
 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
 * valueFormat and valueCount are read from the stream.
 */ Parser.prototype.parseValueRecordList = function() {
    const valueFormat = this.parseUShort();
    const valueCount = this.parseUShort();
    const values = new Array(valueCount);
    for(let i = 0; i < valueCount; i++)values[i] = this.parseValueRecord(valueFormat);
    return values;
};
Parser.prototype.parsePointer = function(description) {
    const structOffset = this.parseOffset16();
    if (structOffset > 0) // NULL offset => return undefined
    return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    return undefined;
};
Parser.prototype.parsePointer32 = function(description) {
    const structOffset = this.parseOffset32();
    if (structOffset > 0) // NULL offset => return undefined
    return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    return undefined;
};
/**
 * Parse a list of offsets to lists of 16-bit integers,
 * or a list of offsets to lists of offsets to any kind of items.
 * If itemCallback is not provided, a list of list of UShort is assumed.
 * If provided, itemCallback is called on each item and must parse the item.
 * See examples in tables/gsub.js
 */ Parser.prototype.parseListOfLists = function(itemCallback) {
    const offsets = this.parseOffset16List();
    const count = offsets.length;
    const relativeOffset = this.relativeOffset;
    const list = new Array(count);
    for(let i = 0; i < count; i++){
        const start = offsets[i];
        if (start === 0) {
            // NULL offset
            // Add i as owned property to list. Convenient with assert.
            list[i] = undefined;
            continue;
        }
        this.relativeOffset = start;
        if (itemCallback) {
            const subOffsets = this.parseOffset16List();
            const subList = new Array(subOffsets.length);
            for(let j = 0; j < subOffsets.length; j++){
                this.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this);
            }
            list[i] = subList;
        } else list[i] = this.parseUShortList();
    }
    this.relativeOffset = relativeOffset;
    return list;
};
///// Complex tables parsing //////////////////////////////////
// Parse a coverage table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
// parser.offset must point to the start of the table containing the coverage.
Parser.prototype.parseCoverage = function() {
    const startOffset = this.offset + this.relativeOffset;
    const format = this.parseUShort();
    const count = this.parseUShort();
    if (format === 1) return {
        format: 1,
        glyphs: this.parseUShortList(count)
    };
    else if (format === 2) {
        const ranges = new Array(count);
        for(let i = 0; i < count; i++)ranges[i] = {
            start: this.parseUShort(),
            end: this.parseUShort(),
            index: this.parseUShort()
        };
        return {
            format: 2,
            ranges: ranges
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};
// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
Parser.prototype.parseClassDef = function() {
    const startOffset = this.offset + this.relativeOffset;
    const format = this.parseUShort();
    if (format === 1) return {
        format: 1,
        startGlyph: this.parseUShort(),
        classes: this.parseUShortList()
    };
    else if (format === 2) return {
        format: 2,
        ranges: this.parseRecordList({
            start: Parser.uShort,
            end: Parser.uShort,
            classId: Parser.uShort
        })
    };
    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};
///// Static methods ///////////////////////////////////
// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.
Parser.list = function(count, itemCallback) {
    return function() {
        return this.parseList(count, itemCallback);
    };
};
Parser.list32 = function(count, itemCallback) {
    return function() {
        return this.parseList32(count, itemCallback);
    };
};
Parser.recordList = function(count, recordDescription) {
    return function() {
        return this.parseRecordList(count, recordDescription);
    };
};
Parser.recordList32 = function(count, recordDescription) {
    return function() {
        return this.parseRecordList32(count, recordDescription);
    };
};
Parser.pointer = function(description) {
    return function() {
        return this.parsePointer(description);
    };
};
Parser.pointer32 = function(description) {
    return function() {
        return this.parsePointer32(description);
    };
};
Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
Parser.uLongList = Parser.prototype.parseULongList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;
///// Script, Feature, Lookup lists ///////////////////////////////////////////////
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
const langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};
Parser.prototype.parseScriptList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    })) || [];
};
Parser.prototype.parseFeatureList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    })) || [];
};
Parser.prototype.parseLookupList = function(lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function() {
        const lookupType = this.parseUShort();
        (0, _checkDefault.default).argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
        const lookupFlag = this.parseUShort();
        const useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    }))) || [];
};
Parser.prototype.parseFeatureVariationsList = function() {
    return this.parsePointer32(function() {
        const majorVersion = this.parseUShort();
        const minorVersion = this.parseUShort();
        (0, _checkDefault.default).argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
        const featureVariations = this.parseRecordList32({
            conditionSetOffset: Parser.offset32,
            featureTableSubstitutionOffset: Parser.offset32
        });
        return featureVariations;
    }) || [];
};
exports.default = {
    getByte,
    getCard8: getByte,
    getUShort,
    getCard16: getUShort,
    getShort,
    getULong,
    getFixed,
    getTag,
    getOffset,
    getBytes,
    bytesToString,
    Parser
};

},{"./check":"184gJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b7PSm":[function(require,module,exports,__globalThis) {
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _encoding = require("../encoding");
var _glyphset = require("../glyphset");
var _glyphsetDefault = parcelHelpers.interopDefault(_glyphset);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _path = require("../path");
var _pathDefault = parcelHelpers.interopDefault(_path);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) return true;
    else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length; i += 1){
            if (!equals(a[i], b[i])) return false;
        }
        return true;
    } else return false;
}
// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    let bias;
    if (subrs.length < 1240) bias = 107;
    else if (subrs.length < 33900) bias = 1131;
    else bias = 32768;
    return bias;
}
// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    const offsets = [];
    const objects = [];
    const count = (0, _parseDefault.default).getCard16(data, start);
    let objectOffset;
    let endOffset;
    if (count !== 0) {
        const offsetSize = (0, _parseDefault.default).getByte(data, start + 2);
        objectOffset = start + (count + 1) * offsetSize + 2;
        let pos = start + 3;
        for(let i = 0; i < count + 1; i += 1){
            offsets.push((0, _parseDefault.default).getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else endOffset = start + 2;
    for(let i = 0; i < offsets.length - 1; i += 1){
        let value = (0, _parseDefault.default).getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) value = conversionFn(value);
        objects.push(value);
    }
    return {
        objects: objects,
        startOffset: start,
        endOffset: endOffset
    };
}
// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    let s = '';
    const eof = 15;
    const lookup = [
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        '.',
        'E',
        'E-',
        null,
        '-'
    ];
    while(true){
        const b = parser.parseByte();
        const n1 = b >> 4;
        const n2 = b & 15;
        if (n1 === eof) break;
        s += lookup[n1];
        if (n2 === eof) break;
        s += lookup[n2];
    }
    return parseFloat(s);
}
// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    let b1;
    let b2;
    let b3;
    let b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }
    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }
    if (b0 === 30) return parseFloatOperand(parser);
    if (b0 >= 32 && b0 <= 246) return b0 - 139;
    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }
    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }
    throw new Error('Invalid b0 ' + b0);
}
// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    const o = {};
    for(let i = 0; i < entries.length; i += 1){
        const key = entries[i][0];
        const values = entries[i][1];
        let value;
        if (values.length === 1) value = values[0];
        else value = values;
        if (o.hasOwnProperty(key) && !isNaN(o[key])) throw new Error('Object ' + o + ' already has key ' + key);
        o[key] = value;
    }
    return o;
}
// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    const parser = new (0, _parseDefault.default).Parser(data, start);
    const entries = [];
    let operands = [];
    size = size !== undefined ? size : data.length;
    while(parser.relativeOffset < size){
        let op = parser.parseByte();
        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) op = 1200 + parser.parseByte();
            entries.push([
                op,
                operands
            ]);
            operands = [];
        } else // Since the operands (values) come before the operators (keys), we store all operands in a list
        // until we encounter an operator.
        operands.push(parseOperand(parser, op));
    }
    return entriesToObject(entries);
}
// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) index = (0, _encoding.cffStandardStrings)[index];
    else index = strings[index - 391];
    return index;
}
// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    const newDict = {};
    let value;
    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for(let i = 0; i < meta.length; i += 1){
        const m = meta[i];
        if (Array.isArray(m.type)) {
            const values = [];
            values.length = m.type.length;
            for(let j = 0; j < m.type.length; j++){
                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                if (value === undefined) value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                if (m.type[j] === 'SID') value = getCFFString(strings, value);
                values[j] = value;
            }
            newDict[m.name] = values;
        } else {
            value = dict[m.op];
            if (value === undefined) value = m.value !== undefined ? m.value : null;
            if (m.type === 'SID') value = getCFFString(strings, value);
            newDict[m.name] = value;
        }
    }
    return newDict;
}
// Parse the CFF header.
function parseCFFHeader(data, start) {
    const header = {};
    header.formatMajor = (0, _parseDefault.default).getCard8(data, start);
    header.formatMinor = (0, _parseDefault.default).getCard8(data, start + 1);
    header.size = (0, _parseDefault.default).getCard8(data, start + 2);
    header.offsetSize = (0, _parseDefault.default).getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}
const TOP_DICT_META = [
    {
        name: 'version',
        op: 0,
        type: 'SID'
    },
    {
        name: 'notice',
        op: 1,
        type: 'SID'
    },
    {
        name: 'copyright',
        op: 1200,
        type: 'SID'
    },
    {
        name: 'fullName',
        op: 2,
        type: 'SID'
    },
    {
        name: 'familyName',
        op: 3,
        type: 'SID'
    },
    {
        name: 'weight',
        op: 4,
        type: 'SID'
    },
    {
        name: 'isFixedPitch',
        op: 1201,
        type: 'number',
        value: 0
    },
    {
        name: 'italicAngle',
        op: 1202,
        type: 'number',
        value: 0
    },
    {
        name: 'underlinePosition',
        op: 1203,
        type: 'number',
        value: -100
    },
    {
        name: 'underlineThickness',
        op: 1204,
        type: 'number',
        value: 50
    },
    {
        name: 'paintType',
        op: 1205,
        type: 'number',
        value: 0
    },
    {
        name: 'charstringType',
        op: 1206,
        type: 'number',
        value: 2
    },
    {
        name: 'fontMatrix',
        op: 1207,
        type: [
            'real',
            'real',
            'real',
            'real',
            'real',
            'real'
        ],
        value: [
            0.001,
            0,
            0,
            0.001,
            0,
            0
        ]
    },
    {
        name: 'uniqueId',
        op: 13,
        type: 'number'
    },
    {
        name: 'fontBBox',
        op: 5,
        type: [
            'number',
            'number',
            'number',
            'number'
        ],
        value: [
            0,
            0,
            0,
            0
        ]
    },
    {
        name: 'strokeWidth',
        op: 1208,
        type: 'number',
        value: 0
    },
    {
        name: 'xuid',
        op: 14,
        type: [],
        value: null
    },
    {
        name: 'charset',
        op: 15,
        type: 'offset',
        value: 0
    },
    {
        name: 'encoding',
        op: 16,
        type: 'offset',
        value: 0
    },
    {
        name: 'charStrings',
        op: 17,
        type: 'offset',
        value: 0
    },
    {
        name: 'private',
        op: 18,
        type: [
            'number',
            'offset'
        ],
        value: [
            0,
            0
        ]
    },
    {
        name: 'ros',
        op: 1230,
        type: [
            'SID',
            'SID',
            'number'
        ]
    },
    {
        name: 'cidFontVersion',
        op: 1231,
        type: 'number',
        value: 0
    },
    {
        name: 'cidFontRevision',
        op: 1232,
        type: 'number',
        value: 0
    },
    {
        name: 'cidFontType',
        op: 1233,
        type: 'number',
        value: 0
    },
    {
        name: 'cidCount',
        op: 1234,
        type: 'number',
        value: 8720
    },
    {
        name: 'uidBase',
        op: 1235,
        type: 'number'
    },
    {
        name: 'fdArray',
        op: 1236,
        type: 'offset'
    },
    {
        name: 'fdSelect',
        op: 1237,
        type: 'offset'
    },
    {
        name: 'fontName',
        op: 1238,
        type: 'SID'
    }
];
const PRIVATE_DICT_META = [
    {
        name: 'subrs',
        op: 19,
        type: 'offset',
        value: 0
    },
    {
        name: 'defaultWidthX',
        op: 20,
        type: 'number',
        value: 0
    },
    {
        name: 'nominalWidthX',
        op: 21,
        type: 'number',
        value: 0
    }
];
// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    const dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}
// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    const dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}
// Returns a list of "Top DICT"s found using an INDEX list.
// Used to read both the usual high-level Top DICTs and also the FDArray
// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
// a Private DICT that is read and saved into the Top DICT.
//
// In addition to the expected/optional values as outlined in TOP_DICT_META
// the following values might be saved into the Top DICT.
//
//    _subrs []        array of local CFF subroutines from Private DICT
//    _subrsBias       bias value computed from number of subroutines
//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
//    _defaultWidthX   default widths for CFF characters
//    _nominalWidthX   bias added to width embedded within glyph description
//
//    _privateDict     saved copy of parsed Private DICT from Top DICT
function gatherCFFTopDicts(data, start, cffIndex, strings) {
    const topDictArray = [];
    for(let iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1){
        const topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        const topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        const privateSize = topDict.private[0];
        const privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
            const privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            topDict._defaultWidthX = privateDict.defaultWidthX;
            topDict._nominalWidthX = privateDict.nominalWidthX;
            if (privateDict.subrs !== 0) {
                const subrOffset = privateOffset + privateDict.subrs;
                const subrIndex = parseCFFIndex(data, subrOffset + start);
                topDict._subrs = subrIndex.objects;
                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            }
            topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
    }
    return topDictArray;
}
// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    let sid;
    let count;
    const parser = new (0, _parseDefault.default).Parser(data, start);
    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    const charset = [
        '.notdef'
    ];
    const format = parser.parseCard8();
    if (format === 0) for(let i = 0; i < nGlyphs; i += 1){
        sid = parser.parseSID();
        charset.push(getCFFString(strings, sid));
    }
    else if (format === 1) while(charset.length <= nGlyphs){
        sid = parser.parseSID();
        count = parser.parseCard8();
        for(let i = 0; i <= count; i += 1){
            charset.push(getCFFString(strings, sid));
            sid += 1;
        }
    }
    else if (format === 2) while(charset.length <= nGlyphs){
        sid = parser.parseSID();
        count = parser.parseCard16();
        for(let i = 0; i <= count; i += 1){
            charset.push(getCFFString(strings, sid));
            sid += 1;
        }
    }
    else throw new Error('Unknown charset format ' + format);
    return charset;
}
// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    let code;
    const enc = {};
    const parser = new (0, _parseDefault.default).Parser(data, start);
    const format = parser.parseCard8();
    if (format === 0) {
        const nCodes = parser.parseCard8();
        for(let i = 0; i < nCodes; i += 1){
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        const nRanges = parser.parseCard8();
        code = 1;
        for(let i = 0; i < nRanges; i += 1){
            const first = parser.parseCard8();
            const nLeft = parser.parseCard8();
            for(let j = first; j <= first + nLeft; j += 1){
                enc[j] = code;
                code += 1;
            }
        }
    } else throw new Error('Unknown encoding format ' + format);
    return new (0, _encoding.CffEncoding)(enc, charset);
}
// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(font, glyph, code) {
    let c1x;
    let c1y;
    let c2x;
    let c2y;
    const p = new (0, _pathDefault.default)();
    const stack = [];
    let nStems = 0;
    let haveWidth = false;
    let open = false;
    let x = 0;
    let y = 0;
    let subrs;
    let subrsBias;
    let defaultWidthX;
    let nominalWidthX;
    if (font.isCIDFont) {
        const fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        const fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
    } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
    }
    let width = defaultWidthX;
    function newContour(x, y) {
        if (open) p.closePath();
        p.moveTo(x, y);
        open = true;
    }
    function parseStems() {
        let hasWidthArg;
        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) width = stack.shift() + nominalWidthX;
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }
    function parse(code) {
        let b1;
        let b2;
        let b3;
        let b4;
        let codeIndex;
        let subrCode;
        let jpx;
        let jpy;
        let c3x;
        let c3y;
        let c4x;
        let c4y;
        let i = 0;
        while(i < code.length){
            let v = code[i];
            i += 1;
            switch(v){
                case 1:
                    parseStems();
                    break;
                case 3:
                    parseStems();
                    break;
                case 4:
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5:
                    while(stack.length > 0){
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }
                    break;
                case 6:
                    while(stack.length > 0){
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) break;
                        y += stack.shift();
                        p.lineTo(x, y);
                    }
                    break;
                case 7:
                    while(stack.length > 0){
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) break;
                        x += stack.shift();
                        p.lineTo(x, y);
                    }
                    break;
                case 8:
                    while(stack.length > 0){
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 10:
                    codeIndex = stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) parse(subrCode);
                    break;
                case 11:
                    return;
                case 12:
                    v = code[i];
                    i += 1;
                    switch(v){
                        case 35:
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y + stack.shift(); // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y + stack.shift(); // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = jpy + stack.shift(); // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = c3y + stack.shift(); // dy5
                            x = c4x + stack.shift(); // dx6
                            y = c4y + stack.shift(); // dy6
                            stack.shift(); // flex depth
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34:
                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y; // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y; // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = c2y; // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = y; // dy5
                            x = c4x + stack.shift(); // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36:
                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y + stack.shift(); // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y; // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = c2y; // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = c3y + stack.shift(); // dy5
                            x = c4x + stack.shift(); // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37:
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y + stack.shift(); // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y + stack.shift(); // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = jpy + stack.shift(); // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = c3y + stack.shift(); // dy5
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) x = c4x + stack.shift();
                            else y = c4y + stack.shift();
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14:
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    if (open) {
                        p.closePath();
                        open = false;
                    }
                    break;
                case 18:
                    parseStems();
                    break;
                case 19:
                case 20:
                    parseStems();
                    i += nStems + 7 >> 3;
                    break;
                case 21:
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22:
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23:
                    parseStems();
                    break;
                case 24:
                    while(stack.length > 2){
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25:
                    while(stack.length > 6){
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26:
                    if (stack.length % 2) x += stack.shift();
                    while(stack.length > 0){
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 27:
                    if (stack.length % 2) y += stack.shift();
                    while(stack.length > 0){
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 28:
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push((b1 << 24 | b2 << 16) >> 16);
                    i += 2;
                    break;
                case 29:
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) parse(subrCode);
                    break;
                case 30:
                    while(stack.length > 0){
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) break;
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 31:
                    while(stack.length > 0){
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) break;
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                default:
                    if (v < 32) console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    else if (v < 247) stack.push(v - 139);
                    else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
                    }
            }
        }
    }
    parse(code);
    glyph.advanceWidth = width;
    return p;
}
function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
    const fdSelect = [];
    let fdIndex;
    const parser = new (0, _parseDefault.default).Parser(data, start);
    const format = parser.parseCard8();
    if (format === 0) // Simple list of nGlyphs elements
    for(let iGid = 0; iGid < nGlyphs; iGid++){
        fdIndex = parser.parseCard8();
        if (fdIndex >= fdArrayCount) throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
        fdSelect.push(fdIndex);
    }
    else if (format === 3) {
        // Ranges
        const nRanges = parser.parseCard16();
        let first = parser.parseCard16();
        if (first !== 0) throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
        let next;
        for(let iRange = 0; iRange < nRanges; iRange++){
            fdIndex = parser.parseCard8();
            next = parser.parseCard16();
            if (fdIndex >= fdArrayCount) throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            if (next > nGlyphs) throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            for(; first < next; first++)fdSelect.push(fdIndex);
            first = next;
        }
        if (next !== nGlyphs) throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
    } else throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
    return fdSelect;
}
// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    const header = parseCFFHeader(data, start);
    const nameIndex = parseCFFIndex(data, header.endOffset, (0, _parseDefault.default).bytesToString);
    const topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    const stringIndex = parseCFFIndex(data, topDictIndex.endOffset, (0, _parseDefault.default).bytesToString);
    const globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
    const topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
    if (topDictArray.length !== 1) throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
    const topDict = topDictArray[0];
    font.tables.cff.topDict = topDict;
    if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
    }
    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) font.isCIDFont = true;
    if (font.isCIDFont) {
        let fdArrayOffset = topDict.fdArray;
        let fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
        fdArrayOffset += start;
        const fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        const fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
    }
    const privateDictOffset = start + topDict.private[1];
    const privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;
    if (privateDict.subrs !== 0) {
        const subrOffset = privateDictOffset + privateDict.subrs;
        const subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }
    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    const charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;
    const charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) // Standard encoding
    font.cffEncoding = new (0, _encoding.CffEncoding)((0, _encoding.cffStandardEncoding), charset);
    else if (topDict.encoding === 1) // Expert encoding
    font.cffEncoding = new (0, _encoding.CffEncoding)((0, _encoding.cffExpertEncoding), charset);
    else font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;
    font.glyphs = new (0, _glyphsetDefault.default).GlyphSet(font);
    for(let i = 0; i < font.nGlyphs; i += 1){
        const charString = charStringsIndex.objects[i];
        font.glyphs.push(i, (0, _glyphsetDefault.default).cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
}
// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    let sid;
    // Is the string in the CFF standard strings?
    let i = (0, _encoding.cffStandardStrings).indexOf(s);
    if (i >= 0) sid = i;
    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) sid = i + (0, _encoding.cffStandardStrings).length;
    else {
        sid = (0, _encoding.cffStandardStrings).length + strings.length;
        strings.push(s);
    }
    return sid;
}
function makeHeader() {
    return new (0, _tableDefault.default).Record('Header', [
        {
            name: 'major',
            type: 'Card8',
            value: 1
        },
        {
            name: 'minor',
            type: 'Card8',
            value: 0
        },
        {
            name: 'hdrSize',
            type: 'Card8',
            value: 4
        },
        {
            name: 'major',
            type: 'Card8',
            value: 1
        }
    ]);
}
function makeNameIndex(fontNames) {
    const t = new (0, _tableDefault.default).Record('Name INDEX', [
        {
            name: 'names',
            type: 'INDEX',
            value: []
        }
    ]);
    t.names = [];
    for(let i = 0; i < fontNames.length; i += 1)t.names.push({
        name: 'name_' + i,
        type: 'NAME',
        value: fontNames[i]
    });
    return t;
}
// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    const m = {};
    for(let i = 0; i < meta.length; i += 1){
        const entry = meta[i];
        let value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') value = encodeString(value, strings);
            m[entry.op] = {
                name: entry.name,
                type: entry.type,
                value: value
            };
        }
    }
    return m;
}
// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    const t = new (0, _tableDefault.default).Record('Top DICT', [
        {
            name: 'dict',
            type: 'DICT',
            value: {}
        }
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}
function makeTopDictIndex(topDict) {
    const t = new (0, _tableDefault.default).Record('Top DICT INDEX', [
        {
            name: 'topDicts',
            type: 'INDEX',
            value: []
        }
    ]);
    t.topDicts = [
        {
            name: 'topDict_0',
            type: 'TABLE',
            value: topDict
        }
    ];
    return t;
}
function makeStringIndex(strings) {
    const t = new (0, _tableDefault.default).Record('String INDEX', [
        {
            name: 'strings',
            type: 'INDEX',
            value: []
        }
    ]);
    t.strings = [];
    for(let i = 0; i < strings.length; i += 1)t.strings.push({
        name: 'string_' + i,
        type: 'STRING',
        value: strings[i]
    });
    return t;
}
function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new (0, _tableDefault.default).Record('Global Subr INDEX', [
        {
            name: 'subrs',
            type: 'INDEX',
            value: []
        }
    ]);
}
function makeCharsets(glyphNames, strings) {
    const t = new (0, _tableDefault.default).Record('Charsets', [
        {
            name: 'format',
            type: 'Card8',
            value: 0
        }
    ]);
    for(let i = 0; i < glyphNames.length; i += 1){
        const glyphName = glyphNames[i];
        const glyphSID = encodeString(glyphName, strings);
        t.fields.push({
            name: 'glyph_' + i,
            type: 'SID',
            value: glyphSID
        });
    }
    return t;
}
function glyphToOps(glyph) {
    const ops = [];
    const path = glyph.path;
    ops.push({
        name: 'width',
        type: 'NUMBER',
        value: glyph.advanceWidth
    });
    let x = 0;
    let y = 0;
    for(let i = 0; i < path.commands.length; i += 1){
        let dx;
        let dy;
        let cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bzier curves, so convert the quad to a bzier.
            const _13 = 1 / 3;
            const _23 = 2 / 3;
            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }
        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({
                name: 'dx',
                type: 'NUMBER',
                value: dx
            });
            ops.push({
                name: 'dy',
                type: 'NUMBER',
                value: dy
            });
            ops.push({
                name: 'rmoveto',
                type: 'OP',
                value: 21
            });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({
                name: 'dx',
                type: 'NUMBER',
                value: dx
            });
            ops.push({
                name: 'dy',
                type: 'NUMBER',
                value: dy
            });
            ops.push({
                name: 'rlineto',
                type: 'OP',
                value: 5
            });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            const dx1 = Math.round(cmd.x1 - x);
            const dy1 = Math.round(cmd.y1 - y);
            const dx2 = Math.round(cmd.x2 - cmd.x1);
            const dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({
                name: 'dx1',
                type: 'NUMBER',
                value: dx1
            });
            ops.push({
                name: 'dy1',
                type: 'NUMBER',
                value: dy1
            });
            ops.push({
                name: 'dx2',
                type: 'NUMBER',
                value: dx2
            });
            ops.push({
                name: 'dy2',
                type: 'NUMBER',
                value: dy2
            });
            ops.push({
                name: 'dx',
                type: 'NUMBER',
                value: dx
            });
            ops.push({
                name: 'dy',
                type: 'NUMBER',
                value: dy
            });
            ops.push({
                name: 'rrcurveto',
                type: 'OP',
                value: 8
            });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }
    // Contours are closed automatically.
    }
    ops.push({
        name: 'endchar',
        type: 'OP',
        value: 14
    });
    return ops;
}
function makeCharStringsIndex(glyphs) {
    const t = new (0, _tableDefault.default).Record('CharStrings INDEX', [
        {
            name: 'charStrings',
            type: 'INDEX',
            value: []
        }
    ]);
    for(let i = 0; i < glyphs.length; i += 1){
        const glyph = glyphs.get(i);
        const ops = glyphToOps(glyph);
        t.charStrings.push({
            name: glyph.name,
            type: 'CHARSTRING',
            value: ops
        });
    }
    return t;
}
function makePrivateDict(attrs, strings) {
    const t = new (0, _tableDefault.default).Record('Private DICT', [
        {
            name: 'dict',
            type: 'DICT',
            value: {}
        }
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}
function makeCFFTable(glyphs, options) {
    const t = new (0, _tableDefault.default).Table('CFF ', [
        {
            name: 'header',
            type: 'RECORD'
        },
        {
            name: 'nameIndex',
            type: 'RECORD'
        },
        {
            name: 'topDictIndex',
            type: 'RECORD'
        },
        {
            name: 'stringIndex',
            type: 'RECORD'
        },
        {
            name: 'globalSubrIndex',
            type: 'RECORD'
        },
        {
            name: 'charsets',
            type: 'RECORD'
        },
        {
            name: 'charStringsIndex',
            type: 'RECORD'
        },
        {
            name: 'privateDict',
            type: 'RECORD'
        }
    ]);
    const fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    const attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [
            0,
            0,
            0,
            0
        ],
        fontMatrix: [
            fontScale,
            0,
            0,
            fontScale,
            0,
            0
        ],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [
            0,
            999
        ]
    };
    const privateAttrs = {};
    const glyphNames = [];
    let glyph;
    // Skip first glyph (.notdef)
    for(let i = 1; i < glyphs.length; i += 1){
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }
    const strings = [];
    t.header = makeHeader();
    t.nameIndex = makeNameIndex([
        options.postScriptName
    ]);
    let topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);
    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);
    const startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;
    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    return t;
}
exports.default = {
    parse: parseCFFTable,
    make: makeCFFTable
};

},{"../encoding":"lPZPs","../glyphset":"d9O7P","../parse":"8RdJX","../path":"gWom8","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lPZPs":[function(require,module,exports,__globalThis) {
// Glyph encoding
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cffStandardStrings", ()=>cffStandardStrings);
parcelHelpers.export(exports, "cffStandardEncoding", ()=>cffStandardEncoding);
parcelHelpers.export(exports, "cffExpertEncoding", ()=>cffExpertEncoding);
parcelHelpers.export(exports, "standardNames", ()=>standardNames);
parcelHelpers.export(exports, "DefaultEncoding", ()=>DefaultEncoding);
parcelHelpers.export(exports, "CmapEncoding", ()=>CmapEncoding);
parcelHelpers.export(exports, "CffEncoding", ()=>CffEncoding);
parcelHelpers.export(exports, "GlyphNames", ()=>GlyphNames);
parcelHelpers.export(exports, "addGlyphNames", ()=>addGlyphNames);
const cffStandardStrings = [
    '.notdef',
    'space',
    'exclam',
    'quotedbl',
    'numbersign',
    'dollar',
    'percent',
    'ampersand',
    'quoteright',
    'parenleft',
    'parenright',
    'asterisk',
    'plus',
    'comma',
    'hyphen',
    'period',
    'slash',
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
    'colon',
    'semicolon',
    'less',
    'equal',
    'greater',
    'question',
    'at',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
    'bracketleft',
    'backslash',
    'bracketright',
    'asciicircum',
    'underscore',
    'quoteleft',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    'braceleft',
    'bar',
    'braceright',
    'asciitilde',
    'exclamdown',
    'cent',
    'sterling',
    'fraction',
    'yen',
    'florin',
    'section',
    'currency',
    'quotesingle',
    'quotedblleft',
    'guillemotleft',
    'guilsinglleft',
    'guilsinglright',
    'fi',
    'fl',
    'endash',
    'dagger',
    'daggerdbl',
    'periodcentered',
    'paragraph',
    'bullet',
    'quotesinglbase',
    'quotedblbase',
    'quotedblright',
    'guillemotright',
    'ellipsis',
    'perthousand',
    'questiondown',
    'grave',
    'acute',
    'circumflex',
    'tilde',
    'macron',
    'breve',
    'dotaccent',
    'dieresis',
    'ring',
    'cedilla',
    'hungarumlaut',
    'ogonek',
    'caron',
    'emdash',
    'AE',
    'ordfeminine',
    'Lslash',
    'Oslash',
    'OE',
    'ordmasculine',
    'ae',
    'dotlessi',
    'lslash',
    'oslash',
    'oe',
    'germandbls',
    'onesuperior',
    'logicalnot',
    'mu',
    'trademark',
    'Eth',
    'onehalf',
    'plusminus',
    'Thorn',
    'onequarter',
    'divide',
    'brokenbar',
    'degree',
    'thorn',
    'threequarters',
    'twosuperior',
    'registered',
    'minus',
    'eth',
    'multiply',
    'threesuperior',
    'copyright',
    'Aacute',
    'Acircumflex',
    'Adieresis',
    'Agrave',
    'Aring',
    'Atilde',
    'Ccedilla',
    'Eacute',
    'Ecircumflex',
    'Edieresis',
    'Egrave',
    'Iacute',
    'Icircumflex',
    'Idieresis',
    'Igrave',
    'Ntilde',
    'Oacute',
    'Ocircumflex',
    'Odieresis',
    'Ograve',
    'Otilde',
    'Scaron',
    'Uacute',
    'Ucircumflex',
    'Udieresis',
    'Ugrave',
    'Yacute',
    'Ydieresis',
    'Zcaron',
    'aacute',
    'acircumflex',
    'adieresis',
    'agrave',
    'aring',
    'atilde',
    'ccedilla',
    'eacute',
    'ecircumflex',
    'edieresis',
    'egrave',
    'iacute',
    'icircumflex',
    'idieresis',
    'igrave',
    'ntilde',
    'oacute',
    'ocircumflex',
    'odieresis',
    'ograve',
    'otilde',
    'scaron',
    'uacute',
    'ucircumflex',
    'udieresis',
    'ugrave',
    'yacute',
    'ydieresis',
    'zcaron',
    'exclamsmall',
    'Hungarumlautsmall',
    'dollaroldstyle',
    'dollarsuperior',
    'ampersandsmall',
    'Acutesmall',
    'parenleftsuperior',
    'parenrightsuperior',
    '266 ff',
    'onedotenleader',
    'zerooldstyle',
    'oneoldstyle',
    'twooldstyle',
    'threeoldstyle',
    'fouroldstyle',
    'fiveoldstyle',
    'sixoldstyle',
    'sevenoldstyle',
    'eightoldstyle',
    'nineoldstyle',
    'commasuperior',
    'threequartersemdash',
    'periodsuperior',
    'questionsmall',
    'asuperior',
    'bsuperior',
    'centsuperior',
    'dsuperior',
    'esuperior',
    'isuperior',
    'lsuperior',
    'msuperior',
    'nsuperior',
    'osuperior',
    'rsuperior',
    'ssuperior',
    'tsuperior',
    'ff',
    'ffi',
    'ffl',
    'parenleftinferior',
    'parenrightinferior',
    'Circumflexsmall',
    'hyphensuperior',
    'Gravesmall',
    'Asmall',
    'Bsmall',
    'Csmall',
    'Dsmall',
    'Esmall',
    'Fsmall',
    'Gsmall',
    'Hsmall',
    'Ismall',
    'Jsmall',
    'Ksmall',
    'Lsmall',
    'Msmall',
    'Nsmall',
    'Osmall',
    'Psmall',
    'Qsmall',
    'Rsmall',
    'Ssmall',
    'Tsmall',
    'Usmall',
    'Vsmall',
    'Wsmall',
    'Xsmall',
    'Ysmall',
    'Zsmall',
    'colonmonetary',
    'onefitted',
    'rupiah',
    'Tildesmall',
    'exclamdownsmall',
    'centoldstyle',
    'Lslashsmall',
    'Scaronsmall',
    'Zcaronsmall',
    'Dieresissmall',
    'Brevesmall',
    'Caronsmall',
    'Dotaccentsmall',
    'Macronsmall',
    'figuredash',
    'hypheninferior',
    'Ogoneksmall',
    'Ringsmall',
    'Cedillasmall',
    'questiondownsmall',
    'oneeighth',
    'threeeighths',
    'fiveeighths',
    'seveneighths',
    'onethird',
    'twothirds',
    'zerosuperior',
    'foursuperior',
    'fivesuperior',
    'sixsuperior',
    'sevensuperior',
    'eightsuperior',
    'ninesuperior',
    'zeroinferior',
    'oneinferior',
    'twoinferior',
    'threeinferior',
    'fourinferior',
    'fiveinferior',
    'sixinferior',
    'seveninferior',
    'eightinferior',
    'nineinferior',
    'centinferior',
    'dollarinferior',
    'periodinferior',
    'commainferior',
    'Agravesmall',
    'Aacutesmall',
    'Acircumflexsmall',
    'Atildesmall',
    'Adieresissmall',
    'Aringsmall',
    'AEsmall',
    'Ccedillasmall',
    'Egravesmall',
    'Eacutesmall',
    'Ecircumflexsmall',
    'Edieresissmall',
    'Igravesmall',
    'Iacutesmall',
    'Icircumflexsmall',
    'Idieresissmall',
    'Ethsmall',
    'Ntildesmall',
    'Ogravesmall',
    'Oacutesmall',
    'Ocircumflexsmall',
    'Otildesmall',
    'Odieresissmall',
    'OEsmall',
    'Oslashsmall',
    'Ugravesmall',
    'Uacutesmall',
    'Ucircumflexsmall',
    'Udieresissmall',
    'Yacutesmall',
    'Thornsmall',
    'Ydieresissmall',
    '001.000',
    '001.001',
    '001.002',
    '001.003',
    'Black',
    'Bold',
    'Book',
    'Light',
    'Medium',
    'Regular',
    'Roman',
    'Semibold'
];
const cffStandardEncoding = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    'space',
    'exclam',
    'quotedbl',
    'numbersign',
    'dollar',
    'percent',
    'ampersand',
    'quoteright',
    'parenleft',
    'parenright',
    'asterisk',
    'plus',
    'comma',
    'hyphen',
    'period',
    'slash',
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
    'colon',
    'semicolon',
    'less',
    'equal',
    'greater',
    'question',
    'at',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
    'bracketleft',
    'backslash',
    'bracketright',
    'asciicircum',
    'underscore',
    'quoteleft',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    'braceleft',
    'bar',
    'braceright',
    'asciitilde',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    'exclamdown',
    'cent',
    'sterling',
    'fraction',
    'yen',
    'florin',
    'section',
    'currency',
    'quotesingle',
    'quotedblleft',
    'guillemotleft',
    'guilsinglleft',
    'guilsinglright',
    'fi',
    'fl',
    '',
    'endash',
    'dagger',
    'daggerdbl',
    'periodcentered',
    '',
    'paragraph',
    'bullet',
    'quotesinglbase',
    'quotedblbase',
    'quotedblright',
    'guillemotright',
    'ellipsis',
    'perthousand',
    '',
    'questiondown',
    '',
    'grave',
    'acute',
    'circumflex',
    'tilde',
    'macron',
    'breve',
    'dotaccent',
    'dieresis',
    '',
    'ring',
    'cedilla',
    '',
    'hungarumlaut',
    'ogonek',
    'caron',
    'emdash',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    'AE',
    '',
    'ordfeminine',
    '',
    '',
    '',
    '',
    'Lslash',
    'Oslash',
    'OE',
    'ordmasculine',
    '',
    '',
    '',
    '',
    '',
    'ae',
    '',
    '',
    '',
    'dotlessi',
    '',
    '',
    'lslash',
    'oslash',
    'oe',
    'germandbls'
];
const cffExpertEncoding = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    'space',
    'exclamsmall',
    'Hungarumlautsmall',
    '',
    'dollaroldstyle',
    'dollarsuperior',
    'ampersandsmall',
    'Acutesmall',
    'parenleftsuperior',
    'parenrightsuperior',
    'twodotenleader',
    'onedotenleader',
    'comma',
    'hyphen',
    'period',
    'fraction',
    'zerooldstyle',
    'oneoldstyle',
    'twooldstyle',
    'threeoldstyle',
    'fouroldstyle',
    'fiveoldstyle',
    'sixoldstyle',
    'sevenoldstyle',
    'eightoldstyle',
    'nineoldstyle',
    'colon',
    'semicolon',
    'commasuperior',
    'threequartersemdash',
    'periodsuperior',
    'questionsmall',
    '',
    'asuperior',
    'bsuperior',
    'centsuperior',
    'dsuperior',
    'esuperior',
    '',
    '',
    'isuperior',
    '',
    '',
    'lsuperior',
    'msuperior',
    'nsuperior',
    'osuperior',
    '',
    '',
    'rsuperior',
    'ssuperior',
    'tsuperior',
    '',
    'ff',
    'fi',
    'fl',
    'ffi',
    'ffl',
    'parenleftinferior',
    '',
    'parenrightinferior',
    'Circumflexsmall',
    'hyphensuperior',
    'Gravesmall',
    'Asmall',
    'Bsmall',
    'Csmall',
    'Dsmall',
    'Esmall',
    'Fsmall',
    'Gsmall',
    'Hsmall',
    'Ismall',
    'Jsmall',
    'Ksmall',
    'Lsmall',
    'Msmall',
    'Nsmall',
    'Osmall',
    'Psmall',
    'Qsmall',
    'Rsmall',
    'Ssmall',
    'Tsmall',
    'Usmall',
    'Vsmall',
    'Wsmall',
    'Xsmall',
    'Ysmall',
    'Zsmall',
    'colonmonetary',
    'onefitted',
    'rupiah',
    'Tildesmall',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    'exclamdownsmall',
    'centoldstyle',
    'Lslashsmall',
    '',
    '',
    'Scaronsmall',
    'Zcaronsmall',
    'Dieresissmall',
    'Brevesmall',
    'Caronsmall',
    '',
    'Dotaccentsmall',
    '',
    '',
    'Macronsmall',
    '',
    '',
    'figuredash',
    'hypheninferior',
    '',
    '',
    'Ogoneksmall',
    'Ringsmall',
    'Cedillasmall',
    '',
    '',
    '',
    'onequarter',
    'onehalf',
    'threequarters',
    'questiondownsmall',
    'oneeighth',
    'threeeighths',
    'fiveeighths',
    'seveneighths',
    'onethird',
    'twothirds',
    '',
    '',
    'zerosuperior',
    'onesuperior',
    'twosuperior',
    'threesuperior',
    'foursuperior',
    'fivesuperior',
    'sixsuperior',
    'sevensuperior',
    'eightsuperior',
    'ninesuperior',
    'zeroinferior',
    'oneinferior',
    'twoinferior',
    'threeinferior',
    'fourinferior',
    'fiveinferior',
    'sixinferior',
    'seveninferior',
    'eightinferior',
    'nineinferior',
    'centinferior',
    'dollarinferior',
    'periodinferior',
    'commainferior',
    'Agravesmall',
    'Aacutesmall',
    'Acircumflexsmall',
    'Atildesmall',
    'Adieresissmall',
    'Aringsmall',
    'AEsmall',
    'Ccedillasmall',
    'Egravesmall',
    'Eacutesmall',
    'Ecircumflexsmall',
    'Edieresissmall',
    'Igravesmall',
    'Iacutesmall',
    'Icircumflexsmall',
    'Idieresissmall',
    'Ethsmall',
    'Ntildesmall',
    'Ogravesmall',
    'Oacutesmall',
    'Ocircumflexsmall',
    'Otildesmall',
    'Odieresissmall',
    'OEsmall',
    'Oslashsmall',
    'Ugravesmall',
    'Uacutesmall',
    'Ucircumflexsmall',
    'Udieresissmall',
    'Yacutesmall',
    'Thornsmall',
    'Ydieresissmall'
];
const standardNames = [
    '.notdef',
    '.null',
    'nonmarkingreturn',
    'space',
    'exclam',
    'quotedbl',
    'numbersign',
    'dollar',
    'percent',
    'ampersand',
    'quotesingle',
    'parenleft',
    'parenright',
    'asterisk',
    'plus',
    'comma',
    'hyphen',
    'period',
    'slash',
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
    'colon',
    'semicolon',
    'less',
    'equal',
    'greater',
    'question',
    'at',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
    'bracketleft',
    'backslash',
    'bracketright',
    'asciicircum',
    'underscore',
    'grave',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    'braceleft',
    'bar',
    'braceright',
    'asciitilde',
    'Adieresis',
    'Aring',
    'Ccedilla',
    'Eacute',
    'Ntilde',
    'Odieresis',
    'Udieresis',
    'aacute',
    'agrave',
    'acircumflex',
    'adieresis',
    'atilde',
    'aring',
    'ccedilla',
    'eacute',
    'egrave',
    'ecircumflex',
    'edieresis',
    'iacute',
    'igrave',
    'icircumflex',
    'idieresis',
    'ntilde',
    'oacute',
    'ograve',
    'ocircumflex',
    'odieresis',
    'otilde',
    'uacute',
    'ugrave',
    'ucircumflex',
    'udieresis',
    'dagger',
    'degree',
    'cent',
    'sterling',
    'section',
    'bullet',
    'paragraph',
    'germandbls',
    'registered',
    'copyright',
    'trademark',
    'acute',
    'dieresis',
    'notequal',
    'AE',
    'Oslash',
    'infinity',
    'plusminus',
    'lessequal',
    'greaterequal',
    'yen',
    'mu',
    'partialdiff',
    'summation',
    'product',
    'pi',
    'integral',
    'ordfeminine',
    'ordmasculine',
    'Omega',
    'ae',
    'oslash',
    'questiondown',
    'exclamdown',
    'logicalnot',
    'radical',
    'florin',
    'approxequal',
    'Delta',
    'guillemotleft',
    'guillemotright',
    'ellipsis',
    'nonbreakingspace',
    'Agrave',
    'Atilde',
    'Otilde',
    'OE',
    'oe',
    'endash',
    'emdash',
    'quotedblleft',
    'quotedblright',
    'quoteleft',
    'quoteright',
    'divide',
    'lozenge',
    'ydieresis',
    'Ydieresis',
    'fraction',
    'currency',
    'guilsinglleft',
    'guilsinglright',
    'fi',
    'fl',
    'daggerdbl',
    'periodcentered',
    'quotesinglbase',
    'quotedblbase',
    'perthousand',
    'Acircumflex',
    'Ecircumflex',
    'Aacute',
    'Edieresis',
    'Egrave',
    'Iacute',
    'Icircumflex',
    'Idieresis',
    'Igrave',
    'Oacute',
    'Ocircumflex',
    'apple',
    'Ograve',
    'Uacute',
    'Ucircumflex',
    'Ugrave',
    'dotlessi',
    'circumflex',
    'tilde',
    'macron',
    'breve',
    'dotaccent',
    'ring',
    'cedilla',
    'hungarumlaut',
    'ogonek',
    'caron',
    'Lslash',
    'lslash',
    'Scaron',
    'scaron',
    'Zcaron',
    'zcaron',
    'brokenbar',
    'Eth',
    'eth',
    'Yacute',
    'yacute',
    'Thorn',
    'thorn',
    'minus',
    'multiply',
    'onesuperior',
    'twosuperior',
    'threesuperior',
    'onehalf',
    'onequarter',
    'threequarters',
    'franc',
    'Gbreve',
    'gbreve',
    'Idotaccent',
    'Scedilla',
    'scedilla',
    'Cacute',
    'cacute',
    'Ccaron',
    'ccaron',
    'dcroat'
];
/**
 * This is the encoding used for fonts created from scratch.
 * It loops through all glyphs and finds the appropriate unicode value.
 * Since it's linear time, other encodings will be faster.
 * @exports opentype.DefaultEncoding
 * @class
 * @constructor
 * @param {opentype.Font}
 */ function DefaultEncoding(font) {
    this.font = font;
}
DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    const code = c.codePointAt(0);
    const glyphs = this.font.glyphs;
    if (glyphs) for(let i = 0; i < glyphs.length; i += 1){
        const glyph = glyphs.get(i);
        for(let j = 0; j < glyph.unicodes.length; j += 1){
            if (glyph.unicodes[j] === code) return i;
        }
    }
    return null;
};
/**
 * @exports opentype.CmapEncoding
 * @class
 * @constructor
 * @param {Object} cmap - a object with the cmap encoded data
 */ function CmapEncoding(cmap) {
    this.cmap = cmap;
}
/**
 * @param  {string} c - the character
 * @return {number} The glyph index.
 */ CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
};
/**
 * @exports opentype.CffEncoding
 * @class
 * @constructor
 * @param {string} encoding - The encoding
 * @param {Array} charset - The character set.
 */ function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}
/**
 * @param  {string} s - The character
 * @return {number} The index.
 */ CffEncoding.prototype.charToGlyphIndex = function(s) {
    const code = s.codePointAt(0);
    const charName = this.encoding[code];
    return this.charset.indexOf(charName);
};
/**
 * @exports opentype.GlyphNames
 * @class
 * @constructor
 * @param {Object} post
 */ function GlyphNames(post) {
    switch(post.version){
        case 1:
            this.names = standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for(let i = 0; i < post.numberOfGlyphs; i++)if (post.glyphNameIndex[i] < standardNames.length) this.names[i] = standardNames[post.glyphNameIndex[i]];
            else this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for(let i = 0; i < post.numberOfGlyphs; i++)this.names[i] = standardNames[i + post.glyphNameIndex[i]];
            break;
        case 3:
            this.names = [];
            break;
        default:
            this.names = [];
            break;
    }
}
/**
 * Gets the index of a glyph by name.
 * @param  {string} name - The glyph name
 * @return {number} The index
 */ GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};
/**
 * @param  {number} gid
 * @return {string}
 */ GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};
/**
 * @alias opentype.addGlyphNames
 * @param {opentype.Font}
 */ function addGlyphNames(font) {
    let glyph;
    const glyphIndexMap = font.tables.cmap.glyphIndexMap;
    const charCodes = Object.keys(glyphIndexMap);
    for(let i = 0; i < charCodes.length; i += 1){
        const c = charCodes[i];
        const glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }
    for(let i = 0; i < font.glyphs.length; i += 1){
        glyph = font.glyphs.get(i);
        if (font.cffEncoding) {
            if (font.isCIDFont) glyph.name = 'gid' + i;
            else glyph.name = font.cffEncoding.charset[i];
        } else if (font.glyphNames.names) glyph.name = font.glyphNames.glyphIndexToName(i);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d9O7P":[function(require,module,exports,__globalThis) {
// The GlyphSet object
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _glyph = require("./glyph");
var _glyphDefault = parcelHelpers.interopDefault(_glyph);
// Define a property on the glyph that depends on the path being loaded.
function defineDependentProperty(glyph, externalName, internalName) {
    Object.defineProperty(glyph, externalName, {
        get: function() {
            // Request the path property to make sure the path is loaded.
            glyph.path; // jshint ignore:line
            return glyph[internalName];
        },
        set: function(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}
/**
 * A GlyphSet represents all glyphs available in the font, but modelled using
 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
 * necessary, to keep the memory footprint down.
 * @exports opentype.GlyphSet
 * @class
 * @param {opentype.Font}
 * @param {Array}
 */ function GlyphSet(font, glyphs) {
    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) for(let i = 0; i < glyphs.length; i++)this.glyphs[i] = glyphs[i];
    this.length = glyphs && glyphs.length || 0;
}
/**
 * @param  {number} index
 * @return {opentype.Glyph}
 */ GlyphSet.prototype.get = function(index) {
    if (typeof this.glyphs[index] === 'function') this.glyphs[index] = this.glyphs[index]();
    return this.glyphs[index];
};
/**
 * @param  {number} index
 * @param  {Object}
 */ GlyphSet.prototype.push = function(index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};
/**
 * @alias opentype.glyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @return {opentype.Glyph}
 */ function glyphLoader(font, index) {
    return new (0, _glyphDefault.default)({
        index: index,
        font: font
    });
}
/**
 * Generate a stub glyph that can be filled with all metadata *except*
 * the "points" and "path" properties, which must be loaded only once
 * the glyph's path is actually requested for text shaping.
 * @alias opentype.ttfGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseGlyph
 * @param  {Object} data
 * @param  {number} position
 * @param  {Function} buildPath
 * @return {opentype.Glyph}
 */ function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function() {
        const glyph = new (0, _glyphDefault.default)({
            index: index,
            font: font
        });
        glyph.path = function() {
            parseGlyph(glyph, data, position);
            const path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };
        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');
        return glyph;
    };
}
/**
 * @alias opentype.cffGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseCFFCharstring
 * @param  {string} charstring
 * @return {opentype.Glyph}
 */ function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function() {
        const glyph = new (0, _glyphDefault.default)({
            index: index,
            font: font
        });
        glyph.path = function() {
            const path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };
        return glyph;
    };
}
exports.default = {
    GlyphSet,
    glyphLoader,
    ttfGlyphLoader,
    cffGlyphLoader
};

},{"./glyph":"1MjxB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1MjxB":[function(require,module,exports,__globalThis) {
// The Glyph object
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("./check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _draw = require("./draw");
var _drawDefault = parcelHelpers.interopDefault(_draw);
var _path = require("./path");
var _pathDefault = parcelHelpers.interopDefault(_path);
// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency
function getPathDefinition(glyph, path) {
    let _path = path || new (0, _pathDefault.default)();
    return {
        configurable: true,
        get: function() {
            if (typeof _path === 'function') _path = _path();
            return _path;
        },
        set: function(p) {
            _path = p;
        }
    };
}
/**
 * @typedef GlyphOptions
 * @type Object
 * @property {string} [name] - The glyph name
 * @property {number} [unicode]
 * @property {Array} [unicodes]
 * @property {number} [xMin]
 * @property {number} [yMin]
 * @property {number} [xMax]
 * @property {number} [yMax]
 * @property {number} [advanceWidth]
 */ // A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
/**
 * @exports opentype.Glyph
 * @class
 * @param {GlyphOptions}
 * @constructor
 */ function Glyph(options) {
    // By putting all the code on a prototype function (which is only declared once)
    // we reduce the memory requirements for larger fonts by some 2%
    this.bindConstructorValues(options);
}
/**
 * @param  {GlyphOptions}
 */ Glyph.prototype.bindConstructorValues = function(options) {
    this.index = options.index || 0;
    // These three values cannot be deferred for memory optimization:
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [
        options.unicode
    ] : [];
    // But by binding these values only when necessary, we reduce can
    // the memory requirements by almost 3% for larger fonts.
    if (options.xMin) this.xMin = options.xMin;
    if (options.yMin) this.yMin = options.yMin;
    if (options.xMax) this.xMax = options.xMax;
    if (options.yMax) this.yMax = options.yMax;
    if (options.advanceWidth) this.advanceWidth = options.advanceWidth;
    // The path for a glyph is the most memory intensive, and is bound as a value
    // with a getter/setter to ensure we actually do path parsing only once the
    // path is actually needed by anything.
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};
/**
 * @param {number}
 */ Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) this.unicode = unicode;
    this.unicodes.push(unicode);
};
/**
 * Calculate the minimum bounding box for this glyph.
 * @return {opentype.BoundingBox}
 */ Glyph.prototype.getBoundingBox = function() {
    return this.path.getBoundingBox();
};
/**
 * Convert the glyph to a Path we can draw on a drawing context.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 * @param  {opentype.Font} if hinting is to be used, the font
 * @return {opentype.Path}
 */ Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    let commands;
    let hPoints;
    if (!options) options = {};
    let xScale = options.xScale;
    let yScale = options.yScale;
    if (options.hinting && font && font.hinting) // in case of hinting, the hinting engine takes care
    // of scaling the points (not the path) before hinting.
    hPoints = this.path && font.hinting.exec(this, fontSize);
    if (hPoints) {
        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
        commands = font.hinting.getCommands(hPoints);
        x = Math.round(x);
        y = Math.round(y);
        // TODO in case of hinting xyScaling is not yet supported
        xScale = yScale = 1;
    } else {
        commands = this.path.commands;
        const scale = 1 / this.path.unitsPerEm * fontSize;
        if (xScale === undefined) xScale = scale;
        if (yScale === undefined) yScale = scale;
    }
    const p = new (0, _pathDefault.default)();
    for(let i = 0; i < commands.length; i += 1){
        const cmd = commands[i];
        if (cmd.type === 'M') p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
        else if (cmd.type === 'L') p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
        else if (cmd.type === 'Q') p.quadraticCurveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);
        else if (cmd.type === 'C') p.curveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x2 * xScale, y + -cmd.y2 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);
        else if (cmd.type === 'Z') p.closePath();
    }
    return p;
};
/**
 * Split the glyph into contours.
 * This function is here for backwards compatibility, and to
 * provide raw access to the TrueType glyph outlines.
 * @return {Array}
 */ Glyph.prototype.getContours = function() {
    if (this.points === undefined) return [];
    const contours = [];
    let currentContour = [];
    for(let i = 0; i < this.points.length; i += 1){
        const pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    (0, _checkDefault.default).argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};
/**
 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
 * @return {Object}
 */ Glyph.prototype.getMetrics = function() {
    const commands = this.path.commands;
    const xCoords = [];
    const yCoords = [];
    for(let i = 0; i < commands.length; i += 1){
        const cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }
        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }
        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }
    const metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };
    if (!isFinite(metrics.xMin)) metrics.xMin = 0;
    if (!isFinite(metrics.xMax)) metrics.xMax = this.advanceWidth;
    if (!isFinite(metrics.yMin)) metrics.yMin = 0;
    if (!isFinite(metrics.yMax)) metrics.yMax = 0;
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};
/**
 * Draw the glyph on the given context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 */ Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};
/**
 * Draw the points of the glyph.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */ Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
    function drawCircles(l, x, y, scale) {
        const PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for(let j = 0; j < l.length; j += 1){
            ctx.moveTo(x + l[j].x * scale, y + l[j].y * scale);
            ctx.arc(x + l[j].x * scale, y + l[j].y * scale, 2, 0, PI_SQ, false);
        }
        ctx.closePath();
        ctx.fill();
    }
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    const scale = 1 / this.path.unitsPerEm * fontSize;
    const blueCircles = [];
    const redCircles = [];
    const path = this.path;
    for(let i = 0; i < path.commands.length; i += 1){
        const cmd = path.commands[i];
        if (cmd.x !== undefined) blueCircles.push({
            x: cmd.x,
            y: -cmd.y
        });
        if (cmd.x1 !== undefined) redCircles.push({
            x: cmd.x1,
            y: -cmd.y1
        });
        if (cmd.x2 !== undefined) redCircles.push({
            x: cmd.x2,
            y: -cmd.y2
        });
    }
    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};
/**
 * Draw lines indicating important font measurements.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */ Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    let scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;
    // Draw the origin
    ctx.strokeStyle = 'black';
    (0, _drawDefault.default).line(ctx, x, -10000, x, 10000);
    (0, _drawDefault.default).line(ctx, -10000, y, 10000, y);
    // This code is here due to memory optimization: by not using
    // defaults in the constructor, we save a notable amount of memory.
    const xMin = this.xMin || 0;
    let yMin = this.yMin || 0;
    const xMax = this.xMax || 0;
    let yMax = this.yMax || 0;
    const advanceWidth = this.advanceWidth || 0;
    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    (0, _drawDefault.default).line(ctx, x + xMin * scale, -10000, x + xMin * scale, 10000);
    (0, _drawDefault.default).line(ctx, x + xMax * scale, -10000, x + xMax * scale, 10000);
    (0, _drawDefault.default).line(ctx, -10000, y + -yMin * scale, 10000, y + -yMin * scale);
    (0, _drawDefault.default).line(ctx, -10000, y + -yMax * scale, 10000, y + -yMax * scale);
    // Draw the advance width
    ctx.strokeStyle = 'green';
    (0, _drawDefault.default).line(ctx, x + advanceWidth * scale, -10000, x + advanceWidth * scale, 10000);
};
exports.default = Glyph;

},{"./check":"184gJ","./draw":"5HLJo","./path":"gWom8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5HLJo":[function(require,module,exports,__globalThis) {
// Drawing utility functions.
// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}
exports.default = {
    line
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4F1f7":[function(require,module,exports,__globalThis) {
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Parse the header `head` table
function parseHeadTable(data, start) {
    const head = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    (0, _checkDefault.default).argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
}
function makeHeadTable(options) {
    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
    const timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    let createdTimestamp = timestamp;
    if (options.createdTimestamp) createdTimestamp = options.createdTimestamp + 2082844800;
    return new (0, _tableDefault.default).Table('head', [
        {
            name: 'version',
            type: 'FIXED',
            value: 0x00010000
        },
        {
            name: 'fontRevision',
            type: 'FIXED',
            value: 0x00010000
        },
        {
            name: 'checkSumAdjustment',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'magicNumber',
            type: 'ULONG',
            value: 0x5F0F3CF5
        },
        {
            name: 'flags',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'unitsPerEm',
            type: 'USHORT',
            value: 1000
        },
        {
            name: 'created',
            type: 'LONGDATETIME',
            value: createdTimestamp
        },
        {
            name: 'modified',
            type: 'LONGDATETIME',
            value: timestamp
        },
        {
            name: 'xMin',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'yMin',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'xMax',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'yMax',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'macStyle',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'lowestRecPPEM',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'fontDirectionHint',
            type: 'SHORT',
            value: 2
        },
        {
            name: 'indexToLocFormat',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'glyphDataFormat',
            type: 'SHORT',
            value: 0
        }
    ], options);
}
exports.default = {
    parse: parseHeadTable,
    make: makeHeadTable
};

},{"../check":"184gJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hxeGk":[function(require,module,exports,__globalThis) {
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    const hhea = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}
function makeHheaTable(options) {
    return new (0, _tableDefault.default).Table('hhea', [
        {
            name: 'version',
            type: 'FIXED',
            value: 0x00010000
        },
        {
            name: 'ascender',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'descender',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'lineGap',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'advanceWidthMax',
            type: 'UFWORD',
            value: 0
        },
        {
            name: 'minLeftSideBearing',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'minRightSideBearing',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'xMaxExtent',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'caretSlopeRise',
            type: 'SHORT',
            value: 1
        },
        {
            name: 'caretSlopeRun',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'caretOffset',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'reserved1',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'reserved2',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'reserved3',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'reserved4',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'metricDataFormat',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'numberOfHMetrics',
            type: 'USHORT',
            value: 0
        }
    ], options);
}
exports.default = {
    parse: parseHheaTable,
    make: makeHheaTable
};

},{"../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8K6zn":[function(require,module,exports,__globalThis) {
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    let advanceWidth;
    let leftSideBearing;
    const p = new (0, _parseDefault.default).Parser(data, start);
    for(let i = 0; i < numGlyphs; i += 1){
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        const glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}
function makeHmtxTable(glyphs) {
    const t = new (0, _tableDefault.default).Table('hmtx', []);
    for(let i = 0; i < glyphs.length; i += 1){
        const glyph = glyphs.get(i);
        const advanceWidth = glyph.advanceWidth || 0;
        const leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({
            name: 'advanceWidth_' + i,
            type: 'USHORT',
            value: advanceWidth
        });
        t.fields.push({
            name: 'leftSideBearing_' + i,
            type: 'SHORT',
            value: leftSideBearing
        });
    }
    return t;
}
exports.default = {
    parse: parseHmtxTable,
    make: makeHmtxTable
};

},{"../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6woWu":[function(require,module,exports,__globalThis) {
// The `ltag` table stores IETF BCP-47 language tags. It allows supporting
// languages for which TrueType does not assign a numeric code.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html
// http://www.w3.org/International/articles/language-tags/
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
function makeLtagTable(tags) {
    const result = new (0, _tableDefault.default).Table('ltag', [
        {
            name: 'version',
            type: 'ULONG',
            value: 1
        },
        {
            name: 'flags',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'numTags',
            type: 'ULONG',
            value: tags.length
        }
    ]);
    let stringPool = '';
    const stringPoolOffset = 12 + tags.length * 4;
    for(let i = 0; i < tags.length; ++i){
        let pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }
        result.fields.push({
            name: 'offset ' + i,
            type: 'USHORT',
            value: stringPoolOffset + pos
        });
        result.fields.push({
            name: 'length ' + i,
            type: 'USHORT',
            value: tags[i].length
        });
    }
    result.fields.push({
        name: 'stringPool',
        type: 'CHARARRAY',
        value: stringPool
    });
    return result;
}
function parseLtagTable(data, start) {
    const p = new (0, _parseDefault.default).Parser(data, start);
    const tableVersion = p.parseULong();
    (0, _checkDefault.default).argument(tableVersion === 1, 'Unsupported ltag table version.');
    // The 'ltag' specification does not define any flags; skip the field.
    p.skip('uLong', 1);
    const numTags = p.parseULong();
    const tags = [];
    for(let i = 0; i < numTags; i++){
        let tag = '';
        const offset = start + p.parseUShort();
        const length = p.parseUShort();
        for(let j = offset; j < offset + length; ++j)tag += String.fromCharCode(data.getInt8(j));
        tags.push(tag);
    }
    return tags;
}
exports.default = {
    make: makeLtagTable,
    parse: parseLtagTable
};

},{"../check":"184gJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eUb67":[function(require,module,exports,__globalThis) {
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    const maxp = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }
    return maxp;
}
function makeMaxpTable(numGlyphs) {
    return new (0, _tableDefault.default).Table('maxp', [
        {
            name: 'version',
            type: 'FIXED',
            value: 0x00005000
        },
        {
            name: 'numGlyphs',
            type: 'USHORT',
            value: numGlyphs
        }
    ]);
}
exports.default = {
    parse: parseMaxpTable,
    make: makeMaxpTable
};

},{"../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1D4sA":[function(require,module,exports,__globalThis) {
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _types = require("../types");
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// NameIDs for the name table.
const nameTableNames = [
    'copyright',
    'fontFamily',
    'fontSubfamily',
    'uniqueID',
    'fullName',
    'version',
    'postScriptName',
    'trademark',
    'manufacturer',
    'designer',
    'description',
    'manufacturerURL',
    'designerURL',
    'license',
    'licenseURL',
    'reserved',
    'preferredFamily',
    'preferredSubfamily',
    'compatibleFullName',
    'sampleText',
    'postScriptFindFontName',
    'wwsFamily',
    'wwsSubfamily' // 22
];
const macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};
// MacOS language ID  MacOS script ID
//
// Note that the script ID is not sufficient to determine what encoding
// to use in TrueType files. For some languages, MacOS used a modification
// of a mainstream script. For example, an Icelandic name would be stored
// with smRoman in the TrueType naming table, but the actual encoding
// is a special Icelandic version of the normal Macintosh Roman encoding.
// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
// Syllables but MacOS had run out of available script codes, so this was
// done as a (pretty radical) "modification" of Ethiopic.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
const macLanguageToScript = {
    0: 0,
    1: 0,
    2: 0,
    3: 0,
    4: 0,
    5: 0,
    6: 0,
    7: 0,
    8: 0,
    9: 0,
    10: 5,
    11: 1,
    12: 4,
    13: 0,
    14: 6,
    15: 0,
    16: 0,
    17: 0,
    18: 0,
    19: 2,
    20: 4,
    21: 9,
    22: 21,
    23: 3,
    24: 29,
    25: 29,
    26: 29,
    27: 29,
    28: 29,
    29: 0,
    30: 0,
    31: 4,
    32: 7,
    33: 25,
    34: 0,
    35: 0,
    36: 0,
    37: 0,
    38: 29,
    39: 29,
    40: 0,
    41: 5,
    42: 7,
    43: 7,
    44: 7,
    45: 7,
    46: 7,
    47: 7,
    48: 7,
    49: 7,
    50: 4,
    51: 24,
    52: 23,
    53: 7,
    54: 7,
    55: 7,
    56: 7,
    57: 27,
    58: 7,
    59: 4,
    60: 4,
    61: 4,
    62: 4,
    63: 26,
    64: 9,
    65: 9,
    66: 9,
    67: 13,
    68: 13,
    69: 11,
    70: 10,
    71: 12,
    72: 17,
    73: 16,
    74: 14,
    75: 15,
    76: 18,
    77: 19,
    78: 20,
    79: 22,
    80: 30,
    81: 0,
    82: 0,
    83: 0,
    84: 4,
    85: 28,
    86: 28,
    87: 28,
    88: 0,
    89: 0,
    90: 0,
    91: 0,
    92: 0,
    93: 0,
    94: 0,
    128: 0,
    129: 0,
    130: 0,
    131: 0,
    132: 0,
    133: 0,
    134: 0,
    135: 7,
    136: 4,
    137: 26,
    138: 0,
    139: 0,
    140: 0,
    141: 0,
    142: 0,
    143: 28,
    144: 0,
    145: 0,
    146: 0,
    147: 0,
    148: 6,
    149: 0,
    150: 0,
    151: 0 // langNynorsk  smRoman
};
// While Microsoft indicates a region/country for all its language
// IDs, we omit the region code if it's equal to the "most likely
// region subtag" according to Unicode CLDR. For scripts, we omit
// the subtag if it is equal to the Suppress-Script entry in the
// IANA language subtag registry for IETF BCP 47.
//
// For example, Microsoft states that its language code 0x041A is
// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
// and not 'hr-HR' because Croatia is the default country for Croatian,
// according to Unicode CLDR. As another example, Microsoft states
// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
// for the Croatian language, according to IANA.
//
// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
const windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',
    // Microsoft has defined two different language codes for
    // Spanish with modern sorting and Spanish with traditional
    // sorting. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give es in both cases.
    0x0C0A: 'es',
    0x040A: 'es',
    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};
// Returns a IETF BCP 47 language code, for example 'zh-Hant'
// for 'Chinese in the traditional script'.
function getLanguageCode(platformID, languageID, ltag) {
    switch(platformID){
        case 0:
            if (languageID === 0xFFFF) return 'und';
            else if (ltag) return ltag[languageID];
            break;
        case 1:
            return macLanguages[languageID];
        case 3:
            return windowsLanguages[languageID];
    }
    return undefined;
}
const utf16 = 'utf-16';
// MacOS script ID  encoding. This table stores the default case,
// which can be overridden by macLanguageEncodings.
const macScriptEncodings = {
    0: 'macintosh',
    1: 'x-mac-japanese',
    2: 'x-mac-chinesetrad',
    3: 'x-mac-korean',
    6: 'x-mac-greek',
    7: 'x-mac-cyrillic',
    9: 'x-mac-devanagai',
    10: 'x-mac-gurmukhi',
    11: 'x-mac-gujarati',
    12: 'x-mac-oriya',
    13: 'x-mac-bengali',
    14: 'x-mac-tamil',
    15: 'x-mac-telugu',
    16: 'x-mac-kannada',
    17: 'x-mac-malayalam',
    18: 'x-mac-sinhalese',
    19: 'x-mac-burmese',
    20: 'x-mac-khmer',
    21: 'x-mac-thai',
    22: 'x-mac-lao',
    23: 'x-mac-georgian',
    24: 'x-mac-armenian',
    25: 'x-mac-chinesesimp',
    26: 'x-mac-tibetan',
    27: 'x-mac-mongolian',
    28: 'x-mac-ethiopic',
    29: 'x-mac-ce',
    30: 'x-mac-vietnamese',
    31: 'x-mac-extarabic' // smExtArabic
};
// MacOS language ID  encoding. This table stores the exceptional
// cases, which override macScriptEncodings. For writing MacOS naming
// tables, we need to emit a MacOS script ID. Therefore, we cannot
// merge macScriptEncodings into macLanguageEncodings.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
const macLanguageEncodings = {
    15: 'x-mac-icelandic',
    17: 'x-mac-turkish',
    18: 'x-mac-croatian',
    24: 'x-mac-ce',
    25: 'x-mac-ce',
    26: 'x-mac-ce',
    27: 'x-mac-ce',
    28: 'x-mac-ce',
    30: 'x-mac-icelandic',
    37: 'x-mac-romanian',
    38: 'x-mac-ce',
    39: 'x-mac-ce',
    40: 'x-mac-ce',
    143: 'x-mac-inuit',
    146: 'x-mac-gaelic' // langIrishGaelicScript
};
function getEncoding(platformID, encodingID, languageID) {
    switch(platformID){
        case 0:
            return utf16;
        case 1:
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
        case 3:
            if (encodingID === 1 || encodingID === 10) return utf16;
            break;
    }
    return undefined;
}
// Parse the naming `name` table.
// FIXME: Format 1 additional fields are not supported yet.
// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
function parseNameTable(data, start, ltag) {
    const name = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    const format = p.parseUShort();
    const count = p.parseUShort();
    const stringOffset = p.offset + p.parseUShort();
    for(let i = 0; i < count; i++){
        const platformID = p.parseUShort();
        const encodingID = p.parseUShort();
        const languageID = p.parseUShort();
        const nameID = p.parseUShort();
        const property = nameTableNames[nameID] || nameID;
        const byteLength = p.parseUShort();
        const offset = p.parseUShort();
        const language = getLanguageCode(platformID, languageID, ltag);
        const encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            let text;
            if (encoding === utf16) text = (0, _types.decode).UTF16(data, stringOffset + offset, byteLength);
            else text = (0, _types.decode).MACSTRING(data, stringOffset + offset, byteLength, encoding);
            if (text) {
                let translations = name[property];
                if (translations === undefined) translations = name[property] = {};
                translations[language] = text;
            }
        }
    }
    let langTagCount = 0;
    if (format === 1) // FIXME: Also handle Microsoft's 'name' table 1.
    langTagCount = p.parseUShort();
    return name;
}
// {23: 'foo'}  {'foo': 23}
// ['bar', 'baz']  {'bar': 0, 'baz': 1}
function reverseDict(dict) {
    const result = {};
    for(let key in dict)result[dict[key]] = parseInt(key);
    return result;
}
function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new (0, _tableDefault.default).Record('NameRecord', [
        {
            name: 'platformID',
            type: 'USHORT',
            value: platformID
        },
        {
            name: 'encodingID',
            type: 'USHORT',
            value: encodingID
        },
        {
            name: 'languageID',
            type: 'USHORT',
            value: languageID
        },
        {
            name: 'nameID',
            type: 'USHORT',
            value: nameID
        },
        {
            name: 'length',
            type: 'USHORT',
            value: length
        },
        {
            name: 'offset',
            type: 'USHORT',
            value: offset
        }
    ]);
}
// Finds the position of needle in haystack, or -1 if not there.
// Like String.indexOf(), but for arrays.
function findSubArray(needle, haystack) {
    const needleLength = needle.length;
    const limit = haystack.length - needleLength + 1;
    loop: for(let pos = 0; pos < limit; pos++)for(; pos < limit; pos++){
        for(let k = 0; k < needleLength; k++){
            if (haystack[pos + k] !== needle[k]) continue loop;
        }
        return pos;
    }
    return -1;
}
function addStringToPool(s, pool) {
    let offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        let i = 0;
        const len = s.length;
        for(; i < len; ++i)pool.push(s[i]);
    }
    return offset;
}
function makeNameTable(names, ltag) {
    let nameID;
    const nameIDs = [];
    const namesWithNumericKeys = {};
    const nameTableIds = reverseDict(nameTableNames);
    for(let key in names){
        let id = nameTableIds[key];
        if (id === undefined) id = key;
        nameID = parseInt(id);
        if (isNaN(nameID)) throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }
    const macLanguageIds = reverseDict(macLanguages);
    const windowsLanguageIds = reverseDict(windowsLanguages);
    const nameRecords = [];
    const stringPool = [];
    for(let i = 0; i < nameIDs.length; i++){
        nameID = nameIDs[i];
        const translations = namesWithNumericKeys[nameID];
        for(let lang in translations){
            const text = translations[lang];
            // For MacOS, we try to emit the name in the form that was introduced
            // in the initial version of the TrueType spec (in the late 1980s).
            // However, this can fail for various reasons: the requested BCP 47
            // language code might not have an old-style Mac equivalent;
            // we might not have a codec for the needed character encoding;
            // or the name might contain characters that cannot be expressed
            // in the old-style Macintosh encoding. In case of failure, we emit
            // the name in a more modern fashion (Unicode encoding with BCP 47
            // language tags) that is recognized by MacOS 10.5, released in 2009.
            // If fonts were only read by operating systems, we could simply
            // emit all names in the modern form; this would be much easier.
            // However, there are many applications and libraries that read
            // 'name' tables directly, and these will usually only recognize
            // the ancient form (silently skipping the unrecognized names).
            let macPlatform = 1; // Macintosh
            let macLanguage = macLanguageIds[lang];
            let macScript = macLanguageToScript[macLanguage];
            const macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            let macName = (0, _types.encode).MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0; // Unicode
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }
                macScript = 4; // Unicode 2.0 and later
                macName = (0, _types.encode).UTF16(text);
            }
            const macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage, nameID, macName.length, macNameOffset));
            const winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                const winName = (0, _types.encode).UTF16(text);
                const winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage, nameID, winName.length, winNameOffset));
            }
        }
    }
    nameRecords.sort(function(a, b) {
        return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;
    });
    const t = new (0, _tableDefault.default).Table('name', [
        {
            name: 'format',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'count',
            type: 'USHORT',
            value: nameRecords.length
        },
        {
            name: 'stringOffset',
            type: 'USHORT',
            value: 6 + nameRecords.length * 12
        }
    ]);
    for(let r = 0; r < nameRecords.length; r++)t.fields.push({
        name: 'record_' + r,
        type: 'RECORD',
        value: nameRecords[r]
    });
    t.fields.push({
        name: 'strings',
        type: 'LITERAL',
        value: stringPool
    });
    return t;
}
exports.default = {
    parse: parseNameTable,
    make: makeNameTable
};

},{"../types":"lc3FJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7A4bk":[function(require,module,exports,__globalThis) {
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
const unicodeRanges = [
    {
        begin: 0x0000,
        end: 0x007F
    },
    {
        begin: 0x0080,
        end: 0x00FF
    },
    {
        begin: 0x0100,
        end: 0x017F
    },
    {
        begin: 0x0180,
        end: 0x024F
    },
    {
        begin: 0x0250,
        end: 0x02AF
    },
    {
        begin: 0x02B0,
        end: 0x02FF
    },
    {
        begin: 0x0300,
        end: 0x036F
    },
    {
        begin: 0x0370,
        end: 0x03FF
    },
    {
        begin: 0x2C80,
        end: 0x2CFF
    },
    {
        begin: 0x0400,
        end: 0x04FF
    },
    {
        begin: 0x0530,
        end: 0x058F
    },
    {
        begin: 0x0590,
        end: 0x05FF
    },
    {
        begin: 0xA500,
        end: 0xA63F
    },
    {
        begin: 0x0600,
        end: 0x06FF
    },
    {
        begin: 0x07C0,
        end: 0x07FF
    },
    {
        begin: 0x0900,
        end: 0x097F
    },
    {
        begin: 0x0980,
        end: 0x09FF
    },
    {
        begin: 0x0A00,
        end: 0x0A7F
    },
    {
        begin: 0x0A80,
        end: 0x0AFF
    },
    {
        begin: 0x0B00,
        end: 0x0B7F
    },
    {
        begin: 0x0B80,
        end: 0x0BFF
    },
    {
        begin: 0x0C00,
        end: 0x0C7F
    },
    {
        begin: 0x0C80,
        end: 0x0CFF
    },
    {
        begin: 0x0D00,
        end: 0x0D7F
    },
    {
        begin: 0x0E00,
        end: 0x0E7F
    },
    {
        begin: 0x0E80,
        end: 0x0EFF
    },
    {
        begin: 0x10A0,
        end: 0x10FF
    },
    {
        begin: 0x1B00,
        end: 0x1B7F
    },
    {
        begin: 0x1100,
        end: 0x11FF
    },
    {
        begin: 0x1E00,
        end: 0x1EFF
    },
    {
        begin: 0x1F00,
        end: 0x1FFF
    },
    {
        begin: 0x2000,
        end: 0x206F
    },
    {
        begin: 0x2070,
        end: 0x209F
    },
    {
        begin: 0x20A0,
        end: 0x20CF
    },
    {
        begin: 0x20D0,
        end: 0x20FF
    },
    {
        begin: 0x2100,
        end: 0x214F
    },
    {
        begin: 0x2150,
        end: 0x218F
    },
    {
        begin: 0x2190,
        end: 0x21FF
    },
    {
        begin: 0x2200,
        end: 0x22FF
    },
    {
        begin: 0x2300,
        end: 0x23FF
    },
    {
        begin: 0x2400,
        end: 0x243F
    },
    {
        begin: 0x2440,
        end: 0x245F
    },
    {
        begin: 0x2460,
        end: 0x24FF
    },
    {
        begin: 0x2500,
        end: 0x257F
    },
    {
        begin: 0x2580,
        end: 0x259F
    },
    {
        begin: 0x25A0,
        end: 0x25FF
    },
    {
        begin: 0x2600,
        end: 0x26FF
    },
    {
        begin: 0x2700,
        end: 0x27BF
    },
    {
        begin: 0x3000,
        end: 0x303F
    },
    {
        begin: 0x3040,
        end: 0x309F
    },
    {
        begin: 0x30A0,
        end: 0x30FF
    },
    {
        begin: 0x3100,
        end: 0x312F
    },
    {
        begin: 0x3130,
        end: 0x318F
    },
    {
        begin: 0xA840,
        end: 0xA87F
    },
    {
        begin: 0x3200,
        end: 0x32FF
    },
    {
        begin: 0x3300,
        end: 0x33FF
    },
    {
        begin: 0xAC00,
        end: 0xD7AF
    },
    {
        begin: 0xD800,
        end: 0xDFFF
    },
    {
        begin: 0x10900,
        end: 0x1091F
    },
    {
        begin: 0x4E00,
        end: 0x9FFF
    },
    {
        begin: 0xE000,
        end: 0xF8FF
    },
    {
        begin: 0x31C0,
        end: 0x31EF
    },
    {
        begin: 0xFB00,
        end: 0xFB4F
    },
    {
        begin: 0xFB50,
        end: 0xFDFF
    },
    {
        begin: 0xFE20,
        end: 0xFE2F
    },
    {
        begin: 0xFE10,
        end: 0xFE1F
    },
    {
        begin: 0xFE50,
        end: 0xFE6F
    },
    {
        begin: 0xFE70,
        end: 0xFEFF
    },
    {
        begin: 0xFF00,
        end: 0xFFEF
    },
    {
        begin: 0xFFF0,
        end: 0xFFFF
    },
    {
        begin: 0x0F00,
        end: 0x0FFF
    },
    {
        begin: 0x0700,
        end: 0x074F
    },
    {
        begin: 0x0780,
        end: 0x07BF
    },
    {
        begin: 0x0D80,
        end: 0x0DFF
    },
    {
        begin: 0x1000,
        end: 0x109F
    },
    {
        begin: 0x1200,
        end: 0x137F
    },
    {
        begin: 0x13A0,
        end: 0x13FF
    },
    {
        begin: 0x1400,
        end: 0x167F
    },
    {
        begin: 0x1680,
        end: 0x169F
    },
    {
        begin: 0x16A0,
        end: 0x16FF
    },
    {
        begin: 0x1780,
        end: 0x17FF
    },
    {
        begin: 0x1800,
        end: 0x18AF
    },
    {
        begin: 0x2800,
        end: 0x28FF
    },
    {
        begin: 0xA000,
        end: 0xA48F
    },
    {
        begin: 0x1700,
        end: 0x171F
    },
    {
        begin: 0x10300,
        end: 0x1032F
    },
    {
        begin: 0x10330,
        end: 0x1034F
    },
    {
        begin: 0x10400,
        end: 0x1044F
    },
    {
        begin: 0x1D000,
        end: 0x1D0FF
    },
    {
        begin: 0x1D400,
        end: 0x1D7FF
    },
    {
        begin: 0xFF000,
        end: 0xFFFFD
    },
    {
        begin: 0xFE00,
        end: 0xFE0F
    },
    {
        begin: 0xE0000,
        end: 0xE007F
    },
    {
        begin: 0x1900,
        end: 0x194F
    },
    {
        begin: 0x1950,
        end: 0x197F
    },
    {
        begin: 0x1980,
        end: 0x19DF
    },
    {
        begin: 0x1A00,
        end: 0x1A1F
    },
    {
        begin: 0x2C00,
        end: 0x2C5F
    },
    {
        begin: 0x2D30,
        end: 0x2D7F
    },
    {
        begin: 0x4DC0,
        end: 0x4DFF
    },
    {
        begin: 0xA800,
        end: 0xA82F
    },
    {
        begin: 0x10000,
        end: 0x1007F
    },
    {
        begin: 0x10140,
        end: 0x1018F
    },
    {
        begin: 0x10380,
        end: 0x1039F
    },
    {
        begin: 0x103A0,
        end: 0x103DF
    },
    {
        begin: 0x10450,
        end: 0x1047F
    },
    {
        begin: 0x10480,
        end: 0x104AF
    },
    {
        begin: 0x10800,
        end: 0x1083F
    },
    {
        begin: 0x10A00,
        end: 0x10A5F
    },
    {
        begin: 0x1D300,
        end: 0x1D35F
    },
    {
        begin: 0x12000,
        end: 0x123FF
    },
    {
        begin: 0x1D360,
        end: 0x1D37F
    },
    {
        begin: 0x1B80,
        end: 0x1BBF
    },
    {
        begin: 0x1C00,
        end: 0x1C4F
    },
    {
        begin: 0x1C50,
        end: 0x1C7F
    },
    {
        begin: 0xA880,
        end: 0xA8DF
    },
    {
        begin: 0xA900,
        end: 0xA92F
    },
    {
        begin: 0xA930,
        end: 0xA95F
    },
    {
        begin: 0xAA00,
        end: 0xAA5F
    },
    {
        begin: 0x10190,
        end: 0x101CF
    },
    {
        begin: 0x101D0,
        end: 0x101FF
    },
    {
        begin: 0x102A0,
        end: 0x102DF
    },
    {
        begin: 0x1F030,
        end: 0x1F09F
    } // Domino Tiles
];
function getUnicodeRange(unicode) {
    for(let i = 0; i < unicodeRanges.length; i += 1){
        const range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) return i;
    }
    return -1;
}
// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    const os2 = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for(let i = 0; i < 10; i++)os2.panose[i] = p.parseByte();
    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }
    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }
    return os2;
}
function makeOS2Table(options) {
    return new (0, _tableDefault.default).Table('OS/2', [
        {
            name: 'version',
            type: 'USHORT',
            value: 0x0003
        },
        {
            name: 'xAvgCharWidth',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'usWeightClass',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'usWidthClass',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'fsType',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'ySubscriptXSize',
            type: 'SHORT',
            value: 650
        },
        {
            name: 'ySubscriptYSize',
            type: 'SHORT',
            value: 699
        },
        {
            name: 'ySubscriptXOffset',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'ySubscriptYOffset',
            type: 'SHORT',
            value: 140
        },
        {
            name: 'ySuperscriptXSize',
            type: 'SHORT',
            value: 650
        },
        {
            name: 'ySuperscriptYSize',
            type: 'SHORT',
            value: 699
        },
        {
            name: 'ySuperscriptXOffset',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'ySuperscriptYOffset',
            type: 'SHORT',
            value: 479
        },
        {
            name: 'yStrikeoutSize',
            type: 'SHORT',
            value: 49
        },
        {
            name: 'yStrikeoutPosition',
            type: 'SHORT',
            value: 258
        },
        {
            name: 'sFamilyClass',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'bFamilyType',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bSerifStyle',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bWeight',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bProportion',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bContrast',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bStrokeVariation',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bArmStyle',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bLetterform',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bMidline',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'bXHeight',
            type: 'BYTE',
            value: 0
        },
        {
            name: 'ulUnicodeRange1',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'ulUnicodeRange2',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'ulUnicodeRange3',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'ulUnicodeRange4',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'achVendID',
            type: 'CHARARRAY',
            value: 'XXXX'
        },
        {
            name: 'fsSelection',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'usFirstCharIndex',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'usLastCharIndex',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'sTypoAscender',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'sTypoDescender',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'sTypoLineGap',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'usWinAscent',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'usWinDescent',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'ulCodePageRange1',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'ulCodePageRange2',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'sxHeight',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'sCapHeight',
            type: 'SHORT',
            value: 0
        },
        {
            name: 'usDefaultChar',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'usBreakChar',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'usMaxContext',
            type: 'USHORT',
            value: 0
        }
    ], options);
}
exports.default = {
    parse: parseOS2Table,
    make: makeOS2Table,
    unicodeRanges,
    getUnicodeRange
};

},{"../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jd3Uk":[function(require,module,exports,__globalThis) {
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _encoding = require("../encoding");
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Parse the PostScript `post` table
function parsePostTable(data, start) {
    const post = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch(post.version){
        case 1:
            post.names = (0, _encoding.standardNames).slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for(let i = 0; i < post.numberOfGlyphs; i++)post.glyphNameIndex[i] = p.parseUShort();
            post.names = [];
            for(let i = 0; i < post.numberOfGlyphs; i++)if (post.glyphNameIndex[i] >= (0, _encoding.standardNames).length) {
                const nameLength = p.parseChar();
                post.names.push(p.parseString(nameLength));
            }
            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for(let i = 0; i < post.numberOfGlyphs; i++)post.offset[i] = p.parseChar();
            break;
    }
    return post;
}
function makePostTable() {
    return new (0, _tableDefault.default).Table('post', [
        {
            name: 'version',
            type: 'FIXED',
            value: 0x00030000
        },
        {
            name: 'italicAngle',
            type: 'FIXED',
            value: 0
        },
        {
            name: 'underlinePosition',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'underlineThickness',
            type: 'FWORD',
            value: 0
        },
        {
            name: 'isFixedPitch',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'minMemType42',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'maxMemType42',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'minMemType1',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'maxMemType1',
            type: 'ULONG',
            value: 0
        }
    ]);
}
exports.default = {
    parse: parsePostTable,
    make: makePostTable
};

},{"../encoding":"lPZPs","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kFRDp":[function(require,module,exports,__globalThis) {
// The `GSUB` table contains ligatures, among other things.
// https://www.microsoft.com/typography/OTSPEC/gsub.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
const subtableParsers = new Array(9); // subtableParsers[0] is unused
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
subtableParsers[1] = function parseLookup1() {
    const start = this.offset + this.relativeOffset;
    const substFormat = this.parseUShort();
    if (substFormat === 1) return {
        substFormat: 1,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        deltaGlyphId: this.parseUShort()
    };
    else if (substFormat === 2) return {
        substFormat: 2,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        substitute: this.parseOffset16List()
    };
    (0, _checkDefault.default).assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
subtableParsers[2] = function parseLookup2() {
    const substFormat = this.parseUShort();
    (0, _checkDefault.default).argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        sequences: this.parseListOfLists()
    };
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
subtableParsers[3] = function parseLookup3() {
    const substFormat = this.parseUShort();
    (0, _checkDefault.default).argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        alternateSets: this.parseListOfLists()
    };
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
subtableParsers[4] = function parseLookup4() {
    const substFormat = this.parseUShort();
    (0, _checkDefault.default).argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        ligatureSets: this.parseListOfLists(function() {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};
const lookupRecordDesc = {
    sequenceIndex: (0, _parse.Parser).uShort,
    lookupListIndex: (0, _parse.Parser).uShort
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
subtableParsers[5] = function parseLookup5() {
    const start = this.offset + this.relativeOffset;
    const substFormat = this.parseUShort();
    if (substFormat === 1) return {
        substFormat: substFormat,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        ruleSets: this.parseListOfLists(function() {
            const glyphCount = this.parseUShort();
            const substCount = this.parseUShort();
            return {
                input: this.parseUShortList(glyphCount - 1),
                lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
            };
        })
    };
    else if (substFormat === 2) return {
        substFormat: substFormat,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        classDef: this.parsePointer((0, _parse.Parser).classDef),
        classSets: this.parseListOfLists(function() {
            const glyphCount = this.parseUShort();
            const substCount = this.parseUShort();
            return {
                classes: this.parseUShortList(glyphCount - 1),
                lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
            };
        })
    };
    else if (substFormat === 3) {
        const glyphCount = this.parseUShort();
        const substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, (0, _parse.Parser).pointer((0, _parse.Parser).coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    (0, _checkDefault.default).assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
subtableParsers[6] = function parseLookup6() {
    const start = this.offset + this.relativeOffset;
    const substFormat = this.parseUShort();
    if (substFormat === 1) return {
        substFormat: 1,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        chainRuleSets: this.parseListOfLists(function() {
            return {
                backtrack: this.parseUShortList(),
                input: this.parseUShortList(this.parseShort() - 1),
                lookahead: this.parseUShortList(),
                lookupRecords: this.parseRecordList(lookupRecordDesc)
            };
        })
    };
    else if (substFormat === 2) return {
        substFormat: 2,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        backtrackClassDef: this.parsePointer((0, _parse.Parser).classDef),
        inputClassDef: this.parsePointer((0, _parse.Parser).classDef),
        lookaheadClassDef: this.parsePointer((0, _parse.Parser).classDef),
        chainClassSet: this.parseListOfLists(function() {
            return {
                backtrack: this.parseUShortList(),
                input: this.parseUShortList(this.parseShort() - 1),
                lookahead: this.parseUShortList(),
                lookupRecords: this.parseRecordList(lookupRecordDesc)
            };
        })
    };
    else if (substFormat === 3) return {
        substFormat: 3,
        backtrackCoverage: this.parseList((0, _parse.Parser).pointer((0, _parse.Parser).coverage)),
        inputCoverage: this.parseList((0, _parse.Parser).pointer((0, _parse.Parser).coverage)),
        lookaheadCoverage: this.parseList((0, _parse.Parser).pointer((0, _parse.Parser).coverage)),
        lookupRecords: this.parseRecordList(lookupRecordDesc)
    };
    (0, _checkDefault.default).assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
subtableParsers[7] = function parseLookup7() {
    // Extension Substitution subtable
    const substFormat = this.parseUShort();
    (0, _checkDefault.default).argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    const extensionLookupType = this.parseUShort();
    const extensionParser = new (0, _parse.Parser)(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};
// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
subtableParsers[8] = function parseLookup8() {
    const substFormat = this.parseUShort();
    (0, _checkDefault.default).argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        backtrackCoverage: this.parseList((0, _parse.Parser).pointer((0, _parse.Parser).coverage)),
        lookaheadCoverage: this.parseList((0, _parse.Parser).pointer((0, _parse.Parser).coverage)),
        substitutes: this.parseUShortList()
    };
};
// https://www.microsoft.com/typography/OTSPEC/gsub.htm
function parseGsubTable(data, start) {
    start = start || 0;
    const p = new (0, _parse.Parser)(data, start);
    const tableVersion = p.parseVersion(1);
    (0, _checkDefault.default).argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
    if (tableVersion === 1) return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers)
    };
    else return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers),
        variations: p.parseFeatureVariationsList()
    };
}
// GSUB Writing //////////////////////////////////////////////
const subtableMakers = new Array(9);
subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) return new (0, _tableDefault.default).Table('substitutionTable', [
        {
            name: 'substFormat',
            type: 'USHORT',
            value: 1
        },
        {
            name: 'coverage',
            type: 'TABLE',
            value: new (0, _tableDefault.default).Coverage(subtable.coverage)
        },
        {
            name: 'deltaGlyphID',
            type: 'USHORT',
            value: subtable.deltaGlyphId
        }
    ]);
    else return new (0, _tableDefault.default).Table('substitutionTable', [
        {
            name: 'substFormat',
            type: 'USHORT',
            value: 2
        },
        {
            name: 'coverage',
            type: 'TABLE',
            value: new (0, _tableDefault.default).Coverage(subtable.coverage)
        }
    ].concat((0, _tableDefault.default).ushortList('substitute', subtable.substitute)));
    (0, _checkDefault.default).fail('Lookup type 1 substFormat must be 1 or 2.');
};
subtableMakers[3] = function makeLookup3(subtable) {
    (0, _checkDefault.default).assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new (0, _tableDefault.default).Table('substitutionTable', [
        {
            name: 'substFormat',
            type: 'USHORT',
            value: 1
        },
        {
            name: 'coverage',
            type: 'TABLE',
            value: new (0, _tableDefault.default).Coverage(subtable.coverage)
        }
    ].concat((0, _tableDefault.default).tableList('altSet', subtable.alternateSets, function(alternateSet) {
        return new (0, _tableDefault.default).Table('alternateSetTable', (0, _tableDefault.default).ushortList('alternate', alternateSet));
    })));
};
subtableMakers[4] = function makeLookup4(subtable) {
    (0, _checkDefault.default).assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new (0, _tableDefault.default).Table('substitutionTable', [
        {
            name: 'substFormat',
            type: 'USHORT',
            value: 1
        },
        {
            name: 'coverage',
            type: 'TABLE',
            value: new (0, _tableDefault.default).Coverage(subtable.coverage)
        }
    ].concat((0, _tableDefault.default).tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
        return new (0, _tableDefault.default).Table('ligatureSetTable', (0, _tableDefault.default).tableList('ligature', ligatureSet, function(ligature) {
            return new (0, _tableDefault.default).Table('ligatureTable', [
                {
                    name: 'ligGlyph',
                    type: 'USHORT',
                    value: ligature.ligGlyph
                }
            ].concat((0, _tableDefault.default).ushortList('component', ligature.components, ligature.components.length + 1)));
        }));
    })));
};
function makeGsubTable(gsub) {
    return new (0, _tableDefault.default).Table('GSUB', [
        {
            name: 'version',
            type: 'ULONG',
            value: 0x10000
        },
        {
            name: 'scripts',
            type: 'TABLE',
            value: new (0, _tableDefault.default).ScriptList(gsub.scripts)
        },
        {
            name: 'features',
            type: 'TABLE',
            value: new (0, _tableDefault.default).FeatureList(gsub.features)
        },
        {
            name: 'lookups',
            type: 'TABLE',
            value: new (0, _tableDefault.default).LookupList(gsub.lookups, subtableMakers)
        }
    ]);
}
exports.default = {
    parse: parseGsubTable,
    make: makeGsubTable
};

},{"../check":"184gJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k28Ba":[function(require,module,exports,__globalThis) {
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _types = require("../types");
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
// Parse the metadata `meta` table.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
function parseMetaTable(data, start) {
    const p = new (0, _parseDefault.default).Parser(data, start);
    const tableVersion = p.parseULong();
    (0, _checkDefault.default).argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong(); // flags - currently unused and set to 0
    p.parseULong(); // tableOffset
    const numDataMaps = p.parseULong();
    const tags = {};
    for(let i = 0; i < numDataMaps; i++){
        const tag = p.parseTag();
        const dataOffset = p.parseULong();
        const dataLength = p.parseULong();
        const text = (0, _types.decode).UTF8(data, start + dataOffset, dataLength);
        tags[tag] = text;
    }
    return tags;
}
function makeMetaTable(tags) {
    const numTags = Object.keys(tags).length;
    let stringPool = '';
    const stringPoolOffset = 16 + numTags * 12;
    const result = new (0, _tableDefault.default).Table('meta', [
        {
            name: 'version',
            type: 'ULONG',
            value: 1
        },
        {
            name: 'flags',
            type: 'ULONG',
            value: 0
        },
        {
            name: 'offset',
            type: 'ULONG',
            value: stringPoolOffset
        },
        {
            name: 'numTags',
            type: 'ULONG',
            value: numTags
        }
    ]);
    for(let tag in tags){
        const pos = stringPool.length;
        stringPool += tags[tag];
        result.fields.push({
            name: 'tag ' + tag,
            type: 'TAG',
            value: tag
        });
        result.fields.push({
            name: 'offset ' + tag,
            type: 'ULONG',
            value: stringPoolOffset + pos
        });
        result.fields.push({
            name: 'length ' + tag,
            type: 'ULONG',
            value: tags[tag].length
        });
    }
    result.fields.push({
        name: 'stringPool',
        type: 'CHARARRAY',
        value: stringPool
    });
    return result;
}
exports.default = {
    parse: parseMetaTable,
    make: makeMetaTable
};

},{"../check":"184gJ","../types":"lc3FJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5To8e":[function(require,module,exports,__globalThis) {
// The Position object provides utility methods to manipulate
// the GPOS position table.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layout = require("./layout");
var _layoutDefault = parcelHelpers.interopDefault(_layout);
/**
 * @exports opentype.Position
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */ function Position(font) {
    (0, _layoutDefault.default).call(this, font, 'gpos');
}
Position.prototype = (0, _layoutDefault.default).prototype;
/**
 * Init some data for faster and easier access later.
 */ Position.prototype.init = function() {
    const script = this.getDefaultScriptName();
    this.defaultKerningTables = this.getKerningTables(script);
};
/**
 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
 *
 * @param {integer} leftIndex - left glyph index
 * @param {integer} rightIndex - right glyph index
 * @returns {integer}
 */ Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
    for(let i = 0; i < kerningLookups.length; i++){
        const subtables = kerningLookups[i].subtables;
        for(let j = 0; j < subtables.length; j++){
            const subtable = subtables[j];
            const covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
            if (covIndex < 0) continue;
            switch(subtable.posFormat){
                case 1:
                    // Search Pair Adjustment Positioning Format 1
                    let pairSet = subtable.pairSets[covIndex];
                    for(let k = 0; k < pairSet.length; k++){
                        let pair = pairSet[k];
                        if (pair.secondGlyph === rightIndex) return pair.value1 && pair.value1.xAdvance || 0;
                    }
                    break; // left glyph found, not right glyph - try next subtable
                case 2:
                    // Search Pair Adjustment Positioning Format 2
                    const class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
                    const class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
                    const pair = subtable.classRecords[class1][class2];
                    return pair.value1 && pair.value1.xAdvance || 0;
            }
        }
    }
    return 0;
};
/**
 * List all kerning lookup tables.
 *
 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
 * @param {string} [language='dflt']
 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
 */ Position.prototype.getKerningTables = function(script, language) {
    if (this.font.tables.gpos) return this.getLookupTables(script, language, 'kern', 2);
};
exports.default = Position;

},{"./layout":"lUd0O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lUd0O":[function(require,module,exports,__globalThis) {
// The Layout object is the prototype of Substitution objects, and provides
// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("./check");
var _checkDefault = parcelHelpers.interopDefault(_check);
function searchTag(arr, tag) {
    /* jshint bitwise: false */ let imin = 0;
    let imax = arr.length - 1;
    while(imin <= imax){
        const imid = imin + imax >>> 1;
        const val = arr[imid].tag;
        if (val === tag) return imid;
        else if (val < tag) imin = imid + 1;
        else imax = imid - 1;
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}
function binSearch(arr, value) {
    /* jshint bitwise: false */ let imin = 0;
    let imax = arr.length - 1;
    while(imin <= imax){
        const imid = imin + imax >>> 1;
        const val = arr[imid];
        if (val === value) return imid;
        else if (val < value) imin = imid + 1;
        else imax = imid - 1;
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}
// binary search in a list of ranges (coverage, class definition)
function searchRange(ranges, value) {
    // jshint bitwise: false
    let range;
    let imin = 0;
    let imax = ranges.length - 1;
    while(imin <= imax){
        const imid = imin + imax >>> 1;
        range = ranges[imid];
        const start = range.start;
        if (start === value) return range;
        else if (start < value) imin = imid + 1;
        else imax = imid - 1;
    }
    if (imin > 0) {
        range = ranges[imin - 1];
        if (value > range.end) return 0;
        return range;
    }
}
/**
 * @exports opentype.Layout
 * @class
 */ function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}
Layout.prototype = {
    /**
     * Binary search an object by "tag" property
     * @instance
     * @function searchTag
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {string} tag
     * @return {number}
     */ searchTag: searchTag,
    /**
     * Binary search in a list of numbers
     * @instance
     * @function binSearch
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {number} value
     * @return {number}
     */ binSearch: binSearch,
    /**
     * Get or create the Layout table (GSUB, GPOS etc).
     * @param  {boolean} create - Whether to create a new one.
     * @return {Object} The GSUB or GPOS table.
     */ getTable: function(create) {
        let layout = this.font.tables[this.tableName];
        if (!layout && create) layout = this.font.tables[this.tableName] = this.createDefaultTable();
        return layout;
    },
    /**
     * Returns all scripts in the substitution table.
     * @instance
     * @return {Array}
     */ getScriptNames: function() {
        let layout = this.getTable();
        if (!layout) return [];
        return layout.scripts.map(function(script) {
            return script.tag;
        });
    },
    /**
     * Returns the best bet for a script name.
     * Returns 'DFLT' if it exists.
     * If not, returns 'latn' if it exists.
     * If neither exist, returns undefined.
     */ getDefaultScriptName: function() {
        let layout = this.getTable();
        if (!layout) return;
        let hasLatn = false;
        for(let i = 0; i < layout.scripts.length; i++){
            const name = layout.scripts[i].tag;
            if (name === 'DFLT') return name;
            if (name === 'latn') hasLatn = true;
        }
        if (hasLatn) return 'latn';
    },
    /**
     * Returns all LangSysRecords in the given script.
     * @instance
     * @param {string} [script='DFLT']
     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
     * @return {Object} An object with tag and script properties.
     */ getScriptTable: function(script, create) {
        const layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            const scripts = layout.scripts;
            const pos = searchTag(layout.scripts, script);
            if (pos >= 0) return scripts[pos].script;
            else if (create) {
                const scr = {
                    tag: script,
                    script: {
                        defaultLangSys: {
                            reserved: 0,
                            reqFeatureIndex: 0xffff,
                            featureIndexes: []
                        },
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },
    /**
     * Returns a language system table
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
     * @return {Object}
     */ getLangSysTable: function(script, language, create) {
        const scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') return scriptTable.defaultLangSys;
            const pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) return scriptTable.langSysRecords[pos].langSys;
            else if (create) {
                const langSysRecord = {
                    tag: language,
                    langSys: {
                        reserved: 0,
                        reqFeatureIndex: 0xffff,
                        featureIndexes: []
                    }
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },
    /**
     * Get a specific feature table.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
     * @return {Object}
     */ getFeatureTable: function(script, language, feature, create) {
        const langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            let featureRecord;
            const featIndexes = langSysTable.featureIndexes;
            const allFeatures = this.font.tables[this.tableName].features;
            // The FeatureIndex array of indices is in arbitrary order,
            // even if allFeatures is sorted alphabetically by feature tag.
            for(let i = 0; i < featIndexes.length; i++){
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) return featureRecord.feature;
            }
            if (create) {
                const index = allFeatures.length;
                // Automatic ordering of features would require to shift feature indexes in the script list.
                (0, _checkDefault.default).assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: {
                        params: 0,
                        lookupListIndexes: []
                    }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },
    /**
     * Get the lookup tables of a given type for a script/language/feature.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - 4-letter feature code
     * @param {number} lookupType - 1 to 9
     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
     * @return {Object[]}
     */ getLookupTables: function(script, language, feature, lookupType, create) {
        const featureTable = this.getFeatureTable(script, language, feature, create);
        const tables = [];
        if (featureTable) {
            let lookupTable;
            const lookupListIndexes = featureTable.lookupListIndexes;
            const allLookups = this.font.tables[this.tableName].lookups;
            // lookupListIndexes are in no particular order, so use naive search.
            for(let i = 0; i < lookupListIndexes.length; i++){
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) tables.push(lookupTable);
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                const index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [
                    lookupTable
                ];
            }
        }
        return tables;
    },
    /**
     * Find a glyph in a class definition table
     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
     * @param {object} classDefTable - an OpenType Layout class definition table
     * @param {number} glyphIndex - the index of the glyph to find
     * @returns {number} -1 if not found
     */ getGlyphClass: function(classDefTable, glyphIndex) {
        switch(classDefTable.format){
            case 1:
                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
                return 0;
            case 2:
                const range = searchRange(classDefTable.ranges, glyphIndex);
                return range ? range.classId : 0;
        }
    },
    /**
     * Find a glyph in a coverage table
     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
     * @param {object} coverageTable - an OpenType Layout coverage table
     * @param {number} glyphIndex - the index of the glyph to find
     * @returns {number} -1 if not found
     */ getCoverageIndex: function(coverageTable, glyphIndex) {
        switch(coverageTable.format){
            case 1:
                const index = binSearch(coverageTable.glyphs, glyphIndex);
                return index >= 0 ? index : -1;
            case 2:
                const range = searchRange(coverageTable.ranges, glyphIndex);
                return range ? range.index + glyphIndex - range.start : -1;
        }
    },
    /**
     * Returns the list of glyph indexes of a coverage table.
     * Format 1: the list is stored raw
     * Format 2: compact list as range records.
     * @instance
     * @param  {Object} coverageTable
     * @return {Array}
     */ expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) return coverageTable.glyphs;
        else {
            const glyphs = [];
            const ranges = coverageTable.ranges;
            for(let i = 0; i < ranges.length; i++){
                const range = ranges[i];
                const start = range.start;
                const end = range.end;
                for(let j = start; j <= end; j++)glyphs.push(j);
            }
            return glyphs;
        }
    }
};
exports.default = Layout;

},{"./check":"184gJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iDhKK":[function(require,module,exports,__globalThis) {
// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("./check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _layout = require("./layout");
var _layoutDefault = parcelHelpers.interopDefault(_layout);
/**
 * @exports opentype.Substitution
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */ function Substitution(font) {
    (0, _layoutDefault.default).call(this, font, 'gsub');
}
// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    const n = ar1.length;
    if (n !== ar2.length) return false;
    for(let i = 0; i < n; i++){
        if (ar1[i] !== ar2[i]) return false;
    }
    return true;
}
// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    const subtables = lookupTable.subtables;
    for(let i = 0; i < subtables.length; i++){
        const subtable = subtables[i];
        if (subtable.substFormat === format) return subtable;
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}
Substitution.prototype = (0, _layoutDefault.default).prototype;
/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */ Substitution.prototype.createDefaultTable = function() {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [
            {
                tag: 'DFLT',
                script: {
                    defaultLangSys: {
                        reserved: 0,
                        reqFeatureIndex: 0xffff,
                        featureIndexes: []
                    },
                    langSysRecords: []
                }
            }
        ],
        features: [],
        lookups: []
    };
};
/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
 * @return {Array} substitutions - The list of substitutions.
 */ Substitution.prototype.getSingle = function(feature, script, language) {
    const substitutions = [];
    const lookupTables = this.getLookupTables(script, language, feature, 1);
    for(let idx = 0; idx < lookupTables.length; idx++){
        const subtables = lookupTables[idx].subtables;
        for(let i = 0; i < subtables.length; i++){
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            let j;
            if (subtable.substFormat === 1) {
                const delta = subtable.deltaGlyphId;
                for(j = 0; j < glyphs.length; j++){
                    const glyph = glyphs[j];
                    substitutions.push({
                        sub: glyph,
                        by: glyph + delta
                    });
                }
            } else {
                const substitute = subtable.substitute;
                for(j = 0; j < glyphs.length; j++)substitutions.push({
                    sub: glyphs[j],
                    by: substitute[j]
                });
            }
        }
    }
    return substitutions;
};
/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
 * @return {Array} alternates - The list of alternates
 */ Substitution.prototype.getAlternates = function(feature, script, language) {
    const alternates = [];
    const lookupTables = this.getLookupTables(script, language, feature, 3);
    for(let idx = 0; idx < lookupTables.length; idx++){
        const subtables = lookupTables[idx].subtables;
        for(let i = 0; i < subtables.length; i++){
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            const alternateSets = subtable.alternateSets;
            for(let j = 0; j < glyphs.length; j++)alternates.push({
                sub: glyphs[j],
                by: alternateSets[j]
            });
        }
    }
    return alternates;
};
/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} ligatures - The list of ligatures.
 */ Substitution.prototype.getLigatures = function(feature, script, language) {
    const ligatures = [];
    const lookupTables = this.getLookupTables(script, language, feature, 4);
    for(let idx = 0; idx < lookupTables.length; idx++){
        const subtables = lookupTables[idx].subtables;
        for(let i = 0; i < subtables.length; i++){
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            const ligatureSets = subtable.ligatureSets;
            for(let j = 0; j < glyphs.length; j++){
                const startGlyph = glyphs[j];
                const ligSet = ligatureSets[j];
                for(let k = 0; k < ligSet.length; k++){
                    const lig = ligSet[k];
                    ligatures.push({
                        sub: [
                            startGlyph
                        ].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};
/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */ Substitution.prototype.addSingle = function(feature, substitution, script, language) {
    const lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    const subtable = getSubstFormat(lookupTable, 2, {
        substFormat: 2,
        coverage: {
            format: 1,
            glyphs: []
        },
        substitute: []
    });
    (0, _checkDefault.default).assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    const coverageGlyph = substitution.sub;
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};
/**
 * Add or modify an alternate substitution (lookup type 1)
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */ Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
    const lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    const subtable = getSubstFormat(lookupTable, 1, {
        substFormat: 1,
        coverage: {
            format: 1,
            glyphs: []
        },
        alternateSets: []
    });
    (0, _checkDefault.default).assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    const coverageGlyph = substitution.sub;
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};
/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */ Substitution.prototype.addLigature = function(feature, ligature, script, language) {
    const lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    let subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {
            substFormat: 1,
            coverage: {
                format: 1,
                glyphs: []
            },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    (0, _checkDefault.default).assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    const coverageGlyph = ligature.sub[0];
    const ligComponents = ligature.sub.slice(1);
    const ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        // ligatureSet already exists
        const ligatureSet = subtable.ligatureSets[pos];
        for(let i = 0; i < ligatureSet.length; i++){
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) return;
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [
            ligatureTable
        ]);
    }
};
/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} substitutions - The list of substitutions.
 */ Substitution.prototype.getFeature = function(feature, script, language) {
    if (/ss\d\d/.test(feature)) // ss01 - ss20
    return this.getSingle(feature, script, language);
    switch(feature){
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.getLigatures(feature, script, language);
    }
    return undefined;
};
/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */ Substitution.prototype.add = function(feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) // ss01 - ss20
    return this.addSingle(feature, sub, script, language);
    switch(feature){
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') return this.addSingle(feature, sub, script, language);
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};
exports.default = Substitution;

},{"./check":"184gJ","./layout":"lUd0O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hbBh1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "nodeBufferToArrayBuffer", ()=>nodeBufferToArrayBuffer);
parcelHelpers.export(exports, "arrayBufferToNodeBuffer", ()=>arrayBufferToNodeBuffer);
parcelHelpers.export(exports, "checkArgument", ()=>checkArgument);
var Buffer = require("5996db4bb4b1ba4c").Buffer;
function isBrowser() {
    return typeof window !== 'undefined';
}
function isNode() {
    return typeof window === 'undefined';
}
function nodeBufferToArrayBuffer(buffer) {
    const ab = new ArrayBuffer(buffer.length);
    const view = new Uint8Array(ab);
    for(let i = 0; i < buffer.length; ++i)view[i] = buffer[i];
    return ab;
}
function arrayBufferToNodeBuffer(ab) {
    const buffer = new Buffer(ab.byteLength);
    const view = new Uint8Array(ab);
    for(let i = 0; i < buffer.length; ++i)buffer[i] = view[i];
    return buffer;
}
function checkArgument(expression, message) {
    if (!expression) throw message;
}

},{"5996db4bb4b1ba4c":"bCaf4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bCaf4":[function(require,module,exports,__globalThis) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"9c62938f1dccc73c":"9I2RJ","aceacb6a4531a9d2":"geXY6"}],"9I2RJ":[function(require,module,exports,__globalThis) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"geXY6":[function(require,module,exports,__globalThis) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"lRqI7":[function(require,module,exports,__globalThis) {
/* A TrueType font hinting interpreter.
*
* (c) 2017 Axel Kittenberger
*
* This interpreter has been implemented according to this documentation:
* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
*
* According to the documentation F24DOT6 values are used for pixels.
* That means calculation is 1/64 pixel accurate and uses integer operations.
* However, Javascript has floating point operations by default and only
* those are available. One could make a case to simulate the 1/64 accuracy
* exactly by truncating after every division operation
* (for example with << 0) to get pixel exactly results as other TrueType
* implementations. It may make sense since some fonts are pixel optimized
* by hand using DELTAP instructions. The current implementation doesn't
* and rather uses full floating point precision.
*
* xScale, yScale and rotation is currently ignored.
*
* A few non-trivial instructions are missing as I didn't encounter yet
* a font that used them to test a possible implementation.
*
* Some fonts seem to use undocumented features regarding the twilight zone.
* Only some of them are implemented as they were encountered.
*
* The exports.DEBUG statements are removed on the minified distribution file.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _glyf = require("./tables/glyf");
var _glyfDefault = parcelHelpers.interopDefault(_glyf);
'use strict';
let instructionTable;
let exec;
let execGlyph;
let execComponent;
/*
* Creates a hinting object.
*
* There ought to be exactly one
* for each truetype font that is used for hinting.
*/ function Hinting(font) {
    // the font this hinting object is for
    this.font = font;
    this.getCommands = function(hPoints) {
        return (0, _glyfDefault.default).getPath(hPoints).commands;
    };
    // cached states
    this._fpgmState = this._prepState = undefined;
    // errorState
    // 0 ... all okay
    // 1 ... had an error in a glyf,
    //       continue working but stop spamming
    //       the console
    // 2 ... error at prep, stop hinting at this ppem
    // 3 ... error at fpeg, stop hinting for this font at all
    this._errorState = 0;
}
/*
* Not rounding.
*/ function roundOff(v) {
    return v;
}
/*
* Rounding to grid.
*/ function roundToGrid(v) {
    //Rounding in TT is supposed to "symmetrical around zero"
    return Math.sign(v) * Math.round(Math.abs(v));
}
/*
* Rounding to double grid.
*/ function roundToDoubleGrid(v) {
    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}
/*
* Rounding to half grid.
*/ function roundToHalfGrid(v) {
    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}
/*
* Rounding to up to grid.
*/ function roundUpToGrid(v) {
    return Math.sign(v) * Math.ceil(Math.abs(v));
}
/*
* Rounding to down to grid.
*/ function roundDownToGrid(v) {
    return Math.sign(v) * Math.floor(Math.abs(v));
}
/*
* Super rounding.
*/ const roundSuper = function(v) {
    const period = this.srPeriod;
    let phase = this.srPhase;
    const threshold = this.srThreshold;
    let sign = 1;
    if (v < 0) {
        v = -v;
        sign = -1;
    }
    v += threshold - phase;
    v = Math.trunc(v / period) * period;
    v += phase;
    // according to http://xgridfit.sourceforge.net/round.html
    if (v < 0) return phase * sign;
    return v * sign;
};
/*
* Unit vector of x-axis.
*/ const xUnitVector = {
    x: 1,
    y: 0,
    axis: 'x',
    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function(p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
    },
    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function(p, rp1, rp2, pv) {
        let do1;
        let do2;
        let doa1;
        let doa2;
        let dm1;
        let dm2;
        let dt;
        if (!pv || pv === this) {
            do1 = p.xo - rp1.xo;
            do2 = p.xo - rp2.xo;
            dm1 = rp1.x - rp1.xo;
            dm2 = rp2.x - rp2.xo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;
            if (dt === 0) {
                p.x = p.xo + (dm1 + dm2) / 2;
                return;
            }
            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }
        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;
        if (dt === 0) {
            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }
        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },
    // Slope of line normal to this
    normalSlope: Number.NEGATIVE_INFINITY,
    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'.
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function(p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.x = (org ? rp.xo : rp.x) + d;
            return;
        }
        const rpx = org ? rp.xo : rp.x;
        const rpy = org ? rp.yo : rp.y;
        const rpdx = rpx + d * pv.x;
        const rpdy = rpy + d * pv.y;
        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
    },
    // Slope of vector line.
    slope: 0,
    // Touches the point p.
    touch: function(p) {
        p.xTouched = true;
    },
    // Tests if a point p is touched.
    touched: function(p) {
        return p.xTouched;
    },
    // Untouches the point p.
    untouch: function(p) {
        p.xTouched = false;
    }
};
/*
* Unit vector of y-axis.
*/ const yUnitVector = {
    x: 0,
    y: 1,
    axis: 'y',
    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function(p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
    },
    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function(p, rp1, rp2, pv) {
        let do1;
        let do2;
        let doa1;
        let doa2;
        let dm1;
        let dm2;
        let dt;
        if (!pv || pv === this) {
            do1 = p.yo - rp1.yo;
            do2 = p.yo - rp2.yo;
            dm1 = rp1.y - rp1.yo;
            dm2 = rp2.y - rp2.yo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;
            if (dt === 0) {
                p.y = p.yo + (dm1 + dm2) / 2;
                return;
            }
            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }
        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;
        if (dt === 0) {
            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }
        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },
    // Slope of line normal to this.
    normalSlope: 0,
    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function(p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.y = (org ? rp.yo : rp.y) + d;
            return;
        }
        const rpx = org ? rp.xo : rp.x;
        const rpy = org ? rp.yo : rp.y;
        const rpdx = rpx + d * pv.x;
        const rpdy = rpy + d * pv.y;
        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
    },
    // Slope of vector line.
    slope: Number.POSITIVE_INFINITY,
    // Touches the point p.
    touch: function(p) {
        p.yTouched = true;
    },
    // Tests if a point p is touched.
    touched: function(p) {
        return p.yTouched;
    },
    // Untouches the point p.
    untouch: function(p) {
        p.yTouched = false;
    }
};
Object.freeze(xUnitVector);
Object.freeze(yUnitVector);
/*
* Creates a unit vector that is not x- or y-axis.
*/ function UnitVector(x, y) {
    this.x = x;
    this.y = y;
    this.axis = undefined;
    this.slope = y / x;
    this.normalSlope = -x / y;
    Object.freeze(this);
}
/*
* Gets the projected distance between two points.
* o1/o2 ... if true, respective original position is used.
*/ UnitVector.prototype.distance = function(p1, p2, o1, o2) {
    return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
};
/*
* Moves point p so the moved position has the same relative
* position to the moved positions of rp1 and rp2 than the
* original positions had.
*
* See APPENDIX on INTERPOLATE at the bottom of this file.
*/ UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
    let dm1;
    let dm2;
    let do1;
    let do2;
    let doa1;
    let doa2;
    let dt;
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
    }
    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};
/*
* Sets the point 'p' relative to point 'rp'
* by the distance 'd'
*
* See APPENDIX on SETRELATIVE at the bottom of this file.
*
* p   ...  point to set
* rp  ... reference point
* d   ... distance on projection vector
* pv  ... projection vector (undefined = this)
* org ... if true, uses the original position of rp as reference.
*/ UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
    pv = pv || this;
    const rpx = org ? rp.xo : rp.x;
    const rpy = org ? rp.yo : rp.y;
    const rpdx = rpx + d * pv.x;
    const rpdy = rpy + d * pv.y;
    const pvns = pv.normalSlope;
    const fvs = this.slope;
    const px = p.x;
    const py = p.y;
    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
    p.y = fvs * (p.x - px) + py;
};
/*
* Touches the point p.
*/ UnitVector.prototype.touch = function(p) {
    p.xTouched = true;
    p.yTouched = true;
};
/*
* Returns a unit vector with x/y coordinates.
*/ function getUnitVector(x, y) {
    const d = Math.sqrt(x * x + y * y);
    x /= d;
    y /= d;
    if (x === 1 && y === 0) return xUnitVector;
    else if (x === 0 && y === 1) return yUnitVector;
    else return new UnitVector(x, y);
}
/*
* Creates a point in the hinting engine.
*/ function HPoint(x, y, lastPointOfContour, onCurve) {
    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value
    this.lastPointOfContour = lastPointOfContour;
    this.onCurve = onCurve;
    this.prevPointOnContour = undefined;
    this.nextPointOnContour = undefined;
    this.xTouched = false;
    this.yTouched = false;
    Object.preventExtensions(this);
}
/*
* Returns the next touched point on the contour.
*
* v  ... unit vector to test touch axis.
*/ HPoint.prototype.nextTouched = function(v) {
    let p = this.nextPointOnContour;
    while(!v.touched(p) && p !== this)p = p.nextPointOnContour;
    return p;
};
/*
* Returns the previous touched point on the contour
*
* v  ... unit vector to test touch axis.
*/ HPoint.prototype.prevTouched = function(v) {
    let p = this.prevPointOnContour;
    while(!v.touched(p) && p !== this)p = p.prevPointOnContour;
    return p;
};
/*
* The zero point.
*/ const HPZero = Object.freeze(new HPoint(0, 0));
/*
* The default state of the interpreter.
*
* Note: Freezing the defaultState and then deriving from it
* makes the V8 Javascript engine going awkward,
* so this is avoided, albeit the defaultState shouldn't
* ever change.
*/ const defaultState = {
    cvCutIn: 17 / 16,
    deltaBase: 9,
    deltaShift: 0.125,
    loop: 1,
    minDis: 1,
    autoFlip: true
};
/*
* The current state of the interpreter.
*
* env  ... 'fpgm' or 'prep' or 'glyf'
* prog ... the program
*/ function State(env, prog) {
    this.env = env;
    this.stack = [];
    this.prog = prog;
    switch(env){
        case 'glyf':
            this.zp0 = this.zp1 = this.zp2 = 1;
            this.rp0 = this.rp1 = this.rp2 = 0;
        /* fall through */ case 'prep':
            this.fv = this.pv = this.dpv = xUnitVector;
            this.round = roundToGrid;
    }
}
/*
* Executes a glyph program.
*
* This does the hinting for each glyph.
*
* Returns an array of moved points.
*
* glyph: the glyph to hint
* ppem: the size the glyph is rendered for
*/ Hinting.prototype.exec = function(glyph, ppem) {
    if (typeof ppem !== 'number') throw new Error('Point size is not a number!');
    // Received a fatal error, don't do any hinting anymore.
    if (this._errorState > 2) return;
    const font = this.font;
    let prepState = this._prepState;
    if (!prepState || prepState.ppem !== ppem) {
        let fpgmState = this._fpgmState;
        if (!fpgmState) {
            // Executes the fpgm state.
            // This is used by fonts to define functions.
            State.prototype = defaultState;
            fpgmState = this._fpgmState = new State('fpgm', font.tables.fpgm);
            fpgmState.funcs = [];
            fpgmState.font = font;
            if (exports.DEBUG) {
                console.log('---EXEC FPGM---');
                fpgmState.step = -1;
            }
            try {
                exec(fpgmState);
            } catch (e) {
                console.log('Hinting error in FPGM:' + e);
                this._errorState = 3;
                return;
            }
        }
        // Executes the prep program for this ppem setting.
        // This is used by fonts to set cvt values
        // depending on to be rendered font size.
        State.prototype = fpgmState;
        prepState = this._prepState = new State('prep', font.tables.prep);
        prepState.ppem = ppem;
        // Creates a copy of the cvt table
        // and scales it to the current ppem setting.
        const oCvt = font.tables.cvt;
        if (oCvt) {
            const cvt = prepState.cvt = new Array(oCvt.length);
            const scale = ppem / font.unitsPerEm;
            for(let c = 0; c < oCvt.length; c++)cvt[c] = oCvt[c] * scale;
        } else prepState.cvt = [];
        if (exports.DEBUG) {
            console.log('---EXEC PREP---');
            prepState.step = -1;
        }
        try {
            exec(prepState);
        } catch (e) {
            if (this._errorState < 2) console.log('Hinting error in PREP:' + e);
            this._errorState = 2;
        }
    }
    if (this._errorState > 1) return;
    try {
        return execGlyph(glyph, prepState);
    } catch (e) {
        if (this._errorState < 1) {
            console.log('Hinting error:' + e);
            console.log('Note: further hinting errors are silenced');
        }
        this._errorState = 1;
        return undefined;
    }
};
/*
* Executes the hinting program for a glyph.
*/ execGlyph = function(glyph, prepState) {
    // original point positions
    const xScale = prepState.ppem / prepState.font.unitsPerEm;
    const yScale = xScale;
    let components = glyph.components;
    let contours;
    let gZone;
    let state;
    State.prototype = prepState;
    if (!components) {
        state = new State('glyf', glyph.instructions);
        if (exports.DEBUG) {
            console.log('---EXEC GLYPH---');
            state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
    } else {
        const font = prepState.font;
        gZone = [];
        contours = [];
        for(let i = 0; i < components.length; i++){
            const c = components[i];
            const cg = font.glyphs.get(c.glyphIndex);
            state = new State('glyf', cg.instructions);
            if (exports.DEBUG) {
                console.log('---EXEC COMP ' + i + '---');
                state.step = -1;
            }
            execComponent(cg, state, xScale, yScale);
            // appends the computed points to the result array
            // post processes the component points
            const dx = Math.round(c.dx * xScale);
            const dy = Math.round(c.dy * yScale);
            const gz = state.gZone;
            const cc = state.contours;
            for(let pi = 0; pi < gz.length; pi++){
                const p = gz[pi];
                p.xTouched = p.yTouched = false;
                p.xo = p.x = p.x + dx;
                p.yo = p.y = p.y + dy;
            }
            const gLen = gZone.length;
            gZone.push.apply(gZone, gz);
            for(let j = 0; j < cc.length; j++)contours.push(cc[j] + gLen);
        }
        if (glyph.instructions && !state.inhibitGridFit) {
            // the composite has instructions on its own
            state = new State('glyf', glyph.instructions);
            state.gZone = state.z0 = state.z1 = state.z2 = gZone;
            state.contours = contours;
            // note: HPZero cannot be used here, since
            //       the point might be modified
            gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));
            if (exports.DEBUG) {
                console.log('---EXEC COMPOSITE---');
                state.step = -1;
            }
            exec(state);
            gZone.length -= 2;
        }
    }
    return gZone;
};
/*
* Executes the hinting program for a component of a multi-component glyph
* or of the glyph itself for a non-component glyph.
*/ execComponent = function(glyph, state, xScale, yScale) {
    const points = glyph.points || [];
    const pLen = points.length;
    const gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
    const contours = state.contours = [];
    // Scales the original points and
    // makes copies for the hinted points.
    let cp; // current point
    for(let i = 0; i < pLen; i++){
        cp = points[i];
        gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve);
    }
    // Chain links the contours.
    let sp; // start point
    let np; // next point
    for(let i = 0; i < pLen; i++){
        cp = gZone[i];
        if (!sp) {
            sp = cp;
            contours.push(i);
        }
        if (cp.lastPointOfContour) {
            cp.nextPointOnContour = sp;
            sp.prevPointOnContour = cp;
            sp = undefined;
        } else {
            np = gZone[i + 1];
            cp.nextPointOnContour = np;
            np.prevPointOnContour = cp;
        }
    }
    if (state.inhibitGridFit) return;
    if (exports.DEBUG) {
        console.log('PROCESSING GLYPH', state.stack);
        for(let i = 0; i < pLen; i++)console.log(i, gZone[i].x, gZone[i].y);
    }
    gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));
    exec(state);
    // Removes the extra points.
    gZone.length -= 2;
    if (exports.DEBUG) {
        console.log('FINISHED GLYPH', state.stack);
        for(let i = 0; i < pLen; i++)console.log(i, gZone[i].x, gZone[i].y);
    }
};
/*
* Executes the program loaded in state.
*/ exec = function(state) {
    let prog = state.prog;
    if (!prog) return;
    const pLen = prog.length;
    let ins;
    for(state.ip = 0; state.ip < pLen; state.ip++){
        if (exports.DEBUG) state.step++;
        ins = instructionTable[prog[state.ip]];
        if (!ins) throw new Error('unknown instruction: 0x' + Number(prog[state.ip]).toString(16));
        ins(state);
    // very extensive debugging for each step
    /*
        if (exports.DEBUG) {
            var da;
            if (state.gZone) {
                da = [];
                for (let i = 0; i < state.gZone.length; i++)
                {
                    da.push(i + ' ' +
                        state.gZone[i].x * 64 + ' ' +
                        state.gZone[i].y * 64 + ' ' +
                        (state.gZone[i].xTouched ? 'x' : '') +
                        (state.gZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('GZ', da);
            }

            if (state.tZone) {
                da = [];
                for (let i = 0; i < state.tZone.length; i++) {
                    da.push(i + ' ' +
                        state.tZone[i].x * 64 + ' ' +
                        state.tZone[i].y * 64 + ' ' +
                        (state.tZone[i].xTouched ? 'x' : '') +
                        (state.tZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('TZ', da);
            }

            if (state.stack.length > 10) {
                console.log(
                    state.stack.length,
                    '...', state.stack.slice(state.stack.length - 10)
                );
            } else {
                console.log(state.stack.length, state.stack);
            }
        }
        */ }
};
/*
* Initializes the twilight zone.
*
* This is only done if a SZPx instruction
* refers to the twilight zone.
*/ function initTZone(state) {
    const tZone = state.tZone = new Array(state.gZone.length);
    // no idea if this is actually correct...
    for(let i = 0; i < tZone.length; i++)tZone[i] = new HPoint(0, 0);
}
/*
* Skips the instruction pointer ahead over an IF/ELSE block.
* handleElse .. if true breaks on matching ELSE
*/ function skip(state, handleElse) {
    const prog = state.prog;
    let ip = state.ip;
    let nesting = 1;
    let ins;
    do {
        ins = prog[++ip];
        if (ins === 0x58) nesting++;
        else if (ins === 0x59) nesting--;
        else if (ins === 0x40) ip += prog[ip + 1] + 1;
        else if (ins === 0x41) ip += 2 * prog[ip + 1] + 1;
        else if (ins >= 0xB0 && ins <= 0xB7) ip += ins - 0xB0 + 1;
        else if (ins >= 0xB8 && ins <= 0xBF) ip += (ins - 0xB8 + 1) * 2;
        else if (handleElse && nesting === 1 && ins === 0x1B) break;
    }while (nesting > 0);
    state.ip = ip;
}
/*----------------------------------------------------------*
*          And then a lot of instructions...                *
*----------------------------------------------------------*/ // SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
// 0x00-0x01
function SVTCA(v, state) {
    if (exports.DEBUG) console.log(state.step, 'SVTCA[' + v.axis + ']');
    state.fv = state.pv = state.dpv = v;
}
// SPVTCA[a] Set Projection Vector to Coordinate Axis
// 0x02-0x03
function SPVTCA(v, state) {
    if (exports.DEBUG) console.log(state.step, 'SPVTCA[' + v.axis + ']');
    state.pv = state.dpv = v;
}
// SFVTCA[a] Set Freedom Vector to Coordinate Axis
// 0x04-0x05
function SFVTCA(v, state) {
    if (exports.DEBUG) console.log(state.step, 'SFVTCA[' + v.axis + ']');
    state.fv = v;
}
// SPVTL[a] Set Projection Vector To Line
// 0x06-0x07
function SPVTL(a, state) {
    const stack = state.stack;
    const p2i = stack.pop();
    const p1i = stack.pop();
    const p2 = state.z2[p2i];
    const p1 = state.z1[p1i];
    if (exports.DEBUG) console.log('SPVTL[' + a + ']', p2i, p1i);
    let dx;
    let dy;
    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }
    state.pv = state.dpv = getUnitVector(dx, dy);
}
// SFVTL[a] Set Freedom Vector To Line
// 0x08-0x09
function SFVTL(a, state) {
    const stack = state.stack;
    const p2i = stack.pop();
    const p1i = stack.pop();
    const p2 = state.z2[p2i];
    const p1 = state.z1[p1i];
    if (exports.DEBUG) console.log('SFVTL[' + a + ']', p2i, p1i);
    let dx;
    let dy;
    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }
    state.fv = getUnitVector(dx, dy);
}
// SPVFS[] Set Projection Vector From Stack
// 0x0A
function SPVFS(state) {
    const stack = state.stack;
    const y = stack.pop();
    const x = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);
    state.pv = state.dpv = getUnitVector(x, y);
}
// SFVFS[] Set Freedom Vector From Stack
// 0x0B
function SFVFS(state) {
    const stack = state.stack;
    const y = stack.pop();
    const x = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);
    state.fv = getUnitVector(x, y);
}
// GPV[] Get Projection Vector
// 0x0C
function GPV(state) {
    const stack = state.stack;
    const pv = state.pv;
    if (exports.DEBUG) console.log(state.step, 'GPV[]');
    stack.push(pv.x * 0x4000);
    stack.push(pv.y * 0x4000);
}
// GFV[] Get Freedom Vector
// 0x0C
function GFV(state) {
    const stack = state.stack;
    const fv = state.fv;
    if (exports.DEBUG) console.log(state.step, 'GFV[]');
    stack.push(fv.x * 0x4000);
    stack.push(fv.y * 0x4000);
}
// SFVTPV[] Set Freedom Vector To Projection Vector
// 0x0E
function SFVTPV(state) {
    state.fv = state.pv;
    if (exports.DEBUG) console.log(state.step, 'SFVTPV[]');
}
// ISECT[] moves point p to the InterSECTion of two lines
// 0x0F
function ISECT(state) {
    const stack = state.stack;
    const pa0i = stack.pop();
    const pa1i = stack.pop();
    const pb0i = stack.pop();
    const pb1i = stack.pop();
    const pi = stack.pop();
    const z0 = state.z0;
    const z1 = state.z1;
    const pa0 = z0[pa0i];
    const pa1 = z0[pa1i];
    const pb0 = z1[pb0i];
    const pb1 = z1[pb1i];
    const p = state.z2[pi];
    if (exports.DEBUG) console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi);
    // math from
    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
    const x1 = pa0.x;
    const y1 = pa0.y;
    const x2 = pa1.x;
    const y2 = pa1.y;
    const x3 = pb0.x;
    const y3 = pb0.y;
    const x4 = pb1.x;
    const y4 = pb1.y;
    const div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    const f1 = x1 * y2 - y1 * x2;
    const f2 = x3 * y4 - y3 * x4;
    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}
// SRP0[] Set Reference Point 0
// 0x10
function SRP0(state) {
    state.rp0 = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SRP0[]', state.rp0);
}
// SRP1[] Set Reference Point 1
// 0x11
function SRP1(state) {
    state.rp1 = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SRP1[]', state.rp1);
}
// SRP1[] Set Reference Point 2
// 0x12
function SRP2(state) {
    state.rp2 = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SRP2[]', state.rp2);
}
// SZP0[] Set Zone Pointer 0
// 0x13
function SZP0(state) {
    const n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SZP0[]', n);
    state.zp0 = n;
    switch(n){
        case 0:
            if (!state.tZone) initTZone(state);
            state.z0 = state.tZone;
            break;
        case 1:
            state.z0 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}
// SZP1[] Set Zone Pointer 1
// 0x14
function SZP1(state) {
    const n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SZP1[]', n);
    state.zp1 = n;
    switch(n){
        case 0:
            if (!state.tZone) initTZone(state);
            state.z1 = state.tZone;
            break;
        case 1:
            state.z1 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}
// SZP2[] Set Zone Pointer 2
// 0x15
function SZP2(state) {
    const n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SZP2[]', n);
    state.zp2 = n;
    switch(n){
        case 0:
            if (!state.tZone) initTZone(state);
            state.z2 = state.tZone;
            break;
        case 1:
            state.z2 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}
// SZPS[] Set Zone PointerS
// 0x16
function SZPS(state) {
    const n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SZPS[]', n);
    state.zp0 = state.zp1 = state.zp2 = n;
    switch(n){
        case 0:
            if (!state.tZone) initTZone(state);
            state.z0 = state.z1 = state.z2 = state.tZone;
            break;
        case 1:
            state.z0 = state.z1 = state.z2 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}
// SLOOP[] Set LOOP variable
// 0x17
function SLOOP(state) {
    state.loop = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SLOOP[]', state.loop);
}
// RTG[] Round To Grid
// 0x18
function RTG(state) {
    if (exports.DEBUG) console.log(state.step, 'RTG[]');
    state.round = roundToGrid;
}
// RTHG[] Round To Half Grid
// 0x19
function RTHG(state) {
    if (exports.DEBUG) console.log(state.step, 'RTHG[]');
    state.round = roundToHalfGrid;
}
// SMD[] Set Minimum Distance
// 0x1A
function SMD(state) {
    const d = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SMD[]', d);
    state.minDis = d / 0x40;
}
// ELSE[] ELSE clause
// 0x1B
function ELSE(state) {
    // This instruction has been reached by executing a then branch
    // so it just skips ahead until matching EIF.
    //
    // In case the IF was negative the IF[] instruction already
    // skipped forward over the ELSE[]
    if (exports.DEBUG) console.log(state.step, 'ELSE[]');
    skip(state, false);
}
// JMPR[] JuMP Relative
// 0x1C
function JMPR(state) {
    const o = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'JMPR[]', o);
    // A jump by 1 would do nothing.
    state.ip += o - 1;
}
// SCVTCI[] Set Control Value Table Cut-In
// 0x1D
function SCVTCI(state) {
    const n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SCVTCI[]', n);
    state.cvCutIn = n / 0x40;
}
// DUP[] DUPlicate top stack element
// 0x20
function DUP(state) {
    const stack = state.stack;
    if (exports.DEBUG) console.log(state.step, 'DUP[]');
    stack.push(stack[stack.length - 1]);
}
// POP[] POP top stack element
// 0x21
function POP(state) {
    if (exports.DEBUG) console.log(state.step, 'POP[]');
    state.stack.pop();
}
// CLEAR[] CLEAR the stack
// 0x22
function CLEAR(state) {
    if (exports.DEBUG) console.log(state.step, 'CLEAR[]');
    state.stack.length = 0;
}
// SWAP[] SWAP the top two elements on the stack
// 0x23
function SWAP(state) {
    const stack = state.stack;
    const a = stack.pop();
    const b = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SWAP[]');
    stack.push(a);
    stack.push(b);
}
// DEPTH[] DEPTH of the stack
// 0x24
function DEPTH(state) {
    const stack = state.stack;
    if (exports.DEBUG) console.log(state.step, 'DEPTH[]');
    stack.push(stack.length);
}
// LOOPCALL[] LOOPCALL function
// 0x2A
function LOOPCALL(state) {
    const stack = state.stack;
    const fn = stack.pop();
    const c = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'LOOPCALL[]', fn, c);
    // saves callers program
    const cip = state.ip;
    const cprog = state.prog;
    state.prog = state.funcs[fn];
    // executes the function
    for(let i = 0; i < c; i++){
        exec(state);
        if (exports.DEBUG) console.log(++state.step, i + 1 < c ? 'next loopcall' : 'done loopcall', i);
    }
    // restores the callers program
    state.ip = cip;
    state.prog = cprog;
}
// CALL[] CALL function
// 0x2B
function CALL(state) {
    const fn = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'CALL[]', fn);
    // saves callers program
    const cip = state.ip;
    const cprog = state.prog;
    state.prog = state.funcs[fn];
    // executes the function
    exec(state);
    // restores the callers program
    state.ip = cip;
    state.prog = cprog;
    if (exports.DEBUG) console.log(++state.step, 'returning from', fn);
}
// CINDEX[] Copy the INDEXed element to the top of the stack
// 0x25
function CINDEX(state) {
    const stack = state.stack;
    const k = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'CINDEX[]', k);
    // In case of k == 1, it copies the last element after popping
    // thus stack.length - k.
    stack.push(stack[stack.length - k]);
}
// MINDEX[] Move the INDEXed element to the top of the stack
// 0x26
function MINDEX(state) {
    const stack = state.stack;
    const k = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'MINDEX[]', k);
    stack.push(stack.splice(stack.length - k, 1)[0]);
}
// FDEF[] Function DEFinition
// 0x2C
function FDEF(state) {
    if (state.env !== 'fpgm') throw new Error('FDEF not allowed here');
    const stack = state.stack;
    const prog = state.prog;
    let ip = state.ip;
    const fn = stack.pop();
    const ipBegin = ip;
    if (exports.DEBUG) console.log(state.step, 'FDEF[]', fn);
    while(prog[++ip] !== 0x2D);
    state.ip = ip;
    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}
// MDAP[a] Move Direct Absolute Point
// 0x2E-0x2F
function MDAP(round, state) {
    const pi = state.stack.pop();
    const p = state.z0[pi];
    const fv = state.fv;
    const pv = state.pv;
    if (exports.DEBUG) console.log(state.step, 'MDAP[' + round + ']', pi);
    let d = pv.distance(p, HPZero);
    if (round) d = state.round(d);
    fv.setRelative(p, HPZero, d, pv);
    fv.touch(p);
    state.rp0 = state.rp1 = pi;
}
// IUP[a] Interpolate Untouched Points through the outline
// 0x30
function IUP(v, state) {
    const z2 = state.z2;
    const pLen = z2.length - 2;
    let cp;
    let pp;
    let np;
    if (exports.DEBUG) console.log(state.step, 'IUP[' + v.axis + ']');
    for(let i = 0; i < pLen; i++){
        cp = z2[i]; // current point
        // if this point has been touched go on
        if (v.touched(cp)) continue;
        pp = cp.prevTouched(v);
        // no point on the contour has been touched?
        if (pp === cp) continue;
        np = cp.nextTouched(v);
        if (pp === np) // only one point on the contour has been touched
        // so simply moves the point like that
        v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        v.interpolate(cp, pp, np, v);
    }
}
// SHP[] SHift Point using reference point
// 0x32-0x33
function SHP(a, state) {
    const stack = state.stack;
    const rpi = a ? state.rp1 : state.rp2;
    const rp = (a ? state.z0 : state.z1)[rpi];
    const fv = state.fv;
    const pv = state.pv;
    let loop = state.loop;
    const z2 = state.z2;
    while(loop--){
        const pi = stack.pop();
        const p = z2[pi];
        const d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);
        if (exports.DEBUG) console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi);
    }
    state.loop = 1;
}
// SHC[] SHift Contour using reference point
// 0x36-0x37
function SHC(a, state) {
    const stack = state.stack;
    const rpi = a ? state.rp1 : state.rp2;
    const rp = (a ? state.z0 : state.z1)[rpi];
    const fv = state.fv;
    const pv = state.pv;
    const ci = stack.pop();
    const sp = state.z2[state.contours[ci]];
    let p = sp;
    if (exports.DEBUG) console.log(state.step, 'SHC[' + a + ']', ci);
    const d = pv.distance(rp, rp, false, true);
    do {
        if (p !== rp) fv.setRelative(p, p, d, pv);
        p = p.nextPointOnContour;
    }while (p !== sp);
}
// SHZ[] SHift Zone using reference point
// 0x36-0x37
function SHZ(a, state) {
    const stack = state.stack;
    const rpi = a ? state.rp1 : state.rp2;
    const rp = (a ? state.z0 : state.z1)[rpi];
    const fv = state.fv;
    const pv = state.pv;
    const e = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SHZ[' + a + ']', e);
    let z;
    switch(e){
        case 0:
            z = state.tZone;
            break;
        case 1:
            z = state.gZone;
            break;
        default:
            throw new Error('Invalid zone');
    }
    let p;
    const d = pv.distance(rp, rp, false, true);
    const pLen = z.length - 2;
    for(let i = 0; i < pLen; i++){
        p = z[i];
        fv.setRelative(p, p, d, pv);
    //if (p !== rp) fv.setRelative(p, p, d, pv);
    }
}
// SHPIX[] SHift point by a PIXel amount
// 0x38
function SHPIX(state) {
    const stack = state.stack;
    let loop = state.loop;
    const fv = state.fv;
    const d = stack.pop() / 0x40;
    const z2 = state.z2;
    while(loop--){
        const pi = stack.pop();
        const p = z2[pi];
        if (exports.DEBUG) console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHPIX[]', pi, d);
        fv.setRelative(p, p, d);
        fv.touch(p);
    }
    state.loop = 1;
}
// IP[] Interpolate Point
// 0x39
function IP(state) {
    const stack = state.stack;
    const rp1i = state.rp1;
    const rp2i = state.rp2;
    let loop = state.loop;
    const rp1 = state.z0[rp1i];
    const rp2 = state.z1[rp2i];
    const fv = state.fv;
    const pv = state.dpv;
    const z2 = state.z2;
    while(loop--){
        const pi = stack.pop();
        const p = z2[pi];
        if (exports.DEBUG) console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'IP[]', pi, rp1i, '<->', rp2i);
        fv.interpolate(p, rp1, rp2, pv);
        fv.touch(p);
    }
    state.loop = 1;
}
// MSIRP[a] Move Stack Indirect Relative Point
// 0x3A-0x3B
function MSIRP(a, state) {
    const stack = state.stack;
    const d = stack.pop() / 64;
    const pi = stack.pop();
    const p = state.z1[pi];
    const rp0 = state.z0[state.rp0];
    const fv = state.fv;
    const pv = state.pv;
    fv.setRelative(p, rp0, d, pv);
    fv.touch(p);
    if (exports.DEBUG) console.log(state.step, 'MSIRP[' + a + ']', d, pi);
    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (a) state.rp0 = pi;
}
// ALIGNRP[] Align to reference point.
// 0x3C
function ALIGNRP(state) {
    const stack = state.stack;
    const rp0i = state.rp0;
    const rp0 = state.z0[rp0i];
    let loop = state.loop;
    const fv = state.fv;
    const pv = state.pv;
    const z1 = state.z1;
    while(loop--){
        const pi = stack.pop();
        const p = z1[pi];
        if (exports.DEBUG) console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'ALIGNRP[]', pi);
        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
    }
    state.loop = 1;
}
// RTG[] Round To Double Grid
// 0x3D
function RTDG(state) {
    if (exports.DEBUG) console.log(state.step, 'RTDG[]');
    state.round = roundToDoubleGrid;
}
// MIAP[a] Move Indirect Absolute Point
// 0x3E-0x3F
function MIAP(round, state) {
    const stack = state.stack;
    const n = stack.pop();
    const pi = stack.pop();
    const p = state.z0[pi];
    const fv = state.fv;
    const pv = state.pv;
    let cv = state.cvt[n];
    if (exports.DEBUG) console.log(state.step, 'MIAP[' + round + ']', n, '(', cv, ')', pi);
    let d = pv.distance(p, HPZero);
    if (round) {
        if (Math.abs(d - cv) < state.cvCutIn) d = cv;
        d = state.round(d);
    }
    fv.setRelative(p, HPZero, d, pv);
    if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
    }
    fv.touch(p);
    state.rp0 = state.rp1 = pi;
}
// NPUSB[] PUSH N Bytes
// 0x40
function NPUSHB(state) {
    const prog = state.prog;
    let ip = state.ip;
    const stack = state.stack;
    const n = prog[++ip];
    if (exports.DEBUG) console.log(state.step, 'NPUSHB[]', n);
    for(let i = 0; i < n; i++)stack.push(prog[++ip]);
    state.ip = ip;
}
// NPUSHW[] PUSH N Words
// 0x41
function NPUSHW(state) {
    let ip = state.ip;
    const prog = state.prog;
    const stack = state.stack;
    const n = prog[++ip];
    if (exports.DEBUG) console.log(state.step, 'NPUSHW[]', n);
    for(let i = 0; i < n; i++){
        let w = prog[++ip] << 8 | prog[++ip];
        if (w & 0x8000) w = -((w ^ 0xffff) + 1);
        stack.push(w);
    }
    state.ip = ip;
}
// WS[] Write Store
// 0x42
function WS(state) {
    const stack = state.stack;
    let store = state.store;
    if (!store) store = state.store = [];
    const v = stack.pop();
    const l = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'WS', v, l);
    store[l] = v;
}
// RS[] Read Store
// 0x43
function RS(state) {
    const stack = state.stack;
    const store = state.store;
    const l = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'RS', l);
    const v = store && store[l] || 0;
    stack.push(v);
}
// WCVTP[] Write Control Value Table in Pixel units
// 0x44
function WCVTP(state) {
    const stack = state.stack;
    const v = stack.pop();
    const l = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'WCVTP', v, l);
    state.cvt[l] = v / 0x40;
}
// RCVT[] Read Control Value Table entry
// 0x45
function RCVT(state) {
    const stack = state.stack;
    const cvte = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'RCVT', cvte);
    stack.push(state.cvt[cvte] * 0x40);
}
// GC[] Get Coordinate projected onto the projection vector
// 0x46-0x47
function GC(a, state) {
    const stack = state.stack;
    const pi = stack.pop();
    const p = state.z2[pi];
    if (exports.DEBUG) console.log(state.step, 'GC[' + a + ']', pi);
    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
}
// MD[a] Measure Distance
// 0x49-0x4A
function MD(a, state) {
    const stack = state.stack;
    const pi2 = stack.pop();
    const pi1 = stack.pop();
    const p2 = state.z1[pi2];
    const p1 = state.z0[pi1];
    const d = state.dpv.distance(p1, p2, a, a);
    if (exports.DEBUG) console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d);
    state.stack.push(Math.round(d * 64));
}
// MPPEM[] Measure Pixels Per EM
// 0x4B
function MPPEM(state) {
    if (exports.DEBUG) console.log(state.step, 'MPPEM[]');
    state.stack.push(state.ppem);
}
// FLIPON[] set the auto FLIP Boolean to ON
// 0x4D
function FLIPON(state) {
    if (exports.DEBUG) console.log(state.step, 'FLIPON[]');
    state.autoFlip = true;
}
// LT[] Less Than
// 0x50
function LT(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'LT[]', e2, e1);
    stack.push(e1 < e2 ? 1 : 0);
}
// LTEQ[] Less Than or EQual
// 0x53
function LTEQ(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'LTEQ[]', e2, e1);
    stack.push(e1 <= e2 ? 1 : 0);
}
// GTEQ[] Greater Than
// 0x52
function GT(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'GT[]', e2, e1);
    stack.push(e1 > e2 ? 1 : 0);
}
// GTEQ[] Greater Than or EQual
// 0x53
function GTEQ(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'GTEQ[]', e2, e1);
    stack.push(e1 >= e2 ? 1 : 0);
}
// EQ[] EQual
// 0x54
function EQ(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'EQ[]', e2, e1);
    stack.push(e2 === e1 ? 1 : 0);
}
// NEQ[] Not EQual
// 0x55
function NEQ(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'NEQ[]', e2, e1);
    stack.push(e2 !== e1 ? 1 : 0);
}
// ODD[] ODD
// 0x56
function ODD(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'ODD[]', n);
    stack.push(Math.trunc(n) % 2 ? 1 : 0);
}
// EVEN[] EVEN
// 0x57
function EVEN(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'EVEN[]', n);
    stack.push(Math.trunc(n) % 2 ? 0 : 1);
}
// IF[] IF test
// 0x58
function IF(state) {
    let test = state.stack.pop();
    let ins;
    if (exports.DEBUG) console.log(state.step, 'IF[]', test);
    // if test is true it just continues
    // if not the ip is skipped until matching ELSE or EIF
    if (!test) {
        skip(state, true);
        if (exports.DEBUG) console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]');
    }
}
// EIF[] End IF
// 0x59
function EIF(state) {
    // this can be reached normally when
    // executing an else branch.
    // -> just ignore it
    if (exports.DEBUG) console.log(state.step, 'EIF[]');
}
// AND[] logical AND
// 0x5A
function AND(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'AND[]', e2, e1);
    stack.push(e2 && e1 ? 1 : 0);
}
// OR[] logical OR
// 0x5B
function OR(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'OR[]', e2, e1);
    stack.push(e2 || e1 ? 1 : 0);
}
// NOT[] logical NOT
// 0x5C
function NOT(state) {
    const stack = state.stack;
    const e = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'NOT[]', e);
    stack.push(e ? 0 : 1);
}
// DELTAP1[] DELTA exception P1
// DELTAP2[] DELTA exception P2
// DELTAP3[] DELTA exception P3
// 0x5D, 0x71, 0x72
function DELTAP123(b, state) {
    const stack = state.stack;
    const n = stack.pop();
    const fv = state.fv;
    const pv = state.pv;
    const ppem = state.ppem;
    const base = state.deltaBase + (b - 1) * 16;
    const ds = state.deltaShift;
    const z0 = state.z0;
    if (exports.DEBUG) console.log(state.step, 'DELTAP[' + b + ']', n, stack);
    for(let i = 0; i < n; i++){
        const pi = stack.pop();
        const arg = stack.pop();
        const appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) continue;
        let mag = (arg & 0x0F) - 8;
        if (mag >= 0) mag++;
        if (exports.DEBUG) console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds);
        const p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
    }
}
// SDB[] Set Delta Base in the graphics state
// 0x5E
function SDB(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SDB[]', n);
    state.deltaBase = n;
}
// SDS[] Set Delta Shift in the graphics state
// 0x5F
function SDS(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SDS[]', n);
    state.deltaShift = Math.pow(0.5, n);
}
// ADD[] ADD
// 0x60
function ADD(state) {
    const stack = state.stack;
    const n2 = stack.pop();
    const n1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'ADD[]', n2, n1);
    stack.push(n1 + n2);
}
// SUB[] SUB
// 0x61
function SUB(state) {
    const stack = state.stack;
    const n2 = stack.pop();
    const n1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SUB[]', n2, n1);
    stack.push(n1 - n2);
}
// DIV[] DIV
// 0x62
function DIV(state) {
    const stack = state.stack;
    const n2 = stack.pop();
    const n1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'DIV[]', n2, n1);
    stack.push(n1 * 64 / n2);
}
// MUL[] MUL
// 0x63
function MUL(state) {
    const stack = state.stack;
    const n2 = stack.pop();
    const n1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'MUL[]', n2, n1);
    stack.push(n1 * n2 / 64);
}
// ABS[] ABSolute value
// 0x64
function ABS(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'ABS[]', n);
    stack.push(Math.abs(n));
}
// NEG[] NEGate
// 0x65
function NEG(state) {
    const stack = state.stack;
    let n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'NEG[]', n);
    stack.push(-n);
}
// FLOOR[] FLOOR
// 0x66
function FLOOR(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'FLOOR[]', n);
    stack.push(Math.floor(n / 0x40) * 0x40);
}
// CEILING[] CEILING
// 0x67
function CEILING(state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'CEILING[]', n);
    stack.push(Math.ceil(n / 0x40) * 0x40);
}
// ROUND[ab] ROUND value
// 0x68-0x6B
function ROUND(dt, state) {
    const stack = state.stack;
    const n = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'ROUND[]');
    stack.push(state.round(n / 0x40) * 0x40);
}
// WCVTF[] Write Control Value Table in Funits
// 0x70
function WCVTF(state) {
    const stack = state.stack;
    const v = stack.pop();
    const l = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'WCVTF[]', v, l);
    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}
// DELTAC1[] DELTA exception C1
// DELTAC2[] DELTA exception C2
// DELTAC3[] DELTA exception C3
// 0x73, 0x74, 0x75
function DELTAC123(b, state) {
    const stack = state.stack;
    const n = stack.pop();
    const ppem = state.ppem;
    const base = state.deltaBase + (b - 1) * 16;
    const ds = state.deltaShift;
    if (exports.DEBUG) console.log(state.step, 'DELTAC[' + b + ']', n, stack);
    for(let i = 0; i < n; i++){
        const c = stack.pop();
        const arg = stack.pop();
        const appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) continue;
        let mag = (arg & 0x0F) - 8;
        if (mag >= 0) mag++;
        const delta = mag * ds;
        if (exports.DEBUG) console.log(state.step, 'DELTACFIX', c, 'by', delta);
        state.cvt[c] += delta;
    }
}
// SROUND[] Super ROUND
// 0x76
function SROUND(state) {
    let n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'SROUND[]', n);
    state.round = roundSuper;
    let period;
    switch(n & 0xC0){
        case 0x00:
            period = 0.5;
            break;
        case 0x40:
            period = 1;
            break;
        case 0x80:
            period = 2;
            break;
        default:
            throw new Error('invalid SROUND value');
    }
    state.srPeriod = period;
    switch(n & 0x30){
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5 * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid SROUND value');
    }
    n &= 0x0F;
    if (n === 0) state.srThreshold = 0;
    else state.srThreshold = (n / 8 - 0.5) * period;
}
// S45ROUND[] Super ROUND 45 degrees
// 0x77
function S45ROUND(state) {
    let n = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'S45ROUND[]', n);
    state.round = roundSuper;
    let period;
    switch(n & 0xC0){
        case 0x00:
            period = Math.sqrt(2) / 2;
            break;
        case 0x40:
            period = Math.sqrt(2);
            break;
        case 0x80:
            period = 2 * Math.sqrt(2);
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }
    state.srPeriod = period;
    switch(n & 0x30){
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5 * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }
    n &= 0x0F;
    if (n === 0) state.srThreshold = 0;
    else state.srThreshold = (n / 8 - 0.5) * period;
}
// ROFF[] Round Off
// 0x7A
function ROFF(state) {
    if (exports.DEBUG) console.log(state.step, 'ROFF[]');
    state.round = roundOff;
}
// RUTG[] Round Up To Grid
// 0x7C
function RUTG(state) {
    if (exports.DEBUG) console.log(state.step, 'RUTG[]');
    state.round = roundUpToGrid;
}
// RDTG[] Round Down To Grid
// 0x7D
function RDTG(state) {
    if (exports.DEBUG) console.log(state.step, 'RDTG[]');
    state.round = roundDownToGrid;
}
// SCANCTRL[] SCAN conversion ConTRoL
// 0x85
function SCANCTRL(state) {
    const n = state.stack.pop();
    // ignored by opentype.js
    if (exports.DEBUG) console.log(state.step, 'SCANCTRL[]', n);
}
// SDPVTL[a] Set Dual Projection Vector To Line
// 0x86-0x87
function SDPVTL(a, state) {
    const stack = state.stack;
    const p2i = stack.pop();
    const p1i = stack.pop();
    const p2 = state.z2[p2i];
    const p1 = state.z1[p1i];
    if (exports.DEBUG) console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i);
    let dx;
    let dy;
    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }
    state.dpv = getUnitVector(dx, dy);
}
// GETINFO[] GET INFOrmation
// 0x88
function GETINFO(state) {
    const stack = state.stack;
    const sel = stack.pop();
    let r = 0;
    if (exports.DEBUG) console.log(state.step, 'GETINFO[]', sel);
    // v35 as in no subpixel hinting
    if (sel & 0x01) r = 35;
    // TODO rotation and stretch currently not supported
    // and thus those GETINFO are always 0.
    // opentype.js is always gray scaling
    if (sel & 0x20) r |= 0x1000;
    stack.push(r);
}
// ROLL[] ROLL the top three stack elements
// 0x8A
function ROLL(state) {
    const stack = state.stack;
    const a = stack.pop();
    const b = stack.pop();
    const c = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'ROLL[]');
    stack.push(b);
    stack.push(a);
    stack.push(c);
}
// MAX[] MAXimum of top two stack elements
// 0x8B
function MAX(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'MAX[]', e2, e1);
    stack.push(Math.max(e1, e2));
}
// MIN[] MINimum of top two stack elements
// 0x8C
function MIN(state) {
    const stack = state.stack;
    const e2 = stack.pop();
    const e1 = stack.pop();
    if (exports.DEBUG) console.log(state.step, 'MIN[]', e2, e1);
    stack.push(Math.min(e1, e2));
}
// SCANTYPE[] SCANTYPE
// 0x8D
function SCANTYPE(state) {
    const n = state.stack.pop();
    // ignored by opentype.js
    if (exports.DEBUG) console.log(state.step, 'SCANTYPE[]', n);
}
// INSTCTRL[] INSTCTRL
// 0x8D
function INSTCTRL(state) {
    const s = state.stack.pop();
    let v = state.stack.pop();
    if (exports.DEBUG) console.log(state.step, 'INSTCTRL[]', s, v);
    switch(s){
        case 1:
            state.inhibitGridFit = !!v;
            return;
        case 2:
            state.ignoreCvt = !!v;
            return;
        default:
            throw new Error('invalid INSTCTRL[] selector');
    }
}
// PUSHB[abc] PUSH Bytes
// 0xB0-0xB7
function PUSHB(n, state) {
    const stack = state.stack;
    const prog = state.prog;
    let ip = state.ip;
    if (exports.DEBUG) console.log(state.step, 'PUSHB[' + n + ']');
    for(let i = 0; i < n; i++)stack.push(prog[++ip]);
    state.ip = ip;
}
// PUSHW[abc] PUSH Words
// 0xB8-0xBF
function PUSHW(n, state) {
    let ip = state.ip;
    const prog = state.prog;
    const stack = state.stack;
    if (exports.DEBUG) console.log(state.ip, 'PUSHW[' + n + ']');
    for(let i = 0; i < n; i++){
        let w = prog[++ip] << 8 | prog[++ip];
        if (w & 0x8000) w = -((w ^ 0xffff) + 1);
        stack.push(w);
    }
    state.ip = ip;
}
// MDRP[abcde] Move Direct Relative Point
// 0xD0-0xEF
// (if indirect is 0)
//
// and
//
// MIRP[abcde] Move Indirect Relative Point
// 0xE0-0xFF
// (if indirect is 1)
function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
    const stack = state.stack;
    const cvte = indirect && stack.pop();
    const pi = stack.pop();
    const rp0i = state.rp0;
    const rp = state.z0[rp0i];
    const p = state.z1[pi];
    const md = state.minDis;
    const fv = state.fv;
    const pv = state.dpv;
    let od; // original distance
    let d; // moving distance
    let sign; // sign of distance
    let cv;
    d = od = pv.distance(p, rp, true, true);
    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0
    // TODO consider autoFlip
    d = Math.abs(d);
    if (indirect) {
        cv = state.cvt[cvte];
        if (ro && Math.abs(d - cv) < state.cvCutIn) d = cv;
    }
    if (keepD && d < md) d = md;
    if (ro) d = state.round(d);
    fv.setRelative(p, rp, sign * d, pv);
    fv.touch(p);
    if (exports.DEBUG) console.log(state.step, (indirect ? 'MIRP[' : 'MDRP[') + (setRp0 ? 'M' : 'm') + (keepD ? '>' : '_') + (ro ? 'R' : '_') + (dt === 0 ? 'Gr' : dt === 1 ? 'Bl' : dt === 2 ? 'Wh' : '') + ']', indirect ? cvte + '(' + state.cvt[cvte] + ',' + cv + ')' : '', pi, '(d =', od, '->', sign * d, ')');
    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (setRp0) state.rp0 = pi;
}
/*
* The instruction table.
*/ instructionTable = [
    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
    /* 0x06 */ SPVTL.bind(undefined, 0),
    /* 0x07 */ SPVTL.bind(undefined, 1),
    /* 0x08 */ SFVTL.bind(undefined, 0),
    /* 0x09 */ SFVTL.bind(undefined, 1),
    /* 0x0A */ SPVFS,
    /* 0x0B */ SFVFS,
    /* 0x0C */ GPV,
    /* 0x0D */ GFV,
    /* 0x0E */ SFVTPV,
    /* 0x0F */ ISECT,
    /* 0x10 */ SRP0,
    /* 0x11 */ SRP1,
    /* 0x12 */ SRP2,
    /* 0x13 */ SZP0,
    /* 0x14 */ SZP1,
    /* 0x15 */ SZP2,
    /* 0x16 */ SZPS,
    /* 0x17 */ SLOOP,
    /* 0x18 */ RTG,
    /* 0x19 */ RTHG,
    /* 0x1A */ SMD,
    /* 0x1B */ ELSE,
    /* 0x1C */ JMPR,
    /* 0x1D */ SCVTCI,
    /* 0x1E */ undefined,
    /* 0x1F */ undefined,
    /* 0x20 */ DUP,
    /* 0x21 */ POP,
    /* 0x22 */ CLEAR,
    /* 0x23 */ SWAP,
    /* 0x24 */ DEPTH,
    /* 0x25 */ CINDEX,
    /* 0x26 */ MINDEX,
    /* 0x27 */ undefined,
    /* 0x28 */ undefined,
    /* 0x29 */ undefined,
    /* 0x2A */ LOOPCALL,
    /* 0x2B */ CALL,
    /* 0x2C */ FDEF,
    /* 0x2D */ undefined,
    /* 0x2E */ MDAP.bind(undefined, 0),
    /* 0x2F */ MDAP.bind(undefined, 1),
    /* 0x30 */ IUP.bind(undefined, yUnitVector),
    /* 0x31 */ IUP.bind(undefined, xUnitVector),
    /* 0x32 */ SHP.bind(undefined, 0),
    /* 0x33 */ SHP.bind(undefined, 1),
    /* 0x34 */ SHC.bind(undefined, 0),
    /* 0x35 */ SHC.bind(undefined, 1),
    /* 0x36 */ SHZ.bind(undefined, 0),
    /* 0x37 */ SHZ.bind(undefined, 1),
    /* 0x38 */ SHPIX,
    /* 0x39 */ IP,
    /* 0x3A */ MSIRP.bind(undefined, 0),
    /* 0x3B */ MSIRP.bind(undefined, 1),
    /* 0x3C */ ALIGNRP,
    /* 0x3D */ RTDG,
    /* 0x3E */ MIAP.bind(undefined, 0),
    /* 0x3F */ MIAP.bind(undefined, 1),
    /* 0x40 */ NPUSHB,
    /* 0x41 */ NPUSHW,
    /* 0x42 */ WS,
    /* 0x43 */ RS,
    /* 0x44 */ WCVTP,
    /* 0x45 */ RCVT,
    /* 0x46 */ GC.bind(undefined, 0),
    /* 0x47 */ GC.bind(undefined, 1),
    /* 0x48 */ undefined,
    /* 0x49 */ MD.bind(undefined, 0),
    /* 0x4A */ MD.bind(undefined, 1),
    /* 0x4B */ MPPEM,
    /* 0x4C */ undefined,
    /* 0x4D */ FLIPON,
    /* 0x4E */ undefined,
    /* 0x4F */ undefined,
    /* 0x50 */ LT,
    /* 0x51 */ LTEQ,
    /* 0x52 */ GT,
    /* 0x53 */ GTEQ,
    /* 0x54 */ EQ,
    /* 0x55 */ NEQ,
    /* 0x56 */ ODD,
    /* 0x57 */ EVEN,
    /* 0x58 */ IF,
    /* 0x59 */ EIF,
    /* 0x5A */ AND,
    /* 0x5B */ OR,
    /* 0x5C */ NOT,
    /* 0x5D */ DELTAP123.bind(undefined, 1),
    /* 0x5E */ SDB,
    /* 0x5F */ SDS,
    /* 0x60 */ ADD,
    /* 0x61 */ SUB,
    /* 0x62 */ DIV,
    /* 0x63 */ MUL,
    /* 0x64 */ ABS,
    /* 0x65 */ NEG,
    /* 0x66 */ FLOOR,
    /* 0x67 */ CEILING,
    /* 0x68 */ ROUND.bind(undefined, 0),
    /* 0x69 */ ROUND.bind(undefined, 1),
    /* 0x6A */ ROUND.bind(undefined, 2),
    /* 0x6B */ ROUND.bind(undefined, 3),
    /* 0x6C */ undefined,
    /* 0x6D */ undefined,
    /* 0x6E */ undefined,
    /* 0x6F */ undefined,
    /* 0x70 */ WCVTF,
    /* 0x71 */ DELTAP123.bind(undefined, 2),
    /* 0x72 */ DELTAP123.bind(undefined, 3),
    /* 0x73 */ DELTAC123.bind(undefined, 1),
    /* 0x74 */ DELTAC123.bind(undefined, 2),
    /* 0x75 */ DELTAC123.bind(undefined, 3),
    /* 0x76 */ SROUND,
    /* 0x77 */ S45ROUND,
    /* 0x78 */ undefined,
    /* 0x79 */ undefined,
    /* 0x7A */ ROFF,
    /* 0x7B */ undefined,
    /* 0x7C */ RUTG,
    /* 0x7D */ RDTG,
    /* 0x7E */ POP,
    /* 0x7F */ POP,
    /* 0x80 */ undefined,
    /* 0x81 */ undefined,
    /* 0x82 */ undefined,
    /* 0x83 */ undefined,
    /* 0x84 */ undefined,
    /* 0x85 */ SCANCTRL,
    /* 0x86 */ SDPVTL.bind(undefined, 0),
    /* 0x87 */ SDPVTL.bind(undefined, 1),
    /* 0x88 */ GETINFO,
    /* 0x89 */ undefined,
    /* 0x8A */ ROLL,
    /* 0x8B */ MAX,
    /* 0x8C */ MIN,
    /* 0x8D */ SCANTYPE,
    /* 0x8E */ INSTCTRL,
    /* 0x8F */ undefined,
    /* 0x90 */ undefined,
    /* 0x91 */ undefined,
    /* 0x92 */ undefined,
    /* 0x93 */ undefined,
    /* 0x94 */ undefined,
    /* 0x95 */ undefined,
    /* 0x96 */ undefined,
    /* 0x97 */ undefined,
    /* 0x98 */ undefined,
    /* 0x99 */ undefined,
    /* 0x9A */ undefined,
    /* 0x9B */ undefined,
    /* 0x9C */ undefined,
    /* 0x9D */ undefined,
    /* 0x9E */ undefined,
    /* 0x9F */ undefined,
    /* 0xA0 */ undefined,
    /* 0xA1 */ undefined,
    /* 0xA2 */ undefined,
    /* 0xA3 */ undefined,
    /* 0xA4 */ undefined,
    /* 0xA5 */ undefined,
    /* 0xA6 */ undefined,
    /* 0xA7 */ undefined,
    /* 0xA8 */ undefined,
    /* 0xA9 */ undefined,
    /* 0xAA */ undefined,
    /* 0xAB */ undefined,
    /* 0xAC */ undefined,
    /* 0xAD */ undefined,
    /* 0xAE */ undefined,
    /* 0xAF */ undefined,
    /* 0xB0 */ PUSHB.bind(undefined, 1),
    /* 0xB1 */ PUSHB.bind(undefined, 2),
    /* 0xB2 */ PUSHB.bind(undefined, 3),
    /* 0xB3 */ PUSHB.bind(undefined, 4),
    /* 0xB4 */ PUSHB.bind(undefined, 5),
    /* 0xB5 */ PUSHB.bind(undefined, 6),
    /* 0xB6 */ PUSHB.bind(undefined, 7),
    /* 0xB7 */ PUSHB.bind(undefined, 8),
    /* 0xB8 */ PUSHW.bind(undefined, 1),
    /* 0xB9 */ PUSHW.bind(undefined, 2),
    /* 0xBA */ PUSHW.bind(undefined, 3),
    /* 0xBB */ PUSHW.bind(undefined, 4),
    /* 0xBC */ PUSHW.bind(undefined, 5),
    /* 0xBD */ PUSHW.bind(undefined, 6),
    /* 0xBE */ PUSHW.bind(undefined, 7),
    /* 0xBF */ PUSHW.bind(undefined, 8),
    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
];
exports.default = Hinting; /*****************************
  Mathematical Considerations
******************************

fv ... refers to freedom vector
pv ... refers to projection vector
rp ... refers to reference point
p  ... refers to to point being operated on
d  ... refers to distance

SETRELATIVE:
============

case freedom vector == x-axis:
------------------------------

                        (pv)
                     .-'
              rpd .-'
               .-*
          d .-'90'
         .-'       '
      .-'           '
   *-'               ' b
  rp                  '
                       '
                        '
            p *----------*-------------- (fv)
                          pm

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b

   y - rpdy = pvns * (x- rpdx)

   y = p.y

   x = rpdx + ( p.y - rpdy ) / pvns


case freedom vector == y-axis:
------------------------------

    * pm
    |\
    | \
    |  \
    |   \
    |    \
    |     \
    |      \
    |       \
    |        \
    |         \ b
    |          \
    |           \
    |            \    .-' (pv)
    |         90 \.-'
    |           .-'* rpd
    |        .-'
    *     *-'  d
    p     rp

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b:
           pvns ... normal slope to pv

   y - rpdy = pvns * (x - rpdx)

   x = p.x

   y = rpdy +  pvns * (p.x - rpdx)



generic case:
-------------


                              .'(fv)
                            .'
                          .* pm
                        .' !
                      .'    .
                    .'      !
                  .'         . b
                .'           !
               *              .
              p               !
                         90   .    ... (pv)
                           ...-*-'''
                  ...---'''    rpd
         ...---'''   d
   *--'''
  rp

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

 equation of line b:
    pvns... normal slope to pv

    y - rpdy = pvns * (x - rpdx)

 equation of freedom vector line:
    fvs ... slope of freedom vector (=fy/fx)

    y - py = fvs * (x - px)


  on pm both equations are true for same x/y

    y - rpdy = pvns * (x - rpdx)

    y - py = fvs * (x - px)

  form to y and set equal:

    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

  expand:

    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

  switch:

    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

  solve for x:

    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



          fvs * px - pvns * rpdx + rpdy - py
    x =  -----------------------------------
                 fvs - pvns

  and:

    y = fvs * (x - px) + py



INTERPOLATE:
============

Examples of point interpolation.

The weight of the movement of the reference point gets bigger
the further the other reference point is away, thus the safest
option (that is avoiding 0/0 divisions) is to weight the
original distance of the other point by the sum of both distances.

If the sum of both distances is 0, then move the point by the
arithmetic average of the movement of both reference points.




           (+6)
    rp1o *---->*rp1
         .     .                          (+12)
         .     .                  rp2o *---------->* rp2
         .     .                       .           .
         .     .                       .           .
         .    10          20           .           .
         |.........|...................|           .
               .   .                               .
               .   . (+8)                          .
                po *------>*p                      .
               .           .                       .
               .    12     .          24           .
               |...........|.......................|
                                  36


-------



           (+10)
    rp1o *-------->*rp1
         .         .                      (-10)
         .         .              rp2 *<---------* rpo2
         .         .                   .         .
         .         .                   .         .
         .    10   .          30       .         .
         |.........|.............................|
                   .                   .
                   . (+5)              .
                po *--->* p            .
                   .    .              .
                   .    .   20         .
                   |....|..............|
                     5        15


-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .
    rp2o *-------->*rp2


                               (+10)
                          po *-------->* p

-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .(+30)
    rp2o *---------------------------->*rp2


                                        (+25)
                          po *----------------------->* p



vim: set ts=4 sw=4 expandtab:
*****/ 

},{"./tables/glyf":"5Ol2G","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Ol2G":[function(require,module,exports,__globalThis) {
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _glyphset = require("../glyphset");
var _glyphsetDefault = parcelHelpers.interopDefault(_glyphset);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _path = require("../path");
var _pathDefault = parcelHelpers.interopDefault(_path);
// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    let v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) v = -v;
        v = previousValue + v;
    } else //  The coordinate is 2 bytes long.
    // If the `same` bit is set, the coordinate is the same as the previous coordinate.
    if ((flag & sameBitMask) > 0) v = previousValue;
    else // Parse the coordinate as a signed 16-bit delta value.
    v = previousValue + p.parseShort();
    return v;
}
// Parse a TrueType glyph.
function parseGlyph(glyph, data, start) {
    const p = new (0, _parseDefault.default).Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    let flags;
    let flag;
    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        const endPointIndices = glyph.endPointIndices = [];
        for(let i = 0; i < glyph.numberOfContours; i += 1)endPointIndices.push(p.parseUShort());
        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for(let i = 0; i < glyph.instructionLength; i += 1)glyph.instructions.push(p.parseByte());
        const numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for(let i = 0; i < numberOfCoordinates; i += 1){
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                const repeatCount = p.parseByte();
                for(let j = 0; j < repeatCount; j += 1){
                    flags.push(flag);
                    i += 1;
                }
            }
        }
        (0, _checkDefault.default).argument(flags.length === numberOfCoordinates, 'Bad flags.');
        if (endPointIndices.length > 0) {
            const points = [];
            let point;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for(let i = 0; i < numberOfCoordinates; i += 1){
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }
                let px = 0;
                for(let i = 0; i < numberOfCoordinates; i += 1){
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }
                let py = 0;
                for(let i = 0; i < numberOfCoordinates; i += 1){
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }
            glyph.points = points;
        } else glyph.points = [];
    } else if (glyph.numberOfContours === 0) glyph.points = [];
    else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        let moreComponents = true;
        while(moreComponents){
            flags = p.parseUShort();
            const component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else // values are matched points
                component.matchedPoints = [
                    p.parseUShort(),
                    p.parseUShort()
                ];
            } else // The arguments are bytes
            if ((flags & 2) > 0) {
                // values are offset
                component.dx = p.parseChar();
                component.dy = p.parseChar();
            } else // values are matched points
            component.matchedPoints = [
                p.parseByte(),
                p.parseByte()
            ];
            if ((flags & 8) > 0) // We have a scale
            component.xScale = component.yScale = p.parseF2Dot14();
            else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }
            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
        if (flags & 0x100) {
            // We have instructions
            glyph.instructionLength = p.parseUShort();
            glyph.instructions = [];
            for(let i = 0; i < glyph.instructionLength; i += 1)glyph.instructions.push(p.parseByte());
        }
    }
}
// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    const newPoints = [];
    for(let i = 0; i < points.length; i += 1){
        const pt = points[i];
        const newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }
    return newPoints;
}
function getContours(points) {
    const contours = [];
    let currentContour = [];
    for(let i = 0; i < points.length; i += 1){
        const pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    (0, _checkDefault.default).argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}
// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    const p = new (0, _pathDefault.default)();
    if (!points) return p;
    const contours = getContours(points);
    for(let contourIndex = 0; contourIndex < contours.length; ++contourIndex){
        const contour = contours[contourIndex];
        let prev = null;
        let curr = contour[contour.length - 1];
        let next = contour[0];
        if (curr.onCurve) p.moveTo(curr.x, curr.y);
        else if (next.onCurve) p.moveTo(next.x, next.y);
        else {
            // If both first and last points are off-curve, start at their middle.
            const start = {
                x: (curr.x + next.x) * 0.5,
                y: (curr.y + next.y) * 0.5
            };
            p.moveTo(start.x, start.y);
        }
        for(let i = 0; i < contour.length; ++i){
            prev = curr;
            curr = next;
            next = contour[(i + 1) % contour.length];
            if (curr.onCurve) // This is a straight line.
            p.lineTo(curr.x, curr.y);
            else {
                let prev2 = prev;
                let next2 = next;
                if (!prev.onCurve) prev2 = {
                    x: (curr.x + prev.x) * 0.5,
                    y: (curr.y + prev.y) * 0.5
                };
                if (!next.onCurve) next2 = {
                    x: (curr.x + next.x) * 0.5,
                    y: (curr.y + next.y) * 0.5
                };
                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            }
        }
        p.closePath();
    }
    return p;
}
function buildPath(glyphs, glyph) {
    if (glyph.isComposite) for(let j = 0; j < glyph.components.length; j += 1){
        const component = glyph.components[j];
        const componentGlyph = glyphs.get(component.glyphIndex);
        // Force the ttfGlyphLoader to parse the glyph.
        componentGlyph.getPath();
        if (componentGlyph.points) {
            let transformedPoints;
            if (component.matchedPoints === undefined) // component positioned by offset
            transformedPoints = transformPoints(componentGlyph.points, component);
            else {
                // component positioned by matched points
                if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) throw Error('Matched points out of range in ' + glyph.name);
                const firstPt = glyph.points[component.matchedPoints[0]];
                let secondPt = componentGlyph.points[component.matchedPoints[1]];
                const transform = {
                    xScale: component.xScale,
                    scale01: component.scale01,
                    scale10: component.scale10,
                    yScale: component.yScale,
                    dx: 0,
                    dy: 0
                };
                secondPt = transformPoints([
                    secondPt
                ], transform)[0];
                transform.dx = firstPt.x - secondPt.x;
                transform.dy = firstPt.y - secondPt.y;
                transformedPoints = transformPoints(componentGlyph.points, transform);
            }
            glyph.points = glyph.points.concat(transformedPoints);
        }
    }
    return getPath(glyph.points);
}
// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    const glyphs = new (0, _glyphsetDefault.default).GlyphSet(font);
    // The last element of the loca table is invalid.
    for(let i = 0; i < loca.length - 1; i += 1){
        const offset = loca[i];
        const nextOffset = loca[i + 1];
        if (offset !== nextOffset) glyphs.push(i, (0, _glyphsetDefault.default).ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        else glyphs.push(i, (0, _glyphsetDefault.default).glyphLoader(font, i));
    }
    return glyphs;
}
exports.default = {
    getPath,
    parse: parseGlyfTable
};

},{"../check":"184gJ","../glyphset":"d9O7P","../parse":"8RdJX","../path":"gWom8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"nSHVg":[function(require,module,exports,__globalThis) {
/**
 * Infer bidirectional properties for a given text and apply
 * the corresponding layout rules.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tokenizer = require("./tokenizer");
var _tokenizerDefault = parcelHelpers.interopDefault(_tokenizer);
var _arabicWord = require("./features/arab/contextCheck/arabicWord");
var _arabicWordDefault = parcelHelpers.interopDefault(_arabicWord);
var _arabicSentence = require("./features/arab/contextCheck/arabicSentence");
var _arabicSentenceDefault = parcelHelpers.interopDefault(_arabicSentence);
var _arabicPresentationForms = require("./features/arab/arabicPresentationForms");
var _arabicPresentationFormsDefault = parcelHelpers.interopDefault(_arabicPresentationForms);
var _arabicRequiredLigatures = require("./features/arab/arabicRequiredLigatures");
var _arabicRequiredLigaturesDefault = parcelHelpers.interopDefault(_arabicRequiredLigatures);
/**
 * Create Bidi. features
 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
 */ function Bidi(baseDir) {
    this.baseDir = baseDir || 'ltr';
    this.tokenizer = new (0, _tokenizerDefault.default)();
    this.features = [];
}
/**
 * Sets Bidi text
 * @param {string} text a text input
 */ Bidi.prototype.setText = function(text) {
    this.text = text;
};
/**
 * Store essential context checks:
 * arabic word check for applying gsub features
 * arabic sentence check for adjusting arabic layout
 */ Bidi.prototype.contextChecks = {
    arabicWordCheck: (0, _arabicWordDefault.default),
    arabicSentenceCheck: (0, _arabicSentenceDefault.default)
};
/**
 * Register arabic word check
 */ function registerArabicWordCheck() {
    const checks = this.contextChecks.arabicWordCheck;
    return this.tokenizer.registerContextChecker('arabicWord', checks.arabicWordStartCheck, checks.arabicWordEndCheck);
}
/**
 * Register arabic sentence check
 */ function registerArabicSentenceCheck() {
    const checks = this.contextChecks.arabicSentenceCheck;
    return this.tokenizer.registerContextChecker('arabicSentence', checks.arabicSentenceStartCheck, checks.arabicSentenceEndCheck);
}
/**
 * Perform pre tokenization procedure then
 * tokenize text input
 */ function tokenizeText() {
    registerArabicWordCheck.call(this);
    registerArabicSentenceCheck.call(this);
    return this.tokenizer.tokenize(this.text);
}
/**
 * Reverse arabic sentence layout
 * TODO: check base dir before applying adjustments - priority low
 */ function reverseArabicSentences() {
    const ranges = this.tokenizer.getContextRanges('arabicSentence');
    ranges.forEach((range)=>{
        let rangeTokens = this.tokenizer.getRangeTokens(range);
        this.tokenizer.replaceRange(range.startIndex, range.endOffset, rangeTokens.reverse());
    });
}
/**
 * Subscribe arabic presentation form features
 * @param {feature} feature a feature to apply
 */ Bidi.prototype.subscribeArabicForms = function(feature) {
    this.tokenizer.events.contextEnd.subscribe((contextName, range)=>{
        if (contextName === 'arabicWord') return (0, _arabicPresentationFormsDefault.default).call(this.tokenizer, range, feature);
    });
};
/**
 * Apply Gsub features
 * @param {feature} features a list of features
 */ Bidi.prototype.applyFeatures = function(features) {
    for(let i = 0; i < features.length; i++){
        const feature = features[i];
        if (feature) {
            const script = feature.script;
            if (!this.features[script]) this.features[script] = {};
            this.features[script][feature.tag] = feature;
        }
    }
};
/**
 * Register a state modifier
 * @param {string} modifierId state modifier id
 * @param {function} condition a predicate function that returns true or false
 * @param {function} modifier a modifier function to set token state
 */ Bidi.prototype.registerModifier = function(modifierId, condition, modifier) {
    this.tokenizer.registerModifier(modifierId, condition, modifier);
};
/**
 * Check if 'glyphIndex' is registered
 */ function checkGlyphIndexStatus() {
    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) throw new Error("glyphIndex modifier is required to apply arabic presentation features.");
}
/**
 * Apply arabic presentation forms features
 */ function applyArabicPresentationForms() {
    if (!this.features.hasOwnProperty('arab')) return;
    checkGlyphIndexStatus.call(this);
    const ranges = this.tokenizer.getContextRanges('arabicWord');
    ranges.forEach((range)=>{
        (0, _arabicPresentationFormsDefault.default).call(this, range);
    });
}
/**
 * Apply required arabic ligatures
 */ function applyArabicRequireLigatures() {
    if (!this.features.hasOwnProperty('arab')) return;
    if (!this.features.arab.hasOwnProperty('rlig')) return;
    checkGlyphIndexStatus.call(this);
    const ranges = this.tokenizer.getContextRanges('arabicWord');
    ranges.forEach((range)=>{
        (0, _arabicRequiredLigaturesDefault.default).call(this, range);
    });
}
/**
 * process text input
 * @param {string} text an input text
 */ Bidi.prototype.processText = function(text) {
    if (!this.text || this.text !== text) {
        this.setText(text);
        tokenizeText.call(this);
        applyArabicPresentationForms.call(this);
        applyArabicRequireLigatures.call(this);
        reverseArabicSentences.call(this);
    }
};
/**
 * Process a string of text to identify and adjust
 * bidirectional text entities.
 * @param {string} text input text
 */ Bidi.prototype.getBidiText = function(text) {
    this.processText(text);
    return this.tokenizer.getText();
};
/**
 * Get the current state index of each token
 * @param {text} text an input text
 */ Bidi.prototype.getTextGlyphs = function(text) {
    this.processText(text);
    let indexes = [];
    for(let i = 0; i < this.tokenizer.tokens.length; i++){
        const token = this.tokenizer.tokens[i];
        if (token.state.deleted) continue;
        const index = token.activeState.value;
        indexes.push(Array.isArray(index) ? index[0] : index);
    }
    return indexes;
};
exports.default = Bidi;

},{"./tokenizer":"faOhG","./features/arab/contextCheck/arabicWord":"8hCzR","./features/arab/contextCheck/arabicSentence":"rz1X9","./features/arab/arabicPresentationForms":"bcSAO","./features/arab/arabicRequiredLigatures":"22P9B","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"faOhG":[function(require,module,exports,__globalThis) {
/**
 * Converts a string into a list of tokens.
 */ /**
 * Create a new token
 * @param {string} char a single char
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Token", ()=>Token);
parcelHelpers.export(exports, "Event", ()=>Event);
parcelHelpers.export(exports, "ContextRange", ()=>ContextRange);
parcelHelpers.export(exports, "ContextParams", ()=>ContextParams);
function Token(char) {
    this.char = char;
    this.state = {};
    this.activeState = null;
}
/**
 * Create a new context range
 * @param {number} startIndex range start index
 * @param {number} endOffset range end index offset
 * @param {string} contextName owner context name
 */ function ContextRange(startIndex, endOffset, contextName) {
    this.contextName = contextName;
    this.startIndex = startIndex;
    this.endOffset = endOffset;
}
/**
 * Check context start and end
 * @param {string} contextName a unique context name
 * @param {function} checkStart a predicate function the indicates a context's start
 * @param {function} checkEnd a predicate function the indicates a context's end
 */ function ContextChecker(contextName, checkStart, checkEnd) {
    this.contextName = contextName;
    this.openRange = null;
    this.ranges = [];
    this.checkStart = checkStart;
    this.checkEnd = checkEnd;
}
/**
 * Create a context params
 * @param {array} context a list of items
 * @param {number} currentIndex current item index
 */ function ContextParams(context, currentIndex) {
    this.context = context;
    this.index = currentIndex;
    this.length = context.length;
    this.current = context[currentIndex];
    this.backtrack = context.slice(0, currentIndex);
    this.lookahead = context.slice(currentIndex + 1);
}
/**
 * Create an event instance
 * @param {string} eventId event unique id
 */ function Event(eventId) {
    this.eventId = eventId;
    this.subscribers = [];
}
/**
 * Initialize a core events and auto subscribe required event handlers
 * @param {any} events an object that enlists core events handlers
 */ function initializeCoreEvents(events) {
    const coreEvents = [
        'start',
        'end',
        'next',
        'newToken',
        'contextStart',
        'contextEnd',
        'insertToken',
        'removeToken',
        'removeRange',
        'replaceToken',
        'replaceRange',
        'composeRUD',
        'updateContextsRanges'
    ];
    coreEvents.forEach((eventId)=>{
        Object.defineProperty(this.events, eventId, {
            value: new Event(eventId)
        });
    });
    if (!!events) coreEvents.forEach((eventId)=>{
        const event = events[eventId];
        if (typeof event === 'function') this.events[eventId].subscribe(event);
    });
    const requiresContextUpdate = [
        'insertToken',
        'removeToken',
        'removeRange',
        'replaceToken',
        'replaceRange',
        'composeRUD'
    ];
    requiresContextUpdate.forEach((eventId)=>{
        this.events[eventId].subscribe(this.updateContextsRanges);
    });
}
/**
 * Converts a string into a list of tokens
 * @param {any} events tokenizer core events
 */ function Tokenizer(events) {
    this.tokens = [];
    this.registeredContexts = {};
    this.contextCheckers = [];
    this.events = {};
    this.registeredModifiers = [];
    initializeCoreEvents.call(this, events);
}
/**
 * Sets the state of a token, usually called by a state modifier.
 * @param {string} key state item key
 * @param {any} value state item value
 */ Token.prototype.setState = function(key, value) {
    this.state[key] = value;
    this.activeState = {
        key,
        value: this.state[key]
    };
    return this.activeState;
};
Token.prototype.getState = function(stateId) {
    return this.state[stateId] || null;
};
/**
 * Checks if an index exists in the tokens list.
 * @param {number} index token index
 */ Tokenizer.prototype.inboundIndex = function(index) {
    return index >= 0 && index < this.tokens.length;
};
/**
 * Compose and apply a list of operations (replace, update, delete)
 * @param {array} RUDs replace, update and delete operations
 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
 */ Tokenizer.prototype.composeRUD = function(RUDs) {
    const silent = true;
    const state = RUDs.map((RUD)=>this[RUD[0]].apply(this, RUD.slice(1).concat(silent)));
    const hasFAILObject = (obj)=>typeof obj === 'object' && obj.hasOwnProperty('FAIL');
    if (state.every(hasFAILObject)) return {
        FAIL: `composeRUD: one or more operations hasn't completed successfully`,
        report: state.filter(hasFAILObject)
    };
    this.dispatch('composeRUD', [
        state.filter((op)=>!hasFAILObject(op))
    ]);
};
/**
 * Replace a range of tokens with a list of tokens
 * @param {number} startIndex range start index
 * @param {number} offset range offset
 * @param {token} tokens a list of tokens to replace
 * @param {boolean} silent dispatch events and update context ranges
 */ Tokenizer.prototype.replaceRange = function(startIndex, offset, tokens, silent) {
    offset = offset !== null ? offset : this.tokens.length;
    const isTokenType = tokens.every((token)=>token instanceof Token);
    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
        const replaced = this.tokens.splice.apply(this.tokens, [
            startIndex,
            offset
        ].concat(tokens));
        if (!silent) this.dispatch('replaceToken', [
            startIndex,
            offset,
            tokens
        ]);
        return [
            replaced,
            tokens
        ];
    } else return {
        FAIL: 'replaceRange: invalid tokens or startIndex.'
    };
};
/**
 * Replace a token with another token
 * @param {number} index token index
 * @param {token} token a token to replace
 * @param {boolean} silent dispatch events and update context ranges
 */ Tokenizer.prototype.replaceToken = function(index, token, silent) {
    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
        const replaced = this.tokens.splice(index, 1, token);
        if (!silent) this.dispatch('replaceToken', [
            index,
            token
        ]);
        return [
            replaced[0],
            token
        ];
    } else return {
        FAIL: 'replaceToken: invalid token or index.'
    };
};
/**
 * Removes a range of tokens
 * @param {number} startIndex range start index
 * @param {number} offset range offset
 * @param {boolean} silent dispatch events and update context ranges
 */ Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
    offset = !isNaN(offset) ? offset : this.tokens.length;
    const tokens = this.tokens.splice(startIndex, offset);
    if (!silent) this.dispatch('removeRange', [
        tokens,
        startIndex,
        offset
    ]);
    return tokens;
};
/**
 * Remove a token at a certain index
 * @param {number} index token index
 * @param {boolean} silent dispatch events and update context ranges
 */ Tokenizer.prototype.removeToken = function(index, silent) {
    if (!isNaN(index) && this.inboundIndex(index)) {
        const token = this.tokens.splice(index, 1);
        if (!silent) this.dispatch('removeToken', [
            token,
            index
        ]);
        return token;
    } else return {
        FAIL: 'removeToken: invalid token index.'
    };
};
/**
 * Insert a list of tokens at a certain index
 * @param {array} tokens a list of tokens to insert
 * @param {number} index insert the list of tokens at index
 * @param {boolean} silent dispatch events and update context ranges
 */ Tokenizer.prototype.insertToken = function(tokens, index, silent) {
    const tokenType = tokens.every((token)=>token instanceof Token);
    if (tokenType) {
        this.tokens.splice.apply(this.tokens, [
            index,
            0
        ].concat(tokens));
        if (!silent) this.dispatch('insertToken', [
            tokens,
            index
        ]);
        return tokens;
    } else return {
        FAIL: 'insertToken: invalid token(s).'
    };
};
/**
 * A state modifier that is called on 'newToken' event
 * @param {string} modifierId state modifier id
 * @param {function} condition a predicate function that returns true or false
 * @param {function} modifier a function to update token state
 */ Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
    this.events.newToken.subscribe(function(token, contextParams) {
        const conditionParams = [
            token,
            contextParams
        ];
        const canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;
        const modifierParams = [
            token,
            contextParams
        ];
        if (canApplyModifier) {
            let newStateValue = modifier.apply(this, modifierParams);
            token.setState(modifierId, newStateValue);
        }
    });
    this.registeredModifiers.push(modifierId);
};
/**
 * Subscribe a handler to an event
 * @param {function} eventHandler an event handler function
 */ Event.prototype.subscribe = function(eventHandler) {
    if (typeof eventHandler === 'function') return this.subscribers.push(eventHandler) - 1;
    else return {
        FAIL: `invalid '${this.eventId}' event handler`
    };
};
/**
 * Unsubscribe an event handler
 * @param {string} subsId subscription id
 */ Event.prototype.unsubscribe = function(subsId) {
    this.subscribers.splice(subsId, 1);
};
/**
 * Sets context params current value index
 * @param {number} index context params current value index
 */ ContextParams.prototype.setCurrentIndex = function(index) {
    this.index = index;
    this.current = this.context[index];
    this.backtrack = this.context.slice(0, index);
    this.lookahead = this.context.slice(index + 1);
};
/**
 * Get an item at an offset from the current value
 * example (current value is 3):
 *  1    2   [3]   4    5   |   items values
 * -2   -1    0    1    2   |   offset values
 * @param {number} offset an offset from current value index
 */ ContextParams.prototype.get = function(offset) {
    switch(true){
        case offset === 0:
            return this.current;
        case offset < 0 && Math.abs(offset) <= this.backtrack.length:
            return this.backtrack.slice(offset)[0];
        case offset > 0 && offset <= this.lookahead.length:
            return this.lookahead[offset - 1];
        default:
            return null;
    }
};
/**
 * Converts a context range into a string value
 * @param {contextRange} range a context range
 */ Tokenizer.prototype.rangeToText = function(range) {
    if (range instanceof ContextRange) return this.getRangeTokens(range).map((token)=>token.char).join('');
};
/**
 * Converts all tokens into a string
 */ Tokenizer.prototype.getText = function() {
    return this.tokens.map((token)=>token.char).join('');
};
/**
 * Get a context by name
 * @param {string} contextName context name to get
 */ Tokenizer.prototype.getContext = function(contextName) {
    let context = this.registeredContexts[contextName];
    return !!context ? context : null;
};
/**
 * Subscribes a new event handler to an event
 * @param {string} eventName event name to subscribe to
 * @param {function} eventHandler a function to be invoked on event
 */ Tokenizer.prototype.on = function(eventName, eventHandler) {
    const event = this.events[eventName];
    if (!!event) return event.subscribe(eventHandler);
    else return null;
};
/**
 * Dispatches an event
 * @param {string} eventName event name
 * @param {any} args event handler arguments
 */ Tokenizer.prototype.dispatch = function(eventName, args) {
    const event = this.events[eventName];
    if (event instanceof Event) event.subscribers.forEach((subscriber)=>{
        subscriber.apply(this, args || []);
    });
};
/**
 * Register a new context checker
 * @param {string} contextName a unique context name
 * @param {function} contextStartCheck a predicate function that returns true on context start
 * @param {function} contextEndCheck  a predicate function that returns true on context end
 * TODO: call tokenize on registration to update context ranges with the new context.
 */ Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
    if (!!this.getContext(contextName)) return {
        FAIL: `context name '${contextName}' is already registered.`
    };
    if (typeof contextStartCheck !== 'function') return {
        FAIL: `missing context start check.`
    };
    if (typeof contextEndCheck !== 'function') return {
        FAIL: `missing context end check.`
    };
    const contextCheckers = new ContextChecker(contextName, contextStartCheck, contextEndCheck);
    this.registeredContexts[contextName] = contextCheckers;
    this.contextCheckers.push(contextCheckers);
    return contextCheckers;
};
/**
 * Gets a context range tokens
 * @param {contextRange} range a context range
 */ Tokenizer.prototype.getRangeTokens = function(range) {
    const endIndex = range.startIndex + range.endOffset;
    return [].concat(this.tokens.slice(range.startIndex, endIndex));
};
/**
 * Gets the ranges of a context
 * @param {string} contextName context name
 */ Tokenizer.prototype.getContextRanges = function(contextName) {
    const context = this.getContext(contextName);
    if (!!context) return context.ranges;
    else return {
        FAIL: `context checker '${contextName}' is not registered.`
    };
};
/**
 * Resets context ranges to run context update
 */ Tokenizer.prototype.resetContextsRanges = function() {
    const registeredContexts = this.registeredContexts;
    for(const contextName in registeredContexts)if (registeredContexts.hasOwnProperty(contextName)) {
        const context = registeredContexts[contextName];
        context.ranges = [];
    }
};
/**
 * Updates context ranges
 */ Tokenizer.prototype.updateContextsRanges = function() {
    this.resetContextsRanges();
    const chars = this.tokens.map((token)=>token.char);
    for(let i = 0; i < chars.length; i++){
        const contextParams = new ContextParams(chars, i);
        this.runContextCheck(contextParams);
    }
    this.dispatch('updateContextsRanges', [
        this.registeredContexts
    ]);
};
/**
 * Sets the end offset of an open range
 * @param {number} offset range end offset
 * @param {string} contextName context name
 */ Tokenizer.prototype.setEndOffset = function(offset, contextName) {
    const startIndex = this.getContext(contextName).openRange.startIndex;
    let range = new ContextRange(startIndex, offset, contextName);
    const ranges = this.getContext(contextName).ranges;
    range.rangeId = `${contextName}.${ranges.length}`;
    ranges.push(range);
    this.getContext(contextName).openRange = null;
    return range;
};
/**
 * Runs a context check on the current context
 * @param {contextParams} contextParams current context params
 */ Tokenizer.prototype.runContextCheck = function(contextParams) {
    const index = contextParams.index;
    this.contextCheckers.forEach((contextChecker)=>{
        let contextName = contextChecker.contextName;
        let openRange = this.getContext(contextName).openRange;
        if (!openRange && contextChecker.checkStart(contextParams)) {
            openRange = new ContextRange(index, null, contextName);
            this.getContext(contextName).openRange = openRange;
            this.dispatch('contextStart', [
                contextName,
                index
            ]);
        }
        if (!!openRange && contextChecker.checkEnd(contextParams)) {
            const offset = index - openRange.startIndex + 1;
            const range = this.setEndOffset(offset, contextName);
            this.dispatch('contextEnd', [
                contextName,
                range
            ]);
        }
    });
};
/**
 * Converts a text into a list of tokens
 * @param {string} text a text to tokenize
 */ Tokenizer.prototype.tokenize = function(text) {
    this.tokens = [];
    this.resetContextsRanges();
    let chars = Array.from(text);
    this.dispatch('start');
    for(let i = 0; i < chars.length; i++){
        const char = chars[i];
        const contextParams = new ContextParams(chars, i);
        this.dispatch('next', [
            contextParams
        ]);
        this.runContextCheck(contextParams);
        let token = new Token(char);
        this.tokens.push(token);
        this.dispatch('newToken', [
            token,
            contextParams
        ]);
    }
    this.dispatch('end', [
        this.tokens
    ]);
    return this.tokens;
};
exports.default = Tokenizer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8hCzR":[function(require,module,exports,__globalThis) {
/**
 * Arabic word context checkers
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arabicWordStartCheck", ()=>arabicWordStartCheck);
parcelHelpers.export(exports, "arabicWordEndCheck", ()=>arabicWordEndCheck);
var _char = require("../../../char");
function arabicWordStartCheck(contextParams) {
    const char = contextParams.current;
    const prevChar = contextParams.get(-1);
    return(// ? arabic first char
    prevChar === null && (0, _char.isArabicChar)(char) || // ? arabic char preceded with a non arabic char
    !(0, _char.isArabicChar)(prevChar) && (0, _char.isArabicChar)(char));
}
function arabicWordEndCheck(contextParams) {
    const nextChar = contextParams.get(1);
    return(// ? last arabic char
    nextChar === null || // ? next char is not arabic
    !(0, _char.isArabicChar)(nextChar));
}
exports.default = {
    arabicWordStartCheck,
    arabicWordEndCheck
};

},{"../../../char":"d6rZY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d6rZY":[function(require,module,exports,__globalThis) {
// 
//  Character Class Assertions  Checks if a char belongs to a certain class 
// 
// jscs:disable maximumLineLength
/**
 * Check if a char is Arabic
 * @param {string} c a single char
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArabicChar", ()=>isArabicChar);
/**
 * Check if a char is an isolated arabic char
 * @param {string} c a single char
 */ parcelHelpers.export(exports, "isIsolatedArabicChar", ()=>isIsolatedArabicChar);
/**
 * Check if a char is an Arabic Tashkeel char
 * @param {string} c a single char
 */ parcelHelpers.export(exports, "isTashkeelArabicChar", ()=>isTashkeelArabicChar);
/**
 * Check if a char is whitespace char
 * @param {string} c a single char
 */ parcelHelpers.export(exports, "isWhiteSpace", ()=>isWhiteSpace);
function isArabicChar(c) {
    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
}
function isIsolatedArabicChar(char) {
    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
}
function isTashkeelArabicChar(char) {
    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
}
function isWhiteSpace(c) {
    return /\s/.test(c);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"rz1X9":[function(require,module,exports,__globalThis) {
/**
 * Arabic sentence context checkers
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arabicSentenceStartCheck", ()=>arabicSentenceStartCheck);
parcelHelpers.export(exports, "arabicSentenceEndCheck", ()=>arabicSentenceEndCheck);
var _char = require("../../../char");
function arabicSentenceStartCheck(contextParams) {
    const char = contextParams.current;
    const prevChar = contextParams.get(-1);
    return(// ? an arabic char preceded with a non arabic char
    ((0, _char.isArabicChar)(char) || (0, _char.isTashkeelArabicChar)(char)) && !(0, _char.isArabicChar)(prevChar));
}
function arabicSentenceEndCheck(contextParams) {
    const nextChar = contextParams.get(1);
    switch(true){
        case nextChar === null:
            return true;
        case !(0, _char.isArabicChar)(nextChar) && !(0, _char.isTashkeelArabicChar)(nextChar):
            const nextIsWhitespace = (0, _char.isWhiteSpace)(nextChar);
            if (!nextIsWhitespace) return true;
            if (nextIsWhitespace) {
                let arabicCharAhead = false;
                arabicCharAhead = contextParams.lookahead.some((c)=>(0, _char.isArabicChar)(c) || (0, _char.isTashkeelArabicChar)(c));
                if (!arabicCharAhead) return true;
            }
            break;
        default:
            return false;
    }
}
exports.default = {
    arabicSentenceStartCheck,
    arabicSentenceEndCheck
};

},{"../../../char":"d6rZY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bcSAO":[function(require,module,exports,__globalThis) {
/**
 * Apply Arabic presentation forms to a range of tokens
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arabicPresentationForms", ()=>arabicPresentationForms);
var _tokenizer = require("../../tokenizer");
var _char = require("../../char");
/**
 * Check if a char can be connected to it's preceding char
 * @param {ContextParams} charContextParams context params of a char
 */ function willConnectPrev(charContextParams) {
    let backtrack = [].concat(charContextParams.backtrack);
    for(let i = backtrack.length - 1; i >= 0; i--){
        const prevChar = backtrack[i];
        const isolated = (0, _char.isIsolatedArabicChar)(prevChar);
        const tashkeel = (0, _char.isTashkeelArabicChar)(prevChar);
        if (!isolated && !tashkeel) return true;
        if (isolated) return false;
    }
    return false;
}
/**
 * Check if a char can be connected to it's proceeding char
 * @param {ContextParams} charContextParams context params of a char
 */ function willConnectNext(charContextParams) {
    if ((0, _char.isIsolatedArabicChar)(charContextParams.current)) return false;
    for(let i = 0; i < charContextParams.lookahead.length; i++){
        const nextChar = charContextParams.lookahead[i];
        const tashkeel = (0, _char.isTashkeelArabicChar)(nextChar);
        if (!tashkeel) return true;
    }
    return false;
}
/**
 * Apply arabic presentation forms to a list of tokens
 * @param {ContextRange} range a range of tokens
 */ function arabicPresentationForms(range) {
    const features = this.features.arab;
    const rangeTokens = this.tokenizer.getRangeTokens(range);
    if (rangeTokens.length === 1) return;
    const getSubstitutionIndex = (substitution)=>substitution.length === 1 && substitution[0].id === 12 && substitution[0].substitution;
    const applyForm = (tag, token, params)=>{
        if (!features.hasOwnProperty(tag)) return;
        let substitution = features[tag].lookup(params) || null;
        let substIndex = getSubstitutionIndex(substitution)[0];
        if (substIndex >= 0) return token.setState(tag, substIndex);
    };
    const tokensParams = new (0, _tokenizer.ContextParams)(rangeTokens, 0);
    const charContextParams = new (0, _tokenizer.ContextParams)(rangeTokens.map((t)=>t.char), 0);
    rangeTokens.forEach((token, i)=>{
        if ((0, _char.isTashkeelArabicChar)(token.char)) return;
        tokensParams.setCurrentIndex(i);
        charContextParams.setCurrentIndex(i);
        let CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
        if (willConnectPrev(charContextParams)) CONNECT |= 1;
        if (willConnectNext(charContextParams)) CONNECT |= 2;
        switch(CONNECT){
            case 0:
                return;
            case 1:
                applyForm('fina', token, tokensParams);
                break;
            case 2:
                applyForm('init', token, tokensParams);
                break;
            case 3:
                applyForm('medi', token, tokensParams);
                break;
        }
    });
}
exports.default = arabicPresentationForms;

},{"../../tokenizer":"faOhG","../../char":"d6rZY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"22P9B":[function(require,module,exports,__globalThis) {
/**
 * Apply Arabic required ligatures feature to a range of tokens
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arabicRequiredLigatures", ()=>arabicRequiredLigatures);
var _tokenizer = require("../../tokenizer");
/**
 * Apply Arabic required ligatures to a context range
 * @param {ContextRange} range a range of tokens
 */ function arabicRequiredLigatures(range) {
    const features = this.features.arab;
    if (!features.hasOwnProperty('rlig')) return;
    let tokens = this.tokenizer.getRangeTokens(range);
    for(let i = 0; i < tokens.length; i++){
        const lookupParams = new (0, _tokenizer.ContextParams)(tokens, i);
        let substitution = features.rlig.lookup(lookupParams) || null;
        const chainingContext = substitution.length === 1 && substitution[0].id === 63 && substitution[0].substitution;
        const ligature = substitution.length === 1 && substitution[0].id === 41 && substitution[0].substitution[0];
        const token = tokens[i];
        if (!!ligature) {
            token.setState('rlig', [
                ligature.ligGlyph
            ]);
            for(let c = 0; c < ligature.components.length; c++){
                const component = ligature.components[c];
                const lookaheadToken = lookupParams.get(c + 1);
                if (lookaheadToken.activeState.value === component) lookaheadToken.state.deleted = true;
            }
        } else if (chainingContext) {
            const substIndex = chainingContext && chainingContext.length === 1 && chainingContext[0].id === 12 && chainingContext[0].substitution;
            if (!!substIndex && substIndex >= 0) token.setState('rlig', substIndex);
        }
    }
}
exports.default = arabicRequiredLigatures;

},{"../../tokenizer":"faOhG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7BAni":[function(require,module,exports,__globalThis) {
/**
 * Query a feature by some of it's properties to lookup a glyph substitution.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Feature", ()=>Feature);
var _tokenizer = require("../tokenizer");
var _char = require("../char");
// DEFAULT TEXT BASE DIRECTION
let BASE_DIR = 'ltr';
/**
 * Create feature query instance
 * @param {Font} font opentype font instance
 * @param {string} baseDir text base direction
 */ function FeatureQuery(font, baseDir) {
    this.font = font;
    this.features = {};
    BASE_DIR = !!baseDir ? baseDir : BASE_DIR;
}
/**
 * Create a new feature lookup
 * @param {string} tag feature tag
 * @param {feature} feature reference to feature at gsub table
 * @param {FeatureLookups} feature lookups associated with this feature
 * @param {string} script gsub script tag
 */ function Feature(tag, feature, featureLookups, script) {
    this.tag = tag;
    this.featureRef = feature;
    this.lookups = featureLookups.lookups;
    this.script = script;
}
/**
 * Create a coverage table lookup
 * @param {any} coverageTable gsub coverage table
 */ function Coverage(coverageTable) {
    this.table = coverageTable;
}
/**
 * Create a ligature set lookup
 * @param {any} ligatureSets gsub ligature set
 */ function LigatureSets(ligatureSets) {
    this.ligatureSets = ligatureSets;
}
/**
 * Lookup a glyph ligature
 * @param {ContextParams} contextParams context params to lookup
 * @param {number} ligSetIndex ligature set index at ligature sets
 */ LigatureSets.prototype.lookup = function(contextParams, ligSetIndex) {
    const ligatureSet = this.ligatureSets[ligSetIndex];
    const matchComponents = (components, indexes)=>{
        if (components.length > indexes.length) return null;
        for(let c = 0; c < components.length; c++){
            const component = components[c];
            const index = indexes[c];
            if (component !== index) return false;
        }
        return true;
    };
    for(let s = 0; s < ligatureSet.length; s++){
        const ligSetItem = ligatureSet[s];
        const lookaheadIndexes = contextParams.lookahead.map((token)=>token.activeState.value);
        if (BASE_DIR === 'rtl') lookaheadIndexes.reverse();
        const componentsMatch = matchComponents(ligSetItem.components, lookaheadIndexes);
        if (componentsMatch) return ligSetItem;
    }
    return null;
};
/**
 * Create a feature substitution
 * @param {any} lookups a reference to gsub lookups
 * @param {Lookuptable} lookupTable a feature lookup table
 * @param {any} subtable substitution table
 */ function Substitution(lookups, lookupTable, subtable) {
    this.lookups = lookups;
    this.subtable = subtable;
    this.lookupTable = lookupTable;
    if (subtable.hasOwnProperty('coverage')) this.coverage = new Coverage(subtable.coverage);
    if (subtable.hasOwnProperty('inputCoverage')) this.inputCoverage = subtable.inputCoverage.map((table)=>new Coverage(table));
    if (subtable.hasOwnProperty('backtrackCoverage')) this.backtrackCoverage = subtable.backtrackCoverage.map((table)=>new Coverage(table));
    if (subtable.hasOwnProperty('lookaheadCoverage')) this.lookaheadCoverage = subtable.lookaheadCoverage.map((table)=>new Coverage(table));
    if (subtable.hasOwnProperty('ligatureSets')) this.ligatureSets = new LigatureSets(subtable.ligatureSets);
}
/**
 * Create a lookup table lookup
 * @param {number} index table index at gsub lookups
 * @param {any} lookups a reference to gsub lookups
 */ function LookupTable(index, lookups) {
    this.index = index;
    this.subtables = lookups[index].subtables.map((subtable)=>new Substitution(lookups, lookups[index], subtable));
}
function FeatureLookups(lookups, lookupListIndexes) {
    this.lookups = lookupListIndexes.map((index)=>new LookupTable(index, lookups));
}
/**
 * Lookup a lookup table subtables
 * @param {ContextParams} contextParams context params to lookup
 */ LookupTable.prototype.lookup = function(contextParams) {
    let substitutions = [];
    for(let i = 0; i < this.subtables.length; i++){
        const subsTable = this.subtables[i];
        let substitution = subsTable.lookup(contextParams);
        if (substitution !== null || substitution.length) substitutions = substitutions.concat(substitution);
    }
    return substitutions;
};
/**
 * Handle a single substitution - format 2
 * @param {ContextParams} contextParams context params to lookup
 */ function singleSubstitutionFormat2(contextParams) {
    let glyphIndex = contextParams.current.activeState.value;
    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
    let substituteIndex = this.coverage.lookup(glyphIndex);
    if (substituteIndex === -1) return [];
    return [
        this.subtable.substitute[substituteIndex]
    ];
}
/**
 * Lookup a list of coverage tables
 * @param {any} coverageList a list of coverage tables
 * @param {any} contextParams context params to lookup
 */ function lookupCoverageList(coverageList, contextParams) {
    let lookupList = [];
    for(let i = 0; i < coverageList.length; i++){
        const coverage = coverageList[i];
        let glyphIndex = contextParams.current.activeState.value;
        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
        const lookupIndex = coverage.lookup(glyphIndex);
        if (lookupIndex !== -1) lookupList.push(lookupIndex);
    }
    if (lookupList.length !== coverageList.length) return -1;
    return lookupList;
}
/**
 * Handle chaining context substitution - format 3
 * @param {any} contextParams context params to lookup
 */ function chainingSubstitutionFormat3(contextParams) {
    const lookupsCount = this.inputCoverage.length + this.lookaheadCoverage.length + this.backtrackCoverage.length;
    if (contextParams.context.length < lookupsCount) return [];
    // INPUT LOOKUP //
    let inputLookups = lookupCoverageList(this.inputCoverage, contextParams);
    if (inputLookups === -1) return [];
    // LOOKAHEAD LOOKUP //
    const lookaheadOffset = this.inputCoverage.length - 1;
    if (contextParams.lookahead.length < this.lookaheadCoverage.length) return [];
    let lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
    while(lookaheadContext.length && (0, _char.isTashkeelArabicChar)(lookaheadContext[0].char))lookaheadContext.shift();
    const lookaheadParams = new (0, _tokenizer.ContextParams)(lookaheadContext, 0);
    let lookaheadLookups = lookupCoverageList(this.lookaheadCoverage, lookaheadParams);
    // BACKTRACK LOOKUP //
    let backtrackContext = [].concat(contextParams.backtrack);
    backtrackContext.reverse();
    while(backtrackContext.length && (0, _char.isTashkeelArabicChar)(backtrackContext[0].char))backtrackContext.shift();
    if (backtrackContext.length < this.backtrackCoverage.length) return [];
    const backtrackParams = new (0, _tokenizer.ContextParams)(backtrackContext, 0);
    let backtrackLookups = lookupCoverageList(this.backtrackCoverage, backtrackParams);
    const contextRulesMatch = inputLookups.length === this.inputCoverage.length && lookaheadLookups.length === this.lookaheadCoverage.length && backtrackLookups.length === this.backtrackCoverage.length;
    let substitutions = [];
    if (contextRulesMatch) {
        let lookupRecords = this.subtable.lookupRecords;
        for(let i = 0; i < lookupRecords.length; i++){
            const lookupRecord = lookupRecords[i];
            for(let j = 0; j < inputLookups.length; j++){
                const inputContext = new (0, _tokenizer.ContextParams)([
                    contextParams.get(j)
                ], 0);
                let lookupIndex = lookupRecord.lookupListIndex;
                const lookupTable = new LookupTable(lookupIndex, this.lookups);
                let lookup = lookupTable.lookup(inputContext);
                substitutions = substitutions.concat(lookup);
            }
        }
    }
    return substitutions;
}
/**
 * Handle ligature substitution - format 1
 * @param {any} contextParams context params to lookup
 */ function ligatureSubstitutionFormat1(contextParams) {
    // COVERAGE LOOKUP //
    let glyphIndex = contextParams.current.activeState.value;
    let ligSetIndex = this.coverage.lookup(glyphIndex);
    if (ligSetIndex === -1) return [];
    // COMPONENTS LOOKUP * note that components is logically ordered
    let ligGlyphs = this.ligatureSets.lookup(contextParams, ligSetIndex);
    return ligGlyphs ? [
        ligGlyphs
    ] : [];
}
/**
 * [ LOOKUP TYPES ]
 * -------------------------------
 * Single                        1;
 * Multiple                      2;
 * Alternate                     3;
 * Ligature                      4;
 * Context                       5;
 * ChainingContext               6;
 * ExtensionSubstitution         7;
 * ReverseChainingContext        8;
 * -------------------------------
 * @param {any} contextParams context params to lookup
 */ Substitution.prototype.lookup = function(contextParams) {
    const substitutions = [];
    const lookupType = this.lookupTable.lookupType;
    const substFormat = this.subtable.substFormat;
    if (lookupType === 1 && substFormat === 2) {
        let substitution = singleSubstitutionFormat2.call(this, contextParams);
        if (substitution.length > 0) substitutions.push({
            id: 12,
            substitution
        });
    }
    if (lookupType === 6 && substFormat === 3) {
        const substitution = chainingSubstitutionFormat3.call(this, contextParams);
        if (substitution.length > 0) substitutions.push({
            id: 63,
            substitution
        });
    }
    if (lookupType === 4 && substFormat === 1) {
        const substitution = ligatureSubstitutionFormat1.call(this, contextParams);
        if (substitution.length > 0) substitutions.push({
            id: 41,
            substitution
        });
    }
    return substitutions;
};
/**
 * Lookup a coverage table
 * @param {number} glyphIndex to lookup
 */ Coverage.prototype.lookup = function(glyphIndex) {
    if (!glyphIndex) return -1;
    switch(this.table.format){
        case 1:
            return this.table.glyphs.indexOf(glyphIndex);
        case 2:
            let ranges = this.table.ranges;
            for(let i = 0; i < ranges.length; i++){
                const range = ranges[i];
                if (glyphIndex >= range.start && glyphIndex <= range.end) {
                    let offset = glyphIndex - range.start;
                    return range.index + offset;
                }
            }
            break;
        default:
            return -1; // not found
    }
    return -1;
};
/**
 * Lookup a feature for a substitution or more
 * @param {any} contextParams context params to lookup
 */ Feature.prototype.lookup = function(contextParams) {
    let lookups = [];
    for(let i = 0; i < this.lookups.length; i++){
        const lookupTable = this.lookups[i];
        let lookup = lookupTable.lookup(contextParams);
        if (lookup !== null || lookup.length) lookups = lookups.concat(lookup);
    }
    return lookups;
};
/**
 * Get feature indexes of a specific script
 * @param {string} scriptTag script tag
 */ FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
    if (!scriptTag) return [];
    const tables = this.font.tables;
    if (!tables.gsub) return [];
    const scripts = this.font.tables.gsub.scripts;
    for(let i = 0; i < scripts.length; i++){
        const script = scripts[i];
        if (script.tag === scriptTag) {
            let defaultLangSys = script.script.defaultLangSys;
            return defaultLangSys.featureIndexes;
        } else {
            let langSysRecords = script.langSysRecords;
            if (!!langSysRecords) for(let j = 0; j < langSysRecords.length; j++){
                const langSysRecord = langSysRecords[j];
                if (langSysRecord.tag === scriptTag) {
                    let langSys = langSysRecord.langSys;
                    return langSys.featureIndexes;
                }
            }
        }
    }
    return [];
};
/**
 * Map a feature tag to a gsub feature
 * @param {any} features gsub features
 * @param {*} scriptTag script tag
 */ FeatureQuery.prototype.mapTagsToFeatures = function(features, scriptTag) {
    let tags = {};
    for(let i = 0; i < features.length; i++){
        const feature = features[i].feature;
        const tag = features[i].tag;
        const lookups = this.font.tables.gsub.lookups;
        const featureLookups = new FeatureLookups(lookups, feature.lookupListIndexes);
        tags[tag] = new Feature(tag, feature, featureLookups, scriptTag);
    }
    this.features[scriptTag].tags = tags;
};
/**
 * Get features of a specific script
 * @param {string} scriptTag script tag
 */ FeatureQuery.prototype.getScriptFeatures = function(scriptTag) {
    let features = this.features[scriptTag];
    if (this.features.hasOwnProperty(scriptTag)) return features;
    const featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
    if (!featuresIndexes) return null;
    const gsub = this.font.tables.gsub;
    features = featuresIndexes.map((index)=>gsub.features[index]);
    this.features[scriptTag] = features;
    this.mapTagsToFeatures(features, scriptTag);
    return features;
};
/**
 * Query a feature by it's properties
 * @param {any} query an object that describes the properties of a query
 */ FeatureQuery.prototype.getFeature = function(query) {
    if (!this.font) return {
        FAIL: `No font was found`
    };
    if (!this.features.hasOwnProperty(query.script)) this.getScriptFeatures(query.script);
    return this.features[query.script].tags[query.tag] || null;
};
exports.default = FeatureQuery;

},{"../tokenizer":"faOhG","../char":"d6rZY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eoH60":[function(require,module,exports,__globalThis) {
"use strict";

},{}],"5EEA5":[function(require,module,exports,__globalThis) {
// The `fvar` table stores font variation axes and instances.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
function addName(name, names) {
    const nameString = JSON.stringify(name);
    let nameID = 256;
    for(let nameKey in names){
        let n = parseInt(nameKey);
        if (!n || n < 256) continue;
        if (JSON.stringify(names[nameKey]) === nameString) return n;
        if (nameID <= n) nameID = n + 1;
    }
    names[nameID] = name;
    return nameID;
}
function makeFvarAxis(n, axis, names) {
    const nameID = addName(axis.name, names);
    return [
        {
            name: 'tag_' + n,
            type: 'TAG',
            value: axis.tag
        },
        {
            name: 'minValue_' + n,
            type: 'FIXED',
            value: axis.minValue << 16
        },
        {
            name: 'defaultValue_' + n,
            type: 'FIXED',
            value: axis.defaultValue << 16
        },
        {
            name: 'maxValue_' + n,
            type: 'FIXED',
            value: axis.maxValue << 16
        },
        {
            name: 'flags_' + n,
            type: 'USHORT',
            value: 0
        },
        {
            name: 'nameID_' + n,
            type: 'USHORT',
            value: nameID
        }
    ];
}
function parseFvarAxis(data, start, names) {
    const axis = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1); // reserved for flags; no values defined
    axis.name = names[p.parseUShort()] || {};
    return axis;
}
function makeFvarInstance(n, inst, axes, names) {
    const nameID = addName(inst.name, names);
    const fields = [
        {
            name: 'nameID_' + n,
            type: 'USHORT',
            value: nameID
        },
        {
            name: 'flags_' + n,
            type: 'USHORT',
            value: 0
        }
    ];
    for(let i = 0; i < axes.length; ++i){
        const axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }
    return fields;
}
function parseFvarInstance(data, start, axes, names) {
    const inst = {};
    const p = new (0, _parseDefault.default).Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1); // reserved for flags; no values defined
    inst.coordinates = {};
    for(let i = 0; i < axes.length; ++i)inst.coordinates[axes[i].tag] = p.parseFixed();
    return inst;
}
function makeFvarTable(fvar, names) {
    const result = new (0, _tableDefault.default).Table('fvar', [
        {
            name: 'version',
            type: 'ULONG',
            value: 0x10000
        },
        {
            name: 'offsetToData',
            type: 'USHORT',
            value: 0
        },
        {
            name: 'countSizePairs',
            type: 'USHORT',
            value: 2
        },
        {
            name: 'axisCount',
            type: 'USHORT',
            value: fvar.axes.length
        },
        {
            name: 'axisSize',
            type: 'USHORT',
            value: 20
        },
        {
            name: 'instanceCount',
            type: 'USHORT',
            value: fvar.instances.length
        },
        {
            name: 'instanceSize',
            type: 'USHORT',
            value: 4 + fvar.axes.length * 4
        }
    ]);
    result.offsetToData = result.sizeOf();
    for(let i = 0; i < fvar.axes.length; i++)result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    for(let j = 0; j < fvar.instances.length; j++)result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    return result;
}
function parseFvarTable(data, start, names) {
    const p = new (0, _parseDefault.default).Parser(data, start);
    const tableVersion = p.parseULong();
    (0, _checkDefault.default).argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    const offsetToData = p.parseOffset16();
    // Skip countSizePairs.
    p.skip('uShort', 1);
    const axisCount = p.parseUShort();
    const axisSize = p.parseUShort();
    const instanceCount = p.parseUShort();
    const instanceSize = p.parseUShort();
    const axes = [];
    for(let i = 0; i < axisCount; i++)axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    const instances = [];
    const instanceStart = start + offsetToData + axisCount * axisSize;
    for(let j = 0; j < instanceCount; j++)instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    return {
        axes: axes,
        instances: instances
    };
}
exports.default = {
    make: makeFvarTable,
    parse: parseFvarTable
};

},{"../check":"184gJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jTIcF":[function(require,module,exports,__globalThis) {
// The `GPOS` table contains kerning pairs, among other things.
// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _table = require("../table");
var _tableDefault = parcelHelpers.interopDefault(_table);
const subtableParsers = new Array(10); // subtableParsers[0] is unused
// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
// this = Parser instance
subtableParsers[1] = function parseLookup1() {
    const start = this.offset + this.relativeOffset;
    const posformat = this.parseUShort();
    if (posformat === 1) return {
        posFormat: 1,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        value: this.parseValueRecord()
    };
    else if (posformat === 2) return {
        posFormat: 2,
        coverage: this.parsePointer((0, _parse.Parser).coverage),
        values: this.parseValueRecordList()
    };
    (0, _checkDefault.default).assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
};
// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
subtableParsers[2] = function parseLookup2() {
    const start = this.offset + this.relativeOffset;
    const posFormat = this.parseUShort();
    (0, _checkDefault.default).assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
    const coverage = this.parsePointer((0, _parse.Parser).coverage);
    const valueFormat1 = this.parseUShort();
    const valueFormat2 = this.parseUShort();
    if (posFormat === 1) // Adjustments for Glyph Pairs
    return {
        posFormat: posFormat,
        coverage: coverage,
        valueFormat1: valueFormat1,
        valueFormat2: valueFormat2,
        pairSets: this.parseList((0, _parse.Parser).pointer((0, _parse.Parser).list(function() {
            return {
                secondGlyph: this.parseUShort(),
                value1: this.parseValueRecord(valueFormat1),
                value2: this.parseValueRecord(valueFormat2)
            };
        })))
    };
    else if (posFormat === 2) {
        const classDef1 = this.parsePointer((0, _parse.Parser).classDef);
        const classDef2 = this.parsePointer((0, _parse.Parser).classDef);
        const class1Count = this.parseUShort();
        const class2Count = this.parseUShort();
        return {
            // Class Pair Adjustment
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            classDef1: classDef1,
            classDef2: classDef2,
            class1Count: class1Count,
            class2Count: class2Count,
            classRecords: this.parseList(class1Count, (0, _parse.Parser).list(class2Count, function() {
                return {
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            }))
        };
    }
};
subtableParsers[3] = function parseLookup3() {
    return {
        error: 'GPOS Lookup 3 not supported'
    };
};
subtableParsers[4] = function parseLookup4() {
    return {
        error: 'GPOS Lookup 4 not supported'
    };
};
subtableParsers[5] = function parseLookup5() {
    return {
        error: 'GPOS Lookup 5 not supported'
    };
};
subtableParsers[6] = function parseLookup6() {
    return {
        error: 'GPOS Lookup 6 not supported'
    };
};
subtableParsers[7] = function parseLookup7() {
    return {
        error: 'GPOS Lookup 7 not supported'
    };
};
subtableParsers[8] = function parseLookup8() {
    return {
        error: 'GPOS Lookup 8 not supported'
    };
};
subtableParsers[9] = function parseLookup9() {
    return {
        error: 'GPOS Lookup 9 not supported'
    };
};
// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
function parseGposTable(data, start) {
    start = start || 0;
    const p = new (0, _parse.Parser)(data, start);
    const tableVersion = p.parseVersion(1);
    (0, _checkDefault.default).argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);
    if (tableVersion === 1) return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers)
    };
    else return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers),
        variations: p.parseFeatureVariationsList()
    };
}
// GPOS Writing //////////////////////////////////////////////
// NOT SUPPORTED
const subtableMakers = new Array(10);
function makeGposTable(gpos) {
    return new (0, _tableDefault.default).Table('GPOS', [
        {
            name: 'version',
            type: 'ULONG',
            value: 0x10000
        },
        {
            name: 'scripts',
            type: 'TABLE',
            value: new (0, _tableDefault.default).ScriptList(gpos.scripts)
        },
        {
            name: 'features',
            type: 'TABLE',
            value: new (0, _tableDefault.default).FeatureList(gpos.features)
        },
        {
            name: 'lookups',
            type: 'TABLE',
            value: new (0, _tableDefault.default).LookupList(gpos.lookups, subtableMakers)
        }
    ]);
}
exports.default = {
    parse: parseGposTable,
    make: makeGposTable
};

},{"../check":"184gJ","../parse":"8RdJX","../table":"8eeDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"RCH2q":[function(require,module,exports,__globalThis) {
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _check = require("../check");
var _checkDefault = parcelHelpers.interopDefault(_check);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
function parseWindowsKernTable(p) {
    const pairs = {};
    // Skip nTables.
    p.skip('uShort');
    const subtableVersion = p.parseUShort();
    (0, _checkDefault.default).argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subtableLength, subtableCoverage
    p.skip('uShort', 2);
    const nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for(let i = 0; i < nPairs; i += 1){
        const leftIndex = p.parseUShort();
        const rightIndex = p.parseUShort();
        const value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}
function parseMacKernTable(p) {
    const pairs = {};
    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
    // Skip the rest.
    p.skip('uShort');
    const nTables = p.parseULong();
    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
    if (nTables > 1) console.warn('Only the first kern subtable is supported.');
    p.skip('uLong');
    const coverage = p.parseUShort();
    const subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        const nPairs = p.parseUShort();
        // Skip searchRange, entrySelector, rangeShift.
        p.skip('uShort', 3);
        for(let i = 0; i < nPairs; i += 1){
            const leftIndex = p.parseUShort();
            const rightIndex = p.parseUShort();
            const value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}
// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    const p = new (0, _parseDefault.default).Parser(data, start);
    const tableVersion = p.parseUShort();
    if (tableVersion === 0) return parseWindowsKernTable(p);
    else if (tableVersion === 1) return parseMacKernTable(p);
    else throw new Error('Unsupported kern table version (' + tableVersion + ').');
}
exports.default = {
    parse: parseKernTable
};

},{"../check":"184gJ","../parse":"8RdJX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fgton":[function(require,module,exports,__globalThis) {
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parse = require("../parse");
var _parseDefault = parcelHelpers.interopDefault(_parse);
// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    const p = new (0, _parseDefault.default).Parser(data, start);
    const parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    const glyphOffsets = [];
    for(let i = 0; i < numGlyphs + 1; i += 1){
        let glyphOffset = parseFn.call(p);
        if (shortVersion) // The short table version stores the actual offset divided by 2.
        glyphOffset *= 2;
        glyphOffsets.push(glyphOffset);
    }
    return glyphOffsets;
}
exports.default = {
    parse: parseLocaTable
};

},{"../parse":"8RdJX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gfVel":[function(require,module,exports,__globalThis) {
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("c0743715070b1b8a");
'use strict';
function assertPath(path) {
    if (typeof path !== 'string') throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    var res = '';
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf('/');
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = '';
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = '';
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += '/..';
                    else res = '..';
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = '';
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = process.cwd();
                path = cwd;
            }
            assertPath(path);
            // Skip empty entries
            if (path.length === 0) continue;
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return '/' + resolvedPath;
            else return '/';
        } else if (resolvedPath.length > 0) return resolvedPath;
        else return '.';
    },
    normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = '.';
        if (path.length > 0 && trailingSeparator) path += '/';
        if (isAbsolute) return '/' + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return '.';
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += '/' + arg;
            }
        }
        if (joined === undefined) return '.';
        return posix.normalize(joined);
    },
    relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return '';
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return '';
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                    else if (i === 0) // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                    else if (i === 0) // We get here if `to` is the root.
                    // For example: from='/foo'; to='/'
                    lastCommonSep = 0;
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i)if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
            if (out.length === 0) out += '..';
            else out += '/..';
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else // We saw the first non-path separator
            matchedSlash = false;
        }
        if (end === -1) return hasRoot ? '/' : '.';
        if (hasRoot && end === 1) return '//';
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return '';
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return '';
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return '';
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== 'object') throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        return _format('/', pathObject);
    },
    parse: function parse(path) {
        assertPath(path);
        var ret = {
            root: '',
            dir: '',
            base: '',
            ext: '',
            name: ''
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = '/';
            start = 1;
        } else start = 0;
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = '/';
        return ret;
    },
    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
};
posix.posix = posix;
module.exports = posix;

},{"c0743715070b1b8a":"euskh"}],"euskh":[function(require,module,exports,__globalThis) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"ibn1F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultStroke", ()=>defaultStroke);
parcelHelpers.export(exports, "defaultFill", ()=>defaultFill);
// Utility functions for components
/**
 * Simplifies the rotation and scale of a component for better consistency and human readability.
 */ parcelHelpers.export(exports, "simpifyRotationAndScale", ()=>simpifyRotationAndScale);
parcelHelpers.export(exports, "approxCompare", ()=>approxCompare);
parcelHelpers.export(exports, "interpolate", ()=>interpolate);
parcelHelpers.export(exports, "closestBasicDirection", ()=>closestBasicDirection);
/**
 * Clamps a value between a minimum and maximum value.
 * @param value The value to clamp
 * @param min The minimum value
 * @param max The maximum value
 */ parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "memorySizeOf", ()=>memorySizeOf);
parcelHelpers.export(exports, "bboxFromPoints", ()=>bboxFromPoints);
var _svgJs = require("@svgdotjs/svg.js");
var _internal = require("../internal");
const defaultStroke = "var(--bs-emphasis-color)";
const defaultFill = "var(--bs-body-bg)";
function simpifyRotationAndScale(rotation, scale) {
    let s = new _svgJs.Point(scale);
    rotation = rotation == -180 ? 180 : rotation;
    if (s.y < 0) {
        if (rotation == 180) {
            rotation = 0;
            s.y *= -1;
            s.x *= -1;
        } else if (s.x < 0) {
            s.x *= -1;
            s.y *= -1;
            rotation = rotation + 180;
        }
    } else if (rotation == 180) {
        rotation = 0;
        s.x *= -1;
        s.y *= -1;
    }
    return [
        rotation,
        s
    ];
}
function approxCompare(value1, value2, eps = 1e-7) {
    return value1 > value2 + eps ? 1 : value1 < value2 - eps ? -1 : 0;
}
function interpolate(a, b, t) {
    return a.add(b.sub(a).mul(t));
}
function closestBasicDirection(direction) {
    return (0, _internal.basicDirections).map((val)=>{
        return {
            dirInfo: val,
            distsq: val.direction.distanceSquared(direction)
        };
    }).reduce((prev, current)=>{
        if (current.distsq < prev.distsq) return current;
        else return prev;
    }, {
        dirInfo: {
            key: "",
            name: "",
            direction: new _svgJs.Point()
        },
        distsq: Number.MAX_VALUE
    }).dirInfo;
}
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
function memorySizeOf(obj) {
    var bytes = 0;
    function sizeOf(obj) {
        if (obj !== null && obj !== undefined) switch(typeof obj){
            case "number":
                bytes += 8;
                break;
            case "string":
                bytes += obj.length * 2;
                break;
            case "boolean":
                bytes += 4;
                break;
            case "object":
                var objClass = Object.prototype.toString.call(obj).slice(8, -1);
                if (objClass === "Object" || objClass === "Array") for(var key in obj){
                    if (!obj.hasOwnProperty(key)) continue;
                    sizeOf(obj[key]);
                }
                else bytes += obj.toString().length * 2;
                break;
        }
        return bytes;
    }
    return sizeOf(obj);
}
function bboxFromPoints(points) {
    let minX = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    for (const point of points){
        if (point.x < minX) minX = point.x;
        if (point.y < minY) minY = point.y;
        if (point.x > maxX) maxX = point.x;
        if (point.y > maxY) maxY = point.y;
    }
    return new _svgJs.Box(minX, minY, maxX - minX, maxY - minY);
}

},{"@svgdotjs/svg.js":"fFByv","../internal":"f6vBb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k3mu1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildTikzStringFromNodeCommand", ()=>buildTikzStringFromNodeCommand);
parcelHelpers.export(exports, "buildTikzStringFromPathCommand", ()=>buildTikzStringFromPathCommand);
function buildTikzStringFromNodeCommand(command) {
    return "\\" + convertNodeCommand(command) + ";";
}
function convertNodeCommand(command) {
    let outputString = [
        "node"
    ];
    if (command.options.length > 0) outputString.push("[" + command.options.join(", ") + "]");
    if (command.name) outputString.push("(" + command.name + ")");
    outputString.push(" at ");
    outputString.push(coordToString(command.position));
    outputString.push("{" + (command.content ?? "") + "}");
    for (const additionalCommand of command.additionalNodes)outputString.push(" " + convertNodeCommand(additionalCommand));
    return outputString.join("");
}
function buildTikzStringFromPathCommand(command) {
    return "\\" + convertPathCommand(command) + ";";
}
function convertPathCommand(command) {
    if (command.coordinates.length !== command.connectors.length + 1) throw new Error("Building path command failed! Number of coordinates has to be one more than number of coordinate connectors");
    if (command.coordinates.length < 2) throw new Error("Building path command failed! Number of coordinates has to be at least 2");
    let outputString = [];
    let drawIndex = command.options.indexOf("draw");
    if (drawIndex >= 0) {
        outputString.push("draw");
        command.options.splice(drawIndex, 1);
    } else outputString.push("path");
    if (command.options.length > 0) outputString.push("[" + command.options.join(", ") + "]");
    for(let index = 0; index < command.connectors.length; index++){
        const coordinate = command.coordinates[index];
        const connector = command.connectors[index];
        outputString.push(" " + coordToString(coordinate));
        if (typeof connector == "string") outputString.push(" " + connector);
        else outputString.push(" " + buildCircuitikzTo(connector));
    }
    outputString.push(" " + coordToString(command.coordinates.at(-1)));
    for (const additionalCommand of command.additionalNodes)// check that additionalCommand is not null
    if (additionalCommand) outputString.push(" " + convertNodeCommand(additionalCommand));
    return outputString.join("");
}
function coordToString(coord) {
    if (typeof coord == "string") return coord;
    else return coord.toTikzString();
}
function buildCircuitikzTo(command) {
    let outputString = [
        ...command.options
    ];
    if (command.name) outputString.push("name=" + command.name);
    return "to[" + outputString.join(", ") + "]";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}]},["i6nKT","g3CsF"], "g3CsF", "parcelRequire77af", {})

//# sourceMappingURL=pages.6c4b1899.js.map
